//--------------------------------------------------------------------------------------------------
//   AST
//--------------------------------------------------------------------------------------------------

abstract class @astAbstractViewDeclaration {
}

//--------------------------------------------------------------------------------------------------

class @astComputedHorizontalViewDeclaration : @astAbstractViewDeclaration {
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @astViewInstructionList mInstructionList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//--------------------------------------------------------------------------------------------------

class @astComputedVerticalViewDeclaration : @astAbstractViewDeclaration {
  public let @bool mHasVerticalScroller
  public let @lstring mConfiguratorName
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @astViewInstructionList mInstructionList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//--------------------------------------------------------------------------------------------------

list @astViewDeclarationList {
  public let @lstring mViewName
  public let @astAbstractViewDeclaration mView
}

//--------------------------------------------------------------------------------------------------

abstract class @astAbstractViewInstructionDeclaration {
}

//--------------------------------------------------------------------------------------------------

class @astSeparatorInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @bool horizontal %initArgLabel

  override proc generateViewCode (let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                  ?prefs: let @bool unused inPreferences,
                                  let @propertyMap unused inRootObservablePropertyMap,
                                  let @propertyMap unused inPreferencesPropertyMap,
                                  let @semanticContext unused inSemanticContext,
                                  let @propertyMap unused inObservablePropertyMap,
                                  let @actionMap unused inActionMap,
                                  let @string unused inReceiverSwiftTypeName,
                                  let @classMap unused inClassMap,
                                  ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                  ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                  ?!@autoLayoutOutletMap unused ioOutletMap,
                                  !@abstractViewInstructionGeneration outInstruction) {
    outInstruction = @autoLayoutSeparatorInstructionGeneration (!horizontal: self.horizontal)
  }

}

//--------------------------------------------------------------------------------------------------

class @astGutterInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @bool horizontal %initArgLabel

  override proc generateViewCode (let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                  ?prefs: let @bool unused inPreferences,
                                  let @propertyMap unused inRootObservablePropertyMap,
                                  let @propertyMap unused inPreferencesPropertyMap,
                                  let @semanticContext unused inSemanticContext,
                                  let @propertyMap unused inObservablePropertyMap,
                                  let @actionMap unused inActionMap,
                                  let @string unused inReceiverSwiftTypeName,
                                  let @classMap unused inClassMap,
                                  ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                  ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                  ?!@autoLayoutOutletMap unused ioOutletMap,
                                  !@abstractViewInstructionGeneration outInstruction) {
    outInstruction = @autoLayoutGutterInstructionGeneration (!horizontal: self.horizontal)
  }

}

//--------------------------------------------------------------------------------------------------

class @astDividerInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @bool horizontal %initArgLabel
}

//--------------------------------------------------------------------------------------------------

enum @optionalHiddenBinding {
  case noBinding
  case binding (@abstractBooleanMultipleBindingExpressionAST hidden)
}

//--------------------------------------------------------------------------------------------------

class @astHStackViewInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @astViewInstructionList mInstructionList
  public let @optionalHiddenBinding mOptionalHiddenBinding
  public let @astNewStackViewDeclarationList mAstNewStackViewDeclarationList
}

//--------------------------------------------------------------------------------------------------

class @astVStackViewInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @bool mHasVerticalScroller
  public let @lstring mConfiguratorName
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @astViewInstructionList mInstructionList
  public let @optionalHiddenBinding mOptionalHiddenBinding
  public let @astNewStackViewDeclarationList mAstNewStackViewDeclarationList
}

//--------------------------------------------------------------------------------------------------

list @astNewStackViewDeclarationList {
  public let @lstring mInstanciedStackViewName
  public let @lstring mTypeStackViewName
}

//--------------------------------------------------------------------------------------------------

class @astSpaceViewInstruction : @astAbstractViewInstructionDeclaration {
}

//--------------------------------------------------------------------------------------------------

class @astLocalViewInstruction : @astAbstractViewInstructionDeclaration {
  public let @lstring mLocalView
}

//--------------------------------------------------------------------------------------------------

class @astComputedViewInstruction : @astAbstractViewInstructionDeclaration {
  public let @lstring mAutoLayoutViewClassName
  public let @astAutoLayoutViewInstructionParameterList mParameterList
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @tableValueBinding mTableValueBinding
  public let @runActionDescriptor mRunActionDescriptor
  public let @multipleBindingDescriptor mEnabledBindingDescriptor
  public let @multipleBindingDescriptor mHiddenBindingDescriptor
  public let @graphicController mGraphicController
  public let @regularBindingList mRegularBindingList
  public let @lstring mConfiguratorName // Empty string if no configurator
  public let @lstring mOutletName // Empty string if no configurator
  public let @bool mOutletIsArray
}

//--------------------------------------------------------------------------------------------------

list @astAutoLayoutViewFunctionCallList {
  public let @lstring mFunctionName
  public let @astAutoLayoutViewInstructionParameterList mParameterList
}

//--------------------------------------------------------------------------------------------------

enum @astAutoLayoutViewInstructionParameterValue {
  case string (@string value)
  case menuItem (@string title, @runActionDescriptor run, @multipleBindingDescriptor enabled)
  case enumFunc (@lstring enumTypeName, @lstring enumFuncName)
  case viewFunc (@astAbstractViewInstructionDeclaration instruction)
  case entity (@lstring entityName)
}

//--------------------------------------------------------------------------------------------------

list @astAutoLayoutViewInstructionParameterList {
  public let @lstring mParameterName
  public let @autoLayoutClassParameterType mParameterType
  public let @astAutoLayoutViewInstructionParameterValue mParameter
}

//--------------------------------------------------------------------------------------------------

list @astViewInstructionList {
  public let @astAbstractViewInstructionDeclaration mInstruction
}

//--------------------------------------------------------------------------------------------------
//   SYNTAX
//--------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  rule <stack_view_declaration> (?!@astViewDeclarationList ioViewDeclarationList) {
    $stackView$
    $viewName$ (?let viewName)
    $vStack$
    let @bool hasVerticalScroller
    select
      hasVerticalScroller = false
    or
      $withVScroller$
      hasVerticalScroller = true
    end
    let @lstring configuratorName
    select
      configuratorName = "".nowhere
    or
      $[$
      $configurator$
      $identifier$ (?configuratorName)
      $]$
    end
    var unusedSet = @stringset ()
    <auto_layout_func_call_list> (!?unusedSet, ?let functionCallList)
    ${$
    var @astNewStackViewDeclarationList astNewStackViewDeclarationList = []
    var @stringset stackViewInstances = []
    var instructionList = @astViewInstructionList []
    <view_instruction_list> (
      !horizontal: false,
      !?stackViewInstances,
      !?astNewStackViewDeclarationList,
      !?instructionList
    )
    $}$
    !?ioViewDeclarationList.append (
      !viewName,
      !@astComputedVerticalViewDeclaration (
        hasVerticalScroller,
        configuratorName,
        functionCallList,
        instructionList,
        astNewStackViewDeclarationList
      )
    )
  }
 
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  rule <stack_view_declaration> (?!@astViewDeclarationList ioViewDeclarationList) {
    $stackView$
    $viewName$ (?let viewName)
    $hStack$
    var unusedSet = @stringset ()
    <auto_layout_func_call_list> (!?unusedSet, ?let functionCallList)
    ${$
    var @astNewStackViewDeclarationList astNewStackViewDeclarationList = []
    var @stringset stackViewInstances = []
    var instructionList = @astViewInstructionList []
    <view_instruction_list> (!horizontal: true, !?stackViewInstances, !?astNewStackViewDeclarationList, !?instructionList)
    $}$
    !?ioViewDeclarationList.append (
      !viewName,
      !@astComputedHorizontalViewDeclaration (functionCallList, instructionList, astNewStackViewDeclarationList)
    )
  }
 
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  rule <auto_layout_func_call_list> (?!@stringset ioStackViewInstances,
                                     !@astAutoLayoutViewFunctionCallList outFunctionCallList) {
   outFunctionCallList = []
   repeat
    while
       $identifier$ (?let functionName)
       <view_actual_parameter_list> (!?ioStackViewInstances, ?let actualParameterList)
       !?outFunctionCallList.append (functionName, actualParameterList)
    end
  }
   
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
  rule <view_instruction_list> (?horizontal: let @bool inHorizontal,
                                ?!@stringset ioStackViewInstances,
                                ?!@astNewStackViewDeclarationList ioNewStackViewDeclarationList,
                                ?!@astViewInstructionList ioInstructionList) {
    repeat
    while
      $newView$
      $identifier$ (?let instancedStackViewName)
      !?ioStackViewInstances.insert (instancedStackViewName)
      $=$
      $viewName$ (?let typeStackViewName)
      $($
      $)$
      !?ioNewStackViewDeclarationList.append (instancedStackViewName, typeStackViewName)
    while
      $separator$
      !?ioInstructionList.append (@astSeparatorInstructionDeclaration (!horizontal: inHorizontal))
    while
      $gutter$
      !?ioInstructionList.append (@astGutterInstructionDeclaration (!horizontal: inHorizontal))
    while
      $divider$
      !?ioInstructionList.append (@astDividerInstructionDeclaration (!horizontal: inHorizontal))
    while
      $view$
      $identifier$ (?let localViewName)
      if not ioStackViewInstances.hasKey (localViewName.string) then
        error localViewName : "the view is not instancied"
      end
      !?ioInstructionList.append (@astLocalViewInstruction (localViewName))
    while
      <view_instruction> (!?ioStackViewInstances, ?let instruction)
      !?ioInstructionList.append (instruction)
    end
  }
  
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
  rule <view_instruction> (?!@stringset unused ioStackViewInstances,
                           !@astAbstractViewInstructionDeclaration outInstruction) {
    $space$
    outInstruction = @astSpaceViewInstruction ()
  }
  
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
  rule <view_instruction> (?!@stringset ioStackViewInstances,
                           !@astAbstractViewInstructionDeclaration outInstruction) {
    <computed_view_instruction> (!?ioStackViewInstances, ?let instruction)
    outInstruction = instruction
  }
  
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
  rule <computed_view_instruction> (?!@stringset ioStackViewInstances,
                                    !@astComputedViewInstruction outInstruction) {
    $Identifier$ (? let viewClassName)
    let @astAutoLayoutViewInstructionParameterList instanciationParameterList
    select
      instanciationParameterList = []
    or
      <view_actual_parameter_list> (!?ioStackViewInstances, ?instanciationParameterList)
    end
    let @lstring configuratorName
    let @lstring outletName
    let @bool outletIsArray
    select
      outletName = "".nowhere
      configuratorName = "".nowhere
      outletIsArray = false
    or
      $[$
      select
        outletName = "".nowhere
        outletIsArray = false
      or
        $outlet$
        $identifier$ (?outletName)
        outletIsArray = false
      or
        $outletArray$
        $identifier$ (?outletName)
        outletIsArray = true
      end
      select
        configuratorName = "".nowhere
      or
        $configurator$
        $identifier$ (?configuratorName)
      end
      $]$
    end
    let @tableValueBinding tableValueBinding
    let @runActionDescriptor runActionDescriptor
    let @multipleBindingDescriptor enabledBindingDescriptor
    let @multipleBindingDescriptor hiddenBindingDescriptor
    let @graphicController graphicController
    let @regularBindingList regularBindingList
    let @astAutoLayoutViewFunctionCallList autoLayoutViewFunctionCallList
    select
      tableValueBinding = .noTableValueBinding
      runActionDescriptor = .noAction
      enabledBindingDescriptor = .noBinding
      hiddenBindingDescriptor = .noBinding
      graphicController = .none
      regularBindingList = []
      autoLayoutViewFunctionCallList = []
    or
      ${$
      <auto_layout_func_call_list> (!?ioStackViewInstances, ?autoLayoutViewFunctionCallList)
      <outlet_binding> (?tableValueBinding,
                        ?runActionDescriptor,
                        ?enabledBindingDescriptor,
                        ?hiddenBindingDescriptor,
                        ?graphicController,
                        ?regularBindingList)
      $}$
    end
    outInstruction = @astComputedViewInstruction (
      viewClassName,
      instanciationParameterList,
      autoLayoutViewFunctionCallList,
      tableValueBinding,
      runActionDescriptor,
      enabledBindingDescriptor,
      hiddenBindingDescriptor,
      graphicController,
      regularBindingList,
      configuratorName,
      outletName,
      outletIsArray
    )
  }
  
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
  rule <view_actual_parameter_list> (?!@stringset ioStackViewInstances,
                                     !@astAutoLayoutViewInstructionParameterList outParameterList) {
    outParameterList = []
    $($
    select
    or
      repeat
        $identifier$ (?let parameterName)
        $:$
        select
          <view_instruction> (!?ioStackViewInstances, ?let @astAbstractViewInstructionDeclaration instruction)
          !?outParameterList.append (parameterName, .typeView, .viewFunc (!instruction: instruction))
        or
          $entity$
          $Identifier$ (?let entityName)
          !?outParameterList.append (parameterName, .entity, .entity(!entityName: entityName))
        or
          $menuItem$
          $literal_string$ (?let menuItemTitle)
          let @runActionDescriptor runActionDescriptor
          select
            runActionDescriptor = .noAction
          or
            $run$
            let @lstring runTargetName
            select
              runTargetName = @lstring ("self", .here)
            or
              $controllerName$ (?runTargetName)
              $.$
            end
            $identifier$ (?let @lstring runActionName)
            runActionDescriptor = .action (!target:runTargetName, !action:runActionName)
          end
          var @multipleBindingDescriptor enabledBindingDescriptor = .noBinding
          select
            enabledBindingDescriptor = .noBinding
          or
            $enabled$
            <booleanMultipleBindingExpression> (?let @abstractBooleanMultipleBindingExpressionAST bindingExpression)
            enabledBindingDescriptor = .binding (!expression:bindingExpression)
          end
          !?outParameterList.append (
           !parameterName,
           !.menuItem,
           !.menuItem (!title: menuItemTitle, !run: runActionDescriptor, !enabled: enabledBindingDescriptor)
         )
        or
          $view$
          $identifier$ (?let viewName)
          if not ioStackViewInstances.hasKey (viewName.string) then
            error viewName : "view is not instancied"
          end
          !?outParameterList.append (parameterName, .typeView, .string (!value: viewName.string))
        or
          $yes$
          !?outParameterList.append (parameterName, .typeBool, .string (!value: "true"))
        or
          $no$
          !?outParameterList.append (parameterName, .typeBool, .string (!value: "false"))
        or
          $literal_integer$ (?let uint32)
          !?outParameterList.append (parameterName, .typeInt, .string (!value: uint32.uint.string ))
        or
          $-$
          $literal_integer$ (?let uint32)
          !?outParameterList.append (parameterName, .typeInt, .string (!value: "-" + uint32.uint.string))
        or
          $literal_string$ (?let literalString)
          !?outParameterList.append (parameterName, .typeString, .string (!value: literalString.string.utf8Representation))
        or
          $.$
          $identifier$ (?let enumConstantName)
          !?outParameterList.append (parameterName, .typeEnum (!name: enumConstantName), .string (!value: "." + enumConstantName))
        or
          $enum$
          $Identifier$ (?let enumTypeName)
          $.$
          $identifier$ (?let enumFuncName)
          !?outParameterList.append (
            !parameterName,
            !.typeStringArray,
            .enumFunc (!enumTypeName: enumTypeName, !enumFuncName: enumFuncName)
          )
        end
      while
        $,$
      end
    end
    $)$
  }
  
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
  rule <view_instruction> (?!@stringset ioStackViewInstances,
                           !@astAbstractViewInstructionDeclaration outInstruction) {
    $vStack$
    let @bool hasVerticalScroller
    select
      hasVerticalScroller = false
    or
      $withVScroller$
      hasVerticalScroller = true
    end
    let @lstring configuratorName
    select
      configuratorName = "".nowhere
    or
      $[$
      $configurator$
      $identifier$ (?configuratorName)
      $]$
    end
    <auto_layout_func_call_list> (!?ioStackViewInstances, ?let functionCallList)
    let @optionalHiddenBinding optionalHiddenBinding
    select
      optionalHiddenBinding = .noBinding
    or
      $hidden$
      <booleanMultipleBindingExpression> (?let @abstractBooleanMultipleBindingExpressionAST bindingExpression)
      optionalHiddenBinding = .binding (!hidden: bindingExpression)
    end
    ${$
    var @astNewStackViewDeclarationList astNewStackViewDeclarationList = []
    var instructionList = @astViewInstructionList []
    <view_instruction_list> (
      !horizontal: false,
      !?ioStackViewInstances,
      !?astNewStackViewDeclarationList,
      !?instructionList
    )
    outInstruction = @astVStackViewInstructionDeclaration (
      hasVerticalScroller,
      configuratorName,
      functionCallList,
      instructionList,
      optionalHiddenBinding,
      astNewStackViewDeclarationList
    )
    $}$
  }
  
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
  rule <view_instruction> (?!@stringset ioStackViewInstances,
                           !@astAbstractViewInstructionDeclaration outInstruction) {
    $hStack$
    <auto_layout_func_call_list> (!?ioStackViewInstances, ?let functionCallList)
    let @optionalHiddenBinding optionalHiddenBinding
    select
      optionalHiddenBinding = .noBinding
    or
      $hidden$
      <booleanMultipleBindingExpression> (?let @abstractBooleanMultipleBindingExpressionAST bindingExpression)
      optionalHiddenBinding = .binding (!hidden: bindingExpression)
    end
    ${$
    var @astNewStackViewDeclarationList astNewStackViewDeclarationList = []
    var instructionList = @astViewInstructionList []
    <view_instruction_list> (
      !horizontal: true,
      !?ioStackViewInstances,
      !?astNewStackViewDeclarationList, 
      !?instructionList
    )
    outInstruction = @astHStackViewInstructionDeclaration (
      functionCallList,
      instructionList,
      optionalHiddenBinding,
      astNewStackViewDeclarationList
    )
    $}$
  }
  
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------
//   SEMANTIC ANALYSIS                            
//--------------------------------------------------------------------------------------------------

map @autoLayoutViewDeclarationMap {
  %insertSetter insertKey %errorMessage "the '%K' view is already declared in %L"
  %searchMethod searchKey %errorMessage "there is no '%K' view"
}

//--------------------------------------------------------------------------------------------------

map @autoLayoutConfiguratorMap {
  public let @string mAutoLayoutOutletTypeName
  %insertSetter insertKey %errorMessage "the '%K' configurator is already declared in %L"
  %searchMethod searchKey %errorMessage "there is no '%K' configurator"
}

//--------------------------------------------------------------------------------------------------

map @autoLayoutOutletMap {
  public let @string mAutoLayoutOutletTypeName
  public let @bool mOutletIsArray
  %insertSetter insertKey %errorMessage "the '%K' outlet is already declared in %L"
  %searchMethod searchKey %errorMessage "there is no '%K' outlet"
}

//--------------------------------------------------------------------------------------------------

list @implicitViewFunctionGenerationList {
  public let @abstractViewInstructionGeneration mInstruction
}

//--------------------------------------------------------------------------------------------------

abstract proc @astAbstractViewDeclaration.checkView(
  let @string inViewName,
  let @autoLayoutViewDeclarationMap inViewDeclarationMap,
  ?prefs: let @bool inPreferences,
  let @propertyMap inRootObservablePropertyMap,
  let @propertyMap inPreferencesPropertyMap,
  let @semanticContext inSemanticContext,
  let @propertyMap inObservablePropertyMap,
  let @actionMap inActionMap,
  let @string inReceiverSwiftTypeName,
  let @classMap inClassMap,
  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
  ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
  ?!@autoLayoutOutletMap ioOutletMap,
  !@abstractViewGeneration outGeneration)

//--------------------------------------------------------------------------------------------------

proc @astAutoLayoutViewFunctionCallList.checkViewFunctionCallList(
                                let @astAutoLayoutViewFunctionMap inFunctionMap,
                                let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                let @bool inPreferences,
                                let @actionMap inPreferencesActionMap,
                                let @propertyMap inRootObservablePropertyMap,
                                let @propertyMap inPreferencesPropertyMap,
                                let @semanticContext inSemanticContext,
                                let @propertyMap inObservablePropertyMap,
                                let @actionMap inActionMap,
                                let @string inReceiverSwiftTypeName,
                                let @classMap inClassMap,
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                ?!@autoLayoutOutletMap ioOutletMap,
                                !@autoLayoutViewInstructionGenerationFuncCallList outFuncCallList) {
  outFuncCallList = []
  for (functionName, actualParameterList) in self do
    var mangleName = functionName.string + "("
    for (parameterName, 2*) in actualParameterList do
      mangleName += parameterName.string + ":"
    end
    mangleName += ")"
    inFunctionMap.searchKey (@(mangleName, functionName.location), ?let formalParameterList)
    var @autoLayoutViewInstructionGenerationParameterList parameterList = []
    if formalParameterList.count != actualParameterList.count then
      error functionName 
      : formalParameterList.count .string + " parameter(s) required, " + actualParameterList.count + " provided"
    else
      for (name, type, value) in actualParameterList, (formalName, formalType) in formalParameterList do
        if let formalTypeEnum = formalType.getTypeEnum, let actualTypeEnum = type.getTypeEnum then
          inClassMap.searchKey (formalTypeEnum.name, ?let typeKind, ?3*)
          if let atomicTypeKind = typeKind.getAtomic, let atomicEnumType = atomicTypeKind.kind.getEnumType then
            atomicEnumType.constantMap.searchKey (actualTypeEnum.name, ?*)
          else
            error formalTypeEnum.name : "this type name is not an enum"
          end
        elsif type != formalType then
          error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
        end
        if name.string != formalName.string then
          error name : "the parameter name should be '" + formalName + "'"
        end
        switch value
        case viewFunc (instruction) :
          instruction.generateViewCode ( 
            inViewDeclarationMap,
            !prefs: inPreferences,
            inRootObservablePropertyMap,
            inPreferencesPropertyMap,
            inSemanticContext,
            inObservablePropertyMap,
            inActionMap,
            inReceiverSwiftTypeName,
            inClassMap,
            !?ioImplicitViewFunctionGenerationList,
            !?ioConfiguratorMap,
            !?ioOutletMap,
            ?let @abstractViewInstructionGeneration viewInstruction
          )
          let viewInstructionString = viewInstruction.generateViewInstruction (
            !prefs: inPreferences,
            name,
            "" // Indentation
          )
          !?parameterList.append (name, "{ () -> NSView in " + viewInstructionString + " ; return " + name + " } ()")
        case string (stringValue) :
          !?parameterList.append (name, stringValue)
        case entity (entityName) :
          inClassMap.searchKey (entityName, ?let classKind, ?3*)
          if not classKind.isEntity then
            error entityName: "an entity is required here"
          end
          !?parameterList.append (name, entityName.string + ".self")
        case menuItem (title, run, enabledBinding) :
          analyzeAutoLayoutRunBinding (
            run,
            !handlesRunAction: true,
            inPreferences,
            "".nowhere ,
            inActionMap,
            inObservablePropertyMap,
            inReceiverSwiftTypeName,
            inPreferencesActionMap,
            ?let runBindingGeneration
          )
          analyzeAutoLayoutEnableBinding (
            enabledBinding,
            !handlesEnabledBinding: true,
            !prefs: inPreferences,
            inRootObservablePropertyMap,
            inSemanticContext,
            inObservablePropertyMap,
            !prefsMap: inPreferencesPropertyMap,
            ?let enabledBindingGeneration
          )
          var s = "AutoLayoutMenuItemDescriptor (title: " + title.utf8Representation
          switch runBindingGeneration 
          case none :
            s += ", target: nil, selector: nil"
          case run (targetName, actionName, runTargetName) :
            s += ", target: " + targetName + ", selector: #selector (" + runTargetName + "." + actionName + " (_:))"
          end
          switch enabledBindingGeneration 
          case none :
            s += ", enableBinding: .alwaysTrue"
          case enabled (binding) :
            s += ", enableBinding: " + binding.expressionString
          end
          s += ")"
          !?parameterList.append (name, s)
        case enumFunc (enumTypeName, funcName) :
          inSemanticContext.mClassMap.searchKey (enumTypeName, ?let type, ?3*)
          if not type.isAtomic then
            error enumTypeName : "this type should be an enum type"
          else
            type.extractAtomic (?kind:let @typeKind typeKind)
            if typeKind.isEnumType then
              typeKind.extractEnumType (?2*, ?funcMap:let funcMap)
              funcMap.searchKey (funcName, ?*)
            else
              error enumTypeName : "this type should be an enum type"
            end
          end
          !?parameterList.append (name, enumTypeName.string + "." + funcName + " ()")
        end
      end
    end
    !?outFuncCallList.append (functionName.string, parameterList)
  end
}

//--------------------------------------------------------------------------------------------------

override proc @astComputedHorizontalViewDeclaration.checkView(
                                  let @string unused inViewName,
                                  let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                  ?prefs: let @bool inPreferences,
                                  let @propertyMap inRootObservablePropertyMap,
                                  let @propertyMap inPreferencesPropertyMap,
                                  let @semanticContext inSemanticContext,
                                  let @propertyMap inObservablePropertyMap,
                                  let @actionMap inActionMap,
                                  let @string inReceiverSwiftTypeName,
                                  let @classMap inClassMap,
                                  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                  ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                  ?!@autoLayoutOutletMap ioOutletMap,
                                  !@abstractViewGeneration outGeneration) {
  inClassMap.searchKey (!@(preferencesName (), .nowhere), ?2*, ?let preferencesActionMap, ?*)
  self.mFunctionCallList.checkViewFunctionCallList
     (inSemanticContext.mAutoLayoutHStackFunctionMap,
     inViewDeclarationMap,
     inPreferences,
     preferencesActionMap,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
  var @autoLayoutViewInstructionGenerationList instructionList = []
  for (instruction) in self.mInstructionList do
    instruction.generateViewCode
      (inViewDeclarationMap,
      !prefs: inPreferences,
      inRootObservablePropertyMap,
      inPreferencesPropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inActionMap,
      inReceiverSwiftTypeName,
      inClassMap,
      !?ioImplicitViewFunctionGenerationList,
      !?ioConfiguratorMap,
      !?ioOutletMap,
      ?let generatedInstruction
    )
    !?instructionList.append (generatedInstruction)
  end
  outGeneration = @computedHorizontalViewGeneration (funcCallList, instructionList, self.mNewStackViewDeclarationList)
}

//--------------------------------------------------------------------------------------------------

override proc @astComputedVerticalViewDeclaration.checkView(
                                  let @string unused inViewName,
                                  let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                  ?prefs: let @bool inPreferences,
                                  let @propertyMap inRootObservablePropertyMap,
                                  let @propertyMap inPreferencesPropertyMap,
                                  let @semanticContext inSemanticContext,
                                  let @propertyMap inObservablePropertyMap,
                                  let @actionMap inActionMap,
                                  let @string inReceiverSwiftTypeName,
                                  let @classMap inClassMap,
                                  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                  ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                  ?!@autoLayoutOutletMap ioOutletMap,
                                  !@abstractViewGeneration outGeneration) {
  inClassMap.searchKey (!@(preferencesName (), .nowhere), ?2*, ?let preferencesActionMap, ?*)
  var @autoLayoutViewInstructionGenerationList instructionList = []
  self.mFunctionCallList.checkViewFunctionCallList
     (inSemanticContext.mAutoLayoutVStackFunctionMap,
     inViewDeclarationMap,
     inPreferences,
     preferencesActionMap,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
  for (instruction) in self.mInstructionList do
   instruction.generateViewCode
      (inViewDeclarationMap,
      !prefs: inPreferences,
      inRootObservablePropertyMap,
      inPreferencesPropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inActionMap,
      inReceiverSwiftTypeName,
      inClassMap,
      !?ioImplicitViewFunctionGenerationList,
      !?ioConfiguratorMap,
      !?ioOutletMap,
      ?let generatedInstruction
    )
    !?instructionList.append (generatedInstruction)
  end
  outGeneration = @computedVerticalViewGeneration (
    self.mHasVerticalScroller,
    self.mConfiguratorName,
    funcCallList,
    instructionList,
    self.mNewStackViewDeclarationList
  )
}

//--------------------------------------------------------------------------------------------------

abstract proc @astAbstractViewInstructionDeclaration.generateViewCode(
                                let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                ?prefs:let @bool inPreferences,
                                let @propertyMap inRootObservablePropertyMap,
                                let @propertyMap inPreferencesPropertyMap,
                                let @semanticContext inSemanticContext,
                                let @propertyMap inObservablePropertyMap,
                                let @actionMap inActionMap,
                                let @string inReceiverSwiftTypeName,
                                let @classMap inClassMap,
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                ?!@autoLayoutOutletMap ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction)

//--------------------------------------------------------------------------------------------------

override proc @astSpaceViewInstruction.generateViewCode(
                                let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                ?prefs: let @bool unused inPreferences,
                                let @propertyMap unused inRootObservablePropertyMap,
                                let @propertyMap unused inPreferencesPropertyMap,
                                let @semanticContext unused inSemanticContext,
                                let @propertyMap unused inObservablePropertyMap,
                                let @actionMap unused inActionMap,
                                let @string unused inReceiverSwiftTypeName,
                                let @classMap unused inClassMap,
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                ?!@autoLayoutOutletMap unused ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  outInstruction = @autoLayoutSpaceViewInstructionGeneration ()
}

//--------------------------------------------------------------------------------------------------

override proc @astDividerInstructionDeclaration.generateViewCode(
                                let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                ?prefs: let @bool unused inPreferences,
                                let @propertyMap unused inRootObservablePropertyMap,
                                let @propertyMap unused inPreferencesPropertyMap,
                                let @semanticContext unused inSemanticContext,
                                let @propertyMap unused inObservablePropertyMap,
                                let @actionMap unused inActionMap,
                                let @string unused inReceiverSwiftTypeName,
                                let @classMap unused inClassMap,
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                ?!@autoLayoutOutletMap unused ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  outInstruction = @autoLayoutDividerInstructionGeneration (!horizontal: self.horizontal)
}

//--------------------------------------------------------------------------------------------------

override proc @astLocalViewInstruction.generateViewCode(
                                let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                ?prefs: let @bool unused inPreferences,
                                let @propertyMap unused inRootObservablePropertyMap,
                                let @propertyMap unused inPreferencesPropertyMap,
                                let @semanticContext unused inSemanticContext,
                                let @propertyMap unused inObservablePropertyMap,
                                let @actionMap unused inActionMap,
                                let @string unused inReceiverSwiftTypeName,
                                let @classMap unused inClassMap,
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                ?!@autoLayoutOutletMap unused ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  outInstruction = @autoLayoutLocalViewInstructionGeneration (self.mLocalView.string)
}

//--------------------------------------------------------------------------------------------------

override proc @astComputedViewInstruction.generateViewCode(
                                let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                ?prefs: let @bool inPreferences,
                                let @propertyMap inRootObservablePropertyMap,
                                let @propertyMap inPreferencesPropertyMap,
                                let @semanticContext inSemanticContext,
                                let @propertyMap inObservablePropertyMap,
                                let @actionMap inActionMap,
                                let @string inReceiverSwiftTypeName,
                                let @classMap inClassMap,
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                ?!@autoLayoutOutletMap ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  inSemanticContext.mAutolayoutViewClassMap.searchKey
     (self.mAutoLayoutViewClassName,
     ?7*,
     ?let formalParameterList,
     ?let functionMap
  )
  inClassMap.searchKey (!@(preferencesName (), .nowhere), ?2*, ?let preferencesActionMap, ?*)
  var @autoLayoutViewInstructionGenerationParameterList parameterList = []
  if formalParameterList.count != self.mParameterList.count then
    error self.mAutoLayoutViewClassName 
    : formalParameterList.count .string + " parameter(s) required, " + self.mParameterList.count + " provided"
  else
    for (name, type, value) in self.mParameterList, (formalName, formalType) in formalParameterList do
      if let formalTypeEnum = formalType.getTypeEnum, let actualTypeEnum = type.getTypeEnum then
        inClassMap.searchKey (formalTypeEnum.name, ?let typeKind, ?3*)
        if let atomicTypeKind = typeKind.getAtomic, let enumKind = atomicTypeKind.kind.getEnumType then
          enumKind.constantMap.searchKey (actualTypeEnum.name, ?*)
        else
          error formalTypeEnum.name : "this type name is not an enum"
        end
      elsif type != formalType then
        error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
      end
      if name.string != formalName.string then
        error name : "the parameter name should be '" + formalName + "'"
      end
      switch value
        case viewFunc (instruction) :
          instruction.generateViewCode 
            (inViewDeclarationMap,
            !prefs: inPreferences,
            inRootObservablePropertyMap,
            inPreferencesPropertyMap,
            inSemanticContext,
            inObservablePropertyMap,
            inActionMap,
            inReceiverSwiftTypeName,
            inClassMap,
            !?ioImplicitViewFunctionGenerationList,
            !?ioConfiguratorMap,
            !?ioOutletMap,
            ?let @abstractViewInstructionGeneration viewInstruction
          )
          !?parameterList.append (name, "self.computeImplicitView_" + ioImplicitViewFunctionGenerationList.count + " ()")
          !?ioImplicitViewFunctionGenerationList.append (viewInstruction)
      case entity (entityName) :
        inClassMap.searchKey (entityName, ?let classKind, ?3*)
        if not classKind.isEntity then
          error entityName: "an entity is required here"
        end
        !?parameterList.append (name, entityName.string + ".self")
      case string (stringValue) :
        !?parameterList.append (name, stringValue)
      case menuItem (title, run, enabledBinding) :
        analyzeAutoLayoutRunBinding (
          run,
          !handlesRunAction: true,
          inPreferences,
          "".nowhere , // mAutoLayoutViewClassName // inTypeName
          inActionMap,
          inObservablePropertyMap,
          inReceiverSwiftTypeName,
          preferencesActionMap,
          ?let runBindingGeneration
        )
        analyzeAutoLayoutEnableBinding (
          enabledBinding,
          !handlesEnabledBinding: true,
          !prefs: inPreferences,
          inRootObservablePropertyMap,
          inSemanticContext,
          inObservablePropertyMap,
          !prefsMap: inPreferencesPropertyMap,
          ?let enabledBindingGeneration
        )
        var s = "AutoLayoutMenuItemDescriptor (title: " + title.utf8Representation
        switch runBindingGeneration 
        case none :
          s += ", target: nil, selector: nil"
        case run (targetName, actionName, runTargetName) :
          s += ", target: " + targetName + ", selector: #selector (" + runTargetName + "." + actionName + " (_:))"
        end
        switch enabledBindingGeneration 
        case none :
          s += ", enableBinding: .alwaysTrue"
        case enabled (binding) :
          s += ", enableBinding: " + binding.expressionString
        end
        s += ")"
        !?parameterList.append (name, s)
      case enumFunc (enumTypeName, funcName) :
        inSemanticContext.mClassMap.searchKey (enumTypeName, ?let type, ?3*)
        if not type.isAtomic then
          error enumTypeName : "this type should be an enum type"
        else
          type.extractAtomic (?kind:let typeKind)
          if typeKind.isEnumType then
            typeKind.extractEnumType (?2*, ?funcMap:let funcMap)
            funcMap.searchKey (funcName, ?*)
          else
            error enumTypeName : "this type should be an enum type"
          end
        end
        !?parameterList.append (name, enumTypeName.string + "." + funcName + " ()")
      end
    end
  end
//-- Bindings
  analyzeAutoLayoutBinding (
    inPreferences,
    inRootObservablePropertyMap,
    inPreferencesPropertyMap,
    preferencesActionMap,
    inSemanticContext,
    inObservablePropertyMap,
    inActionMap,
    inReceiverSwiftTypeName,

    self.mAutoLayoutViewClassName,

     self.mTableValueBinding,
     self.mRunActionDescriptor,
     self.mEnabledBindingDescriptor,
     self.mHiddenBindingDescriptor,
     self.mGraphicController,
     self.mRegularBindingList,

    ?let @autoLayoutRegularBindingsGenerationList regularBindingsGenerationList,
    ?let @autoLayoutMultipleBindingGenerationList multipleBindingGenerationList,
    ?let @autolayoutRunBindingForGeneration runBindingGeneration,
    ?let @string inTableViewBindingGeneration,
    ?let @autoLayoutViewGraphicControllerBindingGeneration ebViewGraphicControllerBindingGeneration
  )
  self.mFunctionCallList.checkViewFunctionCallList
     (functionMap,
     inViewDeclarationMap,
     inPreferences,
     preferencesActionMap,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
//-- Check outlet
  if self.mOutletName.string != "" then
    !?ioOutletMap.insertKey (self.mOutletName, self.mAutoLayoutViewClassName, self.mOutletIsArray)
  end
//-- Check configurator
  if self.mConfiguratorName.string != "" then
    !?ioConfiguratorMap.insertKey (self.mConfiguratorName, self.mAutoLayoutViewClassName)
  end
//--  
  outInstruction = @autoLayoutComputedViewInstructionGeneration (
    self.mAutoLayoutViewClassName,
    parameterList,
    funcCallList,
    regularBindingsGenerationList,
    multipleBindingGenerationList,
    runBindingGeneration,
    inTableViewBindingGeneration,
    ebViewGraphicControllerBindingGeneration,
    self.mConfiguratorName.string,
    self.mOutletName.string,
    self.mOutletIsArray
  )
}

//--------------------------------------------------------------------------------------------------

proc analyzeAutoLayoutBinding (let @bool inPreferences,
              let @propertyMap inRootObservablePropertyMap,
              let @propertyMap inPreferencesPropertyMap,
              let @actionMap inPreferencesActionMap,
              let @semanticContext inSemanticContext,
              let @propertyMap inObservablePropertyMap,
              let @actionMap inActionMap,
              let @string inReceiverSwiftTypeName,
            
              let @lstring inTypeName,
            
              let @tableValueBinding inTableValueBinding,
              let @runActionDescriptor inRunActionDescriptor,
              let @multipleBindingDescriptor inEnabledBindingDescriptor,
              let @multipleBindingDescriptor inHiddenBindingDescriptor,
              let @graphicController inGraphicController,
              let @regularBindingList inRegularBindingList,
            
              !@autoLayoutRegularBindingsGenerationList outRegularBindingsGenerationList,
              !@autoLayoutMultipleBindingGenerationList outMultipleBindingGenerationList,
              !@autolayoutRunBindingForGeneration outRunBindingGeneration,
              !@string outTableViewBindingGeneration,
  !@autoLayoutViewGraphicControllerBindingGeneration outEBViewGraphicControllerBindingGeneration) {
  outRegularBindingsGenerationList = []
  outMultipleBindingGenerationList = []
  outTableViewBindingGeneration = "" // Empty String means no binding
  inSemanticContext.mAutolayoutViewClassMap.searchKey
    (inTypeName,
    ?*,
    ?let @bool handlesRunAction,
    ?let @bool handlesTableViewBinding,
    ?let @bool handlesEnabledBinding,
    ?let @bool handlesHiddenBinding,
    ?let @bool handleGraphicControllerBinding,
    ?3*
  )
//-- $graphicController
  outEBViewGraphicControllerBindingGeneration = .none
  switch inGraphicController
  case none :
  case defined (@lstring controllerName, @lstring propertyName) :
    if not handleGraphicControllerBinding then
      error inTypeName : "the '" + inTypeName + "' type does not handle the $graphicController binding"
    else
      inObservablePropertyMap.searchKey
        (controllerName,
        ?let @propertyKind kind,
        ?2*
      )
      switch kind 
      case property (2*) :
        error controllerName : "the bound model should be an array controller"
      case toMany (4*) :
        error controllerName : "the bound model should be an array controller"
      case toOne (5*) :
        error controllerName : "the bound model should be an array controller"
      case arrayController (entityName, graphic) :
        if propertyName.string == "" then
          if not graphic then
            error controllerName : "the controlled entity (" + entityName + ") should be a graphic entity"
          end
        else
          inSemanticContext.mClassMap.searchKey
            (entityName,
            ?*,
            ?let observablePropertyMap,
            ?2*
          )
          observablePropertyMap.searchKey (propertyName, ?let propertyKind, ?2*)
          switch propertyKind 
          case property (2*) :
            error controllerName : "the bound model should be a toMany property"
          case toMany (kEntityName, *, isGraphic, *) :
            if not isGraphic then
              error controllerName : "the controlled entity (" + kEntityName + ") should be a graphic entity"
            end
          case toOne (5*) :
            error controllerName : "the bound model should be a toMany property"
          case arrayController (2*) :
            error controllerName : "the bound model should be a toMany property"
          case selectionController (*) :
            error controllerName : "the bound model should be a toMany property"
          end
       end
      case selectionController (*) :
        error controllerName : "the bound model should be an array controller"
      end
      outEBViewGraphicControllerBindingGeneration = .binding (!arrayControllerControllerName: controllerName.string)
    end
  end
//-- $tableView
  switch inTableValueBinding
  case noTableValueBinding :
  case tableValueBinding (@lstring controllerName) :
    if not handlesTableViewBinding then
      error inTypeName : "the '" + inTypeName + "' type does not handle the $tableView binding"
    elsif inPreferences then
      inPreferencesPropertyMap.searchKey
        (controllerName,
        ?let @propertyKind kind,
        ?2*
      )
      if not kind.isArrayController then
        error controllerName : "the bound model should be an array controller"
      end
      outTableViewBindingGeneration = controllerName.string
    else
      inObservablePropertyMap.searchKey
        (controllerName,
        ?let @propertyKind kind,
        ?2*
      )
      if not kind.isArrayController then
        error controllerName : "the bound model should be an array controller"
      end
      outTableViewBindingGeneration = controllerName.string
    end
  end
//-- $run
  analyzeAutoLayoutRunBinding (
    inRunActionDescriptor,
    !handlesRunAction: handlesRunAction,
    inPreferences,
    inTypeName,
    inActionMap,
    inObservablePropertyMap,
    inReceiverSwiftTypeName,
    inPreferencesActionMap,
    ?outRunBindingGeneration
  )
//-- Enabled
  analyzeAutoLayoutEnableBinding (
    inEnabledBindingDescriptor,
    !handlesEnabledBinding: handlesEnabledBinding,
    !prefs: inPreferences,
    inRootObservablePropertyMap,
    inSemanticContext,
    inObservablePropertyMap,
    !prefsMap: inPreferencesPropertyMap,
    ?let enabledBindingGeneration
  )
  switch enabledBindingGeneration
  case none :
  case enabled (binding) :
    !?outMultipleBindingGenerationList.append ("enabled", binding)
  end
//-- Hidden
  switch inHiddenBindingDescriptor
  case noBinding :
  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
    expression.analyzeExpressionForMultipleBinding
      (!prefs: inPreferences,
      inRootObservablePropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inPreferencesPropertyMap,
      ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression,
      ?let @typeKind type,
      ?let @location errorLocation
    )
    if not type.isBoolType then
      error errorLocation : "expression is not boolean"
    end
    if not handlesHiddenBinding then
      error errorLocation : "cet outlet n'accepte pas le binding $hidden"
    end
    !?outMultipleBindingGenerationList.append (
      !"hidden",
      !hiddenExpression
    )
  end
//--------------------------------- Regular bindings
  analyzeAutoLayoutRegularBinding (
    !prefs: inPreferences,
    inRootObservablePropertyMap,
    inPreferencesPropertyMap,
    inSemanticContext,
    inObservablePropertyMap,
    inTypeName,
    inRegularBindingList,
    if inPreferences then "preferences_" else "self." end,
    !?outRegularBindingsGenerationList
  )
}

//--------------------------------------------------------------------------------------------------

proc analyzeAutoLayoutEnableBinding(
  let @multipleBindingDescriptor inEnabledBindingDescriptor,
  ?handlesEnabledBinding: let @bool inHandlesEnabledBinding,
  ?prefs: let @bool inPreferences,
  let @propertyMap inRootObservablePropertyMap,
  let @semanticContext inSemanticContext,
  let @propertyMap inObservablePropertyMap,
  ?prefsMap: let @propertyMap inPreferencesPropertyMap,
  !@autolayoutEnabledBindingForGeneration outEnabledBindingGeneration)
{
  switch inEnabledBindingDescriptor
  case noBinding :
    outEnabledBindingGeneration = .none
  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
    expression.analyzeExpressionForMultipleBinding
      (!prefs: inPreferences,
      inRootObservablePropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inPreferencesPropertyMap,
      ?let @abstractBooleanMultipleBindingExpressionForGeneration enableExpression,
      ?let @typeKind type,
      ?let @location errorLocation
    )
    if not inHandlesEnabledBinding then
      error errorLocation : "cet outlet n'accepte pas le binding $enabled"
    end
    if not type.isBoolType then
      error errorLocation : "expression is not boolean"
    end
    outEnabledBindingGeneration = .enabled (!binding: enableExpression)
  end
}

//--------------------------------------------------------------------------------------------------

proc analyzeAutoLayoutRunBinding (let @runActionDescriptor inRunActionDescriptor,
                                  ?handlesRunAction: let @bool inHandlesRunAction,
                                  let @bool inPreferences,
                                  let @lstring inTypeName,
                                  let @actionMap inActionMap,
                                  let @propertyMap inObservablePropertyMap,
                                  let @string inReceiverSwiftTypeName,
                                  let @actionMap inPreferencesActionMap,
                                  !@autolayoutRunBindingForGeneration outRunBindingGeneration) {
  switch inRunActionDescriptor
  case noAction :
    outRunBindingGeneration = .none
  case action (@lstring target, @lstring action) :
    if not inHandlesRunAction then
      error inTypeName : "the '" + inTypeName + "' type does not handle run action"
      spoil (outRunBindingGeneration)
    elsif target.string == "self" then
      inActionMap.searchKey (action)
      outRunBindingGeneration = .run (
        !targetName: "self",
        !actionName: action.string,
        !targetTypeName: inReceiverSwiftTypeName
      )
    elsif target.string == "prefs" then
      inPreferencesActionMap.searchKey (action)
      outRunBindingGeneration = .run (
        !targetName: "g" + preferencesName () + "!",
        !actionName: action.string,
        !targetTypeName: preferencesName ()
      )
    else // It is a controller
      inObservablePropertyMap.searchKey
        (target,
        ?*,
        ?let @actionMap controllerActionMap,
        ?*
      )
      controllerActionMap.searchKey (action)
      outRunBindingGeneration = .run (
        !targetName: if inPreferences then "preferences_" else "" end + target.string,
        !actionName: action.string,
        !targetTypeName: "Controller_" + inReceiverSwiftTypeName + "_" + target
      )
    end
  end
}

//--------------------------------------------------------------------------------------------------

proc analyzeAutoLayoutRegularBinding(
  ?prefs: let @bool inPreferences,
  let @propertyMap inRootPropertyMap,
  let @propertyMap inPreferencesPropertyMap,
  let @semanticContext inSemanticContext,
  let @propertyMap inBoundModelPropertyMap,
  let @lstring inOutletTypeName,
  let @regularBindingList inRegularBindingList,
  let @string inSelfSwiftName,
  ?!@autoLayoutRegularBindingsGenerationList ioRegularBindingsGenerationList)
{
  for (mBindingName, mObservablePropertyList, mBindingOptionList) in inRegularBindingList do
  //-- Analyze model
    var @outletBindingModelList boundModelTypeList = []
    var @boundObjectList boundModelListForGeneration = []
    for (mObservableProperty) in mObservablePropertyList do
      mObservableProperty.analyzeObservableProperty
        (inRootPropertyMap,
        inSemanticContext,
        if inPreferences then inPreferencesPropertyMap else inBoundModelPropertyMap end,
        ?let @propertyKind kind,
        ?let @string unused swiftTypeStringForTransientFunctionArgument,
        ?let @string unused protocolTypeName,
        ?let @string unused defaultValueAsString
      )
      switch kind
      case property (2*) : // Ok
      case toMany (4*) :
        error mObservableProperty.location :"a toMany property cannot be bound"
      case toOne (5*) :
        error mObservableProperty.location :"a toOne property cannot be bound"
      case arrayController (2*) :
        error mObservableProperty.location :"an array controller cannot be bound"
      case selectionController (*) :
        error mObservableProperty.location :"a selection controller cannot be bound"
      end
      !?boundModelListForGeneration.append (mObservableProperty.modelStringForSelf (inSelfSwiftName), kind)
      !?boundModelTypeList.append (kind, mObservableProperty.location )
    end
  //-- Analyze outlet binding
    var @outletBindingSpecificationModelList outletBindingSpecificationModelList = []
    var @controllerBindingOptionDecoratedList controllerBindingOptionDecoratedList = []
    var outletTypeName = inOutletTypeName
    var continues = true
    loop (inSemanticContext.mBindingSpecificationMap.count + 1) while (outletTypeName.string != "") & continues do
      continues = false
      inSemanticContext.mAutoLayoutBindingSpecificationMap.searchKey
        (outletTypeName,
        ?let superOutletClassName,
        ?let bindingMap
      )
      if bindingMap.hasKey (mBindingName.string) then
        bindingMap.searchKey
          (mBindingName,
          ?outletBindingSpecificationModelList,
          ?controllerBindingOptionDecoratedList
        )
      else
        continues = true
        outletTypeName = superOutletClassName
      end
    end
    if continues then
      error mBindingName : "this binding is not defined"
    elsif boundModelTypeList.count != outletBindingSpecificationModelList.count then
      error mBindingName
      : outletBindingSpecificationModelList.count .string
        + " model(s) required for this binding (found: "
        + boundModelTypeList.count + ")"
    else
      for (required_mModelType, required_mModelShouldBeWritableProperty) in outletBindingSpecificationModelList, (found_mKind, found_mErrorLocation) in boundModelTypeList do
        if required_mModelShouldBeWritableProperty && found_mKind.isTransient then
          error found_mErrorLocation : "the model is transient and the binding requires an writable model"
        end
        if required_mModelType.isEnumType && found_mKind.isEnumType then // Ok
        elsif required_mModelType.swiftTypeName != found_mKind.swiftTypeName then
          error found_mErrorLocation : "the model type should be " + required_mModelType.swiftTypeName
        end
      end
    end
  //-- Check options
    var bindingOptionString = ""
    if controllerBindingOptionDecoratedList.count != mBindingOptionList.count then
      var @string s
      if controllerBindingOptionDecoratedList.count == 0 then
        s = "this binding has no option"
      else 
        s = "this binding requires the following options:"
        for (mOptionType, mOptionName) in controllerBindingOptionDecoratedList do
          s += "\n  - " + mOptionName + " : " + mOptionType.swiftTypeName
        end
      end
      error mBindingName : s
    else
      for (controller_mOptionType, controller_mOptionName) in controllerBindingOptionDecoratedList, (binding_mOptionName, binding_mOptionValue) in mBindingOptionList do
        if controller_mOptionName.string != binding_mOptionName.string then
          error binding_mOptionName : "the option name should be '" + controller_mOptionName + "'"
        end
        binding_mOptionValue.analyzeDefaultValueType (
          [@(controller_mOptionType)],
          inPreferencesPropertyMap,
          ?let @string optionValueAsString
        )
        bindingOptionString += ", " + controller_mOptionName.string + ":" + optionValueAsString
      end
    end
  //-- Generate binding
    !?ioRegularBindingsGenerationList.append (
      !mBindingName.string,
      !boundModelListForGeneration,
      !bindingOptionString
    )
  end
}

//--------------------------------------------------------------------------------------------------

override proc @astHStackViewInstructionDeclaration.generateViewCode(
                        let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                        ?prefs: let @bool inPreferences,
                        let @propertyMap inRootObservablePropertyMap,
                        let @propertyMap inPreferencesPropertyMap,
                        let @semanticContext inSemanticContext,
                        let @propertyMap inObservablePropertyMap,
                        let @actionMap inActionMap,
                        let @string inReceiverSwiftTypeName,
                        let @classMap inClassMap,
                        ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                        ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                        ?!@autoLayoutOutletMap ioOutletMap,
                        !@abstractViewInstructionGeneration outInstruction) {
  inClassMap.searchKey (!@(preferencesName (), .nowhere), ?2*, ?let preferencesActionMap, ?*)
  var @autoLayoutViewInstructionGenerationList instructionList = []
  self.mFunctionCallList.checkViewFunctionCallList (
     inSemanticContext.mAutoLayoutHStackFunctionMap,
     inViewDeclarationMap,
     inPreferences,
     preferencesActionMap,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
  var @autoLayoutMultipleBindingGenerationList multipleBindingGenerationList = []
  switch self.mOptionalHiddenBinding 
  case noBinding :
  case binding (hiddenBindingExpression) :
    hiddenBindingExpression.analyzeExpressionForMultipleBinding
      (!prefs: inPreferences,
      inRootObservablePropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inPreferencesPropertyMap,
      ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression,
      ?let @typeKind type,
      ?let @location errorLocation
    )
    if not type.isBoolType then
      error errorLocation : "expression is not boolean"
    end
    !?multipleBindingGenerationList.append (
      !"hidden",
      !hiddenExpression
    )
  end
  for (instruction) in self.mInstructionList do
   instruction.generateViewCode
      (inViewDeclarationMap,
      !prefs: inPreferences,
      inRootObservablePropertyMap,
      inPreferencesPropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inActionMap,
      inReceiverSwiftTypeName,
      inClassMap,
      !?ioImplicitViewFunctionGenerationList,
      !?ioConfiguratorMap,
      !?ioOutletMap,
      ?let generatedInstruction
    )
    !?instructionList.append (generatedInstruction)
  end
  outInstruction = @hStackViewInstructionGeneration (
    funcCallList,
    instructionList,
    multipleBindingGenerationList,
    self.mAstNewStackViewDeclarationList
  )
}

//--------------------------------------------------------------------------------------------------

override proc @astVStackViewInstructionDeclaration.generateViewCode(
                        let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                        ?prefs: let @bool inPreferences,
                        let @propertyMap inRootObservablePropertyMap,
                        let @propertyMap inPreferencesPropertyMap,
                        let @semanticContext inSemanticContext,
                        let @propertyMap inObservablePropertyMap,
                        let @actionMap inActionMap,
                        let @string inReceiverSwiftTypeName,
                        let @classMap inClassMap,
                        ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                        ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                        ?!@autoLayoutOutletMap ioOutletMap,
                        !@abstractViewInstructionGeneration outInstruction) {
  inClassMap.searchKey (!@(preferencesName (), .nowhere), ?2*, ?let preferencesActionMap, ?*)
  var @autoLayoutViewInstructionGenerationList instructionList = []
  self.mFunctionCallList.checkViewFunctionCallList (
     inSemanticContext.mAutoLayoutVStackFunctionMap,
     inViewDeclarationMap,
     inPreferences,
     preferencesActionMap,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
  var @autoLayoutMultipleBindingGenerationList multipleBindingGenerationList = []
  switch self.mOptionalHiddenBinding 
  case noBinding :
  case binding (hiddenBindingExpression) :
    hiddenBindingExpression.analyzeExpressionForMultipleBinding
      (!prefs: inPreferences,
      inRootObservablePropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inPreferencesPropertyMap,
      ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression,
      ?let @typeKind type,
      ?let @location errorLocation
    )
    if not type.isBoolType then
      error errorLocation : "expression is not boolean"
    end
    !?multipleBindingGenerationList.append ("hidden", hiddenExpression)
  end
  for (instruction) in self.mInstructionList do
   instruction.generateViewCode (
      inViewDeclarationMap,
      !prefs: inPreferences,
      inRootObservablePropertyMap,
      inPreferencesPropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inActionMap,
      inReceiverSwiftTypeName,
      inClassMap,
      !?ioImplicitViewFunctionGenerationList,
      !?ioConfiguratorMap,
      !?ioOutletMap,
      ?let generatedInstruction
    )
    !?instructionList.append (generatedInstruction)
  end
  outInstruction = @vStackViewInstructionGeneration (
    self.mHasVerticalScroller,
    self.mConfiguratorName,
    funcCallList,
    instructionList,
    multipleBindingGenerationList,
    self.mAstNewStackViewDeclarationList
  )
}

//--------------------------------------------------------------------------------------------------
//   GENERATION                            
//--------------------------------------------------------------------------------------------------

abstract class @abstractViewGeneration {
}

//--------------------------------------------------------------------------------------------------

class @computedHorizontalViewGeneration : @abstractViewGeneration {
  public let @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  public let @autoLayoutViewInstructionGenerationList mInstructionList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//--------------------------------------------------------------------------------------------------

class @computedVerticalViewGeneration : @abstractViewGeneration {
  public let @bool mHasVerticalScroller
  public let @lstring mConfiguratorName
  public let @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  public let @autoLayoutViewInstructionGenerationList mInstructionList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//--------------------------------------------------------------------------------------------------

list @viewGenerationList {
  public let @string mViewName
  public let @abstractViewGeneration mView
}

//--------------------------------------------------------------------------------------------------

abstract class @abstractViewInstructionGeneration {

  abstract func generateViewInstruction (?prefs: let @bool inPreferences,
                                         let @string inName,
                                         let @string inIndentation) -> @string

  abstract func generateAppendViewInstruction (?prefs: let @bool inPreferences,
                                               ?receiverView: let @string inReceiverViewName,
                                               let @string inIndentation) -> @string

}

//--------------------------------------------------------------------------------------------------

class @hStackViewInstructionGeneration : @abstractViewInstructionGeneration {
  public let @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  public let @autoLayoutViewInstructionGenerationList mInstructionList
  public let @autoLayoutMultipleBindingGenerationList mMultipleBindingGenerationList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//--------------------------------------------------------------------------------------------------

class @vStackViewInstructionGeneration : @abstractViewInstructionGeneration {
  public let @bool mHasVerticalScroller
  public let @lstring mConfiguratorName
  public let @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  public let @autoLayoutViewInstructionGenerationList mInstructionList
  public let @autoLayoutMultipleBindingGenerationList mMultipleBindingGenerationList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//--------------------------------------------------------------------------------------------------

class @autoLayoutSpaceViewInstructionGeneration : @abstractViewInstructionGeneration {
}

//--------------------------------------------------------------------------------------------------

class @autoLayoutSeparatorInstructionGeneration : @abstractViewInstructionGeneration {
  public let @bool horizontal %initArgLabel

  override func generateViewInstruction (?prefs: let @bool unused inPreferences,
                                         let @string inName,
                                         let @string inIndentation) -> @string {
    if self.horizontal then
      result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView.VerticalSeparator ()\n"
    else
      result = inIndentation + "let " + inName + " = AutoLayoutVerticalStackView.HorizontalSeparator ()\n"
    end
  }

  override func generateAppendViewInstruction (?prefs: let @bool unused inPreferences,
                                               ?receiverView: let @string inReceiverViewName,
                                               let @string inIndentation) -> @string {
    result = inIndentation + "_ = " + inReceiverViewName + ".appendSeparator ()\n"
  }


}

//--------------------------------------------------------------------------------------------------

class @autoLayoutGutterInstructionGeneration : @abstractViewInstructionGeneration {
  public let @bool horizontal %initArgLabel

  override func generateViewInstruction (?prefs: let @bool unused inPreferences,
                                         let @string inName,
                                         let @string inIndentation) -> @string {
    if self.horizontal then
      result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView.GutterSeparator ()\n"
    else
      result = inIndentation + "let " + inName + " = AutoLayoutVerticalStackView.GutterSeparator ()\n"
    end
  }

  override func generateAppendViewInstruction (?prefs: let @bool unused inPreferences,
                                               ?receiverView: let @string inReceiverViewName,
                                               let @string inIndentation) -> @string {
    result = inIndentation + "_ = " + inReceiverViewName + ".appendGutter ()\n"
  }

}

//--------------------------------------------------------------------------------------------------

class @autoLayoutDividerInstructionGeneration : @abstractViewInstructionGeneration {
  public let @bool horizontal %initArgLabel
}

//--------------------------------------------------------------------------------------------------

class @autoLayoutLocalViewInstructionGeneration : @abstractViewInstructionGeneration {
  public let @string mLocalView
}

//--------------------------------------------------------------------------------------------------

list @autoLayoutRegularBindingsGenerationList {
  public let @string mBindingName
  public let @boundObjectList mBoundObjectList
  public let @string mBindingOptionsString
}

//--------------------------------------------------------------------------------------------------

list @autoLayoutMultipleBindingGenerationList {
  public let @string mBindingName
  public let @abstractBooleanMultipleBindingExpressionForGeneration mBoundObjectExpression
}

//--------------------------------------------------------------------------------------------------

enum @autolayoutRunBindingForGeneration {
  case none
  case run (@string targetName, @string actionName, @string targetTypeName)
}

//--------------------------------------------------------------------------------------------------

enum @autoLayoutViewGraphicControllerBindingGeneration {
  case none
  case binding (@string arrayControllerControllerName)
}

//--------------------------------------------------------------------------------------------------

enum @autolayoutEnabledBindingForGeneration {
  case none
  case enabled (@abstractBooleanMultipleBindingExpressionForGeneration binding)
}

//--------------------------------------------------------------------------------------------------

class @autoLayoutComputedViewInstructionGeneration : @abstractViewInstructionGeneration {
  public let @lstring mAutoLayoutViewClassName
  public let @autoLayoutViewInstructionGenerationParameterList mParameterList
  public let @autoLayoutViewInstructionGenerationFuncCallList mFunctionCallList
  public let @autoLayoutRegularBindingsGenerationList mRegularBindingsGenerationList
  public let @autoLayoutMultipleBindingGenerationList mMultipleBindingGenerationList
  public let @autolayoutRunBindingForGeneration mRunBindingGeneration
  public let @string mTableViewBindingGeneration // Bound controller name; empty string means no binding
  public let @autoLayoutViewGraphicControllerBindingGeneration mEBViewGraphicControllerBindingGeneration
  public let @string mConfiguratorName // Empty string if no configurator
  public let @string mOutletName // Empty string if no configurator
  public let @bool mOutletIsArray
}

//--------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationParameterList {
  public let @string mParameterName
  public let @string mParameterValue
}

//--------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationFuncCallList {
  public let @string mFunctionName
  public let @autoLayoutViewInstructionGenerationParameterList mParameters
}

//--------------------------------------------------------------------------------------------------

proc @autoLayoutViewInstructionGenerationFuncCallList.generate (let @string inIndentation, ?!@string ioStr) {
  for (funcName, parameterList) in self do
    ioStr += inIndentation + "  ." + funcName + " ("
    for (parameterName, parameterStringValue) in parameterList
      do ioStr += parameterName + ": " + parameterStringValue
      between ioStr += ", "
    end
    ioStr += ")\n"
  end
}

//--------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationList {
  public let @abstractViewInstructionGeneration mInstruction
}

//--------------------------------------------------------------------------------------------------

abstract func @abstractViewGeneration.generateViewBuilder (?prefs: let @bool inPreferences,
                                                           let @string inViewName) -> @string

//--------------------------------------------------------------------------------------------------

override func @computedHorizontalViewGeneration.generateViewBuilder (?prefs: let @bool inPreferences,
                                                                     let @string inViewName) -> @string {
  result = "  final func " + inViewName + " () -> AutoLayoutHorizontalStackView {\n"
  result += "    let hStackView = AutoLayoutHorizontalStackView ()\n"
  self.mFuncCallList.generate ("    ", !?result)
  for (instance, type) in self.mNewStackViewDeclarationList do
    result += "    let " + instance + " = self." + type + " ()\n"
  end
  for (instruction) in self.mInstructionList do // (index)
    result += instruction.generateAppendViewInstruction (!prefs: inPreferences, !receiverView: "hStackView", "    ")
  end
  result += "    return hStackView\n"
  result += "  }\n\n"
}

//--------------------------------------------------------------------------------------------------

override func @computedVerticalViewGeneration.generateViewBuilder (?prefs: let @bool inPreferences,
                                                                   let @string inViewName) -> @string {
  result =  "  final func " + inViewName + " () -> AutoLayoutVerticalStackView {\n"
  result += "    let vStackView = "
  if self.mHasVerticalScroller then
    result += "AutoLayoutVerticalStackViewWithScrollBar"
  else
    result += "AutoLayoutVerticalStackView"
  end
  result += " ()\n"
  if self.mConfiguratorName.string != "" then
    result += "    self.configure_" + self.mConfiguratorName + " (vStackView)\n"
  end
  self.mFuncCallList.generate ("    ", !?result)
  for (instance, type) in self.mNewStackViewDeclarationList do
    result += "    let " + instance + " = self." + type + " ()\n"
  end
  for (instruction) in self.mInstructionList do
    result += instruction.generateAppendViewInstruction (!prefs: inPreferences, !receiverView: "vStackView", "    ")
  end
  result += "    return vStackView\n"
  result += "  }\n\n"
}

//--------------------------------------------------------------------------------------------------

override func @autoLayoutSpaceViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool unused inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutFlexibleSpace ()\n"
}

//--------------------------------------------------------------------------------------------------

override func @autoLayoutSpaceViewInstructionGeneration.generateAppendViewInstruction (?prefs: let @bool unused inPreferences,
                                             ?receiverView: let @string inReceiverViewName,
                                             let @string inIndentation) -> @string {
//  result = inIndentation + "_ = " + inReceiverViewName + ".appendView (AutoLayoutFlexibleSpace ())\n"
  result = inIndentation + "_ = " + inReceiverViewName + ".appendFlexibleSpace ()\n"
}

//--------------------------------------------------------------------------------------------------

override func @autoLayoutDividerInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool unused inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  if self.horizontal then
    result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView.VerticalDivider ()\n"
  else
    result = inIndentation + "let " + inName + " = AutoLayoutVerticalStackView.HorizontalDivider ()\n"
  end
}

override func @autoLayoutDividerInstructionGeneration.generateAppendViewInstruction (?prefs: let @bool unused inPreferences,
                                             ?receiverView: let @string inReceiverViewName,
                                             let @string inIndentation) -> @string {
  result = inIndentation + "_ = " + inReceiverViewName + ".appendDivider ()\n"
}

//--------------------------------------------------------------------------------------------------

override func @autoLayoutLocalViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool unused inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = " + self.mLocalView + "\n"
}

override func @autoLayoutLocalViewInstructionGeneration.generateAppendViewInstruction (?prefs: let @bool unused inPreferences,
                                             ?receiverView: let @string inReceiverViewName,
                                             let @string inIndentation) -> @string {
  result = inIndentation + "_ = " + inReceiverViewName + ".appendView (" + self.mLocalView + ")\n"
}

//--------------------------------------------------------------------------------------------------

override func @autoLayoutComputedViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = AutoLayout" + self.mAutoLayoutViewClassName.string + " ("
  for parameter in self.mParameterList
  do
    result += parameter.mParameterName + ": " + parameter.mParameterValue
  between
    result += ", "
  end
  result += ")\n"
  self.mFunctionCallList.generate (inIndentation, !?result)
  for (bindingName, boundObjectList, optionListString) in self.mRegularBindingsGenerationList do
    result += inIndentation + "  .bind_" + bindingName + " ("
    for (boundObjectString, *) in boundObjectList
      do result += boundObjectString
      between result += ", "
    end
    result += optionListString + ")\n"
  end
  for (bindingName, binding) in self.mMultipleBindingGenerationList do 
    result += inIndentation + "  .bind_" + bindingName + " (" + binding.expressionString + ")\n"
  end
  switch self.mRunBindingGeneration
  case none :
  case run (targetName, actionName, targetTypeName) :
    result += inIndentation + "  .bind_run (\n"
    result += inIndentation + "    target: " + targetName + ",\n"
    result += inIndentation + "    selector: #selector (" + targetTypeName + "." + actionName + " (_:))\n"
    result += inIndentation + "  )\n"
  end
  switch self.mEBViewGraphicControllerBindingGeneration
  case none :
  case binding (controllerName) :
    result += inIndentation + "  .bind_graphic_controller (self." + controllerName + ")\n"
  end
  if self.mTableViewBindingGeneration != "" then
    let prefix = if inPreferences then "preferences_" else "self." end
    result += inIndentation + prefix + self.mTableViewBindingGeneration + ".bind_tableView (" + inName + ")\n"
  end
  if self.mOutletName != "" then
    if self.mOutletIsArray then
       result += inIndentation + "self." + self.mOutletName + ".append (" + inName + ") // Outlet Array\n"
   else
      result += inIndentation + "self." + self.mOutletName + " = " + inName + " // Outlet\n"
    end
  end
  if self.mConfiguratorName != "" then
    result += inIndentation + "self.configure_" + self.mConfiguratorName + " (" + inName + ") // Configurator\n"
  end
}

//--------------------------------------------------------------------------------------------------

override func @autoLayoutComputedViewInstructionGeneration.generateAppendViewInstruction (?prefs: let @bool inPreferences,
                                             ?receiverView: let @string inReceiverViewName,
                                             let @string inIndentation) -> @string {
  result = inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  let name = inReceiverViewName + "_view"
  result += indentation + "let " + name + " = AutoLayout" + self.mAutoLayoutViewClassName.string + " ("
  for parameter in self.mParameterList
  do
    result += parameter.mParameterName + ": " + parameter.mParameterValue
  between
    result += ", "
  end
  result += ")\n"
  self.mFunctionCallList.generate (indentation, !?result)
  for (bindingName, boundObjectList, optionListString) in self.mRegularBindingsGenerationList do
    result += indentation + "  .bind_" + bindingName + " ("
    for (boundObjectString, *) in boundObjectList
      do result += boundObjectString
      between result += ", "
    end
    result += optionListString + ")\n"
  end
  for (bindingName, binding) in self.mMultipleBindingGenerationList do 
    result += indentation + "  .bind_" + bindingName + " (" + binding.expressionString + ")\n"
  end
  switch self.mRunBindingGeneration
  case none :
  case run (targetName, actionName, targetTypeName) :
    result += indentation + "  .bind_run (\n"
    result += indentation + "    target: " + targetName + ",\n"
    result += indentation + "    selector: #selector (" + targetTypeName + "." + actionName + " (_:))\n"
    result += indentation + "  )\n"
  end
  switch self.mEBViewGraphicControllerBindingGeneration
  case none :
  case binding (controllerName) :
    result += indentation + "  .bind_graphic_controller (self." + controllerName + ")\n"
  end
  if self.mTableViewBindingGeneration != "" then
    let prefix = if inPreferences then "preferences_" else "self." end
    result += indentation + prefix + self.mTableViewBindingGeneration + ".bind_tableView (" + name + ")\n"
  end
  if self.mOutletName != "" then
    if self.mOutletIsArray then
       result += indentation + "self." + self.mOutletName + ".append (" + name + ") // Outlet Array\n"
   else
      result += indentation + "self." + self.mOutletName + " = " + name + " // Outlet\n"
    end
  end
  if self.mConfiguratorName != "" then
    result += indentation + "self.configure_" + self.mConfiguratorName + " (" + name + ") // Configurator\n"
  end
  result += indentation + "_ = " + inReceiverViewName + " .appendView (" + name + ")\n"
  result += inIndentation +  "}\n"
}

//--------------------------------------------------------------------------------------------------

override func @hStackViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView ()\n"
  self.mFuncCallList.generate (inIndentation, !?result)
  for (bindingName, binding) in self.mMultipleBindingGenerationList do 
    result += inIndentation + "  .bind_" + bindingName + " (" + binding.expressionString + ")\n"
  end
  for (instance, type) in self.mNewStackViewDeclarationList do
    result += inIndentation + "let " + instance + " = self." + type + " ()\n"
  end
  for (instruction) in self.mInstructionList do
     result += instruction.generateAppendViewInstruction (!prefs: inPreferences, !receiverView: inName, inIndentation)
  end
}

//--------------------------------------------------------------------------------------------------

override func @hStackViewInstructionGeneration.generateAppendViewInstruction (?prefs: let @bool inPreferences,
                                             ?receiverView: let @string inReceiverViewName,
                                             let @string inIndentation) -> @string {
  result = inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  let name = inReceiverViewName + "_view"
  result += indentation + "let " + name + " = AutoLayoutHorizontalStackView ()\n"
  self.mFuncCallList.generate (indentation, !?result)
  for (bindingName, binding) in self.mMultipleBindingGenerationList do 
    result += indentation + "  .bind_" + bindingName + " (" + binding.expressionString + ")\n"
  end
  for (instance, type) in self.mNewStackViewDeclarationList do
    result += indentation + "let " + instance + " = self." + type + " ()\n"
  end
  for (instruction) in self.mInstructionList do
     result += instruction.generateAppendViewInstruction (!prefs: inPreferences, !receiverView: name, indentation)
  end
  result += indentation + "_ = " + inReceiverViewName + " .appendView (" + name + ")\n"
  result += inIndentation + "}\n"
}

//--------------------------------------------------------------------------------------------------

override func @vStackViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = "
  if self.mHasVerticalScroller then
    result += "AutoLayoutVerticalStackViewWithScrollBar"
  else
    result += "AutoLayoutVerticalStackView"
  end
  result += " ()\n"
  if self.mConfiguratorName.string != "" then
    result += "    self.configure_" + self.mConfiguratorName + " (" + inName + ")\n"
  end
  self.mFuncCallList.generate (inIndentation, !?result)
  for (bindingName, binding) in self.mMultipleBindingGenerationList do 
    result += inIndentation + "  .bind_" + bindingName + " (" + binding.expressionString + ")\n"
  end
  for (instance, type) in self.mNewStackViewDeclarationList do
    result += inIndentation + "let " + instance + " = self." + type + " ()\n"
  end
  for (instruction) in self.mInstructionList do
     result += instruction.generateAppendViewInstruction (!prefs: inPreferences, !receiverView: inName, inIndentation)
  end
}

//--------------------------------------------------------------------------------------------------

override func @vStackViewInstructionGeneration.generateAppendViewInstruction (?prefs: let @bool inPreferences,
                                             ?receiverView: let @string inReceiverViewName,
                                             let @string inIndentation) -> @string {
  result = inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  let name = inReceiverViewName + "_view"
  result += indentation + "let " + name + " = "
  if self.mHasVerticalScroller then
    result += "AutoLayoutVerticalStackViewWithScrollBar"
  else
    result += "AutoLayoutVerticalStackView"
  end
  result += " ()\n"
  self.mFuncCallList.generate (indentation, !?result)
  for (bindingName, binding) in self.mMultipleBindingGenerationList do 
    result += indentation + "  .bind_" + bindingName + " (" + binding.expressionString + ")\n"
  end
  for (instance, type) in self.mNewStackViewDeclarationList do
    result += indentation + "let " + instance + " = self." + type + " ()\n"
  end
  for (instruction) in self.mInstructionList do // (index)
     result += instruction.generateAppendViewInstruction (!prefs: inPreferences, !receiverView: name, indentation)
  end
  result += indentation + "_ = " + inReceiverViewName + ".appendView (" + name + ")\n"
  if self.mConfiguratorName.string != "" then
    result += indentation + "self.configure_" + self.mConfiguratorName + " (" + name + ")\n"
  end
  result += inIndentation + "}\n"
}

//--------------------------------------------------------------------------------------------------
