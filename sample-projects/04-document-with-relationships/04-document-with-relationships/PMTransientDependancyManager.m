//---------------------------------------------------------------------------*
//                                                                           *
//                  File 'PMTransientDependancyManager.m'                    *
//                    Generated by version 0.0.1 [debug]                     *
//                     december 30th, 2012, at 10h7'31"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1


#import "PMTransientDependancyManager.h"
#import "easy-bindings-utilities.h"

//-----------------------------------------------------------------------------*

static PMTransientDependancyManager * gDependancyTrigger ;
static NSArray * gTriggeredPropertyArray ;

//-----------------------------------------------------------------------------*

@implementation PMTransientDependancyManager

//-----------------------------------------------------------------------------*

+ (void) enterTriggerForObject: (NSObject *) inObject
         transientIndex: (const NSUInteger) inIndex {
  if (nil == gDependancyTrigger) {
    gDependancyTrigger = [PMTransientDependancyManager new] ;
  }
  [gDependancyTrigger
    enterTriggerForObject:inObject
    transientIndex:inIndex
  ] ;
}

//-----------------------------------------------------------------------------*

- (id) init {
  self = [super init] ;
  if (self) {
    for (NSUInteger i=0 ; i<TRANSIENT_COUNT ; i++) {
      mObserverObjectArray [i] = [NSMutableSet new] ;
    }
    gTriggeredPropertyArray = [NSArray arrayWithObjects:
      @"countItemMessage", // document.PMDocument.countItemMessage
      @"canRemoveString", // document.PMDocument.canRemoveString
      nil
    ] ;
    macroRetain (gTriggeredPropertyArray) ;
  }
  return self ;
}

//-----------------------------------------------------------------------------*

- (void) enterTriggerForObject: (NSObject *) inObject
         transientIndex: (const NSUInteger) inIndex {
  [mObserverObjectArray [inIndex] addObject:inObject] ;
  if (! mDeferredMessageSent) {
    mDeferredMessageSent = YES ;
    [[NSRunLoop mainRunLoop]
      performSelector:@selector (triggerChange)
      target:self
      argument:nil
      order:NSUIntegerMax
      modes:[NSArray arrayWithObject:NSDefaultRunLoopMode]
    ] ;
  }
}

//-----------------------------------------------------------------------------*

- (void) triggerChange {
  for (NSUInteger i=0 ; i<TRANSIENT_COUNT ; i++) {
    NSMutableSet * s = mObserverObjectArray [i] ;
    macroRetain (s) ;
    mObserverObjectArray [i] = [NSMutableSet new] ;
    for (NSObject * object in s) {
      [object willChangeValueForKey:[gTriggeredPropertyArray objectAtIndex:i]] ;
      [object  didChangeValueForKey:[gTriggeredPropertyArray objectAtIndex:i]] ;
    }
    macroReleaseSetToNil (s) ;
  }
  mDeferredMessageSent = NO ;
}

//-----------------------------------------------------------------------------*

@end
//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

