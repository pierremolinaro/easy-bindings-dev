semantics controllerClassAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @controllerClassDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#--- Analyze actions
#  @actionMap actionMap [emptyMap] ;
#  for actionName in mActionDeclarationList do
#    [!?actionMap insertKey !actionName->mValue] ;
#  end for ;
##--- Analyze bindings
#  buildBindingCapabilitiesMap
#    !mBindingList
#    !?ioUnifiedTypeMap
#    ?@outletClassBindingMap bindingMap
#  ;
#--- Analyze attributes
#  @observablePropertyMap observablePropertyMap [emptyMap] ;
  for property in mControllerObservablePropertyList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !property->mTypeName
      ?@unifiedTypeProxy attributeTypeProxy
    ] ;
#    [!?observablePropertyMap insertKey
#      !property->mPropertyName
#      !attributeTypeProxy
#      !false # is not transient
#      !"controller." . mControllerClassName . "." . property->mPropertyName
#      !false # Is not a collection
#    ] ;
  end for ;
#---
#  @outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap [emptyMap] ;
  foreach mControlledObjectBindingOptionList do
#    @unifiedTypeProxyList acceptableTypeList [emptyList] ;
    foreach mAcceptableTypeList do
      [@unifiedTypeProxy makeProxy
        !?ioUnifiedTypeMap
        !mValue
        ?@unifiedTypeProxy type
      ] ;
#      acceptableTypeList += !type ;
    end foreach ;
#    [!?controlledObjectAvailableBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
  end foreach ;
#---
  [!?ioUnifiedTypeMap insertKey
    !mControllerClassName
    ![@ebType new !mControllerClassName ![@typeKind controllerClassType]]
    !selfcopy
    !@entityRelationshipMap {}
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @controllerClassDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Super class ?
  @observablePropertyMap observablePropertyMap [emptyMap] ;
#----------------------------------
  buildObservablePropertyMap
    ![@attributeList emptyList]
    ![@classArrayList emptyList]
    ![@transientList emptyList]
    ![@controllerList emptyList]
    !mControllerObservablePropertyList
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"controller." . mControllerClassName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mControllerClassName
    !mUserDefined
    ![@typeKind controllerClassType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @controllerClassDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#--- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#---
  @outletClassBindingMap bindingMap [emptyMap] ;
  foreach mBindingList do
    @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
    foreach mBindingOptionList do
      @ebTypeList acceptableTypeList [emptyList] ;
      foreach mAcceptableTypeList do
        [inUnifiedTypeMap searchKey !mValue ?@ebType type ?2*] ;
        acceptableTypeList += !type ;
      end foreach ;
      [!?outletClassBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
    end foreach ;
    @ebTypeAndFormatterList acceptableTypeFormatterList [emptyList] ;
    foreach mAcceptableTypeFormatterList do
      [inUnifiedTypeMap searchKey !mTypeName ?@ebType type ?2*] ;
      acceptableTypeFormatterList += !type !mRequiredFormatter ;
    end foreach ;
    [!?bindingMap insertKey !mBindingName !acceptableTypeFormatterList !outletClassBindingOptionMap] ;
  end foreach ;
#---
  @outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap [emptyMap] ;
  foreach mControlledObjectBindingOptionList do
    @ebTypeList acceptableTypeList [emptyList] ;
    foreach mAcceptableTypeList do
      [inUnifiedTypeMap searchKey !mValue ?@ebType type ?2*] ;
      acceptableTypeList += !type ;
    end foreach ;
    [!?controlledObjectAvailableBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
  end foreach ;
#---
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !mControllerClassName
    ?2*
    ?@observablePropertyMap observablePropertyMap
  ] ;
#---
  [!?ioContextAnalysisStruct->mControllerClassMap insertKey
    !mControllerClassName
    !mControllerKind
    !mGenerationKind
    !bindingMap
    !actionMap
    !observablePropertyMap
    !controlledObjectAvailableBindingOptionMap
  ] ;
#----------------------------- Generation
  if mGenerationKind == [@generationKind fullGeneration] then
    ioGenerationList += ![@controllerClassGeneration new
      !mControllerClassName->string
      !bindingMap
      !observablePropertyMap
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
