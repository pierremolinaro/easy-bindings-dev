semantics controllerClassAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @controllerClassDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#--- Analyze actions
#  @actionMap actionMap [emptyMap] ;
#  for actionName in mActionDeclarationList do
#    [!?actionMap insertKey !actionName->mValue] ;
#  end for ;
##--- Analyze bindings
#  buildBindingCapabilitiesMap
#    !mBindingList
#    !?ioUnifiedTypeMap
#    ?@outletClassBindingMap bindingMap
#  ;
#--- Analyze attributes
#  @observablePropertyMap observablePropertyMap [emptyMap] ;
  for property in mControllerObservablePropertyList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !property->mTypeName
      ?@unifiedTypeProxy attributeTypeProxy
    ] ;
#    [!?observablePropertyMap insertKey
#      !property->mPropertyName
#      !attributeTypeProxy
#      !false # is not transient
#      !"controller." . mControllerClassName . "." . property->mPropertyName
#      !false # Is not a collection
#    ] ;
  end for ;
#---
#  @outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap [emptyMap] ;
  foreach mControlledObjectBindingOptionList do
#    @unifiedTypeProxyList acceptableTypeList [emptyList] ;
    foreach mAcceptableTypeList do
      [@unifiedTypeProxy makeProxy
        !?ioUnifiedTypeMap
        !mValue
        ?@unifiedTypeProxy type
      ] ;
#      acceptableTypeList += !type ;
    end foreach ;
#    [!?controlledObjectAvailableBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
  end foreach ;
#---
  [!?ioUnifiedTypeMap insertKey
    !mControllerClassName
    ![@ebType new !mControllerClassName ![@typeKind controllerClassType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @controllerClassDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Super class ?
  @observablePropertyMap observablePropertyMap [emptyMap] ;
#----------------------------------
  buildObservablePropertyMap
    ![@attributeList emptyList]
    ![@classArrayList emptyList]
    ![@transientList emptyList]
    ![@controllerList emptyList]
    !mControllerObservablePropertyList
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"controller." . mControllerClassName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mControllerClassName
    !mUserDefined
    ![@typeKind controllerClassType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @controllerClassDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#--- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#---
  @outletClassBindingMap bindingMap [emptyMap] ;
  foreach mBindingList do
    @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
    foreach mBindingOptionList do
      @ebTypeList acceptableTypeList [emptyList] ;
      foreach mAcceptableTypeList do
        [inUnifiedTypeMap searchKey !mValue ?@ebType type ?*] ;
        acceptableTypeList += !type ;
      end foreach ;
      [!?outletClassBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
    end foreach ;
    @ebTypeAndFormatterList acceptableTypeFormatterList [emptyList] ;
    foreach mAcceptableTypeFormatterList do
      [inUnifiedTypeMap searchKey !mTypeName ?@ebType type ?*] ;
      acceptableTypeFormatterList += !type !mRequiredFormatter ;
    end foreach ;
    [!?bindingMap insertKey !mBindingName !acceptableTypeFormatterList !outletClassBindingOptionMap] ;
  end foreach ;
#---
  @outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap [emptyMap] ;
  foreach mControlledObjectBindingOptionList do
    @ebTypeList acceptableTypeList [emptyList] ;
    foreach mAcceptableTypeList do
      [inUnifiedTypeMap searchKey !mValue ?@ebType type ?*] ;
      acceptableTypeList += !type ;
    end foreach ;
    [!?controlledObjectAvailableBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
  end foreach ;
#---
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !mControllerClassName
    ?2*
    ?@observablePropertyMap observablePropertyMap
  ] ;
#---
  [!?ioContextAnalysisStruct->mControllerClassMap insertKey
    !mControllerClassName
    !mControllerKind
    !mGenerationKind
    !bindingMap
    !actionMap
    !observablePropertyMap
    !controlledObjectAvailableBindingOptionMap
  ] ;
#----------------------------- Generation
  if mGenerationKind == [@generationKind fullGeneration] then
    ioGenerationList += ![@controllerClassGeneration new
      !mControllerClassName->string
      !bindingMap
      !observablePropertyMap
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

#local routine analyzeControllerClass
#  ??@controllerClassList.element inController
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#  ?!@controllerClassMap ioControllerClassMap
#:
##--- Analyze actions
#  @actionMap actionMap [emptyMap] ;
#  for actionName in inController->mActionDeclarationList do
#    [!?actionMap insertKey !actionName->mValue] ;
#  end for ;
##---
#  @EXoutletClassBindingMap bindingMap [emptyMap] ;
#  foreach inController->mBindingList do
#    @EXoutletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
#    foreach mBindingOptionList do
#      @easyBindingTypeList acceptableTypeList [emptyList] ;
#      foreach mAcceptableTypeList do
#        @easyBindingType type := [mType analyze !inContextAnalysisStruct] ;
#        acceptableTypeList += !type ;
#      end foreach ;
#      [!?outletClassBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
#    end foreach ;
#    @EXeasyBindingTypeAndFormatterList acceptableTypeFormatterList [emptyList] ;
#    foreach mAcceptableTypeFormatterList do
#      @easyBindingType type := [mType analyze !inContextAnalysisStruct] ;
#      acceptableTypeFormatterList += !type !mRequiredFormatter ;
#    end foreach ;
#    [!?bindingMap insertKey !mBindingName !acceptableTypeFormatterList !outletClassBindingOptionMap] ;
#  end foreach ;
##---
#  @observablePropertyMap observablePropertyMap [emptyMap] ;
#  for property in inController->mControllerObservablePropertyList do
#    const @lstring observationDependencyKey [new
#      !"controller." . inController->mControllerClassName . "." . property->mPropertyName
#      !property->mPropertyName->location
#    ] ;
#    [!?ioTransientDependencyGraph addNode
#      !observationDependencyKey
#      !observationDependencyKey->string
#    ] ;
#    [!?observablePropertyMap insertKey
#      !property->mPropertyName
#      ![property->mType analyze !inContextAnalysisStruct]
#      !false # is not transient
#      !observationDependencyKey->string
#    ] ;
#  end for ;
##---
#  @EXoutletClassBindingOptionMap controlledObjectAvailableBindingOptionMap [emptyMap] ;
#  foreach inController->mControlledObjectBindingOptionList do
#    @easyBindingTypeList acceptableTypeList [emptyList] ;
#    foreach mAcceptableTypeList do
#      @easyBindingType type := [mType analyze !inContextAnalysisStruct] ;
#      acceptableTypeList += !type ;
#    end foreach ;
#    [!?controlledObjectAvailableBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
#  end foreach ;
##---
#  [!?ioControllerClassMap insertKey
#    !inController->mControllerClassName
#    !inController->mControllerKind
#    !inController->mGenerationKind
#    !bindingMap
#    !actionMap
#    !observablePropertyMap
#    !controlledObjectAvailableBindingOptionMap
#  ] ;
#end routine ;
#
##----------------------------------------------------------------------------*
#
#routine analyzeControllerClasses
#  ??@controllerClassList inControllerClassList
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#  !@controllerClassMap outControllerClassMap
#:
#  outControllerClassMap := [@controllerClassMap emptyMap] ;
#  for controller in inControllerClassList do
#    analyzeControllerClass
#      !controller
#      !inContextAnalysisStruct
#      !?ioTransientDependencyGraph
#      !?outControllerClassMap
#    ;
#  end for ;
#end routine ;

#----------------------------------------------------------------------------*

end semantics ;
