semantics controllerClassAnalysis :
  import "analyzeASTtype.gSemantics" ;

#----------------------------------------------------------------------------*

local routine analyzeControllerClass
  ??@controllerClassList.element inController
  ??@contextAnalysisStruct inContextAnalysisStruct
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ?!@controllerClassMap ioControllerClassMap
:
#--- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in inController->mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#---
  @outletClassBindingMap bindingMap [emptyMap] ;
  foreach inController->mBindingList do
    @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
    foreach mBindingOptionList do
      @easyBindingTypeList acceptableTypeList [emptyList] ;
      foreach mAcceptableTypeList do
        @easyBindingType type := [mType analyze !inContextAnalysisStruct] ;
        acceptableTypeList += !type ;
      end foreach ;
      [!?outletClassBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
    end foreach ;
    @easyBindingTypeAndFormatterList acceptableTypeFormatterList [emptyList] ;
    foreach mAcceptableTypeFormatterList do
      @easyBindingType type := [mType analyze !inContextAnalysisStruct] ;
      acceptableTypeFormatterList += !type !mRequiredFormatter ;
    end foreach ;
    [!?bindingMap insertKey !mBindingName !acceptableTypeFormatterList !outletClassBindingOptionMap] ;
  end foreach ;
#---
  @observablePropertyMap observablePropertyMap [emptyMap] ;
  for property in inController->mControllerObservablePropertyList do
    const @lstring observationDependencyKey [new
      !"controller." . inController->mControllerClassName . "." . property->mPropertyName
      !property->mPropertyName->location
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
    [!?observablePropertyMap insertKey
      !property->mPropertyName
      ![property->mType analyze !inContextAnalysisStruct]
      !false # is not transient
      !observationDependencyKey->string
    ] ;
  end for ;
#---
  @outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap [emptyMap] ;
  foreach inController->mControlledObjectBindingOptionList do
    @easyBindingTypeList acceptableTypeList [emptyList] ;
    foreach mAcceptableTypeList do
      @easyBindingType type := [mType analyze !inContextAnalysisStruct] ;
      acceptableTypeList += !type ;
    end foreach ;
    [!?controlledObjectAvailableBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
  end foreach ;
#---
  [!?ioControllerClassMap insertKey
    !inController->mControllerClassName
    !inController->mControllerKind
    !inController->mGenerationKind
    !bindingMap
    !actionMap
    !observablePropertyMap
    !controlledObjectAvailableBindingOptionMap
  ] ;
end routine ;

#----------------------------------------------------------------------------*

routine analyzeControllerClasses
  ??@controllerClassList inControllerClassList
  ??@contextAnalysisStruct inContextAnalysisStruct
  ?!@transientDependencyGraph ioTransientDependencyGraph
  !@controllerClassMap outControllerClassMap
:
  outControllerClassMap := [@controllerClassMap emptyMap] ;
  for controller in inControllerClassList do
    analyzeControllerClass
      !controller
      !inContextAnalysisStruct
      !?ioTransientDependencyGraph
      !?outControllerClassMap
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
