semantics preferencesAnalysis :
  import "transientAnalysis.gSemantics" ;
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @preferencesDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  @decoratedObservablePropertyMap observablePropertyMap := {} ;
#---------------------------------- Analyze attributes
  @decoratedAttributeMap decoratedAttributeMap := {} ;
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ??@unifiedTypeProxy attributeType
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mAttributeTypeName] ;
    [!?decoratedAttributeMap insertKey
      !mAttributeName
      !attributeType
      !mDefaultValue
     ] ;
    [!?observablePropertyMap insertKey
      !mAttributeName
      !attributeType
      !false # Is not transient
      ![@lstring new !"preference." + mPreferencesName + "." + mAttributeName !mAttributeName->location]
      !false # is not a collection
     ] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mElementClassName] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  foreach mControllerList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mControllerClassName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mControllerClassName] ;
  end foreach ;
#------------------------------------- Analyze transient properties
  @decoratedTransientMap decoratedTransientMap := {} ;
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ??@unifiedTypeProxy transientType
    ] ;
    const signature := [@lstring new !"preference." + mPreferencesName + "." + mTransientName !mTransientName->location] ;
    [!?decoratedTransientMap insertKey
      !mTransientName
      !transientType
      !signature
      !mDependencyList
    ] ;
    [!?observablePropertyMap insertKey
      !mTransientName
      !transientType
      !true # Is transient
      !signature
      !false # is not a collection
     ] ;
  end foreach ;
#------------------------------------- Analyze outlets
  @decoratedOutletMap decoratedOutletMap := {} ;
  foreach mOutletDeclarationList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mOutletType
      ??@unifiedTypeProxy outletType
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mOutletType] ;
    [!?decoratedOutletMap insertKey
      !mOutletName
      !outletType
      !mOutletBindingList
    ] ;
  end foreach ;
#------------------------------------- Enter in preference map
  [!?ioUnifiedTypeMap insertKey
    !mPreferencesName
    ![@typeKind preferencesType]
    ![@unifiedTypeProxy null]
    !decoratedAttributeMap
    !decoratedTransientMap
    !decoratedOutletMap
    !observablePropertyMap
    !@decoratedEntityRelationshipMap {}
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @preferencesDeclaration EXTypeInventory
  ?!@EXunifiedTypeMap ioUnifiedTypeMap
:
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@EXunifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mAttributeTypeName] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@EXunifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mElementClassName] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  foreach mControllerList do
    [@EXunifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mControllerClassName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mControllerClassName] ;
  end foreach ;
#------------------------------------- Analyze transient properties
  foreach mTransientList do
    [@EXunifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#------------------------------------- Analyze outlets
  foreach mOutletDeclarationList do
    [@EXunifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mOutletType
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mOutletType] ;
  end foreach ;
#------------------------------------- Enter in preference map
  [!?ioUnifiedTypeMap insertKey
    !mPreferencesName
    ![@EXebType new !mPreferencesName ![@EXTypeKind preferencesType]]
    !selfcopy
    !@EXentityRelationshipMap {}
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @preferencesDeclaration buildObservablePropertyMap
  ??@EXunifiedTypeMap inUnifiedTypeMap
  ?!@EXobservablePropertyMapMap ioObservablePropertyMapMap
  ?!@EXtransientDependencyGraph ioTransientDependencyGraph
:
  @EXobservablePropertyMap observablePropertyMap [emptyMap] ;
#---------------------------------- Build map
  buildObservablePropertyMap
    !mAttributeList
    !mArrayList
    !mTransientList
    !mControllerList
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"preference." . mPreferencesName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mPreferencesName
    !mUserDefined
    ![@EXTypeKind preferencesType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @preferencesDeclaration semanticAnalysis
  ??@EXunifiedTypeMap inUnifiedTypeMap
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !mPreferencesName
    ?2*
    ?@EXobservablePropertyMap selfObservablePropertyMap
  ] ;    
#------------------------------------- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#------------------------------------- Analyze attributes
  @fileInclusionSet fileInclusionSet [default] ;
  @attributeListForImplementation attributeListForInitHeader [emptyList] ;
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?attributeListForInitHeader
  ;
#------------------------------------- Analyze arraies
  @preferencesPropertyArrayMap preferenceArrayMap [emptyMap] ;
  foreach mArrayList do
    [inUnifiedTypeMap searchKey
      !mElementClassName
      ?@EXebType type
      ?2*
    ] ;
    if type->mKind != [@EXTypeKind classType] then
      error mElementClassName : "'" . mElementClassName . "' is not a class" ;    
    end if ;
    [ioContextAnalysisStruct->mClassMap searchKey
      !mElementClassName
      ?@attributeListForImplementation attributeListForInitMethodHeader
      ?*
    ] ;
    [!?preferenceArrayMap insertKey
      !mArrayName
      !type
      !attributeListForInitMethodHeader
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  @controllerMap controllerMap [emptyMap] ;
  foreach mControllerList do
    [ioContextAnalysisStruct->mControllerClassMap searchKey
      !mControllerClassName
      ?@controllerKind controllerKind
      ?*
      ?@outletClassBindingMap controllerClassBindingMap
      ?@actionMap controllerActionMap
      ?@EXobservablePropertyMap controllerObservablePropertyMap
      ?@outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
    ] ;
  #---
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    @string controllerObjectClassName ;
    switch controllerKind
    when simpleController :
      controllerObjectClassName := "" ;
    when objectController :
      error mControlledObjectName
      :"objectController is not currently handled in nib class"
      :controllerObjectClassName;
    when entityController :
      error mControlledObjectName
      :"entityController is not currently handled in nib class"
      :controllerObjectClassName;
    when entityArrayController :
      error mControlledObjectName
      :"in nib class, use an arrayController, as NSArrayController"
      :controllerObjectClassName;
    when arrayController :
      if mIsRootObject->bool then
        error mIsRootObject
        : "only 'self' is allowed here"
        ;
      end if ;
      [preferenceArrayMap searchKey
        !mControlledObjectName
        ?@EXebType controlledObjectType
        ?*
      ] ;
      controllerObjectClassName := controlledObjectType->mTypeName->string ;
      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
        !controlledObjectType->mTypeName
        ?*
        ?@EXTypeKind kind
        ?@EXobservablePropertyMap classObservablePropertyMap
      ] ;
      if kind != [@EXTypeKind classType] then
        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
      end if ;
      checkBindingOptions
        !ioContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@bindingOptionListForGeneration controlledObjectBindingOptionListForGeneration
        !?fileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        ![@EXebType new !["<unused7>" nowhere] ![@EXTypeKind classType]]
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self"
        !mControlledObjectName->string
        !false # Non optional property, no '?'
        !controlledObjectBindingOptionListForGeneration
      ] ;
      [!?controllerMap insertKey
        !mControllerName
        !mControllerClassName->string
        ![@lstring new !controllerObjectClassName !here]
        !false # Is not an entity : it is a class
        !bindingListForGeneration
        !controllerActionMap
        !controllerObservablePropertyMap
      ] ;
    when treeController :
      if mIsRootObject->bool then
        error mIsRootObject
        : "only 'self' is allowed here"
        ;
      end if ;
      [preferenceArrayMap searchKey
        !mControlledObjectName
        ?@EXebType controlledObjectType
        ?*
      ] ;
      controllerObjectClassName := controlledObjectType->mTypeName->string ;
      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
        !controlledObjectType->mTypeName
        ?*
        ?@EXTypeKind kind
        ?@EXobservablePropertyMap classObservablePropertyMap
      ] ;
      if kind != [@EXTypeKind classType] then
        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
      end if ;
      checkBindingOptions
        !ioContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@bindingOptionListForGeneration controlledObjectBindingOptionListForGeneration
        !?fileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        ![@EXebType new !["<unused8>" nowhere] ![@EXTypeKind classType]]
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self"
        !mControlledObjectName->string
        !false # Non optional property, no '?'
        !controlledObjectBindingOptionListForGeneration
      ] ;
      [!?controllerMap insertKey
        !mControllerName
        !mControllerClassName->string
        ![@lstring new !controllerObjectClassName !here]
        !false # Is not an entity : it is a class
        !bindingListForGeneration
        !controllerActionMap
        !controllerObservablePropertyMap
      ] ;
    end switch ;
  end foreach ;
#------------------------------------- Analyze transient properties
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    !mTransientList
    ![@EXobservablePropertyMap emptyMap] # Root property map
    !?ioContextAnalysisStruct
    !"" # No Root entity
    !selfObservablePropertyMap
    !?fileInclusionSet
    ?transientListForImplementation
  ;
#------------------------------------- Analyze outlets
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach mOutletDeclarationList do
    [ioContextAnalysisStruct->mOutletClassMap searchKey
      !mOutletType
      ?@generationKind generationKind
      ?2*
      ?@bool implementsDeallocProtocol
      ?@outletClassBindingMap outletClassBindingMap
      ?*
      ?@bool hasTableValueBinding
    ] ;
    if generationKind != [@generationKind noGeneration] then
      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
    end if ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        ![@EXobservablePropertyMap emptyMap] # No root
        !selfObservablePropertyMap
        !outletClassBindingMap
        !controllerMap
        !actionMap
        !hasTableValueBinding
        !ioContextAnalysisStruct
        !?outletBindingList
        !?fileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList +=
      ![mOutletType string]
      ![mOutletName string]
      !outletBindingList
      !implementsDeallocProtocol
    ;
  end foreach ;
#------------------------------------- Enter in preference map
  [!?ioContextAnalysisStruct->mPreferencesMap insertKey
    !mPreferencesName
    !attributeListForImplementation
    !transientListForImplementation
    !outletGenerationList
    !mActionDeclarationList
    !selfObservablePropertyMap
    !fileInclusionSet
    !controllerMap
  ] ;
#------------------------------------- Generation
  ioGenerationList += ![@preferenceTypeGeneration new
    !mPreferencesName->string
    !attributeListForImplementation
    !transientListForImplementation
    !outletGenerationList
    !mActionDeclarationList
    !fileInclusionSet
    !controllerMap
    !preferenceArrayMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
