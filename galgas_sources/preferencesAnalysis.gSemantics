semantics preferencesAnalysis :
  import "transientAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

local routine analyzePreference
  ??@preferencesDeclarationList.element inPreference
  ??@controllerClassMap inControllerClassMap
  ??@classMap inClassMap
  ??@outletClassMap inOutletClassMap
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@preferencesMap ioPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------------- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in inPreference->mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#------------------------------------- Analyze attributes
  @stringset implementationFileInclusionSet [emptySet] ;
  @observablePropertyMap selfObservableAttributeMap [emptyMap] ;
  @stringset headerFileInclusionSet [emptySet] ;
  @attributeListForImplementation attributeListForImplementation [emptyList] ;
  foreach inPreference->mAttributeList do
    [mDefaultValue analyzeDefaultValueType
      ![@easyBindingTypeList listWithValue !mType]
      !inGlobalEnumConstantMap
      ?@string directDefaultValueAsString
      ?@string objectiveCDefaultValueAsString
    ] ;
    [mType addFileInclusion !?headerFileInclusionSet] ;
    attributeListForImplementation += !mType ![mAttributeName string] !objectiveCDefaultValueAsString !directDefaultValueAsString ;
    const @lstring observationDependencyKey [new
      !"preference." . inPreference->mPreferencesName->string . "." . mAttributeName
      !mAttributeName->location
    ] ;
    [!?selfObservableAttributeMap insertKey
      !mAttributeName
      !mType
      !false # is not transient
      !observationDependencyKey->string
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#------------------------------------- Analyze arraies
  @preferenceArrayMap preferenceArrayMap [emptyMap] ;
  foreach inPreference->mClassArrayList do
    [inClassMap searchKey
      !mClassName
      ?*
      ?@observablePropertyMap classObservablePropertyMap
      ?2*
      ?@attributeListForImplementation attributeListForImplementation
      ?3*
    ] ;
    [!?preferenceArrayMap insertKey
      !mArrayName
      !mClassName->string
      !classObservablePropertyMap
      !attributeListForImplementation
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  @observablePropertyMap observablePropertyMap [emptyMap] ;
  @controllerMap controllerMap [emptyMap] ;
  foreach inPreference->mControllerList do
    [inControllerClassMap searchKey
      !mControllerClassName
      ?@controllerKind controllerKind
      ?*
      ?@outletClassBindingMap controllerClassBindingMap
      ?@actionMap controllerActionMap
      ?@observablePropertyMap controllerObservablePropertyMap
    ] ;
  #---
    @string controllerObjectClassName ;
    switch controllerKind
    when simpleController :
      controllerObjectClassName := "" ;
    when objectController :
      error mControlledObjectName
      :"objectController is not currently handled in preferences"
      :controllerObjectClassName;
    when arrayController :
      [preferenceArrayMap searchKey
        !mControlledObjectName
        ?controllerObjectClassName
        ?@observablePropertyMap classObservablePropertyMap
        ?@attributeListForImplementation attributeListForImplementation
      ] ;
    end switch ;
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    foreach mControllerBindingList do
      [mBinding analyzeOutletBinding
        ![@observablePropertyMap emptyMap] # No root entity obsevable Map
        !selfObservableAttributeMap
        !ioPreferencesMap
        ![@entityMap emptyMap]
        !inClassMap
        !controllerClassBindingMap
        !controllerMap
        !actionMap
        !false
        !inGlobalEnumConstantMap
        !?bindingListForGeneration
        !?implementationFileInclusionSet
      ] ;
    end foreach ;
    [!?controllerMap insertKey
      !mControllerName
      !mControllerClassName->string
      !controllerObjectClassName
      !false # Is not an entity : it is a class
      !bindingListForGeneration
      !controllerActionMap
      !controllerObservablePropertyMap
    ] ;
  end foreach ;
#------------------------------------- Analyze transient properties
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    ![@preferencesMap emptyMap]
    !"preference." . inPreference->mPreferencesName . "."
    !inPreference->mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !"" # No Root entity
    ![@controllerMap emptyMap]
    !?selfObservableAttributeMap
    !?implementationFileInclusionSet
    ?transientListForImplementation
    !?ioTransientDependencyGraph
  ;
#------------------------------------- Analyze outlets
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach inPreference->mOutletDeclarationList do
    [inOutletClassMap searchKey
      !mOutletType
      ?@generationKind generationKind
      ?2*
      ?@outletClassBindingMap bindingMap
      ?@bool hasTableValueBinding
    ] ;
    if generationKind != [@generationKind noGeneration] then
      implementationFileInclusionSet += !mOutletType->string ;
    end if ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        ![@observablePropertyMap emptyMap]
        !selfObservableAttributeMap
        ![@preferencesMap emptyMap]
        ![@entityMap emptyMap]
        !inClassMap
        !bindingMap
        !controllerMap
        !actionMap
        !hasTableValueBinding
        !inGlobalEnumConstantMap
        !?outletBindingList
        !?implementationFileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList += ![mOutletType string] !generationKind ![mOutletName string] !outletBindingList ;
  end foreach ;
#------------------------------------- Enter in preference map
  [!?implementationFileInclusionSet removeKey !""] ;
  [!?ioPreferencesMap insertKey
    !inPreference->mPreferencesName
    !attributeListForImplementation
    !transientListForImplementation
    !outletGenerationList
    !inPreference->mActionDeclarationList
    !selfObservableAttributeMap
    !headerFileInclusionSet
    !implementationFileInclusionSet
    !controllerMap
    !preferenceArrayMap
  ] ;
end routine ;

#----------------------------------------------------------------------------*

routine analyzePreferences
  ??@preferencesDeclarationList inPreferencesList
  ??@controllerClassMap inControllerClassMap
  ??@classMap inClassMap
  ??@outletClassMap inOutletClassMap
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  !@preferencesMap outPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outPreferencesMap := [@preferencesMap emptyMap] ;
  for preference in inPreferencesList do
    analyzePreference
      !preference
      !inControllerClassMap
      !inClassMap
      !inOutletClassMap
      !inGlobalEnumConstantMap
      !?outPreferencesMap
      !?ioTransientDependencyGraph
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
