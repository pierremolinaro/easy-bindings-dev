semantics preferencesAnalysis :
  import "transientAnalysis.gSemantics" ;
  import "bindingSemanticAnalysis.gSemantics" ;

##----------------------------------------------------------------------------*
#
#override method @preferencesDeclaration EXTypeInventory
#  ?!@EXunifiedTypeMap ioUnifiedTypeMap
#:
##---------------------------------- Analyze attributes
#  foreach mAttributeList do
#    [@EXunifiedTypeProxy makeProxy
#      !?ioUnifiedTypeMap
#      !mAttributeTypeName
#      ?*
#    ] ;
#    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mAttributeTypeName] ;
#  end foreach ;
##---------------------------------- Analyze arraies
#  foreach mArrayList do
#    [@EXunifiedTypeProxy makeProxy
#      !?ioUnifiedTypeMap
#      !mElementClassName
#      ?*
#    ] ;
#    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mElementClassName] ;
#  end foreach ;
##-------------------------------------------------- Analyze controllers
#  foreach mControllerList do
#    [@EXunifiedTypeProxy makeProxy
#      !?ioUnifiedTypeMap
#      !mControllerClassName
#      ?*
#    ] ;
#    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mControllerClassName] ;
#  end foreach ;
##------------------------------------- Analyze transient properties
#  foreach mTransientList do
#    [@EXunifiedTypeProxy makeProxy
#      !?ioUnifiedTypeMap
#      !mTransientTypeName
#      ?*
#    ] ;
#  end foreach ;
##------------------------------------- Analyze outlets
#  foreach mOutletDeclarationList do
#    [@EXunifiedTypeProxy makeProxy
#      !?ioUnifiedTypeMap
#      !mOutletType
#      ?*
#    ] ;
#    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mOutletType] ;
#  end foreach ;
##------------------------------------- Enter in preference map
#  [!?ioUnifiedTypeMap insertKey
#    !mPreferencesName
#    ![@EXebType new !mPreferencesName ![@EXTypeKind preferencesType]]
#    !selfcopy
#    !@EXentityRelationshipMap {}
#  ] ;
#end method ;

#----------------------------------------------------------------------------*

#override method @preferencesDeclaration buildObservablePropertyMap
#  ??@EXunifiedTypeMap inUnifiedTypeMap
#  ?!@EXobservablePropertyMapMap ioObservablePropertyMapMap
#  ?!@EXtransientDependencyGraph ioTransientDependencyGraph
#:
#  @EXobservablePropertyMap observablePropertyMap [emptyMap] ;
##---------------------------------- Build map
#  buildObservablePropertyMap
#    !mAttributeList
#    !mArrayList
#    !mTransientList
#    !mControllerList
#    ![@controllerObservablePropertyList emptyList]
#    !?ioObservablePropertyMapMap
#    !?ioTransientDependencyGraph
#    !inUnifiedTypeMap
#    !"preference." . mPreferencesName
#    !?observablePropertyMap
#  ;
##---------------------------------- Enter class in observable map
#  [!?ioObservablePropertyMapMap insertKey
#    !mPreferencesName
#    !mUserDefined
#    ![@EXTypeKind preferencesType]
#    !observablePropertyMap
#  ] ;
#end method ;
#
##----------------------------------------------------------------------------*
#
#override method @preferencesDeclaration semanticAnalysis
#  ??@EXunifiedTypeMap inUnifiedTypeMap
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@generationList ioGenerationList
#:
#  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
#    !mPreferencesName
#    ?2*
#    ?@EXobservablePropertyMap selfObservablePropertyMap
#  ] ;    
##------------------------------------- Analyze actions
#  @actionMap actionMap [emptyMap] ;
#  for actionName in mActionDeclarationList do
#    [!?actionMap insertKey !actionName->mValue] ;
#  end for ;
##------------------------------------- Analyze attributes
#  @fileInclusionSet fileInclusionSet [default] ;
#  @attributeListForImplementation attributeListForInitHeader [emptyList] ;
#  analyzeAttributeDeclaration
#    !mAttributeList
#    !?ioContextAnalysisStruct
#    !inUnifiedTypeMap
#    !?fileInclusionSet
#    ?@attributeListForImplementation attributeListForImplementation
#    !?attributeListForInitHeader
#  ;
##------------------------------------- Analyze arraies
#  @preferencesPropertyArrayMap preferenceArrayMap [emptyMap] ;
#  foreach mArrayList do
#    [inUnifiedTypeMap searchKey
#      !mElementClassName
#      ?@EXebType type
#      ?2*
#    ] ;
#    if type->mKind != [@EXTypeKind classType] then
#      error mElementClassName : "'" . mElementClassName . "' is not a class" ;    
#    end if ;
#    [ioContextAnalysisStruct->mClassMap searchKey
#      !mElementClassName
#      ?@attributeListForImplementation attributeListForInitMethodHeader
#      ?*
#    ] ;
#    [!?preferenceArrayMap insertKey
#      !mArrayName
#      !type
#      !attributeListForInitMethodHeader
#    ] ;
#  end foreach ;
##-------------------------------------------------- Analyze controllers
#  @controllerMap controllerMap [emptyMap] ;
#  foreach mControllerList do
#    [ioContextAnalysisStruct->mControllerClassMap searchKey
#      !mControllerClassName
#      ?@controllerKind controllerKind
#      ?*
#      ?@outletClassBindingMap controllerClassBindingMap
#      ?@actionMap controllerActionMap
#      ?@EXobservablePropertyMap controllerObservablePropertyMap
#      ?@outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
#    ] ;
#  #---
#    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
#    @string controllerObjectClassName ;
#    switch controllerKind
#    when simpleController :
#      controllerObjectClassName := "" ;
#    when objectController :
#      error mControlledObjectName
#      :"objectController is not currently handled in nib class"
#      :controllerObjectClassName;
#    when entityController :
#      error mControlledObjectName
#      :"entityController is not currently handled in nib class"
#      :controllerObjectClassName;
#    when entityArrayController :
#      error mControlledObjectName
#      :"in nib class, use an arrayController, as NSArrayController"
#      :controllerObjectClassName;
#    when arrayController :
#      if mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'self' is allowed here"
#        ;
#      end if ;
#      [preferenceArrayMap searchKey
#        !mControlledObjectName
#        ?@EXebType controlledObjectType
#        ?*
#      ] ;
#      controllerObjectClassName := controlledObjectType->mTypeName->string ;
#      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
#        !controlledObjectType->mTypeName
#        ?*
#        ?@EXTypeKind kind
#        ?@EXobservablePropertyMap classObservablePropertyMap
#      ] ;
#      if kind != [@EXTypeKind classType] then
#        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
#      end if ;
#      checkBindingOptions
#        !ioContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@bindingOptionListForGeneration controlledObjectBindingOptionListForGeneration
#        !?fileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        ![@EXebType new !["<unused7>" nowhere] ![@EXTypeKind classType]]
#        !"contentArray"
#        ![@formatterEnum noFormatter]
#        !"self"
#        !mControlledObjectName->string
#        !false # Non optional property, no '?'
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#      [!?controllerMap insertKey
#        !mControllerName
#        !mControllerClassName->string
#        ![@lstring new !controllerObjectClassName !here]
#        !false # Is not an entity : it is a class
#        !bindingListForGeneration
#        !controllerActionMap
#        !controllerObservablePropertyMap
#      ] ;
#    when treeController :
#      if mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'self' is allowed here"
#        ;
#      end if ;
#      [preferenceArrayMap searchKey
#        !mControlledObjectName
#        ?@EXebType controlledObjectType
#        ?*
#      ] ;
#      controllerObjectClassName := controlledObjectType->mTypeName->string ;
#      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
#        !controlledObjectType->mTypeName
#        ?*
#        ?@EXTypeKind kind
#        ?@EXobservablePropertyMap classObservablePropertyMap
#      ] ;
#      if kind != [@EXTypeKind classType] then
#        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
#      end if ;
#      checkBindingOptions
#        !ioContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@bindingOptionListForGeneration controlledObjectBindingOptionListForGeneration
#        !?fileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        ![@EXebType new !["<unused8>" nowhere] ![@EXTypeKind classType]]
#        !"contentArray"
#        ![@formatterEnum noFormatter]
#        !"self"
#        !mControlledObjectName->string
#        !false # Non optional property, no '?'
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#      [!?controllerMap insertKey
#        !mControllerName
#        !mControllerClassName->string
#        ![@lstring new !controllerObjectClassName !here]
#        !false # Is not an entity : it is a class
#        !bindingListForGeneration
#        !controllerActionMap
#        !controllerObservablePropertyMap
#      ] ;
#    end switch ;
#  end foreach ;
##------------------------------------- Analyze transient properties
#  @transientListForImplementation transientListForImplementation ;
#  analyzeTransientProperties
#    !mTransientList
#    ![@EXobservablePropertyMap emptyMap] # Root property map
#    !?ioContextAnalysisStruct
#    !"" # No Root entity
#    !selfObservablePropertyMap
#    !?fileInclusionSet
#    ?transientListForImplementation
#  ;
##------------------------------------- Analyze outlets
#  @outletGenerationList outletGenerationList [emptyList] ;
#  foreach mOutletDeclarationList do
#    [ioContextAnalysisStruct->mOutletClassMap searchKey
#      !mOutletType
#      ?@generationKind generationKind
#      ?2*
#      ?@bool implementsDeallocProtocol
#      ?@outletClassBindingMap outletClassBindingMap
#      ?*
#      ?@bool hasTableValueBinding
#    ] ;
#    if generationKind != [@generationKind noGeneration] then
#      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
#    end if ;
#    @outletBindingListForGeneration outletBindingList [emptyList] ;
#    foreach mOutletBindingList do
#      [mBinding analyzeOutletBinding
#        ![@EXobservablePropertyMap emptyMap] # No root
#        !selfObservablePropertyMap
#        !outletClassBindingMap
#        !controllerMap
#        !actionMap
#        !hasTableValueBinding
#        !ioContextAnalysisStruct
#        !?outletBindingList
#        !?fileInclusionSet
#      ] ;
#    end foreach ;
#    outletGenerationList +=
#      ![mOutletType string]
#      ![mOutletName string]
#      !outletBindingList
#      !implementsDeallocProtocol
#    ;
#  end foreach ;
##------------------------------------- Enter in preference map
#  [!?ioContextAnalysisStruct->mPreferencesMap insertKey
#    !mPreferencesName
#    !attributeListForImplementation
#    !transientListForImplementation
#    !outletGenerationList
#    !mActionDeclarationList
#    !selfObservablePropertyMap
#    !fileInclusionSet
#    !controllerMap
#  ] ;
##------------------------------------- Generation
#  ioGenerationList += ![@preferenceTypeGeneration new
#    !mPreferencesName->string
#    !attributeListForImplementation
#    !transientListForImplementation
#    !outletGenerationList
#    !mActionDeclarationList
#    !fileInclusionSet
#    !controllerMap
#    !preferenceArrayMap
#  ] ;
#end method ;

#----------------------------------------------------------------------------*

end semantics ;
