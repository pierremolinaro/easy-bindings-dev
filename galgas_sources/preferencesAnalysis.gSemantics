semantics preferencesAnalysis :
  import "transientAnalysis.gSemantics" ;
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @preferencesDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mAttributeTypeName] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mElementClassName] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  foreach mControllerList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mControllerClassName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mControllerClassName] ;
  end foreach ;
#------------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#------------------------------------- Analyze outlets
  foreach mOutletDeclarationList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mOutletType
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mPreferencesName !mOutletType] ;
  end foreach ;
#------------------------------------- Enter in preference map
  [!?ioUnifiedTypeMap insertKey
    !mPreferencesName
    ![@ebType new !mPreferencesName ![@typeKind preferencesType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @preferencesDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  @observablePropertyMap observablePropertyMap [emptyMap] ;
#---------------------------------- Build map
  buildObservablePropertyMap
    !mAttributeList
    !mArrayList
    !mTransientList
    !mControllerList
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"preference." . mPreferencesName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mPreferencesName
    ![@typeKind preferencesType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @preferencesDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !mPreferencesName
    ?*
    ?@observablePropertyMap selfObservablePropertyMap
  ] ;    
#------------------------------------- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#------------------------------------- Analyze attributes
  @fileInclusionSet fileInclusionSet [default] ;
  @attributeListForImplementation attributeListForInitHeader [emptyList] ;
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?attributeListForInitHeader
  ;
#------------------------------------- Analyze arraies
  @preferencesPropertyArrayMap preferenceArrayMap [emptyMap] ;
  foreach mArrayList do
    [inUnifiedTypeMap searchKey
      !mElementClassName
      ?@ebType type
      ?*
    ] ;
    if type->mKind != [@typeKind classType] then
      error mElementClassName : "'" . mElementClassName . "' is not a class" ;    
    end if ;
    [ioContextAnalysisStruct->mClassMap searchKey
      !mElementClassName
      ?@attributeListForImplementation attributeListForInitMethodHeader
      ?*
    ] ;
    [!?preferenceArrayMap insertKey
      !mArrayName
      !type
      !attributeListForInitMethodHeader
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  @controllerMap controllerMap [emptyMap] ;
  foreach mControllerList do
    [ioContextAnalysisStruct->mControllerClassMap searchKey
      !mControllerClassName
      ?@controllerKind controllerKind
      ?*
      ?@outletClassBindingMap controllerClassBindingMap
      ?@actionMap controllerActionMap
      ?@observablePropertyMap controllerObservablePropertyMap
      ?@outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
    ] ;
  #---
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    @string controllerObjectClassName ;
    switch controllerKind
    when simpleController :
      controllerObjectClassName := "" ;
    when objectController :
      error mControlledObjectName
      :"objectController is not currently handled in nib class"
      :controllerObjectClassName;
    when entityController :
      error mControlledObjectName
      :"entityController is not currently handled in nib class"
      :controllerObjectClassName;
    when entityArrayController :
      error mControlledObjectName
      :"in nib class, use an arrayController, as NSArrayController"
      :controllerObjectClassName;
    when arrayController :
      if mIsRootObject->bool then
        error mIsRootObject
        : "only 'self' is allowed here"
        ;
      end if ;
      [preferenceArrayMap searchKey
        !mControlledObjectName
        ?@ebType controlledObjectType
        ?*
      ] ;
      controllerObjectClassName := controlledObjectType->mTypeName->string ;
      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
        !controlledObjectType->mTypeName
        ?@typeKind kind
        ?@observablePropertyMap classObservablePropertyMap
      ] ;
      if kind != [@typeKind classType] then
        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
      end if ;
      checkBindingOptions
        !ioContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@bindingOptionListForGeneration controlledObjectBindingOptionListForGeneration
        !?fileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self"
        !mControlledObjectName->string
        !controlledObjectBindingOptionListForGeneration
      ] ;
      [!?controllerMap insertKey
        !mControllerName
        !mControllerClassName->string
        ![@lstring new !controllerObjectClassName !here]
        !false # Is not an entity : it is a class
        !bindingListForGeneration
        !controllerActionMap
        !controllerObservablePropertyMap
      ] ;
    when treeController :
      if mIsRootObject->bool then
        error mIsRootObject
        : "only 'self' is allowed here"
        ;
      end if ;
      [preferenceArrayMap searchKey
        !mControlledObjectName
        ?@ebType controlledObjectType
        ?*
      ] ;
      controllerObjectClassName := controlledObjectType->mTypeName->string ;
      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
        !controlledObjectType->mTypeName
        ?@typeKind kind
        ?@observablePropertyMap classObservablePropertyMap
      ] ;
      if kind != [@typeKind classType] then
        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
      end if ;
      checkBindingOptions
        !ioContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@bindingOptionListForGeneration controlledObjectBindingOptionListForGeneration
        !?fileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self"
        !mControlledObjectName->string
        !controlledObjectBindingOptionListForGeneration
      ] ;
      [!?controllerMap insertKey
        !mControllerName
        !mControllerClassName->string
        ![@lstring new !controllerObjectClassName !here]
        !false # Is not an entity : it is a class
        !bindingListForGeneration
        !controllerActionMap
        !controllerObservablePropertyMap
      ] ;
    end switch ;
  end foreach ;
#------------------------------------- Analyze transient properties
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    !mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !?ioContextAnalysisStruct
    !"" # No Root entity
    !selfObservablePropertyMap
    !?fileInclusionSet
    ?transientListForImplementation
  ;
#------------------------------------- Analyze outlets
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach mOutletDeclarationList do
    [ioContextAnalysisStruct->mOutletClassMap searchKey
      !mOutletType
      ?@generationKind generationKind
      ?2*
      ?@bool implementsDeallocProtocol
      ?@outletClassBindingMap outletClassBindingMap
      ?*
      ?@bool hasTableValueBinding
    ] ;
    if generationKind != [@generationKind noGeneration] then
      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
    end if ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        ![@observablePropertyMap emptyMap] # No root
        !selfObservablePropertyMap
        !outletClassBindingMap
        !controllerMap
        !actionMap
        !hasTableValueBinding
        !ioContextAnalysisStruct
        !?outletBindingList
        !?fileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList +=
      ![mOutletType string]
      ![mOutletName string]
      !outletBindingList
      !implementsDeallocProtocol
    ;
  end foreach ;
#------------------------------------- Enter in preference map
  [!?ioContextAnalysisStruct->mPreferencesMap insertKey
    !mPreferencesName
    !attributeListForImplementation
    !transientListForImplementation
    !outletGenerationList
    !mActionDeclarationList
    !selfObservablePropertyMap
    !fileInclusionSet
    !controllerMap
  ] ;
#------------------------------------- Generation
  ioGenerationList += ![@preferenceTypeGeneration new
    !mPreferencesName->string
    !attributeListForImplementation
    !transientListForImplementation
    !outletGenerationList
    !mActionDeclarationList
    !fileInclusionSet
    !controllerMap
    !preferenceArrayMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

#routine analyzePreferences
#  ??@preferencesDeclarationList inPreferencesList
#  ??@controllerClassMap inControllerClassMap
#  ??@classMap inClassMap
#  ??@outletClassMap inOutletClassMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  !@preferencesMap outPreferencesMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
#  outPreferencesMap := [@preferencesMap emptyMap] ;
#  for preference in inPreferencesList do
#    analyzePreference
#      !preference
#      !inControllerClassMap
#      !inClassMap
#      !inOutletClassMap
#      !inContextAnalysisStruct
#      !?outPreferencesMap
#      !?ioTransientDependencyGraph
#    ;
#  end for ;
#end routine ;
#local routine analyzePreference
#  ??@preferencesDeclarationList.element inPreference
#  ??@controllerClassMap inControllerClassMap
#  ??@classMap inClassMap
#  ??@outletClassMap inOutletClassMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@preferencesMap ioPreferencesMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
##------------------------------------- Analyze actions
#  @actionMap actionMap [emptyMap] ;
#  for actionName in inPreference->mActionDeclarationList do
#    [!?actionMap insertKey !actionName->mValue] ;
#  end for ;
##------------------------------------- Analyze attributes
#  @fileInclusionSet fileInclusionSet [default] ;
#  @observablePropertyMap selfObservableAttributeMap [emptyMap] ;
#  @attributeListForImplementation attributeListForInitHeader [emptyList] ;
#  analyzeAttributeDeclaration
#    !inPreference->mAttributeList
#    !inContextAnalysisStruct
#    !"preference." . inPreference->mPreferencesName
#    !?ioTransientDependencyGraph
#    !?fileInclusionSet
#    !?selfObservableAttributeMap
#    ?@attributeListForImplementation attributeListForImplementation
#    !?attributeListForInitHeader # Unused
#  ;
##------------------------------------- Analyze arraies
#  @preferenceArrayMap preferenceArrayMap [emptyMap] ;
#  foreach inPreference->mClassArrayList do
#    [inClassMap searchKey
#      !mClassName
#      ?*
#      ?@observablePropertyMap classObservablePropertyMap
#      ?2*
#      ?@attributeListForImplementation attributeListForImplementation
#      ?4*
#    ] ;
#    [!?preferenceArrayMap insertKey
#      !mArrayName
#      !mClassName->string
#      !classObservablePropertyMap
#      !attributeListForImplementation
#    ] ;
#  end foreach ;
##-------------------------------------------------- Analyze controllers
#  @observablePropertyMap observablePropertyMap [emptyMap] ;
#  @controllerMap controllerMap [emptyMap] ;
#  foreach inPreference->mControllerList do
#    [inControllerClassMap searchKey
#      !mControllerClassName
#      ?@controllerKind controllerKind
#      ?*
#      ?@EXoutletClassBindingMap controllerClassBindingMap
#      ?@actionMap controllerActionMap
#      ?@observablePropertyMap controllerObservablePropertyMap
#      ?@EXoutletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
#    ] ;
#  #---
#    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
#    @string controllerObjectClassName ;
#    switch controllerKind
#    when simpleController :
#      controllerObjectClassName := "" ;
#    when objectController :
#      error mControlledObjectName
#      :"objectController is not currently handled in preferences"
#      :controllerObjectClassName;
#    when entityController :
#      error mControlledObjectName
#      :"entityController is not currently handled in preferences"
#      :controllerObjectClassName;
#    when entityArrayController :
#      error mControlledObjectName
#      :"in preferences, use an arrayController, as NSArrayController"
#      :controllerObjectClassName;
#    when arrayController :
#      if mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'self' is allowed here"
#        ;
#      end if ;
#      [preferenceArrayMap searchKey
#        !mControlledObjectName
#        ?controllerObjectClassName
#        ?@observablePropertyMap classObservablePropertyMap
#        ?@attributeListForImplementation attributeListForImplementation
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?fileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentArray"
#        ![@formatterEnum noFormatter]
#        !"self"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    end switch ;
#    foreach mControllerBindingList do
#      [mBinding analyzeOutletBinding
#        ![@observablePropertyMap emptyMap] # No root entity obsevable Map
#        !selfObservableAttributeMap
#        !ioPreferencesMap
#        ![@entityMap emptyMap]
#        !inClassMap
#        !controllerClassBindingMap
#        !controllerMap
#        !actionMap
#        !false
#        !inContextAnalysisStruct
#        !?bindingListForGeneration
#        !?fileInclusionSet
#      ] ;
#    end foreach ;
#    [!?controllerMap insertKey
#      !mControllerName
#      !mControllerClassName->string
#      ![@lstring new !controllerObjectClassName !here]
#      !false # Is not an entity : it is a class
#      !bindingListForGeneration
#      !controllerActionMap
#      !controllerObservablePropertyMap
#    ] ;
#  end foreach ;
##------------------------------------- Analyze transient properties
#  @transientListForImplementation transientListForImplementation ;
#  analyzeTransientProperties
#    ![@preferencesMap emptyMap]
#    !"preference." . inPreference->mPreferencesName . "."
#    !inPreference->mTransientList
#    ![@observablePropertyMap emptyMap] # Root property map
#    !inContextAnalysisStruct
#    !"" # No Root entity
#    ![@controllerMap emptyMap]
#    !?selfObservableAttributeMap
#    !?fileInclusionSet
#    ?transientListForImplementation
#    !?ioTransientDependencyGraph
#  ;
##------------------------------------- Analyze outlets
#  @outletGenerationList outletGenerationList [emptyList] ;
#  foreach inPreference->mOutletDeclarationList do
#    [inOutletClassMap searchKey
#      !mOutletType
#      ?@generationKind generationKind
#      ?2*
#      ?@bool implementsDeallocProtocol
#      ?@EXoutletClassBindingMap bindingMap
#      ?*
#      ?@bool hasTableValueBinding
#    ] ;
#    if generationKind != [@generationKind noGeneration] then
#      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
#    end if ;
#    @outletBindingListForGeneration outletBindingList [emptyList] ;
#    foreach mOutletBindingList do
#      [mBinding analyzeOutletBinding
#        ![@observablePropertyMap emptyMap]
#        !selfObservableAttributeMap
#        ![@preferencesMap emptyMap]
#        ![@entityMap emptyMap]
#        !inClassMap
#        !bindingMap
#        !controllerMap
#        !actionMap
#        !hasTableValueBinding
#        !inContextAnalysisStruct
#        !?outletBindingList
#        !?fileInclusionSet
#      ] ;
#    end foreach ;
#    outletGenerationList +=
#      ![mOutletType string]
#      ![mOutletName string]
#      !outletBindingList
#      !implementsDeallocProtocol
#    ;
#  end foreach ;
##------------------------------------- Enter in preference map
#  [!?fileInclusionSet->mImplementationFileInclusionSet removeKey !""] ;
#  [!?ioPreferencesMap insertKey
#    !inPreference->mPreferencesName
#    !attributeListForImplementation
#    !transientListForImplementation
#    !outletGenerationList
#    !inPreference->mActionDeclarationList
#    !selfObservableAttributeMap
#    !fileInclusionSet
#    !controllerMap
#    !preferenceArrayMap
#  ] ;
#end routine ;

#----------------------------------------------------------------------------*

#routine analyzePreferences
#  ??@preferencesDeclarationList inPreferencesList
#  ??@controllerClassMap inControllerClassMap
#  ??@classMap inClassMap
#  ??@outletClassMap inOutletClassMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  !@preferencesMap outPreferencesMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
#  outPreferencesMap := [@preferencesMap emptyMap] ;
#  for preference in inPreferencesList do
#    analyzePreference
#      !preference
#      !inControllerClassMap
#      !inClassMap
#      !inOutletClassMap
#      !inContextAnalysisStruct
#      !?outPreferencesMap
#      !?ioTransientDependencyGraph
#    ;
#  end for ;
#end routine ;

#----------------------------------------------------------------------------*

end semantics ;
