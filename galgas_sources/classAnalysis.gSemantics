semantics classAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "transientAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @classDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#------------------------------- Super class ?
  if mSuperClassName->string != "" then
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mSuperClassName
      ?@unifiedTypeProxy superClassProxy
    ] ;
    [!?ioUnifiedTypeMap enterEdge
      !mClassName
      !mSuperClassName
    ] ;
  end if ;
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mClassName !mAttributeTypeName] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !mClassName
    ![@ebType new !mClassName ![@typeKind classType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @classDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Super class ?
  @observablePropertyMap observablePropertyMap ;
  if [mSuperClassName string] != "" then
    [ioObservablePropertyMapMap searchKey
       !mSuperClassName
       ?@typeKind kind
       ?observablePropertyMap
     ] ;
     if kind != [@typeKind classType] then
       error mSuperClassName : "'" . mSuperClassName . "' is not a class" ;
     end if ;
  else
    observablePropertyMap := [@observablePropertyMap emptyMap] ;
  end if ;
#----------------------------------
  buildObservablePropertyMap
    !mAttributeList
    !mArrayList
    !mTransientList
    ![@controllerList emptyList]
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"class." . mClassName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mClassName
    ![@typeKind classType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @classDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#------------------------------- Get Observable property map
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
     !mClassName
     ?*
     ??@observablePropertyMap observablePropertyMap
   ] ;
#-----
  @attributeListForImplementation inheritedAttributeListForInitHeader  ;
  @propertyArrayMap allArrayPropertyForImplementation ;
  if mSuperClassName->string == "" then
    inheritedAttributeListForInitHeader := [@attributeListForImplementation emptyList] ;
    allArrayPropertyForImplementation := [@propertyArrayMap emptyMap] ;
  else
    [ioContextAnalysisStruct->mClassMap searchKey
      !mSuperClassName
      ?inheritedAttributeListForInitHeader
      ?allArrayPropertyForImplementation
    ] ;  
  end if ;
  @attributeListForImplementation attributeListForInitHeader := inheritedAttributeListForInitHeader ;
  @propertyArrayMap currentArrayPropertyForImplementation [emptyMap] ;
#------------------------------- Analyze transient dependancy
  @fileInclusionSet fileInclusionSet [default] ;
  analyzeTransientProperties
    !mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !?ioContextAnalysisStruct
    !"" # No Root entity
    !observablePropertyMap
    !?fileInclusionSet
    ??@transientListForImplementation transientListForImplementation
  ;
#------------------------------- Analyze attributes
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?attributeListForInitHeader
  ;
#------------------------------------- Analyze arraies
  foreach mArrayList do
    [inUnifiedTypeMap searchKey
      !mClassName
      ?@ebType type
      ?*
    ] ;
    if type->mKind != [@typeKind classType] then
      error mClassName : "'" . mClassName . "' is not a class" ;    
    end if ;
    [!?allArrayPropertyForImplementation insertKey
      !mArrayName
      !type
    ] ;
    [!?currentArrayPropertyForImplementation insertKey
      !mArrayName
      !type
    ] ;
  end foreach ;
#------------------------------
  [!?ioContextAnalysisStruct->mClassMap insertKey
    !mClassName
    !attributeListForInitHeader
    !allArrayPropertyForImplementation
  ] ;
#------------------------------
  ioGenerationList += ![@classTypeGeneration new
    !mClassName->string
    !mSuperClassName->string
    !attributeListForInitHeader
    !inheritedAttributeListForInitHeader
    !attributeListForImplementation
    !transientListForImplementation
    !allArrayPropertyForImplementation
    !currentArrayPropertyForImplementation
    !fileInclusionSet
  ] ;
end method ;

#----------------------------------------------------------------------------*
#----------------------------------------------------------------------------*

#local routine analyzeClass
#  ??@classList.element inClass
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@classMap ioClassMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
##------------------------------- Super class ?
#  @observablePropertyMap observablePropertyMap ;
#  @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
#  @preferenceArrayMap allArrayPropertyMap ;
#  if [inClass->mSuperClassName string] != "" then
#    [ioClassMap searchKey !inClass->mSuperClassName ?* ?observablePropertyMap ?propertyListForInitMethodHeader ?4* ?allArrayPropertyMap ?*] ;
#  else
#    observablePropertyMap := [@observablePropertyMap emptyMap] ;
#    propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
#    allArrayPropertyMap := [@preferenceArrayMap emptyMap] ;
#  end if ;
#  const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
##---------------------------------- Analyze attributes
#  @fileInclusionSet fileInclusionSet [new ![@stringset emptySet] ![@stringset emptySet] ![@stringset emptySet]] ;
#  analyzeAttributeDeclaration
#    !inClass->mAttributeList
#    !inContextAnalysisStruct
#    !"class." . inClass->mClassName
#    !?ioTransientDependencyGraph
#    !?fileInclusionSet
#    !?observablePropertyMap
#    ?@attributeListForImplementation attributeListForImplementation
#    !?propertyListForInitMethodHeader
#  ;
##------------------------------------- Analyze arraies
#  @preferenceArrayMap currentArrayPropertyMap [emptyMap] ;
#  foreach inClass->mArrayList do
#    [ioClassMap searchKey
#      !mClassName
#      ?*
#      ?@observablePropertyMap classObservablePropertyMap
#      ?2*
#      ?@attributeListForImplementation attributeListForImplementation
#      ?4*
#    ] ;
#    [!?allArrayPropertyMap insertKey
#      !mArrayName
#      !mClassName->string
#      !classObservablePropertyMap
#      !attributeListForImplementation
#    ] ;
#    [!?currentArrayPropertyMap insertKey
#      !mArrayName
#      !mClassName->string
#      !classObservablePropertyMap
#      !attributeListForImplementation
#    ] ;
#  end foreach ;
##---------------------------------- Analyze transient properties
#  @transientListForImplementation transientListForImplementation ;
#  analyzeTransientProperties
#    ![@preferencesMap emptyMap]
#    !"class." . inClass->mClassName . "."
#    !inClass->mTransientList
#    ![@observablePropertyMap emptyMap] # Root property map
#    !inContextAnalysisStruct
#    !"" # No Root entity
#    ![@controllerMap emptyMap]
#    !?observablePropertyMap
#    !?fileInclusionSet
#    ?transientListForImplementation
#    !?ioTransientDependencyGraph
#  ;
##----------------------------------
#  [!?fileInclusionSet->mImplementationFileInclusionSet removeKey !""] ;
#  [!?ioClassMap insertKey
#    !inClass->mClassName
#    !inClass->mSuperClassName->string
#    !observablePropertyMap
#    !propertyListForInitMethodHeader
#    !inheritedAttributeListForImplementation
#    !attributeListForImplementation
#    !transientListForImplementation
#    !allArrayPropertyMap
#    !currentArrayPropertyMap
#    !fileInclusionSet
#  ] ;
#end routine ;

#----------------------------------------------------------------------------*

#routine analyzeClasses
#  ??@classList inClassList
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  !@classMap outClassMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
#  outClassMap := [@classMap emptyMap] ;
#  for aClass in inClassList do
#    analyzeClass
#      !aClass
#      !inContextAnalysisStruct
#      !?outClassMap
#      !?ioTransientDependencyGraph
#    ;
#  end for ;
#end routine ;

#----------------------------------------------------------------------------*

end semantics ;
