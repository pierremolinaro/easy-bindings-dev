semantics classAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "transientAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @classDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#------------------------------- Super class ?
  if mSuperClassName->string != "" then
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mSuperClassName
      ?@unifiedTypeProxy superClassProxy
    ] ;
    [!?ioUnifiedTypeMap enterEdge
      !mClassName
      !mSuperClassName
    ] ;
  end if ;
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mClassName !mAttributeTypeName] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !mClassName
    ![@ebType new !mClassName ![@typeKind classType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @classDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Super class ?
  @observablePropertyMap observablePropertyMap ;
  if [mSuperClassName string] != "" then
    [ioObservablePropertyMapMap searchKey
       !mSuperClassName
       ?*
       ?@typeKind kind
       ?observablePropertyMap
     ] ;
     if kind != [@typeKind classType] then
       error mSuperClassName : "'" . mSuperClassName . "' is not a class" ;
     end if ;
  else
    observablePropertyMap := [@observablePropertyMap emptyMap] ;
  end if ;
#----------------------------------
  buildObservablePropertyMap
    !mAttributeList
    !mArrayList
    !mTransientList
    ![@controllerList emptyList]
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"class." . mClassName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mClassName
    !mUserDefined
    ![@typeKind classType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @classDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#------------------------------- Get Observable property map
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
     !mClassName
     ?2*
     ??@observablePropertyMap observablePropertyMap
   ] ;
#-----
  @attributeListForImplementation inheritedAttributeListForInitHeader  ;
  @propertyArrayMap allArrayPropertyForImplementation ;
  if mSuperClassName->string == "" then
    inheritedAttributeListForInitHeader := [@attributeListForImplementation emptyList] ;
    allArrayPropertyForImplementation := [@propertyArrayMap emptyMap] ;
  else
    [ioContextAnalysisStruct->mClassMap searchKey
      !mSuperClassName
      ?inheritedAttributeListForInitHeader
      ?allArrayPropertyForImplementation
    ] ;  
  end if ;
  @attributeListForImplementation attributeListForInitHeader := inheritedAttributeListForInitHeader ;
  @propertyArrayMap currentArrayPropertyForImplementation [emptyMap] ;
#------------------------------- Analyze transient dependancy
  @fileInclusionSet fileInclusionSet [default] ;
  analyzeTransientProperties
    !mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !?ioContextAnalysisStruct
    !"" # No Root entity
    !observablePropertyMap
    !?fileInclusionSet
    ??@transientListForImplementation transientListForImplementation
  ;
#------------------------------- Analyze attributes
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?attributeListForInitHeader
  ;
#------------------------------------- Analyze arraies
  foreach mArrayList do
    [inUnifiedTypeMap searchKey
      !mClassName
      ?@ebType type
      ?*
    ] ;
    if type->mKind != [@typeKind classType] then
      error mClassName : "'" . mClassName . "' is not a class" ;    
    end if ;
    [!?allArrayPropertyForImplementation insertKey
      !mArrayName
      !type
    ] ;
    [!?currentArrayPropertyForImplementation insertKey
      !mArrayName
      !type
    ] ;
  end foreach ;
#------------------------------
  [!?ioContextAnalysisStruct->mClassMap insertKey
    !mClassName
    !attributeListForInitHeader
    !allArrayPropertyForImplementation
  ] ;
#------------------------------
  ioGenerationList += ![@classTypeGeneration new
    !mClassName->string
    !mSuperClassName->string
    !attributeListForInitHeader
    !inheritedAttributeListForInitHeader
    !attributeListForImplementation
    !transientListForImplementation
    !allArrayPropertyForImplementation
    !currentArrayPropertyForImplementation
    !fileInclusionSet
  ] ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
