semantics classAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "transientAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @classDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#------------------------------- Super class ?
  if mSuperClassName->string != "" then
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mSuperClassName
      ?@unifiedTypeProxy superClassProxy
    ] ;
  #--- Enter dependance edge
    [!?ioUnifiedTypeMap enterEdge
      !mClassName
      !mSuperClassName
    ] ;
  end if ;
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !mClassName
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*
#----------------------------------------------------------------------------*

#local routine analyzeClass
#  ??@classList.element inClass
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@classMap ioClassMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
##------------------------------- Super class ?
#  @observablePropertyMap observablePropertyMap ;
#  @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
#  @preferenceArrayMap allArrayPropertyMap ;
#  if [inClass->mSuperClassName string] != "" then
#    [ioClassMap searchKey !inClass->mSuperClassName ?* ?observablePropertyMap ?propertyListForInitMethodHeader ?4* ?allArrayPropertyMap ?*] ;
#  else
#    observablePropertyMap := [@observablePropertyMap emptyMap] ;
#    propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
#    allArrayPropertyMap := [@preferenceArrayMap emptyMap] ;
#  end if ;
#  const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
##---------------------------------- Analyze attributes
#  @fileInclusionSet fileInclusionSet [new ![@stringset emptySet] ![@stringset emptySet] ![@stringset emptySet]] ;
#  analyzeAttributeDeclaration
#    !inClass->mAttributeList
#    !inContextAnalysisStruct
#    !"class." . inClass->mClassName
#    !?ioTransientDependencyGraph
#    !?fileInclusionSet
#    !?observablePropertyMap
#    ?@attributeListForImplementation attributeListForImplementation
#    !?propertyListForInitMethodHeader
#  ;
##------------------------------------- Analyze arraies
#  @preferenceArrayMap currentArrayPropertyMap [emptyMap] ;
#  foreach inClass->mArrayList do
#    [ioClassMap searchKey
#      !mClassName
#      ?*
#      ?@observablePropertyMap classObservablePropertyMap
#      ?2*
#      ?@attributeListForImplementation attributeListForImplementation
#      ?4*
#    ] ;
#    [!?allArrayPropertyMap insertKey
#      !mArrayName
#      !mClassName->string
#      !classObservablePropertyMap
#      !attributeListForImplementation
#    ] ;
#    [!?currentArrayPropertyMap insertKey
#      !mArrayName
#      !mClassName->string
#      !classObservablePropertyMap
#      !attributeListForImplementation
#    ] ;
#  end foreach ;
##---------------------------------- Analyze transient properties
#  @transientListForImplementation transientListForImplementation ;
#  analyzeTransientProperties
#    ![@preferencesMap emptyMap]
#    !"class." . inClass->mClassName . "."
#    !inClass->mTransientList
#    ![@observablePropertyMap emptyMap] # Root property map
#    !inContextAnalysisStruct
#    !"" # No Root entity
#    ![@controllerMap emptyMap]
#    !?observablePropertyMap
#    !?fileInclusionSet
#    ?transientListForImplementation
#    !?ioTransientDependencyGraph
#  ;
##----------------------------------
#  [!?fileInclusionSet->mImplementationFileInclusionSet removeKey !""] ;
#  [!?ioClassMap insertKey
#    !inClass->mClassName
#    !inClass->mSuperClassName->string
#    !observablePropertyMap
#    !propertyListForInitMethodHeader
#    !inheritedAttributeListForImplementation
#    !attributeListForImplementation
#    !transientListForImplementation
#    !allArrayPropertyMap
#    !currentArrayPropertyMap
#    !fileInclusionSet
#  ] ;
#end routine ;

#----------------------------------------------------------------------------*

#routine analyzeClasses
#  ??@classList inClassList
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  !@classMap outClassMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
#  outClassMap := [@classMap emptyMap] ;
#  for aClass in inClassList do
#    analyzeClass
#      !aClass
#      !inContextAnalysisStruct
#      !?outClassMap
#      !?ioTransientDependencyGraph
#    ;
#  end for ;
#end routine ;

#----------------------------------------------------------------------------*

end semantics ;
