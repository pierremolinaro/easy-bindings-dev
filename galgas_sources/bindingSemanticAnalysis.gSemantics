semantics bindingSemanticAnalysis :
  import "decoratedTypes.gSemantics" ;

#----------------------------------------------------------------------------*

override method @tableValueBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap inEntityMap
  ??@classMap inClassMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap unused inActionMap
  ??@bool inHasTableValueBinding
  ??@globalEnumConstantMap unused inGlobalEnumConstantMap
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
  if not inHasTableValueBinding then
    error mControllerName: "this outlet does not support $tableValue binding" ;
  else
    [inControllerMap searchKey
      !mControllerName
      ?*
      ?@string controlledClassOrEntityName
      ?@bool isEntity
      ?@outletBindingListForGeneration controllerBindingList
      ?*
      ?*
    ] ;
    @observablePropertyMap observablePropertyMap ;
    if isEntity then
      [inEntityMap searchKey
        ![@lstring new !controlledClassOrEntityName !here]
        ?3*
        ?observablePropertyMap
        ?11*
      ] ;
    else
      [inClassMap searchKey
        ![@lstring new !controlledClassOrEntityName !here]
        ?*
        ?observablePropertyMap
        ?6*
      ] ;
    end if ;
    @columnBindingForTableValueBindingForGeneration columnBindingForTableValueBindingForGeneration [emptyList] ;
    for column in mTableValueColumnBinding do
      [observablePropertyMap searchKey
        !column->mBoundPropertyName
        ?@easyBindingType type
        ?*
        ?*
      ] ;
      const @string requiredCellTypeInTableColumnBinding := [type requiredCellTypeInTableColumnBinding] ;
      if requiredCellTypeInTableColumnBinding == "" then
        error column->mBoundPropertyName:"this property cannot be named in a $tableValue binding" ;
      elsif requiredCellTypeInTableColumnBinding != column->mCellTypeName->string then
        error column->mCellTypeName:"this property requires a " . requiredCellTypeInTableColumnBinding . " cell class" ;
      end if ;
      columnBindingForTableValueBindingForGeneration +=
        !column->mColumnName->string
        !requiredCellTypeInTableColumnBinding
        !column->mBoundPropertyName->string
        ![@2stringlist emptyList]
      ;
    end for ;
    ioOutletBindingListForGeneration += ![@tableValueBindingForGeneration new
      !mControllerName->string
      !columnBindingForTableValueBindingForGeneration
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @runBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@classMap unused inClassMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool unused inHasTableValueBinding
  ??@globalEnumConstantMap unused inGlobalEnumConstantMap
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
  if mTargetName->string == "self" then
    [inActionMap searchKey !mActionName] ;
  else
    @actionMap actionMap ;
    [inControllerMap searchKey !mTargetName ?4* ?actionMap ?*] ;
    [actionMap searchKey !mActionName] ;
  end if ;
  ioOutletBindingListForGeneration += ![@runBindingForGeneration new
    !mTargetName->string
    !mActionName->string
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularControllerBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@classMap unused inClassMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
#---------------------------------- Search binding
  [inBindingMap searchKey
    !mBindingName
    ?@easyBindingTypeAndFormatterList acceptableTypeFormatterList
    ?@outletClassBindingOptionMap outletClassBindingOptionMap
  ] ;
#---------------------------------- Search controller in controller map
  [inControllerMap searchKey
    !mControllerName
    ?5*
    ?@observablePropertyMap observableAttributeMap
  ] ;
#---------------------------------- Search property
  [observableAttributeMap searchKey
    !mControllerAttributeName
    ?@easyBindingType observablePropertyType
    ?@bool isTransient
    ?@string propertySignature
  ] ;
#------------------------------------------------- count option ?
  @string observedKeyPath := mControllerAttributeName->string ;
  if mNamesCountOption then
    observedKeyPath .= ".@count" ;
    if not [observablePropertyType isToManyEntitiesType] then
      error mControllerAttributeName: "the 'count' option is only allowed for to-many relationships" ;
    end if ;
  end if ;
  
#-------------------------------------------------- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mControllerAttributeName:s ;
  end if ;
#--- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    [mDefaultValue analyzeDefaultValueType
      !acceptableTypeList
      !inGlobalEnumConstantMap
      ?*
      ?@string objectiveCDefaultValueAsString
    ] ;
    bindingOptionList += ![mOptionName string] !objectiveCDefaultValueAsString ;
  end foreach ;
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !mControllerName->string
    !observedKeyPath
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularRootBinding analyzeOutletBinding
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@classMap unused inClassMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
#--------------------------------------- Search binding in outlet class binding map
  [inBindingMap searchKey
    !mBindingName
    ?@easyBindingTypeAndFormatterList acceptableTypeFormatterList
    ?@outletClassBindingOptionMap outletClassBindingOptionMap
  ] ;
#---------------------------------------- Find observable property in root entity observable property map
  [inRootEntityObservableAttributeMap searchKey
    !mObservableAttributeName
    ?@easyBindingType observablePropertyType
    ?*
    ?*
  ] ;
  @string observableKeyPath := mObservableAttributeName->string ;
#--------------------------------------- count option ?
  if mNamesCountOption then
    if [observablePropertyType isToManyEntitiesType] then
      observableKeyPath .= ".@count" ;
      observablePropertyType := [@uintegerType new] ;
    else
      error mObservableAttributeName: "the 'count' path is only allowed for to-many relationships" ;
    end if ;
  end if ;
#----------------------------------------- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
#    found := [mType ebTypeIdentifier !""] == [[@enumType new !inEnumTypeName->string] ebTypeIdentifier !""] ;
    found := [mType ebGenericTypeIdentifier ![observablePropertyType ocClassName]] == [observablePropertyType ebTypeIdentifier] ;
#    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebGenericTypeIdentifier ![observablePropertyType ocClassName]] . "'" ;
    end foreach ;
    error mObservableAttributeName:s ;
  end if ;
#----------------------------------------- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    [mDefaultValue analyzeDefaultValueType
      !acceptableTypeList
      !inGlobalEnumConstantMap
      ?*
      ?@string objectiveCDefaultValueAsString
    ] ;
    bindingOptionList += ![mOptionName string] !objectiveCDefaultValueAsString ;
  end foreach ;
#----------------------------------------- Generate binding
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !"mRootObject"
    !observableKeyPath
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularSelfBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@classMap unused inClassMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
#--------------------------------------- Search binding in outlet class binding map
  [inBindingMap searchKey
    !mBindingName
    ?@easyBindingTypeAndFormatterList acceptableTypeFormatterList
    ?@outletClassBindingOptionMap outletClassBindingOptionMap
  ] ;
#---------------------------------------- Find observable property in local observable property map
  [inSelfObservableAttributeMap searchKey
    !mObservableAttributeName
    ?@easyBindingType observablePropertyType
    ?*
    ?*
  ] ;
  @string observableKeyPath := mObservableAttributeName->string ;
#--------------------------------------- count option ?
  if mNamesCountOption then
    if [observablePropertyType isToManyEntitiesType] then
      observableKeyPath .= ".@count" ;
      observablePropertyType := [@uintegerType new] ;
    else
      error mObservableAttributeName: "the 'count' path is only allowed for to-many relationships" ;
    end if ;
  end if ;
#----------------------------------------- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mObservableAttributeName:s ;
  end if ;
#----------------------------------------- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    [mDefaultValue analyzeDefaultValueType
      !acceptableTypeList
      !inGlobalEnumConstantMap
      ?*
      ?@string objectiveCDefaultValueAsString
    ] ;
    bindingOptionList += ![mOptionName string] !objectiveCDefaultValueAsString ;
  end foreach ;
#----------------------------------------- Generate binding
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !"self"
    !observableKeyPath
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularPreferenceBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@classMap unused inClassMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
:
  ioImplementationFileInclusionSet += !mPreferenceName->string ;
#--------------------------------------- Search binding in outlet class binding map
  [inBindingMap searchKey
    !mBindingName
    ?@easyBindingTypeAndFormatterList acceptableTypeFormatterList
    ?@outletClassBindingOptionMap outletClassBindingOptionMap
  ] ;
#---------------------------------------- Search preference in preferences map
  [inPreferencesMap searchKey
    !mPreferenceName
    ?4*
    ?@observablePropertyMap observablePropertyMap
    ?4*
  ] ;
#---------------------------------------- Find observable property in local observable property map
  [observablePropertyMap searchKey
    !mPreferenceAttributeName
    ?@easyBindingType observablePropertyType
    ?*
    ?*
  ] ;
#----------------------------------------- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mPreferenceAttributeName:s ;
  end if ;
#----------------------------------------- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    [mDefaultValue analyzeDefaultValueType
      !acceptableTypeList
      !inGlobalEnumConstantMap
      ?*
      ?@string objectiveCDefaultValueAsString
    ] ;
    bindingOptionList += ![mOptionName string] !objectiveCDefaultValueAsString ;
  end foreach ;
#----------------------------------------- Generate binding
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !"g_" . mPreferenceName
    !mPreferenceAttributeName->string
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @multiValuedBindingBoundToRoot analyzeModel
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@controllerMap unused inControllerMap
  ?!@stringset unused ioImplementationFileInclusionSet
  !@string outObservedObjectName
  !@easyBindingType outObservablePropertyType
:
  [inRootEntityObservableAttributeMap searchKey
    !mPropertyName
    ?outObservablePropertyType
    ?*
    ?*
  ] ;
  outObservedObjectName := "mRootObject" ;
end method ;

#----------------------------------------------------------------------------*

override method @multiValuedBindingBoundToSelf analyzeModel
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@controllerMap unused inControllerMap
  ?!@stringset unused ioImplementationFileInclusionSet
  !@string outObservedObjectName
  !@easyBindingType outObservablePropertyType
:
  [inSelfObservableAttributeMap searchKey
    !mPropertyName
    ?outObservablePropertyType
    ?*
    ?*
  ] ;
  outObservedObjectName := "self" ;
end method ;

#----------------------------------------------------------------------------*

override method @multiValuedBindingBoundToPref analyzeModel
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap inPreferencesMap
  ??@controllerMap unused inControllerMap
  ?!@stringset ioImplementationFileInclusionSet
  !@string outObservedObjectName
  !@easyBindingType outObservablePropertyType
:
  [inPreferencesMap searchKey
    !mPreferenceName
    ?4*
    ?@observablePropertyMap preferenceObservableAttributeMap
    ?4*
  ] ;
  [preferenceObservableAttributeMap searchKey
    !mPropertyName
    ?outObservablePropertyType
    ?*
    ?*
  ] ;
  outObservedObjectName := "g_" . mPreferenceName ;
  ioImplementationFileInclusionSet += !mPreferenceName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @multiValuedBindingBoundToController analyzeModel
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@controllerMap inControllerMap
  ?!@stringset unused ioImplementationFileInclusionSet
  !@string outObservedObjectName
  !@easyBindingType outObservablePropertyType
:
  [inControllerMap searchKey
    !mControllerName
    ?5*
    ?@observablePropertyMap controllerObservableAttributeMap
  ] ;
  [controllerObservableAttributeMap searchKey
    !mPropertyName
    ?outObservablePropertyType
    ?*
    ?*
  ] ;
  outObservedObjectName := mControllerName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @multiValuedBinding analyzeOutletBinding
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@observablePropertyMap inSelfObservableAttributeMap
  ??@preferencesMap inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@classMap unused inClassMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
:
  @outletClassBindingOptionMap outletClassBindingOptionMap ;
  @easyBindingTypeAndFormatterList acceptableTypeFormatterList ;
  [inBindingMap searchKey !mBindingName ?acceptableTypeFormatterList ?outletClassBindingOptionMap] ;
#--- Find observable property
  @string generatedBindingName := mBindingName->string ;
  @uint idx := 1 ;
  foreach mMultiValuedBindingList do
    [mBoundModel analyzeModel
      !inRootEntityObservableAttributeMap
      !inSelfObservableAttributeMap
      !inPreferencesMap
      !inControllerMap
      !?ioImplementationFileInclusionSet
      ?@string observedObjectName
      ?@easyBindingType observablePropertyType
    ] ;
  #----------------------------------------- check model belongs to an acceptable type
    @bool found := false ;
    @formatterEnum requiredFormatter [noFormatter] ;
    foreach acceptableTypeFormatterList while not found do
      requiredFormatter := mRequiredFormatter ;
      found := mType == observablePropertyType ;
    end foreach ;
    if not found then
      @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
      foreach acceptableTypeFormatterList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error [mBoundModel mPropertyName] :s ;
    end if ;
  #--- Check options
    @2stringlist bindingOptionList [emptyList] ;
    if mNegate then
      bindingOptionList += !"NSValueTransformerName" !"NSNegateBooleanTransformerName" ;
    end if ;
    foreach mOutletBindingOptionList do
      @easyBindingTypeList acceptableTypeList ;
      [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    [mDefaultValue analyzeDefaultValueType
      !acceptableTypeList
      !inGlobalEnumConstantMap
      ?*
      ?@string objectiveCDefaultValueAsString
    ] ;
      bindingOptionList += ![mOptionName string] !objectiveCDefaultValueAsString ;
    end foreach ;
    ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
      !generatedBindingName
      !requiredFormatter
      !observedObjectName
      ![mBoundModel mPropertyName]->string
      !bindingOptionList
    ] ;
  #---
    idx ++ ;
    generatedBindingName := mBindingName->string . idx ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

routine checkBindingOptions
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ??@outletBindingOptionList inBindingOptionListAST
  ??@outletClassBindingOptionMap inAvailableBindingOptionMap
  !@2stringlist outBindingOptionListForGeneration
:
  outBindingOptionListForGeneration := [@2stringlist emptyList] ;
  foreach inBindingOptionListAST do
    @easyBindingTypeList acceptableTypeList ;
    [inAvailableBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    [mDefaultValue analyzeDefaultValueType
      !acceptableTypeList
      !inGlobalEnumConstantMap
      ?*
      ?@string objectiveCDefaultValueAsString
    ] ;
    outBindingOptionListForGeneration += ![mOptionName string] !objectiveCDefaultValueAsString ;
  end foreach ;
end routine ;


#----------------------------------------------------------------------------*

end semantics ;
