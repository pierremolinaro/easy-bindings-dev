semantics transientAnalysis :
  import "decoratedTypes.gSemantics" ;
  import "easyBindings_options.gOption" ;
  
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependency analyze
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring inTransientName
  ??@decoratedObservablePropertyMap inLocalObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring inTransientPropertySignature
;

#----------------------------------------------------------------------------*

override method @transientRootSignDependency analyze
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph unused ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
:
end method ;

#----------------------------------------------------------------------------*

override method @transientLocalDependency analyze
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring inTransientPropertySignature
:
  [inLocalObservablePropertyMap searchKey
    !mMasterName
    ?@unifiedTypeProxy masterType
    ?*
    ?@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
  if mNamesCountOption & not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  elsif isCollection & not mNamesCountOption then
    error mMasterName: "to-many relationships requires the 'count' option" ;
  end if ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientControllerDependency analyze
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph unused ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
:
end method ;

#----------------------------------------------------------------------------*

override method @transientRootDependency analyze
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph unused ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
:
end method ;

#----------------------------------------------------------------------------*

override method @transientPreferenceDependency analyze
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring inTransientPropertySignature
:
#--- Get preferences observables properties
  [inUnifiedTypeMap searchKey
    !mPreferencesName
    ??@typeKind kind
    ?5*
    ??@decoratedObservablePropertyMap observablePropertyMap
    ?*
  ] ;
#--- Check
  if kind != [@typeKind preferencesType] then
    error mPreferencesName : "'" . mPreferencesName . "' is not a preference" ;
  end if ;
#---
  [observablePropertyMap searchKey
    !mMasterName
    ?2*
    ??@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !inTransientPropertySignature
    !masterPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@string inSourceFile
  !@transientDependencyGraph outTransientDependencyGraph
:
#------------------------------------------- Build transient dependancy graph
  outTransientDependencyGraph := [@transientDependencyGraph emptyGraph] ;
  for () type_ in inUnifiedTypeMap do
    for () property_ in type_mObservablePropertyMap do
      [!?outTransientDependencyGraph addNode
        !property_mPropertySignature
        !property_mPropertySignature->string
        !property_mIsTransient
      ] ;
    end for ;
    for () transient_ in type_mDecoratedTransientMap do
      @decoratedObservablePropertyMap allObservableProperties := type_mObservablePropertyMap ;
      @unifiedTypeProxy t := type_mSuperType ;
      loop [inUnifiedTypeMap count] : while not [t isNull] do
        for () super_ in [t mObservablePropertyMap] do
          [!?allObservableProperties insertKey
            !super_lkey
            !super_mPropertyType
            !super_mIsTransient
            !super_mPropertySignature
            !super_mIsCollection
         ] ;
        end for ;
        t := [t mSuperType] ;
      end loop ; 
      for () in transient_mDependencyList do
        [mDependency analyze
          !inUnifiedTypeMap
          !?outTransientDependencyGraph
          !transient_lkey
          !allObservableProperties
          ![@unifiedTypeProxy null]
          !transient_mTransientSignature
        ] ;
      end for ;
    end for ;
  end for ;
#------------------------------------------- Output graphviz file ?
  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
    const s := [outTransientDependencyGraph graphviz] ;
    const path := inSourceFile . ".transientDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#------------------------------------------- Topological sort nodes
  [outTransientDependencyGraph topologicalSort
    ?@transientDependencyGraphNodeInfoList sortedNodes
    ?*
    ?@transientDependencyGraphNodeInfoList unsortedNodes
    ?*
  ] ;
  if [unsortedNodes length] > 0 then
    var s := "cannot sort properties and transient ; the following ones are involved in circular dependence:" ;
    foreach unsortedNodes do
      s .= "\n-- " . mSignature ;
    end foreach ;
    error here : s ;
  else # ok no error
  #--- build a string list of all transients
    @stringlist transientList := {} ;
    for () in sortedNodes do
      if mIsTransient then
        transientList += !mSignature ;
      end if ;
    end for ;
#    log sortedNodes ;
 #   log transientList ;
    const @string s := [filewrapper transientManager.applicationInSwift
      !sortedNodes
      !transientList
    ] ;
    [@string generateFileWithPattern
      ![inSourceFile stringByDeletingLastPathComponent]
      !"PMApplication.swift"
      !"//"
      !"\n\n" # Defaut user zone1
      !s
      !"\n\n" # Defaut user zone2
      !""
    ] ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

local filewrapper transientManager in "../generation-templates" {
}{
}{
  template applicationInSwift "PMApplication.swift.gTemplate"
    ?@transientDependencyGraphNodeInfoList PROPERTY_LIST
    ?@stringlist TRANSIENT_LIST
  ;
}
#----------------------------------------------------------------------------*
#! EX
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependency EXanalyze
  ??@lstring inTransientName
  ??@EXobservablePropertyMap inLocalObservablePropertyMap
  ??@EXobservablePropertyMap inRootObjectObservablePropertyMap
  ??@string inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet ioFileInclusionSet
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist ioRootSignDependencyList
;

#----------------------------------------------------------------------------*

override method @transientRootSignDependency EXanalyze
  ??@lstring inTransientName
  ??@EXobservablePropertyMap unused inLocalObservablePropertyMap
  ??@EXobservablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet unused ioFileInclusionSet
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList unused ioDirectDependancyList
  ?!@stringlist ioRootSignDependencyList
:
  if inRootEntityName == "" then
    error mDeclarationLocation: "no root object in this context" ;
  end if ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    ![@lstring new !"entity." . inRootEntityName . ".sign" !mDeclarationLocation]
    !inTransientPropertySignature
  ] ;
#---
  ioRootSignDependencyList += !inTransientPropertySignature->string . inTransientName ;
end method ;

#----------------------------------------------------------------------------*

override method @transientLocalDependency EXanalyze
  ??@lstring unused inTransientName
  ??@EXobservablePropertyMap inLocalObservablePropertyMap
  ??@EXobservablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet unused ioFileInclusionSet
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist unused ioRootSignDependencyList
:
  [inLocalObservablePropertyMap searchKey
    !mMasterName
    ?@EXebType masterType
    ?*
    ?@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
  if mNamesCountOption & not isCollection then
      error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  elsif isCollection & not mNamesCountOption then
      error mMasterName: "to-many relationships requires the 'count' option" ;
  end if ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
#---
  ioDirectDependancyList += ![@transientDependencyFromSelfForImplementation new !masterType !mMasterName->string !mNamesCountOption] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientControllerDependency EXanalyze
  ??@lstring unused inTransientName
  ??@EXobservablePropertyMap inLocalObservablePropertyMap
  ??@EXobservablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet unused ioFileInclusionSet
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist unused ioRootSignDependencyList
:
#--- Search controller in controller map
  [inLocalObservablePropertyMap searchKey
    !mControllerName
    ?@EXebType type
    ?3*
  ] ;
  if type->mKind != [@EXTypeKind controllerClassType] then
    error mControllerName : "'" . mControllerName . "' is not a controller" ;
  end if ;
#--- Search controller observable attribute map
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !type->mTypeName
    ?*
    ?@EXTypeKind typeKind
    ?@EXobservablePropertyMap controllerObservablePropertyMap
  ] ;
#--- Search controller observed attribute
  [controllerObservablePropertyMap searchKey
    !mMasterName
    ?@EXebType masterType
    ?*
    ?@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
#---
  ioDirectDependancyList += ![@transientDependencyFromControllerForImplementation new !masterType !mControllerName->string !mMasterName->string] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootDependency EXanalyze
  ??@lstring unused inTransientName
  ??@EXobservablePropertyMap unused inLocalObservablePropertyMap
  ??@EXobservablePropertyMap inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet unused ioFileInclusionSet
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist unused ioRootSignDependencyList
:
  [inRootObjectObservablePropertyMap searchKey
    !mMasterName
    ?@EXebType masterType
    ?*
    ?@lstring masterDependencyKey
    ?@bool isCollection
  ] ;
#--- Has 'count' option ?
  if mNamesCountOption & not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  end if ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    !masterDependencyKey
    !inTransientPropertySignature
  ] ;
#---
  ioDirectDependancyList += ![@transientDependencyFromRootForImplementation new
    !masterType
    !mMasterName->string
    !mNamesCountOption
    ![masterDependencyKey identifierRepresentation]
 ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientPreferenceDependency EXanalyze
  ??@lstring unused inTransientName
  ??@EXobservablePropertyMap unused inLocalObservablePropertyMap
  ??@EXobservablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet ioFileInclusionSet
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist unused ioRootSignDependencyList
:
#--- Get preferences observables properties
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !mPreferencesName
    ?*
    ?@EXTypeKind kind
    ?@EXobservablePropertyMap observablePropertyMap
  ] ;
#--- Check
  if kind != [@EXTypeKind preferencesType] then
    error mPreferencesName : "'" . mPreferencesName . "' is not a preference" ;
  end if ;
#---
  [observablePropertyMap searchKey
    !mMasterName
    ?@EXebType masterType
    ?@bool isTransient
    ?@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
#--- Add preference header
  ioFileInclusionSet->mImplementationFileInclusionSet += !mPreferencesName->string ;
#---
  ioDirectDependancyList += ![@transientDependencyFromPreferenceForImplementation new
    !masterType
    !mPreferencesName->string
    !mMasterName->string
    !isTransient
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine analyzeTransientProperties
  ??@transientList inTransientList
  ??@EXobservablePropertyMap inRootObjectObservablePropertyMap
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ??@string inRootEntityName
  ??@EXobservablePropertyMap inSelfObjectObservablePropertyMap
  ?!@fileInclusionSet ioFileInclusionSet
  !@transientListForImplementation outTransientListForImplementation
:
  outTransientListForImplementation := [@transientListForImplementation emptyList] ;
  foreach inTransientList do
    [inSelfObjectObservablePropertyMap searchKey
      !mTransientName
      ?@EXebType type
      ?*
      ?@lstring transientPropertySignature
      ?*
    ] ;
  #--- Analyze dependencies
    @directDependancyList directDependancyList [emptyList] ;
    @stringlist rootSignDependencyList [emptyList] ;
    foreach mDependencyList do
      [mDependency EXanalyze
        !mTransientName
        !inSelfObjectObservablePropertyMap
        !inRootObjectObservablePropertyMap
        !inRootEntityName
        !transientPropertySignature
        !?ioFileInclusionSet
        !?ioContextAnalysisStruct
        !?directDependancyList
        !?rootSignDependencyList
      ] ;
    end foreach ;
  #--- Add transient implementation
    outTransientListForImplementation += !type ![mTransientName string] !directDependancyList !rootSignDependencyList ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
