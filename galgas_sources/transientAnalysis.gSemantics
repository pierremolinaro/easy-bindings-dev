semantics transientAnalysis :
  import "typeAnalysis.gSemantics" ;
  import "easyBindings_options.gOption" ;
  
#----------------------------------------------------------------------------*
#! buildTransientDependencyGraph
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyAST buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring inTransientName
  ??@decoratedObservablePropertyMap inLocalObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@arrayControllerMap inArrayControllerMap
  ??@lstring inTransientPropertySignature
;

#----------------------------------------------------------------------------*

override method @transientRootSignDependencyAST buildTransientDependencyGraph
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph unused ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@arrayControllerMap unused inArrayControllerMap
  ??@lstring unused inTransientPropertySignature
:
end method ;

#----------------------------------------------------------------------------*

override method @transientLocalDependencyAST buildTransientDependencyGraph
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@arrayControllerMap unused inArrayControllerMap
  ??@lstring inTransientPropertySignature
:
  [inLocalObservablePropertyMap searchKey
    !mMasterName
    ?@unifiedTypeProxy masterType
    ?*
    ?@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientControllerDependencyAST buildTransientDependencyGraph
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@arrayControllerMap inArrayControllerMap
  ??@lstring inTransientPropertySignature
:
  [inArrayControllerMap searchKey
    !mControllerName
    ?4*
    ??@decoratedObservablePropertyMap controllerObservablePropertyMap
    ?*
  ] ;
#---
  [controllerObservablePropertyMap searchKey
    !mMasterName
    ?*
    ?*
    ?@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootDependencyAST buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@arrayControllerMap unused inArrayControllerMap
  ??@lstring inTransientPropertySignature
:
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap := [inRootEntityType mObservablePropertyMap] ;
  var t := [inRootEntityType mSuperType] ;
  loop [inUnifiedTypeMap count] : while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ] ;
    end for ;
    t := [t mSuperType] ;
  end loop ; 
  [allObservablePropertyMap searchKey
    !mMasterName
    ?*
    ?*
    ?@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootRelationshipDependencyAST buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@arrayControllerMap unused inArrayControllerMap
  ??@lstring inTransientPropertySignature
:
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap := [inRootEntityType mObservablePropertyMap] ;
  var t := [inRootEntityType mSuperType] ;
  loop [inUnifiedTypeMap count] : while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ] ;
    end for ;
    t := [t mSuperType] ;
  end loop ; 
  [allObservablePropertyMap searchKey
    !mRelationshipName
    ??@unifiedTypeProxy relationshipElementType
    ?*
    ?*
    ?@bool isCollection
  ] ;
  if not isCollection then
    error mRelationshipName : "this property should be a tomany relationship" ;
  end if ;
  [[relationshipElementType mObservablePropertyMap] searchKey
    !mMasterName
    ?*
    ?*
    ?@lstring masterPropertySignature
    ?isCollection
  ] ;
  if isCollection then
    error mMasterName : "this property should not be a collection" ;
  end if ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientPreferenceDependencyAST buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@arrayControllerMap unused inArrayControllerMap
  ??@lstring inTransientPropertySignature
:
#--- Get preferences observables properties
  [inUnifiedTypeMap searchKey
    !mPreferencesName
    ?* #?@typeKind kind
    ?5*
    ??@decoratedObservablePropertyMap observablePropertyMap
    ?6*
  ] ;
#---
  [observablePropertyMap searchKey
    !mMasterName
    ?2*
    ??@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@string inSourceFile
  !@transientDependencyGraphNodeInfoList outSortedTransientNodes
:
#------------------------------------------- Build transient dependancy graph
  var transientDependencyGraph := [@transientDependencyGraph emptyGraph] ;
  for () type_ in inUnifiedTypeMap do
    for () property_ in type_mObservablePropertyMap do
      [!?transientDependencyGraph addNode
        !property_mPropertySignature
        !property_mPropertySignature->string
        !property_mIsTransient
      ] ;
    end for ;
    for () arrayController_ in type_mArrayControllerMap do
      [!?transientDependencyGraph addNode
        !arrayController_mPropertySignature
        !arrayController_mPropertySignature->string
        !true # Is transient
      ] ;
    #--- Add dependency arc from model to array controller
      [!?transientDependencyGraph addEdge
        ![arrayController_mBoundModel propertySignature
           ![type_mTypeKind kindName]
           !type_lkey->string
           !type_mRootEntityType
         ]
        !arrayController_mPropertySignature
      ] ;
    end for ;
    for () transient_ in type_mDecoratedTransientMap do
      @decoratedObservablePropertyMap allObservableProperties := type_mObservablePropertyMap ;
      @unifiedTypeProxy t := type_mSuperType ;
      loop [inUnifiedTypeMap count] : while not [t isNull] do
        for () super_ in [t mObservablePropertyMap] do
          [!?allObservableProperties insertKey
            !super_lkey
            !super_mPropertyType
            !super_mIsTransient
            !super_mPropertySignature
            !super_mIsCollection
         ] ;
        end for ;
        t := [t mSuperType] ;
      end loop ; 
      for () in transient_mDependencyList do
        [mDependency buildTransientDependencyGraph
          !inUnifiedTypeMap
          !?transientDependencyGraph
          !transient_lkey
          !allObservableProperties
          !type_mRootEntityType
          !type_mArrayControllerMap
          !transient_mTransientSignature
        ] ;
      end for ;
    end for ;
  end for ;
#------------------------------------------- Output graphviz file ?
  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
    const s := [transientDependencyGraph graphviz] ;
    const path := inSourceFile . ".transientDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#------------------------------------------- Topological sort nodes
  if [@uint errorCount] != 0 then
    outSortedTransientNodes := {} ;
  else
    [transientDependencyGraph topologicalSort
      ?outSortedTransientNodes
      ?*
      ?@transientDependencyGraphNodeInfoList unsortedNodes
      ?*
    ] ;
    if [unsortedNodes length] > 0 then
      var s := "cannot sort properties and transient ; the following ones are involved in circular dependence:" ;
      foreach unsortedNodes do
        s .= "\n-- " . mSignature ;
      end foreach ;
      error here : s ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*
#! transientDependencySemanticAnalysis
#----------------------------------------------------------------------------*

override method @transientRootSignDependencyAST transientDependencySemanticAnalysis
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration unused ioTransientDependencyListForGeneration
:
end method ;

#----------------------------------------------------------------------------*

override method @transientLocalDependencyAST transientDependencySemanticAnalysis
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
  [inAllObservablePropertyMap searchKey
    !mMasterName
    ?@unifiedTypeProxy masterType
    ?*
    ?* #@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
  if mNamesCountOption & not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  elsif isCollection & not mNamesCountOption then
    error mMasterName: "to-many relationships requires the 'count' option" ;
  end if ;
  ioTransientDependencyListForGeneration += ![masterType transientFormalArgumentTypeName] !mMasterName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @transientControllerDependencyAST transientDependencySemanticAnalysis
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ??@arrayControllerMap inArrayControllerMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
  [inArrayControllerMap searchKey
    !mControllerName
    ?4*
    ??@decoratedObservablePropertyMap arrayControllerObservablePropertyMap
    ?*
  ] ;
  [arrayControllerObservablePropertyMap searchKey
    !mMasterName
    ??@unifiedTypeProxy masterType
    ?*
    ?*
    ?*
  ] ;
#---
  ioTransientDependencyListForGeneration += ![masterType transientFormalArgumentTypeName] !mMasterName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootDependencyAST transientDependencySemanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap := [inRootEntityType mObservablePropertyMap] ;
  var t := [inRootEntityType mSuperType] ;
  loop [inUnifiedTypeMap count] : while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ] ;
    end for ;
    t := [t mSuperType] ;
  end loop ; 
  [allObservablePropertyMap searchKey
    !mMasterName
    ??@unifiedTypeProxy masterType
    ?*
    ?*
    ?@bool isCollection
  ] ;
#--- Has 'count' option ?
  if mNamesCountOption & not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  end if ;
#---
  ioTransientDependencyListForGeneration += ![masterType transientFormalArgumentTypeName] !mMasterName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootRelationshipDependencyAST transientDependencySemanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap := [inRootEntityType mObservablePropertyMap] ;
  var t := [inRootEntityType mSuperType] ;
  loop [inUnifiedTypeMap count] : while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ] ;
    end for ;
    t := [t mSuperType] ;
  end loop ; 
  [allObservablePropertyMap searchKey
    !mRelationshipName
    ??@unifiedTypeProxy relationshipElementType
    ?*
    ?*
    ?@bool isCollection
  ] ;
  if not isCollection then
    error mRelationshipName : "this property should be a tomany relationship" ;
  end if ;
  [[relationshipElementType mObservablePropertyMap] searchKey
    !mMasterName
    ?2*
    ?@lstring masterPropertySignature
    ?isCollection
  ] ;
  if isCollection then
    error mMasterName : "this property should not be a collection" ;
  end if ;
#---
  ioTransientDependencyListForGeneration += !"[" + [relationshipElementType key] + "_" + mMasterName + "]" !"arrayOf_" + mMasterName ;
end method ;

#----------------------------------------------------------------------------*

override method @transientPreferenceDependencyAST transientDependencySemanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
#--- Get preferences observables properties
  [inUnifiedTypeMap searchKey
    !mPreferencesName
    ??@typeKind kind
    ?5*
    ??@decoratedObservablePropertyMap observablePropertyMap
    ?6*
  ] ;
#--- Check
  if kind != [@typeKind preferencesType] then
    error mPreferencesName : "'" . mPreferencesName . "' is not a preference" ;
  end if ;
#---
  [observablePropertyMap searchKey
    !mMasterName
    ??@unifiedTypeProxy masterType
    ?*
    ?* # ?@lstring masterPropertySignature
    ?*
  ] ;
  ioTransientDependencyListForGeneration += ![masterType transientFormalArgumentTypeName] !mMasterName->string ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
