semantics transientAnalysis :
  import "typeAnalysis.gSemantics" ;
  import "easyBindings_options.gOption" ;
  
#----------------------------------------------------------------------------*
#! buildTransientDependencyGraph
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependency buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring inTransientName
  ??@decoratedObservablePropertyMap inLocalObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring inTransientPropertySignature
;

#----------------------------------------------------------------------------*

override method @transientRootSignDependency buildTransientDependencyGraph
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph unused ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
:
end method ;

#----------------------------------------------------------------------------*

override method @transientLocalDependency buildTransientDependencyGraph
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring inTransientPropertySignature
:
  [inLocalObservablePropertyMap searchKey
    !mMasterName
    ?@unifiedTypeProxy masterType
    ?*
    ?@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientControllerDependency buildTransientDependencyGraph
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring inTransientPropertySignature
:
  [inLocalObservablePropertyMap searchKey
    !mControllerName
    ??@unifiedTypeProxy controllerType
    ?*
    ?*
    ?*
  ] ;
  const controllerObservablePropertyMap := [controllerType mObservablePropertyMap] ;
#---
  [controllerObservablePropertyMap searchKey
    !mMasterName
    ?*
    ?*
    ?@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !inTransientPropertySignature
    !masterPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootDependency buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring inTransientPropertySignature
:
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap := [inRootEntityType mObservablePropertyMap] ;
  var t := [inRootEntityType mSuperType] ;
  loop [inUnifiedTypeMap count] : while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ] ;
    end for ;
    t := [t mSuperType] ;
  end loop ; 
  [allObservablePropertyMap searchKey
    !mMasterName
    ?*
    ?*
    ?@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !inTransientPropertySignature
    !masterPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientPreferenceDependency buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring inTransientPropertySignature
:
#--- Get preferences observables properties
  [inUnifiedTypeMap searchKey
    !mPreferencesName
    ?* #?@typeKind kind
    ?5*
    ??@decoratedObservablePropertyMap observablePropertyMap
    ?6*
  ] ;
#---
  [observablePropertyMap searchKey
    !mMasterName
    ?2*
    ??@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !inTransientPropertySignature
    !masterPropertySignature
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine buildTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@string inSourceFile
  !@transientDependencyGraphNodeInfoList outSortedTransientNodes
:
#------------------------------------------- Build transient dependancy graph
  var transientDependencyGraph := [@transientDependencyGraph emptyGraph] ;
  for () type_ in inUnifiedTypeMap do
    for () property_ in type_mObservablePropertyMap do
      [!?transientDependencyGraph addNode
        !property_mPropertySignature
        !property_mPropertySignature->string
        !property_mIsTransient
      ] ;
    end for ;
#  @abstractObservablePropertyAST mBoundModel ;
#  @lstring mTableViewOutletName ;
#  @arrayControllerBoundColumnListAST mArrayControllerBoundColumnListAST ;
#  @actionMap mActionMap ;
#  @decoratedObservablePropertyMap mObservablePropertyMap ;
    for () arrayController_ in type_mArrayControllerMap do
      [!?transientDependencyGraph addNode
        !arrayController_mPropertySignature
        !arrayController_mPropertySignature->string
        !true # Is transient
      ] ;
    #--- Add dependency arc from model to array controller
      [!?transientDependencyGraph addEdge
        ![arrayController_mBoundModel propertySignature
           ![type_mTypeKind kindName]
           !type_lkey->string
           !type_mRootEntityType
         ]
        !arrayController_mPropertySignature
      ] ;
    end for ;
    for () transient_ in type_mDecoratedTransientMap do
      @decoratedObservablePropertyMap allObservableProperties := type_mObservablePropertyMap ;
      @unifiedTypeProxy t := type_mSuperType ;
      loop [inUnifiedTypeMap count] : while not [t isNull] do
        for () super_ in [t mObservablePropertyMap] do
          [!?allObservableProperties insertKey
            !super_lkey
            !super_mPropertyType
            !super_mIsTransient
            !super_mPropertySignature
            !super_mIsCollection
         ] ;
        end for ;
        t := [t mSuperType] ;
      end loop ; 
      for () in transient_mDependencyList do
        [mDependency buildTransientDependencyGraph
          !inUnifiedTypeMap
          !?transientDependencyGraph
          !transient_lkey
          !allObservableProperties
          !type_mRootEntityType
          !transient_mTransientSignature
        ] ;
      end for ;
    end for ;
  end for ;
#------------------------------------------- Output graphviz file ?
  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
    const s := [transientDependencyGraph graphviz] ;
    const path := inSourceFile . ".transientDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#------------------------------------------- Topological sort nodes
  if [@uint errorCount] != 0 then
    outSortedTransientNodes := {} ;
  else
    [transientDependencyGraph topologicalSort
      ?outSortedTransientNodes
      ?*
      ?@transientDependencyGraphNodeInfoList unsortedNodes
      ?*
    ] ;
    if [unsortedNodes length] > 0 then
      var s := "cannot sort properties and transient ; the following ones are involved in circular dependence:" ;
      foreach unsortedNodes do
        s .= "\n-- " . mSignature ;
      end foreach ;
      error here : s ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*
#! transientDependencySemanticAnalysis
#----------------------------------------------------------------------------*

override method @transientRootSignDependency transientDependencySemanticAnalysis
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration unused ioTransientDependencyListForGeneration
:
end method ;

#----------------------------------------------------------------------------*

override method @transientLocalDependency transientDependencySemanticAnalysis
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
  [inAllObservablePropertyMap searchKey
    !mMasterName
    ?@unifiedTypeProxy masterType
    ?*
    ?* #@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
  if mNamesCountOption & not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  elsif isCollection & not mNamesCountOption then
    error mMasterName: "to-many relationships requires the 'count' option" ;
  end if ;
  ioTransientDependencyListForGeneration += !masterType !mMasterName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @transientControllerDependency transientDependencySemanticAnalysis
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
  [inAllObservablePropertyMap searchKey
    !mControllerName
    ??@unifiedTypeProxy controllerType
    ?*
    ?*
    ?*
  ] ;
  const controllerObservablePropertyMap := [controllerType mObservablePropertyMap] ;
  [controllerObservablePropertyMap searchKey
    !mMasterName
    ??@unifiedTypeProxy masterType
    ?*
    ?*
    ?*
  ] ;
  if [controllerType mTypeKind] != [@typeKind controllerClassType] then
    error mControllerName : "the '" . mControllerName . "' attribute is not a controller" ;
  end if ;
#---
  ioTransientDependencyListForGeneration += !masterType !mMasterName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootDependency transientDependencySemanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap := [inRootEntityType mObservablePropertyMap] ;
  var t := [inRootEntityType mSuperType] ;
  loop [inUnifiedTypeMap count] : while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ] ;
    end for ;
    t := [t mSuperType] ;
  end loop ; 
  [allObservablePropertyMap searchKey
    !mMasterName
    ??@unifiedTypeProxy masterType
    ?*
    ?*
    ?@bool isCollection
  ] ;
#--- Has 'count' option ?
  if mNamesCountOption & not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  end if ;
#---
  ioTransientDependencyListForGeneration += !masterType !mMasterName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @transientPreferenceDependency transientDependencySemanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring unused inTransientName
  ??@decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ??@lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
:
#--- Get preferences observables properties
  [inUnifiedTypeMap searchKey
    !mPreferencesName
    ??@typeKind kind
    ?5*
    ??@decoratedObservablePropertyMap observablePropertyMap
    ?6*
  ] ;
#--- Check
  if kind != [@typeKind preferencesType] then
    error mPreferencesName : "'" . mPreferencesName . "' is not a preference" ;
  end if ;
#---
  [observablePropertyMap searchKey
    !mMasterName
    ??@unifiedTypeProxy masterType
    ?*
    ?* # ?@lstring masterPropertySignature
    ?*
  ] ;
  ioTransientDependencyListForGeneration += !masterType !mMasterName->string ;
end method ;

##----------------------------------------------------------------------------*
##! EX
##----------------------------------------------------------------------------*
#
#abstract method @abstractTransientDependency EXanalyze
#  ??@lstring inTransientName
#  ??@EXobservablePropertyMap inLocalObservablePropertyMap
#  ??@EXobservablePropertyMap inRootObjectObservablePropertyMap
#  ??@string inRootEntityName
#  ??@lstring inTransientPropertySignature
#  ?!@fileInclusionSet ioFileInclusionSet
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@directDependancyList ioDirectDependancyList
#  ?!@stringlist ioRootSignDependencyList
#;
#
##----------------------------------------------------------------------------*
#
#override method @transientRootSignDependency EXanalyze
#  ??@lstring inTransientName
#  ??@EXobservablePropertyMap unused inLocalObservablePropertyMap
#  ??@EXobservablePropertyMap unused inRootObjectObservablePropertyMap
#  ??@string inRootEntityName
#  ??@lstring inTransientPropertySignature
#  ?!@fileInclusionSet unused ioFileInclusionSet
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@directDependancyList unused ioDirectDependancyList
#  ?!@stringlist ioRootSignDependencyList
#:
#  if inRootEntityName == "" then
#    error mDeclarationLocation: "no root object in this context" ;
#  end if ;
##--- Add dependency arc
#  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
#    ![@lstring new !"entity." . inRootEntityName . ".sign" !mDeclarationLocation]
#    !inTransientPropertySignature
#  ] ;
##---
#  ioRootSignDependencyList += !inTransientPropertySignature->string . inTransientName ;
#end method ;
#
##----------------------------------------------------------------------------*
#
#override method @transientLocalDependency EXanalyze
#  ??@lstring unused inTransientName
#  ??@EXobservablePropertyMap inLocalObservablePropertyMap
#  ??@EXobservablePropertyMap unused inRootObjectObservablePropertyMap
#  ??@string unused inRootEntityName
#  ??@lstring inTransientPropertySignature
#  ?!@fileInclusionSet unused ioFileInclusionSet
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@directDependancyList ioDirectDependancyList
#  ?!@stringlist unused ioRootSignDependencyList
#:
#  [inLocalObservablePropertyMap searchKey
#    !mMasterName
#    ?@EXebType masterType
#    ?*
#    ?@lstring masterPropertySignature
#    ?@bool isCollection
#  ] ;
#  if mNamesCountOption & not isCollection then
#      error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
#  elsif isCollection & not mNamesCountOption then
#      error mMasterName: "to-many relationships requires the 'count' option" ;
#  end if ;
##--- Add dependency arc
#  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
#    !masterPropertySignature
#    !inTransientPropertySignature
#  ] ;
##---
#  ioDirectDependancyList += ![@transientDependencyFromSelfForImplementation new !masterType !mMasterName->string !mNamesCountOption] ;
#end method ;
#
##----------------------------------------------------------------------------*
#
#override method @transientControllerDependency EXanalyze
#  ??@lstring unused inTransientName
#  ??@EXobservablePropertyMap inLocalObservablePropertyMap
#  ??@EXobservablePropertyMap unused inRootObjectObservablePropertyMap
#  ??@string unused inRootEntityName
#  ??@lstring inTransientPropertySignature
#  ?!@fileInclusionSet unused ioFileInclusionSet
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@directDependancyList ioDirectDependancyList
#  ?!@stringlist unused ioRootSignDependencyList
#:
##--- Search controller in controller map
#  [inLocalObservablePropertyMap searchKey
#    !mControllerName
#    ?@EXebType type
#    ?3*
#  ] ;
#  if type->mKind != [@EXTypeKind controllerClassType] then
#    error mControllerName : "'" . mControllerName . "' is not a controller" ;
#  end if ;
##--- Search controller observable attribute map
#  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
#    !type->mTypeName
#    ?*
#    ?@EXTypeKind typeKind
#    ?@EXobservablePropertyMap controllerObservablePropertyMap
#  ] ;
##--- Search controller observed attribute
#  [controllerObservablePropertyMap searchKey
#    !mMasterName
#    ?@EXebType masterType
#    ?*
#    ?@lstring masterPropertySignature
#    ?*
#  ] ;
##--- Add dependency arc
#  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
#    !masterPropertySignature
#    !inTransientPropertySignature
#  ] ;
##---
#  ioDirectDependancyList += ![@transientDependencyFromControllerForImplementation new !masterType !mControllerName->string !mMasterName->string] ;
#end method ;
#
##----------------------------------------------------------------------------*
#
#override method @transientRootDependency EXanalyze
#  ??@lstring unused inTransientName
#  ??@EXobservablePropertyMap unused inLocalObservablePropertyMap
#  ??@EXobservablePropertyMap inRootObjectObservablePropertyMap
#  ??@string unused inRootEntityName
#  ??@lstring inTransientPropertySignature
#  ?!@fileInclusionSet unused ioFileInclusionSet
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@directDependancyList ioDirectDependancyList
#  ?!@stringlist unused ioRootSignDependencyList
#:
#  [inRootObjectObservablePropertyMap searchKey
#    !mMasterName
#    ?@EXebType masterType
#    ?*
#    ?@lstring masterDependencyKey
#    ?@bool isCollection
#  ] ;
##--- Has 'count' option ?
#  if mNamesCountOption & not isCollection then
#    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
#  end if ;
##--- Add dependency arc
#  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
#    !masterDependencyKey
#    !inTransientPropertySignature
#  ] ;
##---
#  ioDirectDependancyList += ![@transientDependencyFromRootForImplementation new
#    !masterType
#    !mMasterName->string
#    !mNamesCountOption
#    ![masterDependencyKey identifierRepresentation]
# ] ;
#end method ;
#
##----------------------------------------------------------------------------*
#
#override method @transientPreferenceDependency EXanalyze
#  ??@lstring unused inTransientName
#  ??@EXobservablePropertyMap unused inLocalObservablePropertyMap
#  ??@EXobservablePropertyMap unused inRootObjectObservablePropertyMap
#  ??@string unused inRootEntityName
#  ??@lstring inTransientPropertySignature
#  ?!@fileInclusionSet ioFileInclusionSet
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@directDependancyList ioDirectDependancyList
#  ?!@stringlist unused ioRootSignDependencyList
#:
##--- Get preferences observables properties
#  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
#    !mPreferencesName
#    ?*
#    ?@EXTypeKind kind
#    ?@EXobservablePropertyMap observablePropertyMap
#  ] ;
##--- Check
#  if kind != [@EXTypeKind preferencesType] then
#    error mPreferencesName : "'" . mPreferencesName . "' is not a preference" ;
#  end if ;
##---
#  [observablePropertyMap searchKey
#    !mMasterName
#    ?@EXebType masterType
#    ?@bool isTransient
#    ?@lstring masterPropertySignature
#    ?*
#  ] ;
##--- Add dependency arc
#  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
#    !masterPropertySignature
#    !inTransientPropertySignature
#  ] ;
##--- Add preference header
#  ioFileInclusionSet->mImplementationFileInclusionSet += !mPreferencesName->string ;
##---
#  ioDirectDependancyList += ![@transientDependencyFromPreferenceForImplementation new
#    !masterType
#    !mPreferencesName->string
#    !mMasterName->string
#    !isTransient
#  ] ;
#end method ;
#
##----------------------------------------------------------------------------*
#
#routine analyzeTransientProperties
#  ??@transientList inTransientList
#  ??@EXobservablePropertyMap inRootObjectObservablePropertyMap
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ??@string inRootEntityName
#  ??@EXobservablePropertyMap inSelfObjectObservablePropertyMap
#  ?!@fileInclusionSet ioFileInclusionSet
#  !@transientListForImplementation outTransientListForImplementation
#:
#  outTransientListForImplementation := [@transientListForImplementation emptyList] ;
#  foreach inTransientList do
#    [inSelfObjectObservablePropertyMap searchKey
#      !mTransientName
#      ?@EXebType type
#      ?*
#      ?@lstring transientPropertySignature
#      ?*
#    ] ;
#  #--- Analyze dependencies
#    @directDependancyList directDependancyList [emptyList] ;
#    @stringlist rootSignDependencyList [emptyList] ;
#    foreach mDependencyList do
#      [mDependency EXanalyze
#        !mTransientName
#        !inSelfObjectObservablePropertyMap
#        !inRootObjectObservablePropertyMap
#        !inRootEntityName
#        !transientPropertySignature
#        !?ioFileInclusionSet
#        !?ioContextAnalysisStruct
#        !?directDependancyList
#        !?rootSignDependencyList
#      ] ;
#    end foreach ;
#  #--- Add transient implementation
#    outTransientListForImplementation += !type ![mTransientName string] !directDependancyList !rootSignDependencyList ;
#  end foreach ;
#end routine ;
#
#----------------------------------------------------------------------------*

end semantics ;
