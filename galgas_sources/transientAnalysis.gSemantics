semantics transientAnalysis :
  import "decoratedTypes.gSemantics" ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependency analyze
  ??@lstring inTransientName
  ??@observablePropertyMap inLocalObservablePropertyMap
  ??@observablePropertyMap inRootObjectObservablePropertyMap
  ??@string inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet ioFileInclusionSet
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist ioRootSignDependencyList
;

#----------------------------------------------------------------------------*

override method @transientRootSignDependency analyze
  ??@lstring inTransientName
  ??@observablePropertyMap unused inLocalObservablePropertyMap
  ??@observablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet unused ioFileInclusionSet
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList unused ioDirectDependancyList
  ?!@stringlist ioRootSignDependencyList
:
  if inRootEntityName == "" then
    error mDeclarationLocation: "no root object in this context" ;
  end if ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    ![@lstring new !"entity." . inRootEntityName . ".sign" !mDeclarationLocation]
    !inTransientPropertySignature
  ] ;
#---
  ioRootSignDependencyList += !inTransientPropertySignature->string . inTransientName ;
end method ;

#----------------------------------------------------------------------------*

override method @transientLocalDependency analyze
  ??@lstring unused inTransientName
  ??@observablePropertyMap inLocalObservablePropertyMap
  ??@observablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet unused ioFileInclusionSet
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist unused ioRootSignDependencyList
:
#  @ebType mType ;
#  @bool mIsTransient ;
#  @string mPropertySignature ;
#  @bool mIsCollection ;
  [inLocalObservablePropertyMap searchKey
    !mMasterName
    ?@ebType masterType
    ?*
    ?@lstring masterPropertySignature
    ?@bool isCollection
  ] ;
  if mNamesCountOption & not isCollection then
      error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  elsif isCollection & not mNamesCountOption then
      error mMasterName: "to-many relationships requires the 'count' option" ;
  end if ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
#---
  ioDirectDependancyList += ![@transientDependencyFromSelfForImplementation new !masterType !mMasterName->string !mNamesCountOption] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientControllerDependency analyze
  ??@lstring unused inTransientName
  ??@observablePropertyMap inLocalObservablePropertyMap
  ??@observablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet unused ioFileInclusionSet
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist unused ioRootSignDependencyList
:
#--- Search controller in controller map
  [inLocalObservablePropertyMap searchKey
    !mControllerName
    ?@ebType type
    ?3*
  ] ;
  if type->mKind != [@typeKind controllerClassType] then
    error mControllerName : "'" . mControllerName . "' is not a controller" ;
  end if ;
#--- Search controller observable attribute map
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !type->mTypeName
    ?*
    ?@typeKind typeKind
    ?@observablePropertyMap controllerObservablePropertyMap
  ] ;
#--- Search controller observed attribute
  [controllerObservablePropertyMap searchKey
    !mMasterName
    ?@ebType masterType
    ?*
    ?@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
#---
  ioDirectDependancyList += ![@transientDependencyFromControllerForImplementation new !masterType !mControllerName->string !mMasterName->string] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootDependency analyze
  ??@lstring unused inTransientName
  ??@observablePropertyMap unused inLocalObservablePropertyMap
  ??@observablePropertyMap inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet unused ioFileInclusionSet
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist unused ioRootSignDependencyList
:
  [inRootObjectObservablePropertyMap searchKey
    !mMasterName
    ?@ebType masterType
    ?*
    ?@lstring masterDependencyKey
    ?@bool isCollection
  ] ;
#--- Has 'count' option ?
  if mNamesCountOption & not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  end if ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    !masterDependencyKey
    !inTransientPropertySignature
  ] ;
#---
  ioDirectDependancyList += ![@transientDependencyFromRootForImplementation new
    !masterType
    !mMasterName->string
    !mNamesCountOption
    ![masterDependencyKey identifierRepresentation]
 ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientPreferenceDependency analyze
  ??@lstring unused inTransientName
  ??@observablePropertyMap unused inLocalObservablePropertyMap
  ??@observablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@lstring inTransientPropertySignature
  ?!@fileInclusionSet ioFileInclusionSet
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@directDependancyList ioDirectDependancyList
  ?!@stringlist unused ioRootSignDependencyList
:
#--- Get preferences observables properties
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !mPreferencesName
    ?*
    ?@typeKind kind
    ?@observablePropertyMap observablePropertyMap
  ] ;
#--- Check
  if kind != [@typeKind preferencesType] then
    error mPreferencesName : "'" . mPreferencesName . "' is not a preference" ;
  end if ;
#---
  [observablePropertyMap searchKey
    !mMasterName
    ?@ebType masterType
    ?@bool isTransient
    ?@lstring masterPropertySignature
    ?*
  ] ;
#--- Add dependency arc
  [!?ioContextAnalysisStruct->mTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ] ;
#--- Add preference header
  ioFileInclusionSet->mImplementationFileInclusionSet += !mPreferencesName->string ;
#---
  ioDirectDependancyList += ![@transientDependencyFromPreferenceForImplementation new
    !masterType
    !mPreferencesName->string
    !mMasterName->string
    !isTransient
  ] ;
end method ;

##----------------------------------------------------------------------------*
#
#routine analyzeTransientProperties
#  ??@preferencesMap inPreferencesMap
#  ??@string inObervationDependencyPrefix
#  ??@transientList inTransientList
#  ??@observablePropertyMap inRootObjectObservablePropertyMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ??@string inRootEntityName
#  ??@controllerMap inControllerMap
#  ?!@observablePropertyMap ioSelfObjectObservablePropertyMap
#  ?!@fileInclusionSet ioFileInclusionSet
#  !@transientListForImplementation outTransientListForImplementation
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
#  outTransientListForImplementation := [@transientListForImplementation emptyList] ;
#  foreach inTransientList do
#    @easyBindingType type := [mType analyze !inContextAnalysisStruct] ;
#  #--- Define transient as a new node in dependency graph
#    const @lstring transientObservationKey [new
#      !inObervationDependencyPrefix . mTransientName
#      !mTransientName->location
#    ] ;
#    [!?ioTransientDependencyGraph addNode !transientObservationKey !transientObservationKey->string] ;
#  #--- Analyze dependencies
#    @directDependancyList directDependancyList [emptyList] ;
#    @stringlist rootSignDependencyList [emptyList] ;
#    foreach mDependencyList do
#      [mDependency analyze
#        !mTransientName
#        !ioSelfObjectObservablePropertyMap
#        !inPreferencesMap
#        !inControllerMap
#        !inRootObjectObservablePropertyMap
#        !inRootEntityName
#        !inObervationDependencyPrefix
#        !?ioFileInclusionSet
#        !?ioTransientDependencyGraph
#        !?directDependancyList
#        !?rootSignDependencyList
#      ] ;
#    end foreach ;
#  #--- Add transient to observable attribute map
#    [!?ioSelfObjectObservablePropertyMap insertKey
#      !mTransientName
#      !type
#      !true # is transient
#      !transientObservationKey->string
#    ] ;
#  #--- Add transient implementation
#    outTransientListForImplementation += !type ![mTransientName string] !directDependancyList !rootSignDependencyList ;
#  end foreach ;
#end routine ;

#----------------------------------------------------------------------------*

routine analyzeTransientProperties
  ??@transientList inTransientList
  ??@observablePropertyMap inRootObjectObservablePropertyMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ??@string inRootEntityName
  ??@observablePropertyMap inSelfObjectObservablePropertyMap
  ?!@fileInclusionSet ioFileInclusionSet
  !@transientListForImplementation outTransientListForImplementation
:
  outTransientListForImplementation := [@transientListForImplementation emptyList] ;
  foreach inTransientList do
    [inSelfObjectObservablePropertyMap searchKey
      !mTransientName
      ?@ebType type
      ?*
      ?@lstring transientPropertySignature
      ?*
    ] ;
  #--- Analyze dependencies
    @directDependancyList directDependancyList [emptyList] ;
    @stringlist rootSignDependencyList [emptyList] ;
    foreach mDependencyList do
      [mDependency analyze
        !mTransientName
        !inSelfObjectObservablePropertyMap
        !inRootObjectObservablePropertyMap
        !inRootEntityName
        !transientPropertySignature
        !?ioFileInclusionSet
        !?ioContextAnalysisStruct
        !?directDependancyList
        !?rootSignDependencyList
      ] ;
    end foreach ;
  #--- Add transient implementation
    outTransientListForImplementation += !type ![mTransientName string] !directDependancyList !rootSignDependencyList ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
