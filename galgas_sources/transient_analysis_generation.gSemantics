semantics transient_analysis_generation :
  import "abstractSyntaxTree.gSemantics" ;

#----------------------------------------------------------------------------*

list @attributeListForImplementation {
  @easyBindingType mType ;
  @string mPropertyName ;
  @string mDefaultValueAsObjectiveCObject ;
  @string mDirectDefaultValue ;
}

#----------------------------------------------------------------------------*

abstract class @abstractBindingForGeneration {
}

#----------------------------------------------------------------------------*

list @outletBindingListForGeneration {
  @abstractBindingForGeneration mBinding ;
}

#----------------------------------------------------------------------------*

list @outletGenerationList {
  @string mOutletType ;
  @generationKind mGenerationKind ;
  @string mOutletName ;
  @outletBindingListForGeneration mOutletBindingList ;
}

#----------------------------------------------------------------------------*

map @preferencesMap {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @observablePropertyMap mObservablePropertyMap ;
  @stringset mImplementationFileInclusionSet ;
  insert insertKey error message "the '%K' preference is already declared" ;
  search searchKey error message "the '%K' preference is not declared" ;
}

#----------------------------------------------------------------------------*

map @observablePropertyMap {
  @easyBindingType mType ;
  @bool mIsTransient ;
  @string mPropertySignature ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#----------------------------------------------------------------------------*

map @observableObjectMap {
  @string mObservableObjectOCName ;
  @string mObservableObjectTypeOCName ;
  @string mIncludeFileName ; # Empty string if no file to include
  @observablePropertyMap mObservableProperties ;
  insert insertKey error message "the '%K' observable object is already declared" ;
  search searchKey error message "the '%K' observable object is not declared" ;
}

#----------------------------------------------------------------------------*

map @actionMap {
  insert insertKey error message "there is already a '%K' action" ;
  search searchKey error message "the '%K' action is not defined" ;
}

#----------------------------------------------------------------------------*

map @controllerMap {
  @string mControllerClassName ;
  @string mControlledClassOrEntityName ;
  @outletBindingListForGeneration mControllerBindingList ;
  @actionMap mActionMap ;
  @observablePropertyMap mObservableAttributeMap ;
  insert insertKey error message "the '%K' controller is already declared" ;
  search searchKey error message "the '%K' controller is not declared" ;
}

#----------------------------------------------------------------------------*

abstract class @abstractTransientDependencyForImplementation {
}

#----------------------------------------------------------------------------*

class @transientDependencyFromSelfForImplementation extends @abstractTransientDependencyForImplementation {
  @string mMasterAttributeName ;
  @easyBindingType mMasterAttributeType ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromControllerForImplementation extends @abstractTransientDependencyForImplementation {
  @string mControllerName ;
  @string mMasterAttributeName ;
  @easyBindingType mMasterAttributeType ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromRootForImplementation extends @abstractTransientDependencyForImplementation {
  @string mMasterAttributeName ;
  @easyBindingType mMasterAttributeType ;
  @bool mNamesCountOption ;
  @string mTriggerRoutineName ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromPreferenceForImplementation extends @abstractTransientDependencyForImplementation {
  @string mPreferenceName ;
  @string mMasterAttributeName ;
  @bool mMasterIsTransient ;
  @easyBindingType mMasterAttributeType ;
}

#----------------------------------------------------------------------------*

abstract reader @abstractTransientDependencyForImplementation generateFormalArgument
  ->@string outResult
;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromSelfForImplementation generateFormalArgument
  ->@string outResult
:
  outResult := [mMasterAttributeType ocTypeName] . " in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromControllerForImplementation generateFormalArgument
  ->@string outResult
:
  outResult := [mMasterAttributeType ocTypeName] . " in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromRootForImplementation generateFormalArgument
  ->@string outResult
:
  if mNamesCountOption then
    outResult := "const NSUInteger in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] . "_count" ;
  else
    outResult := [mMasterAttributeType ocTypeName] . " in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromPreferenceForImplementation generateFormalArgument
  ->@string outResult
:
  outResult := [mMasterAttributeType ocTypeName] . " in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] ;
end reader ;

#----------------------------------------------------------------------------*

abstract reader @abstractTransientDependencyForImplementation generateMasterAttributeCall
  ->@string outResult
;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromSelfForImplementation generateMasterAttributeCall
  ->@string outResult
:
  outResult := "self." . mMasterAttributeName ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromRootForImplementation generateMasterAttributeCall
  ->@string outResult
:
  outResult := "mRootObject." . mMasterAttributeName ;
  if mNamesCountOption then
    outResult .= ".count" ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromControllerForImplementation generateMasterAttributeCall
  ->@string outResult
:
  outResult := mControllerName . "." . mMasterAttributeName ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromPreferenceForImplementation generateMasterAttributeCall
  ->@string outResult
:
  outResult := "g_" . mPreferenceName . "." . mMasterAttributeName ;
end reader ;

#----------------------------------------------------------------------------*

list @directDependancyList {
  @abstractTransientDependencyForImplementation mDependency ;
}

#----------------------------------------------------------------------------*

list @transientListForImplementation {
  @easyBindingType mTransientType ;
  @string mTransientName ;
  @directDependancyList mDependencyList ;
}

#----------------------------------------------------------------------------*

graph @transientDependencyGraph (@stringlist) {
  insert addNode error message "the '%K' transient is already declared at %L" ;
}

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependency analyze
  ??@lstring inTransientName
  ??@observablePropertyMap inLocalObservablePropertyMap
  ??@preferencesMap inPreferencesMap
  ??@controllerMap inControllerMap
  ??@observablePropertyMap inRootObjectObservablePropertyMap
  ??@string inRootEntityName
  ??@string inObervationDependencyPrefix
  ?!@stringset ioImplementationFileInclusionSet
  ?!@transientDependencyGraph ioTransientDependencyGraph
  !@abstractTransientDependencyForImplementation outImplementation
;

#----------------------------------------------------------------------------*

override method @transientLocalDependency analyze
  ??@lstring inTransientName
  ??@observablePropertyMap inLocalObservablePropertyMap
  ??@preferencesMap unused inPreferencesMap
  ??@controllerMap unused inControllerMap
  ??@observablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@string inObervationDependencyPrefix
  ?!@stringset unused ioImplementationFileInclusionSet
  ?!@transientDependencyGraph ioTransientDependencyGraph
  !@abstractTransientDependencyForImplementation outImplementation
:
  [inLocalObservablePropertyMap searchKey
    !mMasterName
    ?@easyBindingType masterType
    ?*
    ?@string masterPropertySignature
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addArc
    ![@lstring new !masterPropertySignature !mMasterName->location]
    ![@lstring new !inObervationDependencyPrefix . inTransientName !inTransientName->location]
  ] ;
#---
  outImplementation := [@transientDependencyFromSelfForImplementation new !mMasterName->string !masterType] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientControllerDependency analyze
  ??@lstring inTransientName
  ??@observablePropertyMap unused inLocalObservablePropertyMap
  ??@preferencesMap unused inPreferencesMap
  ??@controllerMap inControllerMap
  ??@observablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@string inObervationDependencyPrefix
  ?!@stringset unused ioImplementationFileInclusionSet
  ?!@transientDependencyGraph ioTransientDependencyGraph
  !@abstractTransientDependencyForImplementation outImplementation
:
#--- Search controller in controller map
  [inControllerMap searchKey
    !mControllerName
    ?@string controllerClassName
    ?3*
    ?@observablePropertyMap controllerObservablePropertyMap
  ] ;
#--- Search controller observed attribute
  [controllerObservablePropertyMap searchKey
    !mMasterName
    ?@easyBindingType masterType
    ?*
    ?*
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addArc
    ![@lstring new !"controller." . controllerClassName . "." . mMasterName !mMasterName->location]
    ![@lstring new !inObervationDependencyPrefix . inTransientName !inTransientName->location]
  ] ;
#---
  outImplementation := [@transientDependencyFromControllerForImplementation new !mControllerName->string !mMasterName->string !masterType] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientRootDependency analyze
  ??@lstring inTransientName
  ??@observablePropertyMap unused inLocalObservablePropertyMap
  ??@preferencesMap unused inPreferencesMap
  ??@controllerMap unused inControllerMap
  ??@observablePropertyMap inRootObjectObservablePropertyMap
  ??@string inRootEntityName
  ??@string inObervationDependencyPrefix
  ?!@stringset unused ioImplementationFileInclusionSet
  ?!@transientDependencyGraph ioTransientDependencyGraph
  !@abstractTransientDependencyForImplementation outImplementation
:
  [inRootObjectObservablePropertyMap searchKey
    !mMasterName
    ?@easyBindingType masterType
    ?*
    ?@string masterDependencyKey
  ] ;
#--- Has 'count' option ?
  if mNamesCountOption & (masterType != [@easyBindingType toManyEntitiesType]) then
    error mMasterName: "the 'count' option is only allowed for to-many relationships" ;
  end if ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addArc
    ![@lstring new !"entity." . inRootEntityName . "." . mMasterName !mMasterName->location]
    ![@lstring new !inObervationDependencyPrefix . inTransientName !inTransientName->location]
  ] ;
#---
  outImplementation := [@transientDependencyFromRootForImplementation new
    !mMasterName->string
    !masterType
    !mNamesCountOption
    ![masterDependencyKey identifierRepresentation]
 ] ;
end method ;

#----------------------------------------------------------------------------*

override method @transientPreferenceDependency analyze
  ??@lstring inTransientName
  ??@observablePropertyMap unused inLocalObservablePropertyMap
  ??@preferencesMap inPreferencesMap
  ??@controllerMap unused inControllerMap
  ??@observablePropertyMap unused inRootObjectObservablePropertyMap
  ??@string unused inRootEntityName
  ??@string inObervationDependencyPrefix
  ?!@stringset ioImplementationFileInclusionSet
  ?!@transientDependencyGraph ioTransientDependencyGraph
  !@abstractTransientDependencyForImplementation outImplementation
:
  [inPreferencesMap searchKey !mPreferencesName ?4* ?@observablePropertyMap observablePropertyMap ?*] ;
  [observablePropertyMap searchKey
    !mMasterName
    ?@easyBindingType masterType
    ?@bool isTransient
    ?*
  ] ;
#--- Add dependency arc
  [!?ioTransientDependencyGraph addArc
    ![@lstring new !"preference." . mPreferencesName . "." . mMasterName !mMasterName->location]
    ![@lstring new !inObervationDependencyPrefix . inTransientName !inTransientName->location]
  ] ;
#--- Add preference header
  ioImplementationFileInclusionSet += !mPreferencesName->string ;
#---
  outImplementation := [@transientDependencyFromPreferenceForImplementation new
    !mPreferencesName->string
    !mMasterName->string
    !isTransient
    !masterType
  ] ;
end method ;

#----------------------------------------------------------------------------*

routine analyzeTransientProperties
  ??@preferencesMap inPreferencesMap
  ??@string inObervationDependencyPrefix
  ??@transientList inTransientList
  ??@observablePropertyMap inRootObjectObservablePropertyMap
  ??@string inRootEntityName
  ??@controllerMap inControllerMap
  ?!@observablePropertyMap ioSelfObjectObservablePropertyMap
  ?!@stringset ioImplementationFileInclusionSet
  !@transientListForImplementation outTransientListForImplementation
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outTransientListForImplementation := [@transientListForImplementation emptyList] ;
  foreach inTransientList do
  #--- Define transient as a new node in dependency graph
    const @lstring transientObservationKey [new
      !inObervationDependencyPrefix . mTransientName
      !mTransientName->location
    ] ;
    [!?ioTransientDependencyGraph addNode !transientObservationKey !transientObservationKey->string] ;
  #--- Analyze dependencies
    @directDependancyList directDependancyList [emptyList] ;
    foreach mDependencyList do
      [mDependency analyze
        !mTransientName
        !ioSelfObjectObservablePropertyMap
        !inPreferencesMap
        !inControllerMap
        !inRootObjectObservablePropertyMap
        !inRootEntityName
        !inObervationDependencyPrefix
        !?ioImplementationFileInclusionSet
        !?ioTransientDependencyGraph
        ?@abstractTransientDependencyForImplementation implementation
      ] ;
      directDependancyList += !implementation ;
    end foreach ;
  #--- Add transient to observable attribute map
    [!?ioSelfObjectObservablePropertyMap insertKey
      !mTransientName
      !mType
      !true # is transient
      !transientObservationKey->string
    ] ;
  #--- Add transient implementation
    outTransientListForImplementation += !mType ![mTransientName string] !directDependancyList ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

function generateTransientFunctionDeclarations
  ??@string inKindName
  ??@transientListForImplementation inTransientListForImplementation
  ->@string outResult
:
  outResult :=
    "//----------------------------------------------------------------------------*\n"
  . "//   T R A N S I E N T    P R O P E R T I E S                                 *\n"
  . "//----------------------------------------------------------------------------*\n\n" ;

  foreach inTransientListForImplementation do
    outResult .= [mTransientType ocTypeName] . " compute_" . inKindName . "_" . mTransientName . " (\n" ;
    foreach mDependencyList
    do
      outResult .= "    " . [mDependency generateFormalArgument] ;
    between
      outResult .= ",\n" ;
    end foreach ;
    outResult .= ") ;\n\n" ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

function generateTransientCacheRoutine
  ??@string inKindName 
  ??@transientListForImplementation inTransientListForImplementation
  ->@string outResult
:
  outResult := "" ;
  foreach inTransientListForImplementation do
    outResult .=
    "//----------------------------------------------------------------------------*\n"
    "// Cache routine of '" . mTransientName . "' transient     *\n"
    "//----------------------------------------------------------------------------*\n\n"   
    "- (" . [mTransientType ocTypeName] . ") " . mTransientName . " {\n"
    "  if (! " . mTransientName . "__computed) {\n"
    "    " . mTransientName . "__cache = compute_" . inKindName . "_" . mTransientName . " (" ;
    foreach mDependencyList
    do outResult .= [mDependency generateMasterAttributeCall] ;
    between outResult .= ", " ;
    end foreach ;
    outResult .= ") ;\n"
    "    " . mTransientName . "__computed = YES ;\n"
    "  }\n"
    "  return " . mTransientName . "__cache" ;
    if [mTransientType copyOnAssign] then outResult .= ".copy" ; end if ;
    outResult .= " ;\n"
    "}\n\n" ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

listmap @triggeredKeysForSelfObject (@stringlist) ;

#----------------------------------------------------------------------------*

listmap @triggeredKeysForOtherObjects (@2stringlist) ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
:
  if [ioMasterAttributeSet hasKey !mMasterAttributeName] then
    ioMasterAttributeSet += !inTransientName ;
    ioRegisteredTransientSet += !inTransientName ;
    ioContinue := true ;
    ioResult .=
    "  //--- Trigger '" . inTransientName . " transient'\n"
    "    if (" . inTransientName . "__computed) {\n"
    "      " . inTransientName . "__computed = NO ;\n"
    "      [PMTransientDependancyManager\n"
    "        enterTriggerForObject:self\n"
    "        transientIndex:" . [inPrefix . "." . inClassName . "." . inTransientName identifierRepresentation] . "\n"
    "      ] ;\n"
    "    }\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
:
  if [ioMasterAttributeSet hasKey !mMasterAttributeName] then
    ioMasterAttributeSet += !inTransientName ;
    ioRegisteredTransientSet += !inTransientName ;
    ioContinue := true ;
    ioResult .=
    "  //--- Trigger '" . inTransientName . " transient'\n"
    "    if (" . inTransientName . "__computed) {\n"
    "      " . inTransientName . "__computed = NO ;\n"
    "      [PMTransientDependancyManager\n"
    "        enterTriggerForObject:self\n"
    "        transientIndex:" . [inPrefix . "." . inClassName . "." . inTransientName identifierRepresentation] . "\n"
    "      ] ;\n"
    "    }\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateTransientTriggerFromSelfAttribute
  ??@string unused inPrefix # entity, class, preference
  ??@string unused inClassName
  ??@string unused inTransientName
  ?!@stringset unused ioMasterAttributeSet
  ?!@stringset unused ioRegisteredTransientSet
  ?!@bool unused ioContinue
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateTransientTriggerFromSelfAttribute
  ??@string unused inPrefix # entity, class, preference
  ??@string unused inClassName
  ??@string unused inTransientName
  ?!@stringset unused ioMasterAttributeSet
  ?!@stringset unused ioRegisteredTransientSet
  ?!@bool unused ioContinue
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

function generateTransientTriggering
  ??@string inPropertyName
  ??@string inClassName
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inPrefix # entity, class, preference
  ->@string outResult
:
  outResult := "" ;
#----
  @stringset masterSet [setWithString !inPropertyName] ;
  @stringset registeredTransientSet [emptySet] ;
  @bool looping := true ;
  loop [inTransientListForImplementation length] + 1 while looping do
    looping := false ;
    foreach inTransientListForImplementation do
      foreach mDependencyList do
        if (not [registeredTransientSet hasKey !mTransientName]) then
          [mDependency generateTransientTriggerFromSelfAttribute
            !inPrefix
            !inClassName
            !mTransientName
            !?masterSet
            !?registeredTransientSet
            !?looping
            !?outResult
          ] ;
        end if ;
      end foreach ;
    end foreach ;
  end loop ;
end function ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateAddObserverForTransient
  ??@string inLeadingSpaces
  ?!@string ioResult
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateAddObserverForTransient
  ??@string unused inLeadingSpaces
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateAddObserverForTransient
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  ioResult .= inLeadingSpaces .
  "  [" . mControllerName . "\n"
  "    addObserver:self\n"
  "    forKeyPath:@\"" . mMasterAttributeName . "\"\n"
  "    options:0\n"
  "    context:NULL\n"
  "  ] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateAddObserverForTransient
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  if not mMasterIsTransient then
    ioResult .= inLeadingSpaces . "  [g_" . mPreferenceName . " addObserverOf_" . mMasterAttributeName . ":self] ;\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateAddObserverForTransient
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  ioResult .= inLeadingSpaces . "  [mRootObject addObserverOf_" . mMasterAttributeName . ":self] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

function generateAddObserverForTransients
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inLeadingSpaces
  ->@string outResult
:
  outResult := "" ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency generateAddObserverForTransient
        !inLeadingSpaces
        !?outResult
      ] ;
    end foreach ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateRemoveObserverForTransient
  ?!@string ioResult
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateRemoveObserverForTransient
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateRemoveObserverForTransient
  ?!@string ioResult
:
  ioResult .=
  "  [" . mControllerName . "\n"
  "    removeObserver:self\n"
  "    forKeyPath:@\"" . mMasterAttributeName . "\"\n"
  "  ] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateRemoveObserverForTransient
  ?!@string ioResult
:
  if not mMasterIsTransient then
    ioResult .= "  [g_" . mPreferenceName . " removeObserverOf_" . mMasterAttributeName . ":self] ;\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateRemoveObserverForTransient
  ?!@string ioResult
:
  ioResult .= "  [mRootObject removeObserverOf_" . mMasterAttributeName . ":self] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

function generateRemoveObserverForTransients
  ??@transientListForImplementation inTransientListForImplementation
  ->@string outResult
:
  outResult := "" ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency generateRemoveObserverForTransient
        !?outResult
      ] ;
    end foreach ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

listmap @observerListMap (@stringlist) ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateObserverRoutineForTransient
  ??@string inTransientName
  ?!@observerListMap didChangeTriggeredRoutineListMap
  ?!@observerListMap ioObserveForKeyPathRoutineElementListMap
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateObserverRoutineForTransient
  ??@string unused inTransientName
  ?!@observerListMap unused didChangeTriggeredRoutineListMap
  ?!@observerListMap unused ioObserveForKeyPathRoutineElementListMap
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateObserverRoutineForTransient
  ??@string inTransientName
  ?!@observerListMap unused didChangeTriggeredRoutineListMap
  ?!@observerListMap ioObserveForKeyPathRoutineElementListMap
:
  ioObserveForKeyPathRoutineElementListMap += !mControllerName . "." . mMasterAttributeName !inTransientName ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateObserverRoutineForTransient
  ??@string inTransientName
  ?!@observerListMap didChangeTriggeredRoutineListMap
  ?!@observerListMap unused ioObserveForKeyPathRoutineElementListMap
:
  if not mMasterIsTransient then
    didChangeTriggeredRoutineListMap += !["preference." . mPreferenceName . "." . mMasterAttributeName identifierRepresentation] !inTransientName ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateObserverRoutineForTransient
  ??@string inTransientName
  ?!@observerListMap didChangeTriggeredRoutineListMap
  ?!@observerListMap unused ioObserveForKeyPathRoutineElementListMap
:
  didChangeTriggeredRoutineListMap += !mTriggerRoutineName !inTransientName ;
end method ;

#----------------------------------------------------------------------------*

function generateObserverRoutinesForTransient
  ??@string inKindName 
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inPrefix # entity, class, preference
  ->@string outResult
:
  outResult := "" ;
  @observerListMap didChangeTriggeredRoutineListMap [emptyMap] ;
  @observerListMap observeForKeyPathRoutineElementListMap [emptyMap] ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency generateObserverRoutineForTransient
        !mTransientName
        !?didChangeTriggeredRoutineListMap
        !?observeForKeyPathRoutineElementListMap
      ] ;
    end foreach ;
  end foreach ;
#------------------------ Generate xxx_xxx_didChange methods
  const @string fullPrefix := inPrefix . "." . inKindName . "." ;
  foreach didChangeTriggeredRoutineListMap do
    outResult .=
    "//----------------------------------------------------------------------------*\n"
    "//  " . key . "_didChange   *\n"
    "//----------------------------------------------------------------------------*\n\n"
    "- (void) " . key . "_didChange {\n" ;
    foreach mList do
    outResult .=
      "  //--- Trigger '" . mValue . " transient'\n"
      "  if (" . mValue . "__computed) {\n"
      "    " . mValue . "__computed = NO ;\n"
      "    [PMTransientDependancyManager\n"
      "      enterTriggerForObject:self\n"
      "      transientIndex:" . [fullPrefix . mValue identifierRepresentation] . "\n"
      "    ] ;\n"
      "  }\n" ;
    end foreach ;
    outResult .= "}\n\n" ;
  end foreach ;
#------------------------ Generate observeValueForKeyPath method
  foreach observeForKeyPathRoutineElementListMap
  before
    outResult .=
    "//----------------------------------------------------------------------------*\n"
    "//  observeValueForKeyPath:ofObject:change:context:                           *\n"
    "//----------------------------------------------------------------------------*\n\n"
    "- (void) observeValueForKeyPath: (NSString *) inKeyPath\n"
    "         ofObject: (id) inObject\n"
    "         change: (NSDictionary *) inChange\n"
    "         context: (void *) inContext {\n"
    " " ;
  do
    outResult .=
    " if ((inObject == " . [key stringByDeletingPathExtension] .") && [inKeyPath isEqualToString:@\"" . [key pathExtension] . "\"]) {\n" ;
    foreach mList do
      outResult .=
      "  //--- Trigger '" . mValue . " transient'\n"
      "    if (" . mValue . "__computed) {\n"
      "      " . mValue . "__computed = NO ;\n"
      "      [PMTransientDependancyManager\n"
      "        enterTriggerForObject:self\n"
      "        transientIndex:" . [fullPrefix . mValue identifierRepresentation] . "\n"
      "      ] ;\n"
      "    }\n" ;
    end foreach ;
    outResult .= "  }else" ;
  after
    outResult .=
    "{\n"
    "    [super\n"
    "     observeValueForKeyPath:inKeyPath\n"
    "     ofObject:inObject\n"
    "     change:inChange\n"
    "     context:inContext\n"
    "    ] ;\n"
    "  }\n"
    "}\n\n" ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

local filewrapper transientManager in "../generation-templates/transient-dependency-manager" {
}{
}{
  template managerDeclaration "PMTransientDependancyManager.h.gTemplate"
    ?@string GRAPH_STRING
    ?@string TRANSIENT_LIST_STRING
    ?@string TRANSIENT_INDEXES
    ?@uint TRANSIENT_COUNT
  ;
  
  template managerImplementation "PMTransientDependancyManager.m.gTemplate"
    ?@string TRANSIENT_LIST
  ;
}

#----------------------------------------------------------------------------*

routine generateTransientDependencyFiles
  ??@2stringlist inTransientDependencyArcList
  ??@string inSourceDirectoryPath
  ??@stringlist inSortedTransientOrderedList
:
#--- Output dependency order definition file
  @string graphString := "" ;
  @stringset dependentSet [emptySet] ;
  foreach inTransientDependencyArcList do
    graphString .= "// " . mValue0 . " -> " . mValue1 . "\n" ;
    dependentSet += !mValue1 ;
  end foreach ;
  @string transientOrderedList := "" ;
  foreach \down inSortedTransientOrderedList do
    transientOrderedList .= "// " . mValue . "\n" ;
  end foreach ;
  @string transientIndexesString := "" ;
  @string transientList := "" ;
  @uint idx := 0 ;
  foreach \down inSortedTransientOrderedList do
    if [dependentSet hasKey !mValue] then
      transientIndexesString .= "#define " . [mValue identifierRepresentation] . " (" . idx . ")\n" ;
      transientList .= "      @" . [[mValue pathExtension] utf8Representation] . ", // " . mValue . "\n" ;
      idx ++ ;
    end if ;
  end foreach ;
  const @uint transientCount := idx ;
#--- Header
  @string s := [filewrapper transientManager.managerDeclaration
    !graphString
    !transientOrderedList
    !transientIndexesString
    !transientCount
  ] ;
  [@string generateFileWithPattern
    !inSourceDirectoryPath
    !"PMTransientDependancyManager.h"
    !"//"
    !"\n\n" # Defaut user zone1
    !s
    !"\n\n" # Defaut user zone2
    !""
  ] ;
#--- Implementation
  s := [filewrapper transientManager.managerImplementation
    !transientList
  ] ;
  [@string generateFileWithPattern
    !inSourceDirectoryPath
    !"PMTransientDependancyManager.m"
    !"//"
    !"\n\n" # Defaut user zone1
    !s
    !"\n\n" # Defaut user zone2
    !""
  ] ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
