semantics nibClassAnalysis :
  import "transientAnalysis.gSemantics" ;
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @nibClassDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#------------------------------------- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  foreach mControllerList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mControllerClassName
      ?*
    ] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !mClassName
    ![@ebType new !mClassName ![@typeKind nibClassType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @nibClassDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  @observablePropertyMap observablePropertyMap [emptyMap] ;
#---------------------------------- Analyze attributes
  buildObservablePropertyMap
    !mAttributeList
    !mArrayList
    !mTransientList
    !mControllerList
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"nibclass." . mClassName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mClassName
    !mUserDefined
    ![@typeKind nibClassType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @nibClassDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#------------------------------- Get Observable property map
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
     !mClassName
     ?2*
     ?@observablePropertyMap selfObservablePropertyMap
   ] ;
#-----
  @propertyArrayMap allArrayPropertyForImplementation [emptyMap] ;
  @propertyArrayMap currentArrayPropertyForImplementation [emptyMap] ;
  @fileInclusionSet fileInclusionSet [default] ;
#------------------------------------- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#------------------------------- Analyze transient dependancy
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    !mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !?ioContextAnalysisStruct
    !"" # No Root entity
    !selfObservablePropertyMap
    !?fileInclusionSet
    ?transientListForImplementation
  ;
#------------------------------- Analyze attributes
  @attributeListForImplementation unusedAttributList [emptyList] ;
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?unusedAttributList
  ;
#------------------------------------- Analyze arraies
  foreach mArrayList do
    [inUnifiedTypeMap searchKey
      !mElementClassName
      ?@ebType type
      ?*
    ] ;
    if type->mKind != [@typeKind classType] then
      error mClassName : "'" . mClassName . "' is not a class" ;    
    end if ;
    [!?currentArrayPropertyForImplementation insertKey
      !mArrayName
      !type
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  @controllerMap controllerMap [emptyMap] ;
  foreach mControllerList do
    [ioContextAnalysisStruct->mControllerClassMap searchKey
      !mControllerClassName
      ?@controllerKind controllerKind
      ?*
      ?@outletClassBindingMap controllerClassBindingMap
      ?@actionMap controllerActionMap
      ?@observablePropertyMap controllerObservablePropertyMap
      ?@outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
    ] ;
  #---
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    @string controllerObjectClassName ;
    switch controllerKind
    when simpleController :
      controllerObjectClassName := "" ;
    when objectController :
      error mControlledObjectName
      :"objectController is not currently handled in nib class"
      :controllerObjectClassName;
    when entityController :
      error mControlledObjectName
      :"entityController is not currently handled in nib class"
      :controllerObjectClassName;
    when entityArrayController :
      error mControlledObjectName
      :"in nib class, use an arrayController, as NSArrayController"
      :controllerObjectClassName;
    when arrayController :
      if mIsRootObject->bool then
        error mIsRootObject
        : "only 'self' is allowed here"
        ;
      end if ;
      [currentArrayPropertyForImplementation searchKey
        !mControlledObjectName
        ?@ebType controlledObjectType
      ] ;
      controllerObjectClassName := controlledObjectType->mTypeName->string ;
      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
        !controlledObjectType->mTypeName
        ?*
        ?@typeKind kind
        ?@observablePropertyMap classObservablePropertyMap
      ] ;
      if kind != [@typeKind classType] then
        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
      end if ;
      checkBindingOptions
        !ioContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@bindingOptionListForGeneration controlledObjectBindingOptionListForGeneration
        !?fileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        ![@ebType new !["<unused4>" nowhere] ![@typeKind classType]]
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self"
        !mControlledObjectName->string
        !false # Non optional property, no '?'
        !controlledObjectBindingOptionListForGeneration
      ] ;
    when treeController :
      if mIsRootObject->bool then
        error mIsRootObject
        : "only 'self' is allowed here"
        ;
      end if ;
      [currentArrayPropertyForImplementation searchKey
        !mControlledObjectName
        ?@ebType controlledObjectType
      ] ;
      controllerObjectClassName := controlledObjectType->mTypeName->string ;
      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
        !controlledObjectType->mTypeName
        ?*
        ?@typeKind kind
        ?@observablePropertyMap classObservablePropertyMap
      ] ;
      if kind != [@typeKind classType] then
        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
      end if ;
      checkBindingOptions
        !ioContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@bindingOptionListForGeneration controlledObjectBindingOptionListForGeneration
        !?fileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        ![@ebType new !["<unused6>" nowhere] ![@typeKind classType]]
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self"
        !mControlledObjectName->string
        !false # Non optional property, no '?'
        !controlledObjectBindingOptionListForGeneration
      ] ;
    #--- Check "childrenKeyPath"
      [classObservablePropertyMap searchKey
        !mChildRelationshipName
        ??@ebType type
        ?* #?@bool isTransient
        ?* #?@lstring propertySignature
        ??@bool isCollection
      ] ;
      if (not isCollection) | (type->mKind != [@typeKind classType]) | (type->mTypeName->string != controlledObjectType->mTypeName->string) then
        error mChildRelationshipName: "this relationship is used as 'childrenKeyPath' and should be an '" . controlledObjectType->mTypeName . "' array" ;
      end if ;
      bindingListForGeneration += ![@treeControllerForGeneration new
        !mChildRelationshipName->string
      ] ;
    end switch ;
    foreach mControllerBindingList do
      [mBinding analyzeOutletBinding
        ![@observablePropertyMap emptyMap] # No root entity observable Map
        !selfObservablePropertyMap
        !controllerClassBindingMap
        !controllerMap
        !actionMap
        !false
        !ioContextAnalysisStruct
        !?bindingListForGeneration
        !?fileInclusionSet
      ] ;
    end foreach ;
    [!?controllerMap insertKey
      !mControllerName
      !mControllerClassName->string
      ![@lstring new !controllerObjectClassName !here]
      !false # Is not an entity : it is a class
      !bindingListForGeneration
      !controllerActionMap
      !controllerObservablePropertyMap
    ] ;
  end foreach ;
#------------------------------------- Analyze outlets
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach mOutletDeclarationList do
    [ioContextAnalysisStruct->mOutletClassMap searchKey
      !mOutletType
      ?@generationKind generationKind
      ?2*
      ?@bool implementsDeallocProtocol
      ?@outletClassBindingMap outletClassBindingMap
      ?*
      ?@bool hasTableValueBinding
    ] ;
    if generationKind != [@generationKind noGeneration] then
      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
    end if ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        ![@observablePropertyMap emptyMap] # No root
        !selfObservablePropertyMap
        !outletClassBindingMap
        !controllerMap
        !actionMap
        !hasTableValueBinding
        !ioContextAnalysisStruct
        !?outletBindingList
        !?fileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList +=
      ![mOutletType string]
      ![mOutletName string]
      !outletBindingList
      !implementsDeallocProtocol
    ;
  end foreach ;
#-------
  ioGenerationList += ![@nibClassTypeGeneration new
    !mClassName->string
    !attributeListForImplementation
    !transientListForImplementation
    !outletGenerationList
    !mActionDeclarationList
    !selfObservablePropertyMap
    !fileInclusionSet
    !controllerMap
    !currentArrayPropertyForImplementation
  ] ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
