semantics nibClassAnalysis :
  import "transientAnalysis.gSemantics" ;
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @nibClassDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#------------------------------------- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  foreach mControllerList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mControllerClassName
      ?*
    ] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !mClassName
    ![@ebType new !mClassName ![@typeKind nibClassType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @nibClassDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  @observablePropertyMap observablePropertyMap [emptyMap] ;
#---------------------------------- Analyze attributes
  buildObservablePropertyMap
    !mAttributeList
    !mArrayList
    !mTransientList
    !mControllerList
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"nibclass." . mClassName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mClassName
    ![@typeKind nibClassType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @nibClassDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#------------------------------- Get Observable property map
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
     !mClassName
     ?*
     ?@observablePropertyMap selfObservablePropertyMap
   ] ;
#-----
  @propertyArrayMap allArrayPropertyForImplementation [emptyMap] ;
  @propertyArrayMap currentArrayPropertyForImplementation [emptyMap] ;
  @fileInclusionSet fileInclusionSet [default] ;
#------------------------------------- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#------------------------------- Analyze transient dependancy
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    !mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !?ioContextAnalysisStruct
    !"" # No Root entity
    !selfObservablePropertyMap
    !?fileInclusionSet
    ?transientListForImplementation
  ;
#------------------------------- Analyze attributes
  @attributeListForImplementation unusedAttributList [emptyList] ;
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?unusedAttributList
  ;
#------------------------------------- Analyze arraies
  foreach mArrayList do
    [inUnifiedTypeMap searchKey
      !mElementClassName
      ?@ebType type
      ?*
    ] ;
    if type->mKind != [@typeKind classType] then
      error mClassName : "'" . mClassName . "' is not a class" ;    
    end if ;
    [!?currentArrayPropertyForImplementation insertKey
      !mArrayName
      !type
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  @controllerMap controllerMap [emptyMap] ;
  foreach mControllerList do
    [ioContextAnalysisStruct->mControllerClassMap searchKey
      !mControllerClassName
      ?@controllerKind controllerKind
      ?*
      ?@outletClassBindingMap controllerClassBindingMap
      ?@actionMap controllerActionMap
      ?@observablePropertyMap controllerObservablePropertyMap
      ?@outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
    ] ;
  #---
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    @string controllerObjectClassName ;
    switch controllerKind
    when simpleController :
      controllerObjectClassName := "" ;
    when objectController :
      error mControlledObjectName
      :"objectController is not currently handled in nib class"
      :controllerObjectClassName;
    when entityController :
      error mControlledObjectName
      :"entityController is not currently handled in nib class"
      :controllerObjectClassName;
    when entityArrayController :
      error mControlledObjectName
      :"in nib class, use an arrayController, as NSArrayController"
      :controllerObjectClassName;
    when arrayController :
      if mIsRootObject->bool then
        error mIsRootObject
        : "only 'self' is allowed here"
        ;
      end if ;
      [currentArrayPropertyForImplementation searchKey
        !mControlledObjectName
        ?@ebType controlledObjectType
      ] ;
      controllerObjectClassName := controlledObjectType->mTypeName->string ;
      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
        !controlledObjectType->mTypeName
        ?@typeKind kind
        ?@observablePropertyMap classObservablePropertyMap
      ] ;
      if kind != [@typeKind classType] then
        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
      end if ;
      checkBindingOptions
        !ioContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@2stringlist controlledObjectBindingOptionListForGeneration
        !?fileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self"
        !mControlledObjectName->string
        !controlledObjectBindingOptionListForGeneration
      ] ;
    when treeController :
      if mIsRootObject->bool then
        error mIsRootObject
        : "only 'self' is allowed here"
        ;
      end if ;
      [currentArrayPropertyForImplementation searchKey
        !mControlledObjectName
        ?@ebType controlledObjectType
      ] ;
      controllerObjectClassName := controlledObjectType->mTypeName->string ;
      [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
        !controlledObjectType->mTypeName
        ?@typeKind kind
        ?@observablePropertyMap classObservablePropertyMap
      ] ;
      if kind != [@typeKind classType] then
        error mControlledObjectName : "'" . mControlledObjectName . "' is not a class" ;
      end if ;
      checkBindingOptions
        !ioContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@2stringlist controlledObjectBindingOptionListForGeneration
        !?fileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self"
        !mControlledObjectName->string
        !controlledObjectBindingOptionListForGeneration
      ] ;
    #--- Check "childrenKeyPath"
      [classObservablePropertyMap searchKey
        !mChildRelationshipName
        ??@ebType type
        ?* #?@bool isTransient
        ?* #?@lstring propertySignature
        ??@bool isCollection
      ] ;
      if (not isCollection) | (type->mKind != [@typeKind classType]) | (type->mTypeName->string != controlledObjectType->mTypeName->string) then
        error mChildRelationshipName: "this relationship is used as 'childrenKeyPath' and should be an '" . controlledObjectType->mTypeName . "' array" ;
      end if ;
      bindingListForGeneration += ![@treeControllerForGeneration new
        !mChildRelationshipName->string
      ] ;
    end switch ;
    foreach mControllerBindingList do
      [mBinding analyzeOutletBinding
        ![@observablePropertyMap emptyMap] # No root entity observable Map
        !selfObservablePropertyMap
        !controllerClassBindingMap
        !controllerMap
        !actionMap
        !false
        !ioContextAnalysisStruct
        !?bindingListForGeneration
        !?fileInclusionSet
      ] ;
    end foreach ;
    [!?controllerMap insertKey
      !mControllerName
      !mControllerClassName->string
      ![@lstring new !controllerObjectClassName !here]
      !false # Is not an entity : it is a class
      !bindingListForGeneration
      !controllerActionMap
      !controllerObservablePropertyMap
    ] ;
  end foreach ;
#------------------------------------- Analyze outlets
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach mOutletDeclarationList do
    [ioContextAnalysisStruct->mOutletClassMap searchKey
      !mOutletType
      ?@generationKind generationKind
      ?2*
      ?@bool implementsDeallocProtocol
      ?@outletClassBindingMap outletClassBindingMap
      ?*
      ?@bool hasTableValueBinding
    ] ;
    if generationKind != [@generationKind noGeneration] then
      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
    end if ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        ![@observablePropertyMap emptyMap] # No root
        !selfObservablePropertyMap
        !outletClassBindingMap
        !controllerMap
        !actionMap
        !hasTableValueBinding
        !ioContextAnalysisStruct
        !?outletBindingList
        !?fileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList +=
      ![mOutletType string]
      ![mOutletName string]
      !outletBindingList
      !implementsDeallocProtocol
    ;
  end foreach ;
#-------
  ioGenerationList += ![@nibClassTypeGeneration new
    !mClassName->string
    !attributeListForImplementation
    !transientListForImplementation
    !outletGenerationList
    !mActionDeclarationList
    !selfObservablePropertyMap
    !fileInclusionSet
    !controllerMap
    !currentArrayPropertyForImplementation
  ] ;
end method ;

#----------------------------------------------------------------------------*

#local routine analyzeNibClass
#  ??@nibClassDeclarationList.element inNibClass
#  ??@controllerClassMap inControllerClassMap
#  ??@classMap inClassMap
#  ??@outletClassMap inOutletClassMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@nibClassMap ioNibClassMap
#  ??@preferencesMap inPreferencesMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
##------------------------------------- Analyze actions
#  @actionMap actionMap [emptyMap] ;
#  for actionName in inNibClass->mActionDeclarationList do
#    [!?actionMap insertKey !actionName->mValue] ;
#  end for ;
##------------------------------------- Analyze attributes
#  @fileInclusionSet fileInclusionSet [default] ;
#  @observablePropertyMap selfObservableAttributeMap [emptyMap] ;
#  @attributeListForImplementation attributeListForInitHeader [emptyList] ;
#  analyzeAttributeDeclaration
#    !inNibClass->mAttributeList
#    !inContextAnalysisStruct
#    !"nibclass." . inNibClass->mClassName
#    !?ioTransientDependencyGraph
#    !?fileInclusionSet
#    !?selfObservableAttributeMap
#    ?@attributeListForImplementation attributeListForImplementation
#    !?attributeListForInitHeader # Unused
#  ;
##------------------------------------- Analyze arraies
#  @preferenceArrayMap preferenceArrayMap [emptyMap] ;
#  foreach inNibClass->mClassArrayList do
#    [inClassMap searchKey
#      !mClassName
#      ?*
#      ?@observablePropertyMap classObservablePropertyMap
#      ?2*
#      ?@attributeListForImplementation attributeListForImplementation
#      ?4*
#    ] ;
#    [!?preferenceArrayMap insertKey
#      !mArrayName
#      !mClassName->string
#      !classObservablePropertyMap
#      !attributeListForImplementation
#    ] ;
#  end foreach ;
##-------------------------------------------------- Analyze controllers
#  @observablePropertyMap observablePropertyMap [emptyMap] ;
#  @controllerMap controllerMap [emptyMap] ;
#  foreach inNibClass->mControllerList do
#    [inControllerClassMap searchKey
#      !mControllerClassName
#      ?@controllerKind controllerKind
#      ?*
#      ?@EXoutletClassBindingMap controllerClassBindingMap
#      ?@actionMap controllerActionMap
#      ?@observablePropertyMap controllerObservablePropertyMap
#      ?@EXoutletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
#    ] ;
#  #---
#    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
#    @string controllerObjectClassName ;
#    switch controllerKind
#    when simpleController :
#      controllerObjectClassName := "" ;
#    when objectController :
#      error mControlledObjectName
#      :"objectController is not currently handled in nib class"
#      :controllerObjectClassName;
#    when entityController :
#      error mControlledObjectName
#      :"entityController is not currently handled in nib class"
#      :controllerObjectClassName;
#    when entityArrayController :
#      error mControlledObjectName
#      :"in nib class, use an arrayController, as NSArrayController"
#      :controllerObjectClassName;
#    when arrayController :
#      if mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'self' is allowed here"
#        ;
#      end if ;
#      [preferenceArrayMap searchKey
#        !mControlledObjectName
#        ?controllerObjectClassName
#        ?@observablePropertyMap classObservablePropertyMap
#        ?@attributeListForImplementation attributeListForImplementation
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?fileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentArray"
#        ![@formatterEnum noFormatter]
#        !"self"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    end switch ;
#    foreach mControllerBindingList do
#      [mBinding analyzeOutletBinding
#        ![@observablePropertyMap emptyMap] # No root entity obsevable Map
#        !selfObservableAttributeMap
#        !inPreferencesMap
#        ![@entityMap emptyMap]
#        !inClassMap
#        !controllerClassBindingMap
#        !controllerMap
#        !actionMap
#        !false
#        !inContextAnalysisStruct
#        !?bindingListForGeneration
#        !?fileInclusionSet
#      ] ;
#    end foreach ;
#    [!?controllerMap insertKey
#      !mControllerName
#      !mControllerClassName->string
#      ![@lstring new !controllerObjectClassName !here]
#      !false # Is not an entity : it is a class
#      !bindingListForGeneration
#      !controllerActionMap
#      !controllerObservablePropertyMap
#    ] ;
#  end foreach ;
##------------------------------------- Analyze transient properties
#  @transientListForImplementation transientListForImplementation ;
#  analyzeTransientProperties
#    ![@preferencesMap emptyMap]
#    !"nibclass." . inNibClass->mClassName . "."
#    !inNibClass->mTransientList
#    ![@observablePropertyMap emptyMap] # Root property map
#    !inContextAnalysisStruct
#    !"" # No Root entity
#    ![@controllerMap emptyMap]
#    !?selfObservableAttributeMap
#    !?fileInclusionSet
#    ?transientListForImplementation
#    !?ioTransientDependencyGraph
#  ;
##------------------------------------- Analyze outlets
#  @outletGenerationList outletGenerationList [emptyList] ;
#  foreach inNibClass->mOutletDeclarationList do
#    [inOutletClassMap searchKey
#      !mOutletType
#      ?@generationKind generationKind
#      ?2*
#      ?@bool implementsDeallocProtocol
#      ?@EXoutletClassBindingMap bindingMap
#      ?*
#      ?@bool hasTableValueBinding
#    ] ;
#    if generationKind != [@generationKind noGeneration] then
#      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
#    end if ;
#    @outletBindingListForGeneration outletBindingList [emptyList] ;
#    foreach mOutletBindingList do
#      [mBinding analyzeOutletBinding
#        ![@observablePropertyMap emptyMap]
#        !selfObservableAttributeMap
#        ![@preferencesMap emptyMap]
#        ![@entityMap emptyMap]
#        !inClassMap
#        !bindingMap
#        !controllerMap
#        !actionMap
#        !hasTableValueBinding
#        !inContextAnalysisStruct
#        !?outletBindingList
#        !?fileInclusionSet
#      ] ;
#    end foreach ;
#    outletGenerationList +=
#      ![mOutletType string]
#      ![mOutletName string]
#      !outletBindingList
#      !implementsDeallocProtocol
#    ;
#  end foreach ;
##------------------------------------- Enter in preference map
#  [!?fileInclusionSet->mImplementationFileInclusionSet removeKey !""] ;
#  [!?ioNibClassMap insertKey
#    !inNibClass->mClassName
#    !attributeListForImplementation
#    !transientListForImplementation
#    !outletGenerationList
#    !inNibClass->mActionDeclarationList
#    !selfObservableAttributeMap
#    !fileInclusionSet
#    !controllerMap
#    !preferenceArrayMap
#  ] ;
#end routine ;

#----------------------------------------------------------------------------*

#routine analyzeNibClasses
#  ??@nibClassDeclarationList inNibClassList
#  ??@controllerClassMap inControllerClassMap
#  ??@classMap inClassMap
#  ??@outletClassMap inOutletClassMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  !@nibClassMap outNibClassMap
#  ??@preferencesMap inPreferencesMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
#  outNibClassMap := [@nibClassMap emptyMap] ;
#  for nibClass in inNibClassList do
#    analyzeNibClass
#      !nibClass
#      !inControllerClassMap
#      !inClassMap
#      !inOutletClassMap
#      !inContextAnalysisStruct
#      !?outNibClassMap
#      !inPreferencesMap
#      !?ioTransientDependencyGraph
#    ;
#  end for ;
#end routine ;

#----------------------------------------------------------------------------*

end semantics ;
