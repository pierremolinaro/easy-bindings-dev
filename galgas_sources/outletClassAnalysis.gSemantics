semantics outletClassAnalysis :
  import "decoratedTypes.gSemantics" ;

#----------------------------------------------------------------------------*

routine analyzeOutletClasses
  ??@outletClassList inOutletClassList
  ??@protocolMap inProtocolMap
  !@outletClassMap outOutletClassMap
:
  outOutletClassMap := [@outletClassMap emptyMap] ;
  foreach inOutletClassList do
    @outletClassBindingMap allBindingMap ;
  #--- Has super class ?
    if mSuperClassName->string == "" then
      allBindingMap := [@outletClassBindingMap emptyMap] ;
    else
      [outOutletClassMap searchKey
        !mSuperClassName
        ?3*
        ?allBindingMap
        ?2*
      ] ;
    end if ;
  #---
    @outletClassBindingMap currentBindingMap [emptyMap] ;
    foreach mOutletClassBindingList do
      @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
      foreach mBindingOptionList do
        [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
      end foreach ;
      [!?allBindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
      [!?currentBindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
    end foreach ;
  #--- Analyze protocols
    foreach mAdoptedProtocolList do
      [inProtocolMap searchKey !mValue] ;
    end foreach ;
  #---
    [!?outOutletClassMap insertKey
      !mOutletClassName
      !mGeneration
      !mSuperClassName->string
      !mAdoptedProtocolList
      !allBindingMap
      !currentBindingMap
      !mHasTableValueBinding
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
