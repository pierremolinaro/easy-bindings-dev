semantics typeInventory :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "transientAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @predefinedTypeDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  [!?ioUnifiedTypeMap insertKey
    ![mTypeName nowhere]
    !mKind
    ![@unifiedTypeMap-proxy null] # Super type
    ![@unifiedTypeMap-proxy null] # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
    !@bindingList {}
    !@lstringlist {} # mEnumConstantList
    !@enumConstantMap {} # mEnumConstantMap
    !{} # No array controller
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @enumDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  @enumConstantMap enumConstantMap := {} ;
  for (s) in mEnumConstantNameList do
    [!?enumConstantMap insertKey !s] ;
  end for ;
  [!?ioUnifiedTypeMap insertKey
    !mEnumTypeName
    ![@typeKind enumType]
    ![@unifiedTypeMap-proxy null] # Super type
    ![@unifiedTypeMap-proxy null] # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
    !@bindingList {}
    !mEnumConstantNameList
    !enumConstantMap
    !{} # No array controller
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @structDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  foreach mFieldList do
    [!?ioUnifiedTypeMap enterEdge
      !mStructTypeName
      !mFieldTypeName
    ] ;
  end foreach ;
  log mStructTypeName ;
  [!?ioUnifiedTypeMap insertKey
    !mStructTypeName
    ![@typeKind structType]
    ![@unifiedTypeMap-proxy null] # Super type
    ![@unifiedTypeMap-proxy null] # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
    !@bindingList {}
    !@lstringlist {} # mEnumConstantList
    !@enumConstantMap {} # mEnumConstantMap
    !{} # No array controller
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @unifiedTypeDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  const kindName := [mTypeKind kindName] ;
#------------------------------- Super type ?
  @unifiedTypeMap-proxy superTypeProxy ;
  if mSuperTypeName->string == "" then
    superTypeProxy := [@unifiedTypeMap-proxy null] ;
  else
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mSuperTypeName
      ?superTypeProxy
    ] ;
    [!?ioUnifiedTypeMap enterEdge
      !mTypeName
      !mSuperTypeName
    ] ;
  end if ;
#------------------------------------------------ Root Entity ?
  @unifiedTypeMap-proxy rootEntityType ;
  if mRootEntityName->string == "" then
    rootEntityType := [@unifiedTypeMap-proxy null] ;
  else
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mRootEntityName
      ?rootEntityType
    ] ;
  [!?ioUnifiedTypeMap enterEdge !mTypeName !mRootEntityName] ;
  end if ;
#---------------------------------- Analyze attributes
  @decoratedObservablePropertyMap observablePropertyMap := {} ;
  @decoratedAttributeMap decoratedAttributeMap := {} ;
  foreach mAttributeList do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ??@unifiedTypeMap-proxy attributeType
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mTypeName !mAttributeTypeName] ;
    [!?decoratedAttributeMap insertKey
      !mAttributeName
      !attributeType
      !mDefaultValue
      !mNeedsValidation
     ] ;
    [!?observablePropertyMap insertKey
      !mAttributeName
      !attributeType
      !false # Is not transient
      ![@lstring new !kindName + "." + mTypeName + "." + mAttributeName !mAttributeName->location]
      !false # is not a collection
     ] ;
  end foreach ;
#---------------------------------------- Analyze relationship (only check name is unique)
  @decoratedEntityRelationshipMap currentRelationshipMap := {} ;
  foreach mRelationshipList do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mDestinationEntityName
      ??@unifiedTypeMap-proxy destinationTypeProxy
    ] ;
    [!?currentRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !destinationTypeProxy
      !mInverseRelationshipName
    ] ;
    [!?observablePropertyMap insertKey
      !mRelationshipName
      !destinationTypeProxy
      !false # Is not transient
      ![@lstring new !kindName . "." + mTypeName + "." + mRelationshipName !mRelationshipName->location]
      !true # is a collection
     ] ;
  end foreach ;
#------------------------------------- Analyze transient properties
  @decoratedTransientMap decoratedTransientMap := {} ;
  foreach mTransientList do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ??@unifiedTypeMap-proxy transientType
    ] ;
    const signature := [@lstring new !kindName + "." + mTypeName + "." + mTransientName !mTransientName->location] ;
    [!?decoratedTransientMap insertKey
      !mTransientName
      !transientType
      !signature
      !mDependencyList
    ] ;
    [!?observablePropertyMap insertKey
      !mTransientName
      !transientType
      !true # Is transient
      !signature
      !false # is not a collection
     ] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mTypeName !mElementClassName] ;
  end foreach ;
#------------------------------------- Analyze outlets
  @decoratedOutletMap decoratedOutletMap := {} ;
  foreach mOutletDeclarationList do
    [!?decoratedOutletMap insertKey
      !mOutletName
      !mOutletType
      !mRunDescriptor
      !mEnabledBindingDescriptor
    ] ;
  end foreach ;
#--------------------------------------------------- Analyze actions
  @actionMap documentActionMap := {} ;
  for actionName in mActionDeclarationList do
    [!?documentActionMap insertKey !actionName->mValue] ;
  end for ;
#--------------------------------------------------- Analyze array controllers
  @arrayControllerMap arrayControllerMap := {} ;
  for () in mArrayControllerDeclarationListAST do
    const arrayController_propertySignature := [@lstring new
      !kindName + "." + mTypeName + "." + mControllerName
      !mControllerName->location
    ] ;
    [@unifiedTypeMap-proxy makeProxy !?ioUnifiedTypeMap !["Bool" nowhere] ??@unifiedTypeMap-proxy boolTypeProxy] ;
    const @decoratedObservablePropertyMap arrayControllerObservablePropertyMap := {
      !["canRemove" nowhere]
      !boolTypeProxy
      !false # mIsTransient ;
      !arrayController_propertySignature
      !false # mIsCollection ;
    } ;
    [!?arrayControllerMap insertKey
      !mControllerName
      !mBoundModel
      !mTableViewOutletName
      !mArrayControllerBoundColumnListAST
      !{!["add" nowhere], !["remove" nowhere]}
      !arrayControllerObservablePropertyMap
      !arrayController_propertySignature
      ![mBoundModel arrayControllerTypeName !mTypeName->string !rootEntityType]
    ] ;
  end for ;
#------------------------------------- Enter in type map
  [!?ioUnifiedTypeMap insertKey
    !mTypeName
    !mTypeKind
    !superTypeProxy
    !rootEntityType
    !decoratedAttributeMap
    !decoratedTransientMap
    !decoratedOutletMap
    !observablePropertyMap
    !currentRelationshipMap
    !documentActionMap
    !mBindingList
    !@lstringlist {} # mEnumConstantList
    !@enumConstantMap {} # mEnumConstantMap
    !arrayControllerMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
