semantics typeInventory :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "transientAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

override method @predefinedTypeDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  [!?ioUnifiedTypeMap insertKey
    ![mTypeName nowhere]
    !mKind
    ![@unifiedTypeProxy null] # Super type
    ![@unifiedTypeProxy null] # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @controllerClassDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#--- Analyze actions
#  @actionMap actionMap [emptyMap] ;
#  for actionName in mActionDeclarationList do
#    [!?actionMap insertKey !actionName->mValue] ;
#  end for ;
##--- Analyze bindings
#  buildBindingCapabilitiesMap
#    !mBindingList
#    !?ioUnifiedTypeMap
#    ?@outletClassBindingMap bindingMap
#  ;
#--- Analyze attributes
  @decoratedObservablePropertyMap observablePropertyMap [emptyMap] ;
  for property in mControllerObservablePropertyList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !property->mTypeName
      ?@unifiedTypeProxy attributeTypeProxy
    ] ;
    [!?observablePropertyMap insertKey
      !property->mPropertyName
      !attributeTypeProxy
      !false # is not transient
      ![@lstring new !"controller." . mControllerClassName . "." . property->mPropertyName !property->mPropertyName->location]
      !false # Is not a collection
    ] ;
  end for ;
#---
#  @outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap [emptyMap] ;
  foreach mControlledObjectBindingOptionList do
#    @EXunifiedTypeProxyList acceptableTypeList [emptyList] ;
    foreach mAcceptableTypeList do
      [@unifiedTypeProxy makeProxy
        !?ioUnifiedTypeMap
        !mValue
        ?@unifiedTypeProxy type
      ] ;
#      acceptableTypeList += !type ;
    end foreach ;
#    [!?controlledObjectAvailableBindingOptionMap insertKey !mBindingOptionName !acceptableTypeList] ;
  end foreach ;
#---
  [!?ioUnifiedTypeMap insertKey
    !mControllerClassName
    ![@typeKind controllerClassType]
    ![@unifiedTypeProxy null] # Super type
    ![@unifiedTypeProxy null] # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !observablePropertyMap
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @enumDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  [!?ioUnifiedTypeMap insertKey
    !mEnumTypeName
    ![@typeKind enumType]
    ![@unifiedTypeProxy null] # Super type
    ![@unifiedTypeProxy null] # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @structDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  foreach mFieldList do
    [!?ioUnifiedTypeMap enterEdge
      !mStructTypeName
      !mFieldTypeName
    ] ;
  end foreach ;
  log mStructTypeName ;
  [!?ioUnifiedTypeMap insertKey
    !mStructTypeName
    ![@typeKind structType]
    ![@unifiedTypeProxy null] # Super type
    ![@unifiedTypeProxy null] # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @unifiedTypeDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
  const kindName := [mTypeKind kindName] ;
#------------------------------- Super type ?
  @unifiedTypeProxy superTypeProxy ;
  if mSuperTypeName->string == "" then
    superTypeProxy := [@unifiedTypeProxy null] ;
  else
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mSuperTypeName
      ?superTypeProxy
    ] ;
    [!?ioUnifiedTypeMap enterEdge
      !mTypeName
      !mSuperTypeName
    ] ;
  end if ;
#------------------------------------------------ Root Entity ?
  @unifiedTypeProxy rootEntityType ;
  if mRootEntityName->string == "" then
    rootEntityType := [@unifiedTypeProxy null] ;
  else
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mRootEntityName
      ?rootEntityType
    ] ;
  [!?ioUnifiedTypeMap enterEdge !mTypeName !mRootEntityName] ;
  end if ;
#---------------------------------- Analyze attributes
  @decoratedObservablePropertyMap observablePropertyMap := {} ;
  @decoratedAttributeMap decoratedAttributeMap := {} ;
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ??@unifiedTypeProxy attributeType
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mTypeName !mAttributeTypeName] ;
    [!?decoratedAttributeMap insertKey
      !mAttributeName
      !attributeType
      !mDefaultValue
     ] ;
    [!?observablePropertyMap insertKey
      !mAttributeName
      !attributeType
      !false # Is not transient
      ![@lstring new !kindName + "." + mTypeName + "." + mAttributeName !mAttributeName->location]
      !false # is not a collection
     ] ;
  end foreach ;
#------------------------------------- Analyze transient properties
  @decoratedTransientMap decoratedTransientMap := {} ;
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ??@unifiedTypeProxy transientType
    ] ;
    const signature := [@lstring new !kindName + "." + mTypeName + "." + mTransientName !mTransientName->location] ;
    [!?decoratedTransientMap insertKey
      !mTransientName
      !transientType
      !signature
      !mDependencyList
    ] ;
    [!?observablePropertyMap insertKey
      !mTransientName
      !transientType
      !true # Is transient
      !signature
      !false # is not a collection
     ] ;
  end foreach ;
#---------------------------------------- Analyze relationship (only check name is unique)
  @decoratedEntityRelationshipMap currentRelationshipMap := {} ;
  foreach mRelationshipList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mDestinationEntityName
      ??@unifiedTypeProxy destinationTypeProxy
    ] ;
    [!?currentRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !destinationTypeProxy
      !mInverseRelationshipName
    ] ;
    [!?observablePropertyMap insertKey
      !mRelationshipName
      !destinationTypeProxy
      !false # Is not transient
      ![@lstring new !kindName . "." + mTypeName + "." + mRelationshipName !mRelationshipName->location]
      !true # is a collection
     ] ;
  end foreach ;
#---------------------------------- Analyze arraies
  foreach mArrayList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mTypeName !mElementClassName] ;
  end foreach ;
#------------------------------------- Analyze outlets
  @decoratedOutletMap decoratedOutletMap := {} ;
  foreach mOutletDeclarationList do
    [!?decoratedOutletMap insertKey
      !mOutletName
      !mOutletType
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  foreach mControllerList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mControllerClassName
      ??@unifiedTypeProxy controllerTypeProxy
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mTypeName !mControllerClassName] ;
    [!?observablePropertyMap insertKey
      !mControllerName
      !controllerTypeProxy
      !false # Is not transient
      ![@lstring new !kindName . "." + mTypeName + "." + mControllerName !mControllerName->location]
      !true # is a collection
     ] ;
  end foreach ;
#--------------------------------------------------- Analyze actions
  @actionMap documentActionMap := {} ;
  for actionName in mActionDeclarationList do
    [!?documentActionMap insertKey !actionName->mValue] ;
  end for ;
#------------------------------------- Enter in type map
  [!?ioUnifiedTypeMap insertKey
    !mTypeName
    !mTypeKind
    !superTypeProxy
    !rootEntityType
    !decoratedAttributeMap
    !decoratedTransientMap
    !decoratedOutletMap
    !observablePropertyMap
    !currentRelationshipMap
    !documentActionMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
