syntax easyBindings_syntax ("easyBindings_lexique.gLexique") :
import "easyBindings_options.gOption" ;
import "abstractSyntaxTree.gSemantics" ;

#----------------------------------------------------------------------------*

rule <start_symbol> !@ASTstruct outAST :
#---
  @classList classList [emptyList] ;
  @entityList entityList [emptyList] ;
  @preferencesDeclarationList preferencesList [emptyList] ;
  @outletClassList outletClassList [emptyList] ;
  @documentDeclarationList documentDeclarationList [emptyList] ;
  @controllerClassList controllerClassList [emptyList] ;
  repeat
  while
    <class_declaration> !?classList ;
  while
    <entity_declaration> !?entityList ;
  while
    <preferences_declaration> !?preferencesList ;
  while
    <document_declaration> !?documentDeclarationList ;
  while
    <outlet_class_declaration> !?outletClassList ;
  while
    <controller_class_declaration> !?controllerClassList ;
  end repeat ;
  $end$ ;
  outAST := [@ASTstruct new
    !classList
    !entityList
    !preferencesList
    !outletClassList
    !controllerClassList
    !documentDeclarationList
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <bindings>
  !@bindingList outOutletBindingList
:
  outOutletBindingList := [@bindingList emptyList] ;
  repeat
  while
    @lstring bindingName ;
    select
      $enabled$ ;
      bindingName := [@lstring new !"enabled" !here] ;
    or
      $editable$ ;
      bindingName := [@lstring new !"editable" !here] ;
    end select ;
    @multiValuedBindingList multiValuedBindingList [emptyList] ;
    repeat 
      @bool negate ;
      select
        negate := false ;
      or
        $!$ ;
        negate := true ;
      end select ;
      @lstring mBoundObject ;
      select
        $self$ ;
        mBoundObject := [@lstring new !"self" !here] ;
      or
        $root$ ;
        mBoundObject := [@lstring new !"root" !here] ;
      or
        $identifier$ ?mBoundObject ;
      or
        $Identifier$ ?mBoundObject ;
      end select ;
      $.$ ;
      $identifier$ ?@lstring boundPropertyName ;
    #---
      @outletBindingOptionList outletBindingOptionList [emptyList] ;
      select
      or
        ${$ ;
        repeat
          $Identifier$ ? @lstring optionName ;
          $:$ ;
          @easyBindingTypeList correspondingAcceptableTypes ;
          @string defaultValueObjectiveCObject ;
          <explicit_value> ?correspondingAcceptableTypes ?defaultValueObjectiveCObject ?* ;
          outletBindingOptionList +=
            !optionName
            !correspondingAcceptableTypes
            !defaultValueObjectiveCObject
          ;
        while
          $,$ ;
        end repeat ;
        $}$ ;
      end select ;
      multiValuedBindingList += !negate !mBoundObject !boundPropertyName !outletBindingOptionList ;
    while
      $&$ ;
    end repeat ;
    outOutletBindingList += ![@multiValuedBinding new
      !bindingName
      !multiValuedBindingList
    ] ;
  while
    $hidden$ ;
    const @lstring bindingName [new !"hidden" !here] ;
    @multiValuedBindingList multiValuedBindingList [emptyList] ;
    repeat 
      @bool negate ;
      select
        negate := false ;
      or
        $!$ ;
        negate := true ;
      end select ;
      @lstring mBoundObject ;
      select
        $self$ ;
        mBoundObject := [@lstring new !"self" !here] ;
      or
        $root$ ;
        mBoundObject := [@lstring new !"root" !here] ;
      or
        $identifier$ ?mBoundObject ;
      or
        $Identifier$ ?mBoundObject ;
      end select ;
      $.$ ;
      $identifier$ ?@lstring boundPropertyName ;
    #---
      @outletBindingOptionList outletBindingOptionList [emptyList] ;
      select
      or
        ${$ ;
        repeat
          $Identifier$ ? @lstring optionName ;
          $:$ ;
          @easyBindingTypeList correspondingAcceptableTypes ;
          @string defaultValueObjectiveCObject ;
          <explicit_value> ?correspondingAcceptableTypes ?defaultValueObjectiveCObject ?* ;
          outletBindingOptionList +=
            !optionName
            !correspondingAcceptableTypes
            !defaultValueObjectiveCObject
          ;
        while
          $,$ ;
        end repeat ;
        $}$ ;
      end select ;
      multiValuedBindingList += !negate !mBoundObject !boundPropertyName !outletBindingOptionList ;
    while
      $|$ ;
    end repeat ;
    outOutletBindingList += ![@multiValuedBinding new
      !bindingName
      !multiValuedBindingList
    ] ;
  while
    $run$ ;
    @lstring targetName ;
    select
      $self$ ;
      targetName := [@lstring new !"self" !here] ;
    or
      $identifier$ ?targetName ;
    end select ;
    $.$ ;
    $identifier$ ?@lstring actionName ;
    outOutletBindingList += ![@runBinding new
      !targetName
      !actionName
    ] ;
  while
    $tableValue$ ;
    $identifier$ ?@lstring controllerName ;
    ${$ ;
    @tableValueColumnBinding tableValueColumnBinding [emptyList] ;
    repeat
    while
      $column$ ;
      $literal_string$ ?@lstring columnName ;
      $:$ ;
      $Identifier$ ?@lstring cellTypeName ;
      $identifier$ ?@lstring boundPropertyName ;
      tableValueColumnBinding += !columnName !cellTypeName !boundPropertyName ;
      $;$ ;
    end repeat ;
    outOutletBindingList += ![@tableValueBinding new !controllerName !tableValueColumnBinding] ;
    $}$ ;
  while
    $binding$ ? @lstring bindingName ;
    @lstring observedObjectName ;
    select
      $root$ ;
      observedObjectName := [@lstring new !"root" !here] ;
    or
      $self$ ;
      observedObjectName := [@lstring new !"self" !here] ;
    or
      $identifier$ ? observedObjectName ;
    or
      $Identifier$ ? observedObjectName ;
    end select ;
    $.$ ;
    $identifier$ ? @lstring rootObservablePropertyName ;
  #---
    @bool namesCountOption ;
    select
      namesCountOption := false ;
    or
      $.$ ;
      $count$ ;
      namesCountOption := true ;
    end select ;
  #---
    @outletBindingOptionList outletBindingOptionList [emptyList] ;
    select
    or
      ${$ ;
      repeat
        $Identifier$ ? @lstring optionName ;
        $:$ ;
        @easyBindingTypeList correspondingAcceptableTypes ;
        @string defaultValueObjectiveCObject ;
        <explicit_value> ?correspondingAcceptableTypes ?defaultValueObjectiveCObject ?* ;
        outletBindingOptionList +=
          !optionName
          !correspondingAcceptableTypes
          !defaultValueObjectiveCObject
        ;
      while
        $,$ ;
      end repeat ;
      $}$ ;
    end select ;
    outOutletBindingList += ![@regularBinding new
      !bindingName
      !observedObjectName
      !rootObservablePropertyName
      !outletBindingOptionList
      !namesCountOption
    ] ;
  end repeat ;
end rule ;

#----------------------------------------------------------------------------*

rule <outlet_declaration>
  ?!@outletDeclarationList ioOutletDeclarationList
:
  $outlet$ ;
  $Identifier$ ? @lstring outletTypeName ;
  $identifier$ ? @lstring outletName ;
  <bindings> ?@bindingList outletBindingList ;
  $;$ ;
  ioOutletDeclarationList += !outletTypeName !outletName !outletBindingList ;
end rule ;

#----------------------------------------------------------------------------*

rule <action_declaration>
  ?!@lstringlist ioActionDeclarationList
:
  $action$ ;
  $identifier$ ? @lstring actionName ;
  $;$ ;
  ioActionDeclarationList += !actionName ;
end rule ;

#----------------------------------------------------------------------------*

rule <preferences_declaration>
  ?!@preferencesDeclarationList ioPreferencesList
:
  $preferences$ ;
  $Identifier$ ? @lstring preferencesName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  @transientList transientList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  repeat
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  end repeat ;
  $}$ ;
  ioPreferencesList += !preferencesName !outletDeclarationList !attributeList !transientList !actionDeclarationList ;
end rule ;

#----------------------------------------------------------------------------*

rule <document_declaration>
  ?!@documentDeclarationList ioDocumentList
:
  $document$ ;
  $Identifier$ ? @lstring preferencesName ;
  $root$ ;
  $Identifier$ ? @lstring rootEntityName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @controllerList controllerList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @transientList transientList [emptyList] ;
  repeat
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <controller_declaration> !?controllerList ;
  end repeat ;
  $}$ ;
  ioDocumentList +=
    !preferencesName
    !rootEntityName
    !outletDeclarationList
    !controllerList
    !actionDeclarationList
    !transientList
  ;
end rule ;

#----------------------------------------------------------------------------*

once predefinedDates -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"date" ;
end once ;

#----------------------------------------------------------------------------*

once predefinedColors -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"blackColor" ;
  outResult += !"blueColor" ;
  outResult += !"brownColor" ;
  outResult += !"clearColor" ;
  outResult += !"controlColor" ;
  outResult += !"controlDarkShadowColor" ;
  outResult += !"controlHighlightColor" ;
  outResult += !"controlLightHighlightColor" ;
  outResult += !"controlShadowColor" ;
  outResult += !"controlTextColor" ;
  outResult += !"cyanColor" ;
  outResult += !"darkGrayColor" ;
  outResult += !"disabledControlTextColor" ;
  outResult += !"grayColor" ;
  outResult += !"greenColor" ;
  outResult += !"gridColor" ;
  outResult += !"headerColor" ;
  outResult += !"headerTextColor" ;
  outResult += !"highlightColor" ;
  outResult += !"keyboardFocusIndicatorColor" ;
  outResult += !"knobColor" ;
  outResult += !"lightGrayColor" ;
  outResult += !"magentaColor" ;
  outResult += !"orangeColor" ;
  outResult += !"purpleColor" ;
  outResult += !"redColor" ;
  outResult += !"scrollBarColor" ;
  outResult += !"selectedControlColor" ;
  outResult += !"selectedControlTextColor" ;
  outResult += !"selectedKnobColor" ;
  outResult += !"selectedMenuItemColor" ;
  outResult += !"selectedMenuItemTextColor" ;
  outResult += !"selectedTextBackgroundColor" ;
  outResult += !"selectedTextColor" ;
  outResult += !"shadowColor" ;
  outResult += !"textBackgroundColor" ;
  outResult += !"textColor" ;
  outResult += !"whiteColor" ;
  outResult += !"windowBackgroundColor" ;
  outResult += !"windowFrameColor" ;
  outResult += !"windowFrameTextColor" ;
  outResult += !"yellowColor" ;
end once ;

#----------------------------------------------------------------------------*

once predefinedFonts -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"boldSystemFontOfSize" ;
  outResult += !"controlContentFontOfSize" ;
  outResult += !"labelFontOfSize" ;
  outResult += !"menuFontOfSize" ;
  outResult += !"menuBarFontOfSize" ;
  outResult += !"messageFontOfSize" ;
  outResult += !"paletteFontOfSize" ;
  outResult += !"systemFontOfSize" ;
  outResult += !"titleBarFontOfSize" ;
  outResult += !"toolTipsFontOfSize" ;
end once ;

#----------------------------------------------------------------------------*

rule <explicit_value>
  !@easyBindingTypeList outCorrespondingAcceptableTypes
  !@string outDefaultValueObjectiveCObject
  !@string outDirectDefaultValue
:
  outCorrespondingAcceptableTypes := [@easyBindingTypeList emptyList] ;
  select
    $YES$ ;
    outDefaultValueObjectiveCObject := "[NSNumber numberWithBool:YES]" ;
    outDirectDefaultValue := "YES" ;
    outCorrespondingAcceptableTypes += ![@easyBindingType boolType] ;
  or
    $NO$ ;
    outDefaultValueObjectiveCObject := "[NSNumber numberWithBool:NO]" ;
    outDirectDefaultValue := "NO" ;
    outCorrespondingAcceptableTypes += ![@easyBindingType boolType] ;
  or
    $literal_integer$ ? @luint integerValue ;
    outDirectDefaultValue := [integerValue string] ;
    outDefaultValueObjectiveCObject := "[NSNumber numberWithInt:" . [integerValue string] . "]" ;
    outCorrespondingAcceptableTypes += ![@easyBindingType integer16Type] ;
    outCorrespondingAcceptableTypes += ![@easyBindingType integer32Type] ;
    outCorrespondingAcceptableTypes += ![@easyBindingType integer64Type] ;
  or
    $literal_string$ ? @lstring stringValue ;
    outDefaultValueObjectiveCObject := "@" . [stringValue utf8Representation] ;
    outDirectDefaultValue := outDefaultValueObjectiveCObject ;
    outCorrespondingAcceptableTypes += ![@easyBindingType stringType] ;
  or
    $identifier$ ? @lstring stringValue ;
    @luint additionalIntegerValue ;
    select
      additionalIntegerValue := [@luint new !0 ![@location nowhere]] ;
    or
      $:$ ;
      $literal_integer$ ? additionalIntegerValue ;
    end select ;
    if [predefinedColors [] hasKey ![stringValue string]] then
      outDefaultValueObjectiveCObject := "[NSColor " . stringValue . "]" ;
      outDirectDefaultValue := outDefaultValueObjectiveCObject ;
      outCorrespondingAcceptableTypes += ![@easyBindingType colorType] ;
      if additionalIntegerValue->location != [@location nowhere] then
        error additionalIntegerValue:"an integer value is not allowed for a color" ;
      end if ;
    elsif [predefinedDates [] hasKey ![stringValue string]] then
      outDefaultValueObjectiveCObject := "[NSDate " . stringValue . "]" ;
      outDirectDefaultValue := outDefaultValueObjectiveCObject ;
      outCorrespondingAcceptableTypes += ![@easyBindingType dateType] ;
      if additionalIntegerValue->location != [@location nowhere] then
        error additionalIntegerValue:"an integer value is not allowed for a date" ;
      end if ;
    elsif [predefinedFonts [] hasKey ![stringValue string]] then
      outDefaultValueObjectiveCObject := "[NSFont " . stringValue . ":" . additionalIntegerValue->uint . "]" ;
      outDirectDefaultValue := outDefaultValueObjectiveCObject ;
      outCorrespondingAcceptableTypes += ![@easyBindingType fontType] ;
      if additionalIntegerValue->location == [@location nowhere] then
        error stringValue:"an integer value is needed for a font" ;
      end if ;
    else
      error stringValue
      : "unknown constant value"
      : outDefaultValueObjectiveCObject, outDirectDefaultValue, outCorrespondingAcceptableTypes
      ;
    end if ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <class_declaration>
  ?!@classList ioClassList
:
  $class$ ;
  $Identifier$ ? @lstring className ;
  @lstring superClassName ;
  select
    superClassName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superClassName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  end repeat ;
  $}$ ;
  ioClassList += !className !superClassName !attributeList !classTransientList ;
end rule ;

#----------------------------------------------------------------------------*

rule <attribute_declaration>
  ?!@attributeList ioAttributeList
:
  $attribute$ ;
  <attribute_type> ?@easyBindingType propertyType ;
  $identifier$ ? @lstring propertyName ;
  $default$ ;
  <explicit_value>
    ?@easyBindingTypeList correspondingAcceptableTypes
    ?@string defaultValueObjectiveCObject
    ?@string directDefaultValue
  ;
  $;$ ;
  ioAttributeList +=
    !propertyType
    !propertyName
    !correspondingAcceptableTypes
    !defaultValueObjectiveCObject
    !directDefaultValue
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <transient_declaration>
  ?!@transientList ioTransientList
:
  $transient$ ;
  <attribute_type> ?@easyBindingType type ;
  $identifier$ ? @lstring transientName ;
  $dependsFrom$ ;
  @dependanceList dependanceList [emptyList] ;
  repeat
    @lstring objectName ;
    select
      $self$ ;
      objectName := [@lstring new !"self" !here] ;
    or
      $root$ ;
      objectName := [@lstring new !"root" !here] ;
    or
      $identifier$ ?objectName ;
    or
      $Identifier$ ?objectName ;
    end select ;
    $.$ ;
    $identifier$ ? @lstring dependencyName ;
  #---
    @bool namesCountOption ;
    select
      namesCountOption := false ;
    or
      $.$ ;
      $count$ ;
      namesCountOption := true ;
    end select ;
  #---
    dependanceList += !objectName !dependencyName !namesCountOption ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
  ioTransientList += !type !transientName !dependanceList ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $controller$ ;
  $Identifier$ ? @lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  $Identifier$ ? @lstring controlledClassOrEntityName ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    !controllerClassName
    !controllerName
    !controlledClassOrEntityName
    !controllerBindingList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityList ioEntityList
:
  $entity$ ;
  $Identifier$ ? @lstring entityName ;
  @lstring superEntityName ;
  select
    superEntityName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superEntityName ;
  end select ;
  $class$ ;
  $Identifier$ ? @lstring implementationClassName ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  @relationshipList relationshipList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  while
    @bool isToMany ;
    select
      $toOne$ ;
      isToMany := false ;
    or
      $toMany$ ;
      isToMany := true ;
    end select ;
    $Identifier$ ? @lstring destinationEntityName ;
    $identifier$ ? @lstring relationshipName ;
    $inverse$ ;
    $identifier$ ? @lstring inverseRelationshipName ;
    @deleteRuleEnum deleteRule ;
    select
      $nullify$ ;
      deleteRule := [@deleteRuleEnum nullifyDeleteRule] ;
    or
      $cascade$ ;
      deleteRule := [@deleteRuleEnum cascadeDeleteRule] ;
    or
      $deny$ ;
      deleteRule := [@deleteRuleEnum denyDeleteRule] ;
    end select ;
    $;$ ;
    relationshipList +=
      !isToMany
      !destinationEntityName
      !relationshipName
      !inverseRelationshipName
      !deleteRule
    ;
  end repeat ;
  $}$ ;
  ioEntityList +=
    !entityName
    !superEntityName
    !implementationClassName
    !attributeList
    !classTransientList
    !relationshipList
   ;
end rule ;

#----------------------------------------------------------------------------*

rule <attribute_type>
  !@easyBindingType outPropertyType
:
  select
    $bool$ ;
    outPropertyType := [@easyBindingType boolType] ;
  or
    $integer16$ ;
    outPropertyType := [@easyBindingType integer16Type] ;
  or
    $integer32$ ;
    outPropertyType := [@easyBindingType integer32Type] ;
  or
    $integer64$ ;
    outPropertyType := [@easyBindingType integer64Type] ;
  or
    $float$ ;
    outPropertyType := [@easyBindingType floatType] ;
  or
    $double$ ;
    outPropertyType := [@easyBindingType doubleType] ;
  or
    $decimal$ ;
    outPropertyType := [@easyBindingType decimalType] ;
  or
    $NSString$ ;
    outPropertyType := [@easyBindingType stringType] ;
  or
    $NSFont$ ;
    outPropertyType := [@easyBindingType fontType] ;
  or
    $NSImage$ ;
    outPropertyType := [@easyBindingType imageType] ;
  or
    $NSColor$ ;
    outPropertyType := [@easyBindingType colorType] ;
  or
    $NSData$ ;
    outPropertyType := [@easyBindingType dataType] ;
  or
    $NSDate$ ;
    outPropertyType := [@easyBindingType dateType] ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <type_list>
  !@easyBindingTypeList outEasyBindingTypeList
:
  outEasyBindingTypeList := [@easyBindingTypeList emptyList] ;
  repeat
    select
      @easyBindingType bindingType ;
      <attribute_type> ? bindingType ;
      outEasyBindingTypeList += !bindingType ;
    or
      $integer$ ;
      outEasyBindingTypeList += ![@easyBindingType integer16Type] ;
      outEasyBindingTypeList += ![@easyBindingType integer32Type] ;
      outEasyBindingTypeList += ![@easyBindingType integer64Type] ;
      outEasyBindingTypeList += ![@easyBindingType uintegerType] ;
    or
      $number$ ;
      outEasyBindingTypeList += ![@easyBindingType integer16Type] ;
      outEasyBindingTypeList += ![@easyBindingType integer32Type] ;
      outEasyBindingTypeList += ![@easyBindingType integer64Type] ;
      outEasyBindingTypeList += ![@easyBindingType uintegerType] ;
      outEasyBindingTypeList += ![@easyBindingType decimalType] ;
      outEasyBindingTypeList += ![@easyBindingType floatType] ;
      outEasyBindingTypeList += ![@easyBindingType doubleType] ;
    end select ;
  while
    $,$ ;
  end repeat ;
end rule ;

#----------------------------------------------------------------------------*

rule <formatter> 
  !@formatterEnum outRequiredFormatter
:
  select
    outRequiredFormatter := [@formatterEnum noFormatter] ;
  or
    $NSDateFormatter$ ;
    outRequiredFormatter := [@formatterEnum dateFormatter] ;
  or
    $NSNumberFormatter$ ;
    outRequiredFormatter := [@formatterEnum numberFormatter] ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <type_formatter_list>
  !@easyBindingTypeAndFormatterList outEasyBindingTypeFormatterList
:
  outEasyBindingTypeFormatterList := [@easyBindingTypeAndFormatterList emptyList] ;
  repeat
    select
      @easyBindingType bindingType ;
      <attribute_type> ? bindingType ;
      <formatter> ?@formatterEnum requiredFormatter ;
      outEasyBindingTypeFormatterList += !bindingType !requiredFormatter ;
    or
      $integer$ ;
      <formatter> ?@formatterEnum requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType integer16Type] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType integer32Type] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType integer64Type] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType uintegerType] !requiredFormatter ;
    or
      $number$ ;
      <formatter> ?@formatterEnum requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType integer16Type] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType integer32Type] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType integer64Type] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType uintegerType] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType decimalType] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType floatType] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@easyBindingType doubleType] !requiredFormatter ;
    or
      $toManyEntities$ ;
      outEasyBindingTypeFormatterList += ![@easyBindingType toManyEntitiesType] ![@formatterEnum noFormatter] ;
    end select ;
  while
    $,$ ;
  end repeat ;
end rule ;

#----------------------------------------------------------------------------*

rule <outlet_class_declaration>
  ?!@outletClassList ioOutletClassList
:
  @bool generateCode ;
  select
    generateCode := true ;
  or
    $extern$ ;
    generateCode := false ;
  end select ;
  $outletClass$ ;
  $Identifier$ ? @lstring outletClassName ;
  @lstring superClass ;
  select
    superClass := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ?superClass ;
  end select ;
  ${$ ;
  @outletClassBindingList outletClassBindingList [emptyList] ;
  @bool hasTableValueBinding := false ;
  repeat
  while
    $tableValue$ ;
    $;$ ;
    hasTableValueBinding := true ;
  while
    @lstring bindingName ;
    select
      $binding$ ? bindingName ;
    or
      $hidden$ ;
      bindingName := [@lstring new !"hidden" !here] ;
    or
      $editable$ ;
      bindingName := [@lstring new !"editable" !here] ;
    or
      $enabled$ ;
      bindingName := [@lstring new !"enabled" !here] ;
    end select ;
    $:$ ;
    @easyBindingTypeAndFormatterList easyBindingTypeFormatterList ;
    <type_formatter_list> ? easyBindingTypeFormatterList ;
    ${$ ;
    @bindingOptionList bindingOptionList [emptyList] ;
    repeat
    while
      $Identifier$ ? @lstring optionName ;
      $:$ ;
      <type_list> ?@easyBindingTypeList optionTypeList ;
      $;$ ;
      bindingOptionList += !optionName !optionTypeList ;
    end repeat ;
    $}$ ;
    outletClassBindingList += !bindingName !easyBindingTypeFormatterList !bindingOptionList ;
  end repeat ;
  $}$ ;
  ioOutletClassList +=
    !outletClassName
    !superClass
    !generateCode
    !outletClassBindingList
    !hasTableValueBinding
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_class_declaration>
  ?!@controllerClassList ioControllerClassList
:
  @bool generateCode ;
  select
    generateCode := true ;
  or
    $extern$ ;
    generateCode := false ;
  end select ;
  $controllerClass$ ;
  $Identifier$ ? @lstring controllerClassName ;
  ${$ ;
  @outletClassBindingList controllerClassBindingList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @controllerObservablePropertyList controllerObservablePropertyList [emptyList] ;
  repeat
  while
    $attribute$ ;
    <attribute_type> ?@easyBindingType attributeType ;
    $identifier$ ? @lstring attributeName ;
    $;$ ;
    controllerObservablePropertyList += !attributeType !attributeName ;
  while
    <action_declaration> !?actionDeclarationList ;
  while
    @lstring bindingName ;
    select
      $binding$ ? bindingName ;
    or
      $hidden$ ;
      bindingName := [@lstring new !"hidden" !here] ;
    or
      $editable$ ;
      bindingName := [@lstring new !"editable" !here] ;
    or
      $enabled$ ;
      bindingName := [@lstring new !"enabled" !here] ;
    end select ;
    $:$ ;
    @easyBindingTypeAndFormatterList easyBindingTypeFormatterList ;
    <type_formatter_list> ? easyBindingTypeFormatterList ;
    ${$ ;
    @bindingOptionList bindingOptionList [emptyList] ;
    repeat
    while
      $Identifier$ ? @lstring optionName ;
      $:$ ;
      <type_list> ?@easyBindingTypeList optionTypeList ;
      $;$ ;
      bindingOptionList += !optionName !optionTypeList ;
    end repeat ;
    $}$ ;
    controllerClassBindingList += !bindingName !easyBindingTypeFormatterList !bindingOptionList ;
  end repeat ;
  $}$ ;
  ioControllerClassList +=
    !controllerClassName
    !generateCode
    !controllerClassBindingList
    !actionDeclarationList
    !controllerObservablePropertyList
  ;
end rule ;

#----------------------------------------------------------------------------*

end syntax ;
