syntax easyBindings_syntax ("easyBindings_lexique.gLexique") :
import "easyBindings_options.gOption" ;
import "abstractSyntaxTypes.gSemantics" ;
import "easyBindings_grammar.gGrammar" ;

#----------------------------------------------------------------------------*

rule <start_symbol>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
  !@location outEndOfFile
:
  repeat
  while
    $include$ ;
    $literal_string$ ?@lstring filePath ;
    $;$ ;
    const sourceFile := [@lstring new
      ![filePath->string absolutePathFromPath ![[@string stringWithSourceFilePath] stringByDeletingLastPathComponent]]
      !filePath->location
    ] ;
    grammar easyBindings_grammar in sourceFile
      !userDefined:inIsUserDefined
      !?ioDeclarationAST
      ?*
    ;
#  while
#    <struct_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <enum_declaration> !inIsUserDefined !?ioDeclarationAST ;
#  while
#    <cursor_declaration> !?ioCursorList ;
#  while
#    <protocol_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <class_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <entity_declaration>  !inIsUserDefined  !?ioDeclarationAST ;
#  while
#    <nib_class_declaration>  !inIsUserDefined  !?ioDeclarationAST ;
  while
    <preferences_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <document_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <outlet_class_declaration> !inIsUserDefined !?ioDeclarationAST->mOutletClassDeclarationList ;
  while
    <controller_template_declaration> !inIsUserDefined !?ioDeclarationAST->mControllerTemplateList ;
  end repeat ;
  outEndOfFile := here ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_template_declaration>
  ??@bool inIsUserDefined
  ?!@controllerTemplateList ioControllerTemplateList
:
  $controllerTemplate$ ;
  $Identifier$ ??@lstring outletClassName ;
  $binding$ ??@lstring bindingName ;
  $:$ ;
  @bool modelShouldBeWritableProperty ;
  select
    $property$ ;
    modelShouldBeWritableProperty := true ;
  or
    $transient$ ;
    modelShouldBeWritableProperty := false ;
  end select ;
  $Identifier$ ??@lstring modelTypeName ;
  $identifier$ ??@lstring modelName ;
  
  @controllerBindingOptionList bindingOptionList := {} ;
  select
  or
    ${$ ;
    repeat
      $identifier$ ??@lstring optionName ;
      $:$ ;
      $Identifier$ ??@lstring optionType ;
      bindingOptionList += !optionName !optionType ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
  end select ;
  $;$ ;
  ioControllerTemplateList +=
    !inIsUserDefined
    !outletClassName
    !bindingName
    !modelTypeName
    !modelName
    !modelShouldBeWritableProperty
    !bindingOptionList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <count_option>
  !@bool outCountOptionOn
:
  select
    outCountOptionOn := false ;
  or
    $.$ ;
    $count$ ;
    outCountOptionOn := true ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

enum @runActionDescriptor {
  no_Action,
  action (@lstring, @lstring)
}

#----------------------------------------------------------------------------*

rule <outlet_declaration>
  ?!@outletDeclarationList ioOutletDeclarationList
:
  $outlet$ ;
  $Identifier$ ??outletTypeName ;
  $identifier$ ??outletName ;
#--- Run
  @lstring runTargetName ;
  @lstring runActionName ;
  @runActionDescriptor runActionDescriptor ; 
  select
    runActionDescriptor := [@runActionDescriptor no_Action] ;
    runTargetName := ["" nowhere] ;
    runActionName := ["" nowhere] ;
  or
    $run$ ;
    select
      $self$ ;
      runTargetName := [@lstring new !"self" !here] ;
    or
      $identifier$ ?runTargetName ; # Controller
    end select ;
    $.$ ;
    $identifier$ ?runActionName ;
    runActionDescriptor := [@runActionDescriptor action !runTargetName !runActionName] ;
  end select ;
  log runActionDescriptor ;
  switch runActionDescriptor
  when no_Action :
  when action (*) :
  end switch ;
#--- Enabled

#---
  $;$ ;
  ioOutletDeclarationList +=
    !outletTypeName
    !outletName
    !runTargetName
    !runActionName
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <action_declaration>
  ?!@lstringlist ioActionDeclarationList
:
  $action$ ;
  $identifier$ ??@lstring actionName ;
  $;$ ;
  ioActionDeclarationList += !actionName ;
end rule ;

#----------------------------------------------------------------------------*

rule <preferences_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $preferences$ ;
  $Identifier$ ??@lstring preferencesName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  @transientList transientList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @bindingList bindingList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <binding_declaration> !?bindingList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !preferencesName
    ![@typeKind preferencesType]
    !["" nowhere] # NoSuper type
    !outletDeclarationList
    !["" nowhere] # No root entity
    !attributeList
    !@relationshipList {}
    !classArrayList
    !transientList
    !bindingList
    !actionDeclarationList
    !{}
  ] ;
end rule ;

#----------------------------------------------------------------------------*

#rule <nib_class_declaration>
#  ??@bool unused inIsUserDefined
#  ?!@astDeclarationStruct unused ioDeclarationAST
#:
#  $nibClass$ ;
#  $Identifier$ ??@lstring preferencesName ;
#  ${$ ;
#  @outletDeclarationList outletDeclarationList [emptyList] ;
#  @attributeList attributeList [emptyList] ;
#  @transientList transientList [emptyList] ;
#  @lstringlist actionDeclarationList [emptyList] ;
#  @bindingList bindingList [emptyList] ;
#  @classArrayList classArrayList [emptyList] ;
#  repeat
#  while
#    <action_declaration> !?actionDeclarationList ;
#  while
#    <attribute_declaration> !?attributeList ;
#  while
#    <outlet_declaration> !?outletDeclarationList ;
#  while
#    <transient_declaration> !?transientList ;
#  while
#    <binding_declaration> !?bindingList ;
#  while
#    <array_declaration> !?classArrayList ;
#  end repeat ;
#  $}$ ;
#end rule ;

#----------------------------------------------------------------------------*

rule <array_declaration>
  ?!@classArrayList ioClassArrayList
:
  $array$ ;
  $Identifier$ ?@lstring className ;
  $identifier$ ?@lstring arrayName ;
  $;$ ;
  ioClassArrayList += !className !arrayName ;
end rule ;

#----------------------------------------------------------------------------*

rule <array_controller_declaration>
  ?!@arrayControllerDeclarationListAST ioArrayControllerDeclarationListAST
:
  $arrayController$ ;
  $identifier$ ??@lstring controllerName ;
  $bind$ ;
  <observable_property> ??@abstractObservablePropertyAST observablePropertyAST ;
  $to$ ;
  $identifier$ ??@lstring tableViewOutletName ;
  @arrayControllerBoundColumnListAST arrayControllerBoundColumnListAST := {} ;
  repeat
    $column$ ;
    $literal_string$ ??columnName ;
    $Identifier$ ??columnOutletTypeName ;
    $identifier$ ??observablePropertyName ;
    <binding_option_list> ??bindingOptions ;
    arrayControllerBoundColumnListAST +=
      !columnName
      !columnOutletTypeName
      !observablePropertyName
      !bindingOptions
    ;
  while
  end repeat ;
  $;$ ;
  ioArrayControllerDeclarationListAST +=
    !controllerName
    !observablePropertyAST
    !tableViewOutletName
    !arrayControllerBoundColumnListAST
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <binding_option_list> !@bindingOptionList outBindingOptions :
  outBindingOptions := {} ;
  select
  or
    ${$ ;
    repeat
      $identifier$ ??@lstring optionName ;
      $:$ ;
      <explicit_value> ??@abstractDefaultValue optionValue ;
      outBindingOptions += !optionName !optionValue ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <document_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $document$ ;
  $Identifier$ ??@lstring documentName ;
  $root$ ;
  $Identifier$ ??@lstring rootEntityName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @bindingList bindingList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @transientList transientList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  @arrayControllerDeclarationListAST arrayControllerDeclarationListAST := {} ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <binding_declaration> !?bindingList ;
  while
    <array_controller_declaration> !?arrayControllerDeclarationListAST ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !documentName
    ![@typeKind documentType]
    !["" nowhere] # No super type
    !outletDeclarationList
    !rootEntityName
    !attributeList
    !@relationshipList {}
    !@classArrayList {}
    !transientList
    !bindingList
    !actionDeclarationList
    !arrayControllerDeclarationListAST
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <explicit_value>
  !@abstractDefaultValue outDefaultValue
:
  select
    $yes$ ;
    outDefaultValue := [@boolAsDefaultValue new ![@lbool new !true !here]] ;
  or
    $no$ ;
    outDefaultValue := [@boolAsDefaultValue new ![@lbool new !false !here]] ;
  or
    $literal_integer$ ? @luint integerValue ;
    outDefaultValue := [@integerAsDefaultValue new !integerValue] ;
  or
    $literal_double$ ? @ldouble doubleValue ?* ;
    outDefaultValue := [@doubleAsDefaultValue new !doubleValue] ;
  or
    $literal_string$ ?@lstring stringValue ;
    outDefaultValue := [@stringAsDefaultValue new !stringValue] ;
  or
    $identifier$ ??@lstring stringValue ;
    outDefaultValue := [@identifierAsDefaultValue new !stringValue] ;
  or
    $($ ;
    const @location startLocation := here ;
    @defaultValueList defaultValueList [emptyList] ;
    repeat
      <explicit_value> ?@abstractDefaultValue defaultValue ;
      defaultValueList += !defaultValue ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
    outDefaultValue := [@listAsDefaultValue new !startLocation !defaultValueList] ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <class_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $class$ ;
  $Identifier$ ??@lstring className ;
  @lstring superClassName ;
  select
    superClassName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superClassName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !className
    ![@typeKind classType]
    !superClassName
    !@outletDeclarationList {}
    !["" nowhere] # No root entity
    !attributeList
    !@relationshipList {}
    !classArrayList
    !classTransientList
    !@bindingList {}
    !@lstringlist {} # No action
    !{} # No array controller
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <attribute_declaration>
  ?!@attributeList ioAttributeList
:
  $property$ ;
  @bool needsValidation ;
  select
    needsValidation := false ;
  or
    $validates$ ;
    needsValidation := true ;
  end select ;
  $Identifier$ ?@lstring attributeTypeName ;
  $identifier$ ?@lstring attributeName ;
  $default$ ;
  <explicit_value> ?@abstractDefaultValue defaultValue ;
  $;$ ;
  ioAttributeList +=
    !attributeTypeName
    !attributeName
    !defaultValue
    !needsValidation
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <transient_declaration>
  ?!@transientList ioTransientList
:
  $transient$ ;
  $Identifier$ ?@lstring transientTypeName ;
  $identifier$ ??@lstring transientName ;
  $dependsFrom$ ;
  @dependanceList dependanceList [emptyList] ;
  repeat
    select
      $root$ ;
      $.$ ;
      $signature$ ;
      dependanceList += ![@transientRootSignDependencyAST new !here] ;
    or
      $self$ ;
      $.$ ;
      $identifier$ ??@lstring masterName ;
      <count_option> ?@bool namesCountOption ;
      dependanceList += ![@transientLocalDependencyAST new !masterName !namesCountOption] ;
    or
      $root$ ;
      $.$ ;
      $identifier$ ??@lstring masterName ;
      <count_option> ?@bool namesCountOption ;
      dependanceList += ![@transientRootDependencyAST new !masterName !namesCountOption] ;
    or
      $root$ ;
      $.$ ;
      $identifier$ ??@lstring relationshipName ;
      $.$ ;
      $identifier$ ??@lstring masterName ;
      dependanceList += ![@transientRootRelationshipDependencyAST new !relationshipName !masterName] ;
    or
      $identifier$ ?@lstring controllerName ;
      $.$ ;
      $identifier$ ??@lstring masterName ;
      dependanceList += ![@transientControllerDependencyAST new !controllerName !masterName] ;
    or
      $Identifier$ ?@lstring preferenceName ;
      $.$ ;
      $identifier$ ??@lstring masterName ;
      dependanceList += ![@transientPreferenceDependencyAST new !preferenceName !masterName] ;
    end select ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
  ioTransientList += !transientTypeName !transientName !dependanceList ;
end rule ;

#----------------------------------------------------------------------------*

rule <observable_property> !@abstractObservablePropertyAST outObservablePropertyAST :
  $self$ ;
  $.$ ;
  $identifier$ ??@lstring observableProperty ;
  outObservablePropertyAST := [@selfObservablePropertyAST new
    !observableProperty
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <observable_property> !@abstractObservablePropertyAST outObservablePropertyAST :
  $root$ ;
  $.$ ;
  $identifier$ ??@lstring observableProperty ;
  <count_option> ??@bool namesCountOption ;
  outObservablePropertyAST := [@rootObservablePropertyAST new
    !observableProperty
    !namesCountOption
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <observable_property> !@abstractObservablePropertyAST outObservablePropertyAST :
  $Identifier$ ??@lstring preferenceName ;
  $.$ ;
  $identifier$ ??@lstring observableProperty ;
  outObservablePropertyAST := [@preferenceObservablePropertyAST new
    !preferenceName
    !observableProperty
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <observable_property> !@abstractObservablePropertyAST outObservablePropertyAST :
  $identifier$ ??@lstring arrayControllerName ;
  $.$ ;
  $identifier$ ??@lstring observableProperty ;
  outObservablePropertyAST := [@arrayControllerObservablePropertyAST new
    !arrayControllerName
    !observableProperty
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <binding_declaration>
  ?!@bindingList ioBindingList
:
  $bind$ ;
  $identifier$ ??@lstring modelSelectorName ;
  $:$ ;
  <observable_property> ??@abstractObservablePropertyAST observablePropertyAST ;
  $to$ ;
  $identifier$ ??@lstring outletName ;
  $binding$ ??@lstring bindingName ;
  <binding_option_list> ??bindingOptions ;
  $;$ ;
  ioBindingList +=
    !modelSelectorName
    !observablePropertyAST
    !outletName
    !bindingName
    !bindingOptions
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <entity_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $entity$ ;
  $Identifier$ ??@lstring entityName ;
  @lstring superEntityName ;
  select
    superEntityName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superEntityName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  @relationshipList relationshipList [emptyList] ;
  @lstringlist signList [emptyList] ;
  repeat
  while
    $signature$ ;
    repeat
      $identifier$ ??@lstring propertyName ;
      signList += !propertyName ;
    while
      $,$ ;
    end repeat ;
    $;$ ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  while
    @bool isToMany ;
    select
      $toOne$ ;
      isToMany := false ;
    or
      $toMany$ ;
      isToMany := true ;
    end select ;
    $Identifier$ ??@lstring destinationEntityName ;
    $identifier$ ??@lstring relationshipName ;
    $inverse$ ;
    @bool inverseIsToMany ;
    select
      $toOne$ ;
      inverseIsToMany := false ;
    or
      $toMany$ ;
      inverseIsToMany := true ;
    end select ;
    $identifier$ ??@lstring inverseRelationshipName ;
    $;$ ;
    relationshipList +=
      !isToMany
      !destinationEntityName
      !relationshipName
      !inverseRelationshipName
      !inverseIsToMany
    ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !entityName
    ![@typeKind entityType]
    !superEntityName
    !@outletDeclarationList {}
    !["" nowhere] # No root entity
    !attributeList
    !relationshipList
    !@classArrayList {}
    !classTransientList
    !@bindingList {}
    !@lstringlist {} # No action
    !{} # No array controller
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <outlet_class_declaration>
  ??@bool inIsUserDefined
  ?!@outletClassDeclarationList ioOutletClassDeclarationList
:
  $outletClass$ ;
  $Identifier$ ??@lstring outletClassName ;
  @bool hasRunAction := false ;
  @bool hasEnabled := false ;
  repeat
  while
    $run$ ;
    hasRunAction := true ;
  while
    $enabled$ ;
    hasEnabled := true ;
  end repeat ;
  $;$ ;
  ioOutletClassDeclarationList +=
    !inIsUserDefined
    !outletClassName
    !hasRunAction
    !hasEnabled
  ;
end rule ;

#----------------------------------------------------------------------------*

#rule <protocol_declaration>
#  ??@bool inIsUserDefined
#  !@protocolDeclaration outEXDeclaration
#  ?!@astDeclarationList unused ioDeclarationAST
#:
#  @bool isPredefined ;
#  select
#    $extern$ ; isPredefined := false ;
#  or
#    $predefined$ ; isPredefined := true ;
#  end select ;
#  $protocol$ ;
#  $Identifier$ ??@lstring protocolName ;
#  $;$ ;
#  outEXDeclaration := [@protocolDeclaration new
#    !inIsUserDefined
#    !isPredefined
#    !protocolName
#  ] ;
#end rule ;
#
#----------------------------------------------------------------------------*

#rule <cursor_declaration>
#  ?!@cursorList ioCursorList
#:
#  $cursor$ ;
#  $identifier$ ??@lstring cursorName ;
#  $($ ;
#  $literal_double$ ?@ldouble hotSpotX ?* ;
#  $,$ ;
#  $literal_double$ ?@ldouble hotSpotY ?* ;
#  $)$ ;
#  $;$ ;
#  ioCursorList += !cursorName !hotSpotX !hotSpotY ;
#end rule ;

#----------------------------------------------------------------------------*

rule <enum_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $enum$ ;
  $Identifier$ ??@lstring enumName ;
  ${$ ;
  @lstringlist enumConstants [emptyList] ;
  repeat
    $identifier$ ??@lstring constantName ;
    enumConstants += !constantName ;
  while
    $,$ ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@enumDeclaration new !inIsUserDefined !enumName !enumConstants] ;
end rule ;

#----------------------------------------------------------------------------*

#rule <controller_class_declaration>
#  ??@bool inIsUserDefined
#  ?!@astDeclarationList ioDeclarationAST
#:
#  @generationKind generationKind ;
#  select
#    generationKind := [@generationKind fullGeneration] ;
#  or
#    $predefined$ ;
#    generationKind := [@generationKind noGeneration] ;
#  or
#    $extern$ ;
#    generationKind := [@generationKind generateImport] ;
#  end select ;
#  @controllerKind controllerKind ;
#  @lstring controllerClassName ;
#  @bindingOptionList controlledObjectBindingOptionList [emptyList] ;
#  select
#    $controller$ ;
#    controllerKind := [@controllerKind simpleController] ;
#    $Identifier$ ?controllerClassName ;
#  or
#    $objectController$ ;
#    controllerKind := [@controllerKind objectController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ??@lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $entityController$ ;
#    controllerKind := [@controllerKind entityController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ??@lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $arrayController$ ;
#    controllerKind := [@controllerKind arrayController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ??@lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $entityArrayController$ ;
#    controllerKind := [@controllerKind entityArrayController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ??@lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $treeController$ ;
#    controllerKind := [@controllerKind treeController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ??@lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  end select ;
#  ${$ ;
#  @outletClassBindingList controllerClassBindingList [emptyList] ;
#  @lstringlist actionDeclarationList [emptyList] ;
#  @controllerObservablePropertyList controllerObservablePropertyList [emptyList] ;
#  repeat
#  while
#    $attribute$ ;
#    $Identifier$ ??@lstring attributeTypeName ;
#    $identifier$ ??@lstring attributeName ;
#    $;$ ;
#    controllerObservablePropertyList += !attributeTypeName !attributeName ;
#  while
#    <action_declaration> !?actionDeclarationList ;
#  while
#    @lstring bindingName ;
#    select
#      $binding$ ? bindingName ;
#    or
#      $hidden$ ;
#      bindingName := [@lstring new !"hidden" !here] ;
#    or
#      $editable$ ;
#      bindingName := [@lstring new !"editable" !here] ;
#    or
#      $enabled$ ;
#      bindingName := [@lstring new !"enabled" !here] ;
#    end select ;
#    $:$ ;
#    <type_formatter_list> ?@attributeASTTypeAndFormatterList easyBindingTypeFormatterList ;
#    @bindingOptionList bindingOptionList [emptyList] ;
#    select
#      $;$ ;
#    or
#      ${$ ;
#      repeat
#      while
#        $Identifier$ ??@lstring optionName ;
#        $:$ ;
#        <type_list> ?@lstringlist optionTypeList ;
#        $;$ ;
#        bindingOptionList += !optionName !optionTypeList ;
#      end repeat ;
#      $}$ ;
#    end select ;
#    controllerClassBindingList += !bindingName !easyBindingTypeFormatterList !bindingOptionList ;
#  end repeat ;
#  $}$ ;
#  ioDeclarationAST += ![@controllerClassDeclaration new
#    !inIsUserDefined
#    !controllerKind
#    !controllerClassName
#    !controlledObjectBindingOptionList
#    !generationKind
#    !controllerClassBindingList
#    !actionDeclarationList
#    !controllerObservablePropertyList
#  ] ;
#end rule ;

#----------------------------------------------------------------------------*

end syntax ;
