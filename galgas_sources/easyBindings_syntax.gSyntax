syntax easyBindings_syntax ("easyBindings_lexique.gLexique") :
import "easyBindings_options.gOption" ;
import "abstractSyntaxTypes.gSemantics" ;
import "easyBindings_grammar.gGrammar" ;

#----------------------------------------------------------------------------*

rule <start_symbol>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
  !@location outEndOfFile
:
  repeat
  while
    $include$ ;
    $literal_string$ ?@lstring filePath ;
    $;$ ;
    const sourceFile := [@lstring new
      ![filePath->string absolutePathFromPath ![[@string stringWithSourceFilePath] stringByDeletingLastPathComponent]]
      !filePath->location
    ] ;
    grammar easyBindings_grammar in sourceFile
      !userDefined:inIsUserDefined
      !?ioDeclarationAST
      ?*
    ;
#  while
#    <struct_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <enum_declaration> !inIsUserDefined !?ioDeclarationAST ;
#  while
#    <cursor_declaration> !?ioCursorList ;
#  while
#    <protocol_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <class_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <entity_declaration>  !inIsUserDefined  !?ioDeclarationAST ;
  while
    <nib_class_declaration>  !inIsUserDefined  !?ioDeclarationAST ;
  while
    <preferences_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <document_declaration> !inIsUserDefined !?ioDeclarationAST ;
  while
    <outlet_class_declaration> !inIsUserDefined !?ioDeclarationAST->mOutletClassDeclarationList ;
  while
    <controller_template_declaration> !inIsUserDefined !?ioDeclarationAST->mControllerTemplateList ;
  end repeat ;
  outEndOfFile := here ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_template_declaration>
  ??@bool inIsUserDefined
  ?!@controllerTemplateList ioControllerTemplateList
:
  $controllerTemplate$ ;
  $Identifier$ ??@lstring outletClassName ;
  $binding$ ??@lstring bindingName ;
  $:$ ;
  $Identifier$ ??@lstring modelTypeName ;
  $identifier$ ??@lstring modelName ;
  
  @controllerBindingOptionList bindingOptionList := {} ;
  select
  or
    ${$ ;
    repeat
      $identifier$ ??@lstring optionName ;
      $:$ ;
      $Identifier$ ??@lstring optionType ;
      bindingOptionList += !optionName !optionType ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
  end select ;
  $;$ ;
  ioControllerTemplateList +=
    !inIsUserDefined
    !outletClassName
    !bindingName
    !modelTypeName
    !modelName
    !bindingOptionList
  ;
end rule ;

#----------------------------------------------------------------------------*

#rule <struct_declaration>
#  ??@bool inIsUserDefined
#  ?!@astDeclarationList ioDeclarationAST
#:
#  $struct$ ;
#  $Identifier$ ? @lstring structName ;
#  @structFieldASTList structFieldList [emptyList] ;
#  ${$ ;
#  repeat
#    $Identifier$ ?@lstring fieldTypeName ;
#    $identifier$ ?@lstring fieldName ;
#    structFieldList += !fieldTypeName !fieldName ;
#  while
#    $,$ ;
#  end repeat ;
#  $}$ ;
#  ioDeclarationAST += ![@structDeclaration new
#    !inIsUserDefined
#    !structName
#    !structFieldList
#  ] ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <binding_options>
#  !@outletBindingOptionList outBindingOptionList
#:
#  outBindingOptionList := [@outletBindingOptionList emptyList] ;
#  select
#  or
#    ${$ ;
#    repeat
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <explicit_value> ?@abstractDefaultValue defaultValue ;
#      outBindingOptionList +=
#        !optionName
#        !defaultValue
#      ;
#    while
#      $,$ ;
#    end repeat ;
#    $}$ ;
#  end select ;
#end rule ;

#----------------------------------------------------------------------------*

rule <count_option>
  !@bool outCountOptionOn
:
  select
    outCountOptionOn := false ;
  or
    $.$ ;
    $count$ ;
    outCountOptionOn := true ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

#rule <multi_value_binding_element>
#  ?!@multiValuedBindingList ioMultiValuedBindingList
#:
#  @bool negate ;
#  select
#    negate := false ;
#  or
#    $!$ ;
#    negate := true ;
#  end select ;
#  @multiValuedBindingBoundModel boundModel ;
#  select
#    $self$ ;
#    $.$ ;
#    $identifier$ ?@lstring boundPropertyName ;
#    boundModel := [@multiValuedBindingBoundToSelf new !boundPropertyName] ;
#  or
#    $root$ ;
#    $.$ ;
#    $identifier$ ?@lstring boundPropertyName ;
#    boundModel := [@multiValuedBindingBoundToRoot new !boundPropertyName] ;
#  or
#    $identifier$ ?@lstring controllerName ;
#    $.$ ;
#    select
#      $selection$ ;
#      $.$ ;
#      $identifier$ ? @lstring boundPropertyName ;
#      boundModel := [@multiValuedBindingBoundToControllerSelection new !boundPropertyName !controllerName] ;
#    or
#      $identifier$ ?@lstring boundPropertyName ;
#      boundModel := [@multiValuedBindingBoundToController new !boundPropertyName !controllerName] ;
#    end select ;
#  or
#    $Identifier$ ?@lstring preferenceName ;
#    $.$ ;
#    $identifier$ ?@lstring boundPropertyName ;
#    boundModel := [@multiValuedBindingBoundToPref new !boundPropertyName !preferenceName] ;
#  end select ;
#  <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
#  ioMultiValuedBindingList += !negate !boundModel !outletBindingOptionList ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <enabled_editable_bindings>
#  ?!@bindingList ioBindingList
#:
#  @lstring bindingName ;
#  select
#    $enabled$ ;
#    bindingName := [@lstring new !"enabled" !here] ;
#  or
#    $editable$ ;
#    bindingName := [@lstring new !"editable" !here] ;
#  end select ;
#  @multiValuedBindingList multiValuedBindingList [emptyList] ;
#  repeat
#    <multi_value_binding_element> !?multiValuedBindingList ;
#  while
#    $&$ ;
#  end repeat ;
#  ioBindingList += ![@multiValuedBinding new
#    !bindingName
#    !multiValuedBindingList
#  ] ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <bindings>
#  !@bindingList outOutletBindingList
#:
#  outOutletBindingList := [@bindingList emptyList] ;
#  repeat
#  while
#    <enabled_editable_bindings> !?outOutletBindingList ;
#  while
#    $hidden$ ;
#    const bindingName := [@lstring new !"hidden" !here] ;
#    @multiValuedBindingList multiValuedBindingList [emptyList] ;
#    repeat 
#      <multi_value_binding_element> !?multiValuedBindingList ;
#    while
#      $|$ ;
#    end repeat ;
#    outOutletBindingList += ![@multiValuedBinding new
#      !bindingName
#      !multiValuedBindingList
#    ] ;
#  while
#    $run$ ;
#    @lstring targetName ;
#    select
#      $self$ ;
#      targetName := [@lstring new !"self" !here] ;
#    or
#      $identifier$ ?targetName ;
#    end select ;
#    $.$ ;
#    $identifier$ ?@lstring actionName ;
#    outOutletBindingList += ![@runBinding new
#      !targetName
#      !actionName
#    ] ;
#  while
#    $tableValue$ ;
#    $identifier$ ?@lstring controllerName ;
#    ${$ ;
#    @tableValueColumnBinding tableValueColumnBinding [emptyList] ;
#    repeat
#    while
#      $column$ ;
#      $literal_string$ ?@lstring columnName ;
#      $Identifier$ ?@lstring cellTypeName ;
#      $identifier$ ?@lstring boundPropertyName ;
#      tableValueColumnBinding += !columnName !cellTypeName !boundPropertyName ;
#      $;$ ;
#    end repeat ;
#    outOutletBindingList += ![@tableValueBinding new !controllerName !tableValueColumnBinding] ;
#    $}$ ;
#  while
#    $binding$ ? @lstring bindingName ;
#    select
#      $root$ ;
#      $.$ ;
#      $identifier$ ? @lstring rootObservablePropertyName ;
#      <count_option> ?@bool namesCountOption ;
#      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
#      outOutletBindingList += ![@regularRootBinding new
#        !bindingName
#        !rootObservablePropertyName
#        !outletBindingOptionList
#        !namesCountOption
#      ] ;
#    or
#      $self$ ;
#      $.$ ;
#      $identifier$ ? @lstring rootObservablePropertyName ;
#      <count_option> ?@bool namesCountOption ;
#      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
#      outOutletBindingList += ![@regularSelfBinding new
#        !bindingName
#        !rootObservablePropertyName
#        !outletBindingOptionList
#        !namesCountOption
#      ] ;
#    or
#      $identifier$ ? @lstring controllerName ;
#      $.$ ;
#      select
#        $selection$ ;
#        $.$ ;
#        $identifier$ ? @lstring controllerObservablePropertyName ;
#        <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
#        outOutletBindingList += ![@regularControllerSelectionBinding new
#          !bindingName
#          !controllerName
#          !controllerObservablePropertyName
#          !outletBindingOptionList
#        ] ;
#      or
#        $identifier$ ? @lstring controllerObservablePropertyName ;
#        <count_option> ?@bool namesCountOption ;
#        <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
#        outOutletBindingList += ![@regularControllerBinding new
#          !bindingName
#          !controllerName
#          !controllerObservablePropertyName
#          !outletBindingOptionList
#          !namesCountOption
#        ] ;
#      end select ;
#    or
#      $Identifier$ ?@lstring preferenceName ;
#      $.$ ;
#      $identifier$ ? @lstring preferenceObservablePropertyName ;
#      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
#      outOutletBindingList += ![@regularPreferenceBinding new
#        !bindingName
#        !preferenceName
#        !preferenceObservablePropertyName
#        !outletBindingOptionList
#      ] ;
#    end select ;
#  end repeat ;
#end rule ;

#----------------------------------------------------------------------------*

rule <outlet_declaration>
  ?!@outletDeclarationList ioOutletDeclarationList
:
  $outlet$ ;
  $Identifier$ ? @lstring outletTypeName ;
  $identifier$ ? @lstring outletName ;
  $;$ ;
  ioOutletDeclarationList += !outletTypeName !outletName ;
end rule ;

#----------------------------------------------------------------------------*

rule <action_declaration>
  ?!@lstringlist ioActionDeclarationList
:
  $action$ ;
  $identifier$ ? @lstring actionName ;
  $;$ ;
  ioActionDeclarationList += !actionName ;
end rule ;

#----------------------------------------------------------------------------*

rule <preferences_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $preferences$ ;
  $Identifier$ ? @lstring preferencesName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  @transientList transientList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @bindingList bindingList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <binding_declaration> !?bindingList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !preferencesName
    ![@typeKind preferencesType]
    !["" nowhere] # NoSuper type
    !outletDeclarationList
    !["" nowhere] # No root entity
    !attributeList
    !@relationshipList {}
    !classArrayList
    !transientList
    !bindingList
    !actionDeclarationList
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <nib_class_declaration>
  ??@bool unused inIsUserDefined
  ?!@astDeclarationStruct unused ioDeclarationAST
:
  $nibClass$ ;
  $Identifier$ ? @lstring preferencesName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  @transientList transientList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @bindingList bindingList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <binding_declaration> !?bindingList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
end rule ;

#----------------------------------------------------------------------------*

rule <array_declaration>
  ?!@classArrayList ioClassArrayList
:
  $array$ ;
  $Identifier$ ?@lstring className ;
  $identifier$ ?@lstring arrayName ;
  $;$ ;
  ioClassArrayList += !className !arrayName ;
end rule ;

#----------------------------------------------------------------------------*

rule <document_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $document$ ;
  $Identifier$ ? @lstring documentName ;
  $root$ ;
  $Identifier$ ? @lstring rootEntityName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @bindingList bindingList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @transientList transientList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <binding_declaration> !?bindingList ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !documentName
    ![@typeKind documentType]
    !["" nowhere] # No super type
    !outletDeclarationList
    !rootEntityName
    !attributeList
    !@relationshipList {}
    !@classArrayList {}
    !transientList
    !bindingList
    !actionDeclarationList
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <explicit_value>
  !@abstractDefaultValue outDefaultValue
:
  select
    $yes$ ;
    outDefaultValue := [@boolAsDefaultValue new ![@lbool new !true !here]] ;
  or
    $no$ ;
    outDefaultValue := [@boolAsDefaultValue new ![@lbool new !false !here]] ;
  or
    $literal_integer$ ? @luint integerValue ;
    outDefaultValue := [@integerAsDefaultValue new !integerValue] ;
  or
    $literal_double$ ? @ldouble doubleValue ?* ;
    outDefaultValue := [@doubleAsDefaultValue new !doubleValue] ;
  or
    $literal_string$ ?@lstring stringValue ;
    outDefaultValue := [@stringAsDefaultValue new !stringValue] ;
  or
    $identifier$ ? @lstring stringValue ;
    outDefaultValue := [@identifierAsDefaultValue new !stringValue] ;
  or
    $($ ;
    const @location startLocation := here ;
    @defaultValueList defaultValueList [emptyList] ;
    repeat
      <explicit_value> ?@abstractDefaultValue defaultValue ;
      defaultValueList += !defaultValue ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
    outDefaultValue := [@listAsDefaultValue new !startLocation !defaultValueList] ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <class_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $class$ ;
  $Identifier$ ? @lstring className ;
  @lstring superClassName ;
  select
    superClassName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superClassName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !className
    ![@typeKind classType]
    !superClassName
    !@outletDeclarationList {}
    !["" nowhere] # No root entity
    !attributeList
    !@relationshipList {}
    !classArrayList
    !classTransientList
    !@bindingList {}
    !@lstringlist {} # No action
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <attribute_declaration>
  ?!@attributeList ioAttributeList
:
  $property$ ;
  $Identifier$ ?@lstring attributeTypeName ;
  $identifier$ ?@lstring attributeName ;
  $default$ ;
  <explicit_value> ?@abstractDefaultValue defaultValue ;
  $;$ ;
  ioAttributeList +=
    !attributeTypeName
    !attributeName
    !defaultValue
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <transient_declaration>
  ?!@transientList ioTransientList
:
  $transient$ ;
  $Identifier$ ?@lstring transientTypeName ;
  $identifier$ ? @lstring transientName ;
  $dependsFrom$ ;
  @dependanceList dependanceList [emptyList] ;
  repeat
    select
      $root$ ;
      $.$ ;
      $signature$ ;
      dependanceList += ![@transientRootSignDependency new !here] ;
    or
      $self$ ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      <count_option> ?@bool namesCountOption ;
      dependanceList += ![@transientLocalDependency new !masterName !namesCountOption] ;
    or
      $root$ ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      <count_option> ?@bool namesCountOption ;
      dependanceList += ![@transientRootDependency new !masterName !namesCountOption] ;
    or
      $identifier$ ?@lstring controllerName ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      dependanceList += ![@transientControllerDependency new !controllerName !masterName] ;
    or
      $Identifier$ ?@lstring preferenceName ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      dependanceList += ![@transientPreferenceDependency new !preferenceName !masterName] ;
    end select ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
  ioTransientList += !transientTypeName !transientName !dependanceList ;
end rule ;

#----------------------------------------------------------------------------*


#----------------------------------------------------------------------------*

rule <binding_declaration>
  ?!@bindingList ioBindingList
:
  $bind$ ;
  $identifier$ ??@lstring modelSelectorName ;
  $:$ ;
  $self$ ;
  $.$ ;
  $identifier$ ??@lstring observableProperty ;
  $to$ ;
  $identifier$ ??@lstring outletName ;
  $binding$ ??@lstring bindingName ;
  @bindingOptionList bindingOptions := {} ;
  select
  or
    ${$ ;
    repeat
      $identifier$ ??@lstring optionName ;
      $:$ ;
      <explicit_value> ??@abstractDefaultValue optionValue ;
      bindingOptions += !optionName !optionValue ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
  end select ;
  $;$ ;
  ioBindingList +=
    !observableProperty
    !modelSelectorName
    !outletName
    !bindingName
    !bindingOptions
  ;
end rule ;

#----------------------------------------------------------------------------*

#rule <controller_declaration>
#  ?!@controllerList ioControllerList
#:
#  $controller$ ;
#  $Identifier$ ? @lstring controllerClassName ;
#  $identifier$ ? @lstring controllerName ;
#  <bindings> ?@bindingList controllerBindingList ;
#  $;$ ;
#  ioControllerList +=
#    ![@controllerKind simpleController]
#    !controllerClassName
#    !controllerName
#    ![@lbool new !false !here] # Any value, no controlled object
#    ![@lstring new !"" ! here] # No controlled Object
#    ![@outletBindingOptionList emptyList]
#    !controllerBindingList
#    !["" nowhere]
#  ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <controller_declaration>
#  ?!@controllerList ioControllerList
#:
#  $arrayController$ ;
#  $Identifier$ ?@lstring controllerClassName ;
#  $identifier$ ? @lstring controllerName ;
#  $:$ ;
#  @lbool isRoot ;
#  select
#    $root$ ;
#    isRoot := [@lbool new !true !here] ;
#  or
#    $self$ ;
#    isRoot := [@lbool new !false !here] ;
#  end select ;
#  $.$ ;
#  $identifier$ ?@lstring controlledObject ;
#  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
#  <bindings> ?@bindingList controllerBindingList ;
#  $;$ ;
#  ioControllerList +=
#    ![@controllerKind arrayController]
#    !controllerClassName
#    !controllerName
#    !isRoot
#    !controlledObject
#    !controlledObjectBindingOptionList
#    !controllerBindingList
#    !["" nowhere]
#  ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <controller_declaration>
#  ?!@controllerList ioControllerList
#:
#  $entityArrayController$ ;
#  $Identifier$ ?@lstring controllerClassName ;
#  $identifier$ ? @lstring controllerName ;
#  $:$ ;
#  @lbool isRoot ;
#  select
#    $root$ ;
#    isRoot := [@lbool new !true !here] ;
#  or
#    $self$ ;
#    isRoot := [@lbool new !false !here] ;
#  end select ;
#  $.$ ;
#  $identifier$ ?@lstring controlledObject ;
#  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
#  <bindings> ?@bindingList controllerBindingList ;
#  $;$ ;
#  ioControllerList +=
#    ![@controllerKind entityArrayController]
#    !controllerClassName
#    !controllerName
#    !isRoot
#    !controlledObject
#    !controlledObjectBindingOptionList
#    !controllerBindingList
#    !["" nowhere]
#  ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <controller_declaration>
#  ?!@controllerList ioControllerList
#:
#  $objectController$ ;
#  $Identifier$ ? @lstring controllerClassName ;
#  $identifier$ ? @lstring controllerName ;
#  $:$ ;
#  @lbool isRoot ;
#  select
#    $root$ ;
#    isRoot := [@lbool new !true !here] ;
#  or
#    $self$ ;
#    isRoot := [@lbool new !false !here] ;
#  end select ;
#  $.$ ;
#  $identifier$ ?@lstring controlledObject ;
#  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
#  <bindings> ?@bindingList controllerBindingList ;
#  $;$ ;
#  ioControllerList +=
#    ![@controllerKind objectController]
#    !controllerClassName
#    !controllerName
#    !isRoot
#    !controlledObject
#    !controlledObjectBindingOptionList
#    !controllerBindingList
#    !["" nowhere]
#  ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <controller_declaration>
#  ?!@controllerList ioControllerList
#:
#  $entityController$ ;
#  $Identifier$ ? @lstring controllerClassName ;
#  $identifier$ ? @lstring controllerName ;
#  $:$ ;
#  @lbool isRoot ;
#  select
#    $root$ ;
#    isRoot := [@lbool new !true !here] ;
#  or
#    $self$ ;
#    isRoot := [@lbool new !false !here] ;
#  end select ;
#  $.$ ;
#  $identifier$ ?@lstring controlledObject ;
#  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
#  <bindings> ?@bindingList controllerBindingList ;
#  $;$ ;
#  ioControllerList +=
#    ![@controllerKind entityController]
#    !controllerClassName
#    !controllerName
#    !isRoot
#    !controlledObject
#    !controlledObjectBindingOptionList
#    !controllerBindingList
#    !["" nowhere]
#  ;
#end rule ;

#----------------------------------------------------------------------------*

rule <entity_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $entity$ ;
  $Identifier$ ? @lstring entityName ;
  @lstring superEntityName ;
  select
    superEntityName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superEntityName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  @relationshipList relationshipList [emptyList] ;
  @lstringlist signList [emptyList] ;
  repeat
  while
    $signature$ ;
    repeat
      $identifier$ ? @lstring propertyName ;
      signList += !propertyName ;
    while
      $,$ ;
    end repeat ;
    $;$ ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  while
    @bool isToMany ;
    select
      $toOne$ ;
      isToMany := false ;
    or
      $toMany$ ;
      isToMany := true ;
    end select ;
    $Identifier$ ? @lstring destinationEntityName ;
    $identifier$ ? @lstring relationshipName ;
    $inverse$ ;
    @bool inverseIsToMany ;
    select
      $toOne$ ;
      inverseIsToMany := false ;
    or
      $toMany$ ;
      inverseIsToMany := true ;
    end select ;
    $identifier$ ? @lstring inverseRelationshipName ;
    @deleteRuleEnum deleteRule ;
    select
      $nullify$ ;
      deleteRule := [@deleteRuleEnum nullifyDeleteRule] ;
    or
      $cascade$ ;
      deleteRule := [@deleteRuleEnum cascadeDeleteRule] ;
    or
      $deny$ ;
      deleteRule := [@deleteRuleEnum denyDeleteRule] ;
    end select ;
    $;$ ;
    relationshipList +=
      !isToMany
      !destinationEntityName
      !relationshipName
      !inverseRelationshipName
      !inverseIsToMany
      !deleteRule
    ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !entityName
    ![@typeKind entityType]
    !superEntityName
    !@outletDeclarationList {}
    !["" nowhere] # No root entity
    !attributeList
    !relationshipList
    !@classArrayList {}
    !classTransientList
    !@bindingList {}
    !@lstringlist {} # No action
  ] ;
end rule ;

#----------------------------------------------------------------------------*

#rule <type_list>
#  !@lstringlist outEasyBindingTypeList
#:
#  outEasyBindingTypeList := [@lstringlist emptyList] ;
#  repeat
#    select
#      $Identifier$ ?@lstring bindingTypeName ;
#      outEasyBindingTypeList += !bindingTypeName ;
#    or
#      $AnyScalar$ ;
#      outEasyBindingTypeList += ![@lstring new !"Integer" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"UInteger" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"Bool" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"enum" !here] ;
#    or
#      $AnyNumber$ ;
#      outEasyBindingTypeList += ![@lstring new !"Double" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"Integer" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"UInteger" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"Bool" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"enum" !here] ;
#    end select ;
#  while
#    $,$ ;
#  end repeat ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <formatter> 
#  !@formatterEnum outRequiredFormatter
#:
#  select
#    outRequiredFormatter := [@formatterEnum noFormatter] ;
#  or
#    $NSDateFormatter$ ;
#    outRequiredFormatter := [@formatterEnum dateFormatter] ;
#  or
#    $NSNumberFormatter$ ;
#    outRequiredFormatter := [@formatterEnum numberFormatter] ;
#  end select ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <type_formatter_list>
#  !@attributeASTTypeAndFormatterList outEasyBindingTypeFormatterList
#:
#  outEasyBindingTypeFormatterList := [@attributeASTTypeAndFormatterList emptyList] ;
#  repeat
#    select
#      $Identifier$ ?@lstring typeName ;
#      <formatter> ?@formatterEnum requiredFormatter ;
#      outEasyBindingTypeFormatterList += !typeName !requiredFormatter ;
#    or
#      $AnyScalar$ ;
#      <formatter> ?@formatterEnum requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Integer" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"UInteger" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Bool" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"enum" !here] !requiredFormatter ;
#    or
#      $AnyNumber$ ;
#      <formatter> ?@formatterEnum requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Double" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Integer" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"UInteger" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Bool" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"enum" !here] !requiredFormatter ;
#    end select ;
#  while
#    $,$ ;
#  end repeat ;
#end rule ;

#----------------------------------------------------------------------------*

rule <outlet_class_declaration>
  ??@bool inIsUserDefined
  ?!@outletClassDeclarationList ioOutletClassDeclarationList
:
  $outletClass$ ;
  $Identifier$ ??@lstring outletClassName ;
  $;$ ;
  ioOutletClassDeclarationList +=
    !inIsUserDefined
    !outletClassName
  ;
end rule ;

#----------------------------------------------------------------------------*

#rule <protocol_declaration>
#  ??@bool inIsUserDefined
#  !@protocolDeclaration outEXDeclaration
#  ?!@astDeclarationList unused ioDeclarationAST
#:
#  @bool isPredefined ;
#  select
#    $extern$ ; isPredefined := false ;
#  or
#    $predefined$ ; isPredefined := true ;
#  end select ;
#  $protocol$ ;
#  $Identifier$ ? @lstring protocolName ;
#  $;$ ;
#  outEXDeclaration := [@protocolDeclaration new
#    !inIsUserDefined
#    !isPredefined
#    !protocolName
#  ] ;
#end rule ;
#
#----------------------------------------------------------------------------*

#rule <cursor_declaration>
#  ?!@cursorList ioCursorList
#:
#  $cursor$ ;
#  $identifier$ ? @lstring cursorName ;
#  $($ ;
#  $literal_double$ ?@ldouble hotSpotX ?* ;
#  $,$ ;
#  $literal_double$ ?@ldouble hotSpotY ?* ;
#  $)$ ;
#  $;$ ;
#  ioCursorList += !cursorName !hotSpotX !hotSpotY ;
#end rule ;

#----------------------------------------------------------------------------*

rule <enum_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationStruct ioDeclarationAST
:
  $enum$ ;
  $Identifier$ ??@lstring enumName ;
  ${$ ;
  @lstringlist enumConstants [emptyList] ;
  repeat
    $identifier$ ??@lstring constantName ;
    enumConstants += !constantName ;
  while
    $,$ ;
  end repeat ;
  $}$ ;
  ioDeclarationAST->mDeclarationList += ![@enumDeclaration new !inIsUserDefined !enumName !enumConstants] ;
end rule ;

#----------------------------------------------------------------------------*

#rule <controller_class_declaration>
#  ??@bool inIsUserDefined
#  ?!@astDeclarationList ioDeclarationAST
#:
#  @generationKind generationKind ;
#  select
#    generationKind := [@generationKind fullGeneration] ;
#  or
#    $predefined$ ;
#    generationKind := [@generationKind noGeneration] ;
#  or
#    $extern$ ;
#    generationKind := [@generationKind generateImport] ;
#  end select ;
#  @controllerKind controllerKind ;
#  @lstring controllerClassName ;
#  @bindingOptionList controlledObjectBindingOptionList [emptyList] ;
#  select
#    $controller$ ;
#    controllerKind := [@controllerKind simpleController] ;
#    $Identifier$ ?controllerClassName ;
#  or
#    $objectController$ ;
#    controllerKind := [@controllerKind objectController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $entityController$ ;
#    controllerKind := [@controllerKind entityController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $arrayController$ ;
#    controllerKind := [@controllerKind arrayController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $entityArrayController$ ;
#    controllerKind := [@controllerKind entityArrayController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $treeController$ ;
#    controllerKind := [@controllerKind treeController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  end select ;
#  ${$ ;
#  @outletClassBindingList controllerClassBindingList [emptyList] ;
#  @lstringlist actionDeclarationList [emptyList] ;
#  @controllerObservablePropertyList controllerObservablePropertyList [emptyList] ;
#  repeat
#  while
#    $attribute$ ;
#    $Identifier$ ? @lstring attributeTypeName ;
#    $identifier$ ? @lstring attributeName ;
#    $;$ ;
#    controllerObservablePropertyList += !attributeTypeName !attributeName ;
#  while
#    <action_declaration> !?actionDeclarationList ;
#  while
#    @lstring bindingName ;
#    select
#      $binding$ ? bindingName ;
#    or
#      $hidden$ ;
#      bindingName := [@lstring new !"hidden" !here] ;
#    or
#      $editable$ ;
#      bindingName := [@lstring new !"editable" !here] ;
#    or
#      $enabled$ ;
#      bindingName := [@lstring new !"enabled" !here] ;
#    end select ;
#    $:$ ;
#    <type_formatter_list> ?@attributeASTTypeAndFormatterList easyBindingTypeFormatterList ;
#    @bindingOptionList bindingOptionList [emptyList] ;
#    select
#      $;$ ;
#    or
#      ${$ ;
#      repeat
#      while
#        $Identifier$ ? @lstring optionName ;
#        $:$ ;
#        <type_list> ?@lstringlist optionTypeList ;
#        $;$ ;
#        bindingOptionList += !optionName !optionTypeList ;
#      end repeat ;
#      $}$ ;
#    end select ;
#    controllerClassBindingList += !bindingName !easyBindingTypeFormatterList !bindingOptionList ;
#  end repeat ;
#  $}$ ;
#  ioDeclarationAST += ![@controllerClassDeclaration new
#    !inIsUserDefined
#    !controllerKind
#    !controllerClassName
#    !controlledObjectBindingOptionList
#    !generationKind
#    !controllerClassBindingList
#    !actionDeclarationList
#    !controllerObservablePropertyList
#  ] ;
#end rule ;

#----------------------------------------------------------------------------*

end syntax ;
