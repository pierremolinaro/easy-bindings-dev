syntax easyBindings_syntax ("easyBindings_lexique.gLexique") :
import "easyBindings_options.gOption" ;
import "abstractSyntaxTypes.gSemantics" ;
import "easyBindings_grammar.gGrammar" ;

#----------------------------------------------------------------------------*

rule <start_symbol>
  ?!@classList ioClassList
  ?!@entityList ioEntityList
  ?!@preferencesDeclarationList ioPreferencesList
  ?!@outletClassList ioOutletClassList
  ?!@documentDeclarationList ioDocumentDeclarationList
  ?!@controllerClassList ioControllerClassList
  ?!@protocolList ioProtocolList
  ?!@cursorList ioCursorList
  ?!@enumList ioEnumList
  ?!@lstringlist ioPlainOldDataTypeList
  !@location outEndOfFile
:
  repeat
  while
    $include$ ;
    $literal_string$ ?@lstring filePath ;
    $;$ ;
    const @lstring sourceFile [new
      ![filePath->string absolutePathFromPath ![[@string stringWithSourceFilePath] stringByDeletingLastPathComponent]]
      !filePath->location
    ] ;
    grammar easyBindings_grammar in sourceFile
      !?ioClassList
      !?ioEntityList
      !?ioPreferencesList
      !?ioOutletClassList
      !?ioDocumentDeclarationList
      !?ioControllerClassList
      !?ioProtocolList
      !?ioCursorList
      !?ioEnumList
      !?ioPlainOldDataTypeList
      ?*
    ;
  while
    <pain_old_data_declaration> !?ioPlainOldDataTypeList ;
  while
    <enum_declaration> !?ioEnumList ;
  while
    <cursor_declaration> !?ioCursorList ;
  while
    <protocol_declaration> !?ioProtocolList ;
  while
    <class_declaration> !?ioClassList ;
  while
    <entity_declaration> !?ioEntityList ;
  while
    <preferences_declaration> !?ioPreferencesList ;
  while
    <document_declaration> !?ioDocumentDeclarationList ;
  while
    <outlet_class_declaration> !?ioOutletClassList ;
  while
    <controller_class_declaration> !?ioControllerClassList ;
  end repeat ;
  outEndOfFile := here ;
  $end$ ;
end rule ;

#----------------------------------------------------------------------------*

rule <pain_old_data_declaration>
  ?!@lstringlist ioPlainOldDataTypeList
:
  $plainOldData$ ;
  $Identifier$ ? @lstring podName ;
  ioPlainOldDataTypeList += !podName ;
  $;$ ;
end rule ;

#----------------------------------------------------------------------------*

rule <binding_options>
  !@outletBindingOptionList outBindingOptionList
:
  outBindingOptionList := [@outletBindingOptionList emptyList] ;
  select
  or
    ${$ ;
    repeat
      $Identifier$ ? @lstring optionName ;
      $:$ ;
      <explicit_value> ?@abstractDefaultValue defaultValue ;
      outBindingOptionList +=
        !optionName
        !defaultValue
      ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <count_option>
  !@bool outCountOptionOn
:
  select
    outCountOptionOn := false ;
  or
    $.$ ;
    $count$ ;
    outCountOptionOn := true ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <multi_value_binding_element>
  ?!@multiValuedBindingList ioMultiValuedBindingList
:
  @bool negate ;
  select
    negate := false ;
  or
    $!$ ;
    negate := true ;
  end select ;
  @multiValuedBindingBoundModel boundModel ;
  select
    $self$ ;
    $.$ ;
    $identifier$ ?@lstring boundPropertyName ;
    boundModel := [@multiValuedBindingBoundToSelf new !boundPropertyName] ;
  or
    $root$ ;
    $.$ ;
    $identifier$ ?@lstring boundPropertyName ;
    boundModel := [@multiValuedBindingBoundToRoot new !boundPropertyName] ;
  or
    $identifier$ ?@lstring controllerName ;
    $.$ ;
    select
      $selection$ ;
      $.$ ;
      $identifier$ ? @lstring boundPropertyName ;
      boundModel := [@multiValuedBindingBoundToControllerSelection new !boundPropertyName !controllerName] ;
    or
      $identifier$ ?@lstring boundPropertyName ;
      boundModel := [@multiValuedBindingBoundToController new !boundPropertyName !controllerName] ;
    end select ;
  or
    $Identifier$ ?@lstring preferenceName ;
    $.$ ;
    $identifier$ ?@lstring boundPropertyName ;
    boundModel := [@multiValuedBindingBoundToPref new !boundPropertyName !preferenceName] ;
  end select ;
  <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
  ioMultiValuedBindingList += !negate !boundModel !outletBindingOptionList ;
end rule ;

#----------------------------------------------------------------------------*

rule <enabled_editable_bindings>
  ?!@bindingList ioBindingList
:
  @lstring bindingName ;
  select
    $enabled$ ;
    bindingName := [@lstring new !"enabled" !here] ;
  or
    $editable$ ;
    bindingName := [@lstring new !"editable" !here] ;
  end select ;
  @multiValuedBindingList multiValuedBindingList [emptyList] ;
  repeat
    <multi_value_binding_element> !?multiValuedBindingList ;
  while
    $&$ ;
  end repeat ;
  ioBindingList += ![@multiValuedBinding new
    !bindingName
    !multiValuedBindingList
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <bindings>
  !@bindingList outOutletBindingList
:
  outOutletBindingList := [@bindingList emptyList] ;
  repeat
  while
    <enabled_editable_bindings> !?outOutletBindingList ;
  while
    $hidden$ ;
    const @lstring bindingName [new !"hidden" !here] ;
    @multiValuedBindingList multiValuedBindingList [emptyList] ;
    repeat 
      <multi_value_binding_element> !?multiValuedBindingList ;
    while
      $|$ ;
    end repeat ;
    outOutletBindingList += ![@multiValuedBinding new
      !bindingName
      !multiValuedBindingList
    ] ;
  while
    $run$ ;
    @lstring targetName ;
    select
      $self$ ;
      targetName := [@lstring new !"self" !here] ;
    or
      $identifier$ ?targetName ;
    end select ;
    $.$ ;
    $identifier$ ?@lstring actionName ;
    outOutletBindingList += ![@runBinding new
      !targetName
      !actionName
    ] ;
  while
    $tableValue$ ;
    $identifier$ ?@lstring controllerName ;
    ${$ ;
    @tableValueColumnBinding tableValueColumnBinding [emptyList] ;
    repeat
    while
      $column$ ;
      $literal_string$ ?@lstring columnName ;
      $Identifier$ ?@lstring cellTypeName ;
      $identifier$ ?@lstring boundPropertyName ;
      tableValueColumnBinding += !columnName !cellTypeName !boundPropertyName ;
      $;$ ;
    end repeat ;
    outOutletBindingList += ![@tableValueBinding new !controllerName !tableValueColumnBinding] ;
    $}$ ;
  while
    $binding$ ? @lstring bindingName ;
    select
      $root$ ;
      $.$ ;
      $identifier$ ? @lstring rootObservablePropertyName ;
      <count_option> ?@bool namesCountOption ;
      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
      outOutletBindingList += ![@regularRootBinding new
        !bindingName
        !rootObservablePropertyName
        !outletBindingOptionList
        !namesCountOption
      ] ;
    or
      $self$ ;
      $.$ ;
      $identifier$ ? @lstring rootObservablePropertyName ;
      <count_option> ?@bool namesCountOption ;
      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
      outOutletBindingList += ![@regularSelfBinding new
        !bindingName
        !rootObservablePropertyName
        !outletBindingOptionList
        !namesCountOption
      ] ;
    or
      $identifier$ ? @lstring controllerName ;
      $.$ ;
      select
        $selection$ ;
        $.$ ;
        $identifier$ ? @lstring controllerObservablePropertyName ;
        <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
        outOutletBindingList += ![@regularControllerSelectionBinding new
          !bindingName
          !controllerName
          !controllerObservablePropertyName
          !outletBindingOptionList
        ] ;
      or
        $identifier$ ? @lstring controllerObservablePropertyName ;
        <count_option> ?@bool namesCountOption ;
        <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
        outOutletBindingList += ![@regularControllerBinding new
          !bindingName
          !controllerName
          !controllerObservablePropertyName
          !outletBindingOptionList
          !namesCountOption
        ] ;
      end select ;
    or
      $Identifier$ ?@lstring preferenceName ;
      $.$ ;
      $identifier$ ? @lstring preferenceObservablePropertyName ;
      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
      outOutletBindingList += ![@regularPreferenceBinding new
        !bindingName
        !preferenceName
        !preferenceObservablePropertyName
        !outletBindingOptionList
      ] ;
    end select ;
  end repeat ;
end rule ;

#----------------------------------------------------------------------------*

rule <outlet_declaration>
  ?!@outletDeclarationList ioOutletDeclarationList
:
  $outlet$ ;
  $Identifier$ ? @lstring outletTypeName ;
  $identifier$ ? @lstring outletName ;
  <bindings> ?@bindingList outletBindingList ;
  $;$ ;
  ioOutletDeclarationList += !outletTypeName !outletName !outletBindingList ;
end rule ;

#----------------------------------------------------------------------------*

rule <action_declaration>
  ?!@lstringlist ioActionDeclarationList
:
  $action$ ;
  $identifier$ ? @lstring actionName ;
  $;$ ;
  ioActionDeclarationList += !actionName ;
end rule ;

#----------------------------------------------------------------------------*

rule <preferences_declaration>
  ?!@preferencesDeclarationList ioPreferencesList
:
  $preferences$ ;
  $Identifier$ ? @lstring preferencesName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  @transientList transientList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @controllerList controllerList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <controller_declaration> !?controllerList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
  ioPreferencesList +=
    !preferencesName
    !outletDeclarationList
    !attributeList
    !transientList
    !actionDeclarationList
    !controllerList
    !classArrayList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <array_declaration>
  ?!@classArrayList ioClassArrayList
:
  $array$ ;
  $Identifier$ ?@lstring className ;
  $identifier$ ?@lstring arrayName ;
  $;$ ;
  ioClassArrayList += !className !arrayName ;
end rule ;

#----------------------------------------------------------------------------*

rule <document_declaration>
  ?!@documentDeclarationList ioDocumentList
:
  $document$ ;
  $Identifier$ ? @lstring preferencesName ;
  $root$ ;
  $Identifier$ ? @lstring rootEntityName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @controllerList controllerList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @transientList transientList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <controller_declaration> !?controllerList ;
  end repeat ;
  $}$ ;
  ioDocumentList +=
    !preferencesName
    !rootEntityName
    !outletDeclarationList
    !controllerList
    !actionDeclarationList
    !transientList
    !attributeList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <explicit_value>
  !@abstractDefaultValue outDefaultValue
:
  select
    $YES$ ;
    outDefaultValue := [@boolAsDefaultValue new ![@lbool new !true !here]] ;
  or
    $NO$ ;
    outDefaultValue := [@boolAsDefaultValue new ![@lbool new !false !here]] ;
  or
    $literal_integer$ ? @luint integerValue ;
    outDefaultValue := [@integerAsDefaultValue new !integerValue] ;
  or
    $literal_double$ ? @ldouble doubleValue ?* ;
    outDefaultValue := [@doubleAsDefaultValue new !doubleValue] ;
  or
    $literal_string$ ?@lstring stringValue ;
    outDefaultValue := [@stringAsDefaultValue new !stringValue] ;
  or
    $identifier$ ? @lstring stringValue ;
    outDefaultValue := [@identifierAsDefaultValue new !stringValue] ;
  or
    $($ ;
    const @location startLocation := here ;
    @defaultValueList defaultValueList [emptyList] ;
    repeat
      <explicit_value> ?@abstractDefaultValue defaultValue ;
      defaultValueList += !defaultValue ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
    outDefaultValue := [@listAsDefaultValue new !startLocation !defaultValueList] ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <class_declaration>
  ?!@classList ioClassList
:
  $class$ ;
  $Identifier$ ? @lstring className ;
  @lstring superClassName ;
  select
    superClassName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superClassName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  end repeat ;
  $}$ ;
  ioClassList += !className !superClassName !attributeList !classTransientList ;
end rule ;

#----------------------------------------------------------------------------*

rule <attribute_declaration>
  ?!@attributeList ioAttributeList
:
  $attribute$ ;
  @attributeASTType propertyType ;
  select
    $Identifier$ ? @lstring typeName ;
    propertyType := [@namedASTType new !typeName] ;
  or
    <attribute_type> ?propertyType ;
  end select ;
  $identifier$ ? @lstring propertyName ;
  $default$ ;
  <explicit_value> ?@abstractDefaultValue defaultValue ;
  $;$ ;
  ioAttributeList +=
    !propertyType
    !propertyName
    !defaultValue
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <transient_declaration>
  ?!@transientList ioTransientList
:
  $transient$ ;
  <attribute_type> ?@attributeASTType type ;
  $identifier$ ? @lstring transientName ;
  $dependsFrom$ ;
  @dependanceList dependanceList [emptyList] ;
  repeat
    select
      $root$ ;
      $.$ ;
      $signature$ ;
      dependanceList += ![@transientRootSignDependency new !here] ;
    or
      $self$ ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      dependanceList += ![@transientLocalDependency new !masterName] ;
    or
      $root$ ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      <count_option> ?@bool namesCountOption ;
      dependanceList += ![@transientRootDependency new !masterName !namesCountOption] ;
    or
      $identifier$ ?@lstring controllerName ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      dependanceList += ![@transientControllerDependency new !controllerName !masterName] ;
    or
      $Identifier$ ?@lstring preferenceName ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      dependanceList += ![@transientPreferenceDependency new !preferenceName !masterName] ;
    end select ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
  ioTransientList += !type !transientName !dependanceList ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $controller$ ;
  $Identifier$ ? @lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind simpleController]
    !controllerClassName
    !controllerName
    ![@lbool new !false !here] # Any value, no controlled object
    ![@lstring new !"" ! here] # No controlled Object
    ![@outletBindingOptionList emptyList]
    !controllerBindingList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $arrayController$ ;
  $Identifier$ ?@lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind arrayController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $entityArrayController$ ;
  $Identifier$ ?@lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind entityArrayController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $objectController$ ;
  $Identifier$ ? @lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind objectController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $entityController$ ;
  $Identifier$ ? @lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind entityController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <entity_declaration>
  ?!@entityList ioEntityList
:
  $entity$ ;
  $Identifier$ ? @lstring entityName ;
  @lstring superEntityName ;
  select
    superEntityName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superEntityName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  @relationshipList relationshipList [emptyList] ;
  @lstringlist signList [emptyList] ;
  repeat
  while
    $signature$ ;
    repeat
      $identifier$ ? @lstring propertyName ;
      signList += !propertyName ;
    while
      $,$ ;
    end repeat ;
    $;$ ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  while
    @bool isToMany ;
    select
      $toOne$ ;
      isToMany := false ;
    or
      $toMany$ ;
      isToMany := true ;
    end select ;
    $Identifier$ ? @lstring destinationEntityName ;
    $identifier$ ? @lstring relationshipName ;
    $inverse$ ;
    @bool inverseIsToMany ;
    select
      $toOne$ ;
      inverseIsToMany := false ;
    or
      $toMany$ ;
      inverseIsToMany := true ;
    end select ;
    $identifier$ ? @lstring inverseRelationshipName ;
    @deleteRuleEnum deleteRule ;
    select
      $nullify$ ;
      deleteRule := [@deleteRuleEnum nullifyDeleteRule] ;
    or
      $cascade$ ;
      deleteRule := [@deleteRuleEnum cascadeDeleteRule] ;
    or
      $deny$ ;
      deleteRule := [@deleteRuleEnum denyDeleteRule] ;
    end select ;
    $;$ ;
    relationshipList +=
      !isToMany
      !destinationEntityName
      !relationshipName
      !inverseRelationshipName
      !inverseIsToMany
      !deleteRule
    ;
  end repeat ;
  $}$ ;
  ioEntityList +=
    !entityName
    !superEntityName
    !attributeList
    !classTransientList
    !relationshipList
    !signList
   ;
end rule ;

#----------------------------------------------------------------------------*

rule <attribute_type>
  !@attributeASTType outAttributeType
:
  select
    $bool$ ;
    outAttributeType := [@boolASTType new] ;
  or
    $integer$ ;
    outAttributeType := [@integerASTType new] ;
  or
    $double$ ;
    outAttributeType := [@doubleASTType new] ;
  or
    $decimal$ ;
    outAttributeType := [@decimalASTType new] ;
  or
    $NSString$ ;
    outAttributeType := [@stringASTType new] ;
  or
    $NSFont$ ;
    outAttributeType := [@fontASTType new] ;
  or
    $NSImage$ ;
    outAttributeType := [@imageASTType new] ;
  or
    $NSColor$ ;
    outAttributeType := [@colorASTType new] ;
  or
    $NSData$ ;
    outAttributeType := [@dataASTType new] ;
  or
    $NSDate$ ;
    outAttributeType := [@dateASTType new] ;
  or
    $NSValue$ ;
    outAttributeType := [@valueASTType new] ;
  or
    $NSArray$ ;
    outAttributeType := [@arrayASTType new] ;
  or
    $NSBezierPath$ ;
    outAttributeType := [@bezierASTType new] ;
  or
    $NSMenu$ ;
    outAttributeType := [@menuASTType new] ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <type_list>
  !@attributeASTTypeList outEasyBindingTypeList
:
  outEasyBindingTypeList := [@attributeASTTypeList emptyList] ;
  repeat
    select
      @attributeASTType bindingType ;
      <attribute_type> ? bindingType ;
      outEasyBindingTypeList += !bindingType ;
    or
      $int$ ;
      outEasyBindingTypeList += ![@integerASTType new] ;
      outEasyBindingTypeList += ![@uintegerASTType new] ;
      outEasyBindingTypeList += ![@anyEnumASTType new] ;
    or
      $number$ ;
      outEasyBindingTypeList += ![@integerASTType new] ;
      outEasyBindingTypeList += ![@uintegerASTType new] ;
      outEasyBindingTypeList += ![@decimalASTType new] ;
      outEasyBindingTypeList += ![@doubleASTType new] ;
      outEasyBindingTypeList += ![@anyEnumASTType new] ;
    end select ;
  while
    $,$ ;
  end repeat ;
end rule ;

#----------------------------------------------------------------------------*

rule <formatter> 
  !@formatterEnum outRequiredFormatter
:
  select
    outRequiredFormatter := [@formatterEnum noFormatter] ;
  or
    $NSDateFormatter$ ;
    outRequiredFormatter := [@formatterEnum dateFormatter] ;
  or
    $NSNumberFormatter$ ;
    outRequiredFormatter := [@formatterEnum numberFormatter] ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <type_formatter_list>
  !@attributeASTTypeAndFormatterList outEasyBindingTypeFormatterList
:
  outEasyBindingTypeFormatterList := [@attributeASTTypeAndFormatterList emptyList] ;
  repeat
    select
      @attributeASTType bindingType ;
      <attribute_type> ? bindingType ;
      <formatter> ?@formatterEnum requiredFormatter ;
      outEasyBindingTypeFormatterList += !bindingType !requiredFormatter ;
    or
      $int$ ;
      <formatter> ?@formatterEnum requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@integerASTType new] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@uintegerASTType new] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@anyEnumASTType new] !requiredFormatter  ;
    or
      $number$ ;
      <formatter> ?@formatterEnum requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@integerASTType new] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@uintegerASTType new] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@decimalASTType new] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@doubleASTType new] !requiredFormatter ;
      outEasyBindingTypeFormatterList += ![@anyEnumASTType new] !requiredFormatter  ;
    end select ;
  while
    $,$ ;
  end repeat ;
end rule ;

#----------------------------------------------------------------------------*

rule <outlet_class_declaration>
  ?!@outletClassList ioOutletClassList
:
  @generationKind generationKind ;
  select
    generationKind := [@generationKind fullGeneration] ;
  or
    $extern$ ;
    generationKind := [@generationKind generateImport] ;
  or
    $predefined$ ;
    generationKind := [@generationKind noGeneration] ;
  end select ;
  $outletClass$ ;
  $Identifier$ ? @lstring outletClassName ;
  @lstring superClass ;
  select
    superClass := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ?superClass ;
  end select ;
  @lstringlist adoptedProtocolList [emptyList] ;
  select
  or
    $<$ ;
    repeat
      $Identifier$ ? @lstring protocolName ;
      adoptedProtocolList += !protocolName ;
    while
      $,$ ;
    end repeat ;
    $>$ ;
  end select ;
  ${$ ;
  @outletClassBindingList outletClassBindingList [emptyList] ;
  @lstringlist optionList [emptyList] ;
  @bool hasTableValueBinding := false ;
  repeat
  while
    $option$ ;
    $literal_string$ ?@lstring optionValue ;
    optionList += !optionValue ;
    $;$ ;
  while
    $tableValue$ ;
    $;$ ;
    hasTableValueBinding := true ;
  while
    @lstring bindingName ;
    select
      $binding$ ? bindingName ;
    or
      $hidden$ ;
      bindingName := [@lstring new !"hidden" !here] ;
    or
      $editable$ ;
      bindingName := [@lstring new !"editable" !here] ;
    or
      $enabled$ ;
      bindingName := [@lstring new !"enabled" !here] ;
    end select ;
    $:$ ;
    <type_formatter_list> ?@attributeASTTypeAndFormatterList easyBindingTypeFormatterList ;
    @bindingOptionList bindingOptionList [emptyList] ;
    select
      $;$ ;
    or
      ${$ ;
      repeat
      while
        $Identifier$ ? @lstring optionName ;
        $:$ ;
        <type_list> ?@attributeASTTypeList optionTypeList ;
        $;$ ;
        bindingOptionList += !optionName !optionTypeList ;
      end repeat ;
    $}$ ;
    end select ;
    outletClassBindingList += !bindingName !easyBindingTypeFormatterList !bindingOptionList ;
  end repeat ;
  $}$ ;
  ioOutletClassList +=
    !outletClassName
    !superClass
    !adoptedProtocolList
    !generationKind
    !outletClassBindingList
    !hasTableValueBinding
    !optionList
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <protocol_declaration>
  ?!@protocolList ioProtocolList
:
  @bool isPredefined ;
  select
    $extern$ ; isPredefined := false ;
  or
    $predefined$ ; isPredefined := true ;
  end select ;
  $protocol$ ;
  $Identifier$ ? @lstring protocolName ;
  $;$ ;
  ioProtocolList += !isPredefined !protocolName ;
end rule ;

#----------------------------------------------------------------------------*

rule <cursor_declaration>
  ?!@cursorList ioCursorList
:
  $cursor$ ;
  $identifier$ ? @lstring cursorName ;
  $($ ;
  $literal_double$ ?@ldouble hotSpotX ?* ;
  $,$ ;
  $literal_double$ ?@ldouble hotSpotY ?* ;
  $)$ ;
  $;$ ;
  ioCursorList += !cursorName !hotSpotX !hotSpotY ;
end rule ;

#----------------------------------------------------------------------------*

rule <enum_declaration>
  ?!@enumList ioEnumList
:
  $enum$ ;
  $Identifier$ ? @lstring enumName ;
  ${$ ;
  @lstringlist enumConstants [emptyList] ;
  repeat
    $identifier$ ? @lstring constantName ;
    enumConstants += !constantName ;
  while
    $,$ ;
  end repeat ;
  $}$ ;
  ioEnumList += !enumName !enumConstants ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_class_declaration>
  ?!@controllerClassList ioControllerClassList
:
  @generationKind generationKind ;
  select
    generationKind := [@generationKind fullGeneration] ;
  or
    $predefined$ ;
    generationKind := [@generationKind noGeneration] ;
  or
    $extern$ ;
    generationKind := [@generationKind generateImport] ;
  end select ;
  @controllerKind controllerKind ;
  @lstring controllerClassName ;
  @bindingOptionList controlledObjectBindingOptionList [emptyList] ;
  select
    $controller$ ;
    controllerKind := [@controllerKind simpleController] ;
    $Identifier$ ?controllerClassName ;
  or
    $objectController$ ;
    controllerKind := [@controllerKind objectController] ;
    $Identifier$ ?controllerClassName ;
    ${$ ;
    repeat
    while
      $Identifier$ ? @lstring optionName ;
      $:$ ;
      <type_list> ?@attributeASTTypeList optionTypeList ;
      $;$ ;
      controlledObjectBindingOptionList += !optionName !optionTypeList ;
    end repeat ;
    $}$ ;
  or
    $entityController$ ;
    controllerKind := [@controllerKind entityController] ;
    $Identifier$ ?controllerClassName ;
    ${$ ;
    repeat
    while
      $Identifier$ ? @lstring optionName ;
      $:$ ;
      <type_list> ?@attributeASTTypeList optionTypeList ;
      $;$ ;
      controlledObjectBindingOptionList += !optionName !optionTypeList ;
    end repeat ;
    $}$ ;
  or
    $arrayController$ ;
    controllerKind := [@controllerKind arrayController] ;
    $Identifier$ ?controllerClassName ;
    ${$ ;
    repeat
    while
      $Identifier$ ? @lstring optionName ;
      $:$ ;
      <type_list> ?@attributeASTTypeList optionTypeList ;
      $;$ ;
      controlledObjectBindingOptionList += !optionName !optionTypeList ;
    end repeat ;
    $}$ ;
  or
    $entityArrayController$ ;
    controllerKind := [@controllerKind entityArrayController] ;
    $Identifier$ ?controllerClassName ;
    ${$ ;
    repeat
    while
      $Identifier$ ? @lstring optionName ;
      $:$ ;
      <type_list> ?@attributeASTTypeList optionTypeList ;
      $;$ ;
      controlledObjectBindingOptionList += !optionName !optionTypeList ;
    end repeat ;
    $}$ ;
  end select ;
  ${$ ;
  @outletClassBindingList controllerClassBindingList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @controllerObservablePropertyList controllerObservablePropertyList [emptyList] ;
  repeat
  while
    $attribute$ ;
    <attribute_type> ?@attributeASTType attributeType ;
    $identifier$ ? @lstring attributeName ;
    $;$ ;
    controllerObservablePropertyList += !attributeType !attributeName ;
  while
    <action_declaration> !?actionDeclarationList ;
  while
    @lstring bindingName ;
    select
      $binding$ ? bindingName ;
    or
      $hidden$ ;
      bindingName := [@lstring new !"hidden" !here] ;
    or
      $editable$ ;
      bindingName := [@lstring new !"editable" !here] ;
    or
      $enabled$ ;
      bindingName := [@lstring new !"enabled" !here] ;
    end select ;
    $:$ ;
    <type_formatter_list> ?@attributeASTTypeAndFormatterList easyBindingTypeFormatterList ;
    @bindingOptionList bindingOptionList [emptyList] ;
    select
      $;$ ;
    or
      ${$ ;
      repeat
      while
        $Identifier$ ? @lstring optionName ;
        $:$ ;
        <type_list> ?@attributeASTTypeList optionTypeList ;
        $;$ ;
        bindingOptionList += !optionName !optionTypeList ;
      end repeat ;
      $}$ ;
    end select ;
    controllerClassBindingList += !bindingName !easyBindingTypeFormatterList !bindingOptionList ;
  end repeat ;
  $}$ ;
  ioControllerClassList +=
    !controllerKind
    !controllerClassName
    !controlledObjectBindingOptionList
    !generationKind
    !controllerClassBindingList
    !actionDeclarationList
    !controllerObservablePropertyList
  ;
end rule ;

#----------------------------------------------------------------------------*

end syntax ;
