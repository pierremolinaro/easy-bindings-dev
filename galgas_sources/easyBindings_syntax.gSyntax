syntax easyBindings_syntax ("easyBindings_lexique.gLexique") :
import "easyBindings_options.gOption" ;
import "abstractSyntaxTypes.gSemantics" ;
import "easyBindings_grammar.gGrammar" ;

#----------------------------------------------------------------------------*

rule <start_symbol>
  ??@bool inIsUserDefined
  ?!@astDeclarationList ioDeclarationList
  ?!@cursorList ioCursorList
  ?!@outletClassDeclarationList ioOutletClassDeclarationList
  !@location outEndOfFile
:
  repeat
  while
    $include$ ;
    $literal_string$ ?@lstring filePath ;
    $;$ ;
    const sourceFile := [@lstring new
      ![filePath->string absolutePathFromPath ![[@string stringWithSourceFilePath] stringByDeletingLastPathComponent]]
      !filePath->location
    ] ;
    grammar easyBindings_grammar in sourceFile
      !userDefined:inIsUserDefined
      !?ioDeclarationList
      !?ioCursorList
      !?ioOutletClassDeclarationList
      ?*
    ;
#  while
#    <struct_declaration> !inIsUserDefined !?ioDeclarationList ;
#  while
#    <enum_declaration> !inIsUserDefined !?ioDeclarationList ;
#  while
#    <cursor_declaration> !?ioCursorList ;
#  while
#    <protocol_declaration> !inIsUserDefined !?ioDeclarationList ;
  while
    <class_declaration> !inIsUserDefined !?ioDeclarationList ;
  while
    <entity_declaration>  !inIsUserDefined  !?ioDeclarationList ;
  while
    <nib_class_declaration>  !inIsUserDefined  !?ioDeclarationList ;
  while
    <preferences_declaration> !inIsUserDefined !?ioDeclarationList ;
  while
    <document_declaration> !inIsUserDefined !?ioDeclarationList ;
  while
    <outlet_class_declaration> !inIsUserDefined !?ioOutletClassDeclarationList ;
#  while
#    <controller_class_declaration> !inIsUserDefined ?@EXcontrollerClassDeclaration declaration !?ioDeclarationList ;
#    ioEXDeclarationList += !declaration ;
  end repeat ;
  outEndOfFile := here ;
  $end$ ;
end rule ;

#----------------------------------------------------------------------------*

#rule <struct_declaration>
#  ??@bool inIsUserDefined
#  ?!@astDeclarationList ioDeclarationList
#:
#  $struct$ ;
#  $Identifier$ ? @lstring structName ;
#  @structFieldASTList structFieldList [emptyList] ;
#  ${$ ;
#  repeat
#    $Identifier$ ?@lstring fieldTypeName ;
#    $identifier$ ?@lstring fieldName ;
#    structFieldList += !fieldTypeName !fieldName ;
#  while
#    $,$ ;
#  end repeat ;
#  $}$ ;
#  ioDeclarationList += ![@structDeclaration new
#    !inIsUserDefined
#    !structName
#    !structFieldList
#  ] ;
#end rule ;

#----------------------------------------------------------------------------*

rule <binding_options>
  !@outletBindingOptionList outBindingOptionList
:
  outBindingOptionList := [@outletBindingOptionList emptyList] ;
  select
  or
    ${$ ;
    repeat
      $Identifier$ ? @lstring optionName ;
      $:$ ;
      <explicit_value> ?@abstractDefaultValue defaultValue ;
      outBindingOptionList +=
        !optionName
        !defaultValue
      ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <count_option>
  !@bool outCountOptionOn
:
  select
    outCountOptionOn := false ;
  or
    $.$ ;
    $count$ ;
    outCountOptionOn := true ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <multi_value_binding_element>
  ?!@multiValuedBindingList ioMultiValuedBindingList
:
  @bool negate ;
  select
    negate := false ;
  or
    $!$ ;
    negate := true ;
  end select ;
  @multiValuedBindingBoundModel boundModel ;
  select
    $self$ ;
    $.$ ;
    $identifier$ ?@lstring boundPropertyName ;
    boundModel := [@multiValuedBindingBoundToSelf new !boundPropertyName] ;
  or
    $root$ ;
    $.$ ;
    $identifier$ ?@lstring boundPropertyName ;
    boundModel := [@multiValuedBindingBoundToRoot new !boundPropertyName] ;
  or
    $identifier$ ?@lstring controllerName ;
    $.$ ;
    select
      $selection$ ;
      $.$ ;
      $identifier$ ? @lstring boundPropertyName ;
      boundModel := [@multiValuedBindingBoundToControllerSelection new !boundPropertyName !controllerName] ;
    or
      $identifier$ ?@lstring boundPropertyName ;
      boundModel := [@multiValuedBindingBoundToController new !boundPropertyName !controllerName] ;
    end select ;
  or
    $Identifier$ ?@lstring preferenceName ;
    $.$ ;
    $identifier$ ?@lstring boundPropertyName ;
    boundModel := [@multiValuedBindingBoundToPref new !boundPropertyName !preferenceName] ;
  end select ;
  <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
  ioMultiValuedBindingList += !negate !boundModel !outletBindingOptionList ;
end rule ;

#----------------------------------------------------------------------------*

rule <enabled_editable_bindings>
  ?!@bindingList ioBindingList
:
  @lstring bindingName ;
  select
    $enabled$ ;
    bindingName := [@lstring new !"enabled" !here] ;
  or
    $editable$ ;
    bindingName := [@lstring new !"editable" !here] ;
  end select ;
  @multiValuedBindingList multiValuedBindingList [emptyList] ;
  repeat
    <multi_value_binding_element> !?multiValuedBindingList ;
  while
    $&$ ;
  end repeat ;
  ioBindingList += ![@multiValuedBinding new
    !bindingName
    !multiValuedBindingList
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <bindings>
  !@bindingList outOutletBindingList
:
  outOutletBindingList := [@bindingList emptyList] ;
  repeat
  while
    <enabled_editable_bindings> !?outOutletBindingList ;
  while
    $hidden$ ;
    const bindingName := [@lstring new !"hidden" !here] ;
    @multiValuedBindingList multiValuedBindingList [emptyList] ;
    repeat 
      <multi_value_binding_element> !?multiValuedBindingList ;
    while
      $|$ ;
    end repeat ;
    outOutletBindingList += ![@multiValuedBinding new
      !bindingName
      !multiValuedBindingList
    ] ;
  while
    $run$ ;
    @lstring targetName ;
    select
      $self$ ;
      targetName := [@lstring new !"self" !here] ;
    or
      $identifier$ ?targetName ;
    end select ;
    $.$ ;
    $identifier$ ?@lstring actionName ;
    outOutletBindingList += ![@runBinding new
      !targetName
      !actionName
    ] ;
  while
    $tableValue$ ;
    $identifier$ ?@lstring controllerName ;
    ${$ ;
    @tableValueColumnBinding tableValueColumnBinding [emptyList] ;
    repeat
    while
      $column$ ;
      $literal_string$ ?@lstring columnName ;
      $Identifier$ ?@lstring cellTypeName ;
      $identifier$ ?@lstring boundPropertyName ;
      tableValueColumnBinding += !columnName !cellTypeName !boundPropertyName ;
      $;$ ;
    end repeat ;
    outOutletBindingList += ![@tableValueBinding new !controllerName !tableValueColumnBinding] ;
    $}$ ;
  while
    $binding$ ? @lstring bindingName ;
    select
      $root$ ;
      $.$ ;
      $identifier$ ? @lstring rootObservablePropertyName ;
      <count_option> ?@bool namesCountOption ;
      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
      outOutletBindingList += ![@regularRootBinding new
        !bindingName
        !rootObservablePropertyName
        !outletBindingOptionList
        !namesCountOption
      ] ;
    or
      $self$ ;
      $.$ ;
      $identifier$ ? @lstring rootObservablePropertyName ;
      <count_option> ?@bool namesCountOption ;
      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
      outOutletBindingList += ![@regularSelfBinding new
        !bindingName
        !rootObservablePropertyName
        !outletBindingOptionList
        !namesCountOption
      ] ;
    or
      $identifier$ ? @lstring controllerName ;
      $.$ ;
      select
        $selection$ ;
        $.$ ;
        $identifier$ ? @lstring controllerObservablePropertyName ;
        <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
        outOutletBindingList += ![@regularControllerSelectionBinding new
          !bindingName
          !controllerName
          !controllerObservablePropertyName
          !outletBindingOptionList
        ] ;
      or
        $identifier$ ? @lstring controllerObservablePropertyName ;
        <count_option> ?@bool namesCountOption ;
        <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
        outOutletBindingList += ![@regularControllerBinding new
          !bindingName
          !controllerName
          !controllerObservablePropertyName
          !outletBindingOptionList
          !namesCountOption
        ] ;
      end select ;
    or
      $Identifier$ ?@lstring preferenceName ;
      $.$ ;
      $identifier$ ? @lstring preferenceObservablePropertyName ;
      <binding_options> ?@outletBindingOptionList outletBindingOptionList ;
      outOutletBindingList += ![@regularPreferenceBinding new
        !bindingName
        !preferenceName
        !preferenceObservablePropertyName
        !outletBindingOptionList
      ] ;
    end select ;
  end repeat ;
end rule ;

#----------------------------------------------------------------------------*

rule <outlet_declaration>
  ?!@outletDeclarationList ioOutletDeclarationList
:
  $outlet$ ;
  $Identifier$ ? @lstring outletTypeName ;
  $identifier$ ? @lstring outletName ;
  <bindings> ?@bindingList outletBindingList ;
  $;$ ;
  ioOutletDeclarationList += !outletTypeName !outletName !outletBindingList ;
end rule ;

#----------------------------------------------------------------------------*

rule <action_declaration>
  ?!@lstringlist ioActionDeclarationList
:
  $action$ ;
  $identifier$ ? @lstring actionName ;
  $;$ ;
  ioActionDeclarationList += !actionName ;
end rule ;

#----------------------------------------------------------------------------*

rule <preferences_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationList ioDeclarationList
:
  $preferences$ ;
  $Identifier$ ? @lstring preferencesName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  @transientList transientList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @controllerList controllerList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <controller_declaration> !?controllerList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
  ioDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !preferencesName
    ![@typeKind preferencesType]
    !["" nowhere] # NoSuper type
    !outletDeclarationList
    !["" nowhere] # No root entity
    !attributeList
    !@relationshipList {}
    !classArrayList
    !transientList
    !controllerList
    !actionDeclarationList
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <nib_class_declaration>
  ??@bool unused inIsUserDefined
  ?!@astDeclarationList unused ioDeclarationList
:
  $nibClass$ ;
  $Identifier$ ? @lstring preferencesName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  @transientList transientList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @controllerList controllerList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <controller_declaration> !?controllerList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
end rule ;

#----------------------------------------------------------------------------*

rule <array_declaration>
  ?!@classArrayList ioClassArrayList
:
  $array$ ;
  $Identifier$ ?@lstring className ;
  $identifier$ ?@lstring arrayName ;
  $;$ ;
  ioClassArrayList += !className !arrayName ;
end rule ;

#----------------------------------------------------------------------------*

rule <document_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationList ioDeclarationList
:
  $document$ ;
  $Identifier$ ? @lstring documentName ;
  $root$ ;
  $Identifier$ ? @lstring rootEntityName ;
  ${$ ;
  @outletDeclarationList outletDeclarationList [emptyList] ;
  @controllerList controllerList [emptyList] ;
  @lstringlist actionDeclarationList [emptyList] ;
  @transientList transientList [emptyList] ;
  @attributeList attributeList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <action_declaration> !?actionDeclarationList ;
  while
    <transient_declaration> !?transientList ;
  while
    <outlet_declaration> !?outletDeclarationList ;
  while
    <controller_declaration> !?controllerList ;
  end repeat ;
  $}$ ;
  ioDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !documentName
    ![@typeKind documentType]
    !["" nowhere] # No super type
    !@outletDeclarationList {}
    !rootEntityName
    !attributeList
    !@relationshipList {}
    !@classArrayList {}
    !transientList
    !controllerList
    !actionDeclarationList
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <explicit_value>
  !@abstractDefaultValue outDefaultValue
:
  select
    $YES$ ;
    outDefaultValue := [@boolAsDefaultValue new ![@lbool new !true !here]] ;
  or
    $NO$ ;
    outDefaultValue := [@boolAsDefaultValue new ![@lbool new !false !here]] ;
  or
    $literal_integer$ ? @luint integerValue ;
    outDefaultValue := [@integerAsDefaultValue new !integerValue] ;
  or
    $literal_double$ ? @ldouble doubleValue ?* ;
    outDefaultValue := [@doubleAsDefaultValue new !doubleValue] ;
  or
    $literal_string$ ?@lstring stringValue ;
    outDefaultValue := [@stringAsDefaultValue new !stringValue] ;
  or
    $identifier$ ? @lstring stringValue ;
    outDefaultValue := [@identifierAsDefaultValue new !stringValue] ;
  or
    $($ ;
    const @location startLocation := here ;
    @defaultValueList defaultValueList [emptyList] ;
    repeat
      <explicit_value> ?@abstractDefaultValue defaultValue ;
      defaultValueList += !defaultValue ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
    outDefaultValue := [@listAsDefaultValue new !startLocation !defaultValueList] ;
  end select ;
end rule ;

#----------------------------------------------------------------------------*

rule <class_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationList ioDeclarationList
:
  $class$ ;
  $Identifier$ ? @lstring className ;
  @lstring superClassName ;
  select
    superClassName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superClassName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  @classArrayList classArrayList [emptyList] ;
  repeat
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  while
    <array_declaration> !?classArrayList ;
  end repeat ;
  $}$ ;
  ioDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !className
    ![@typeKind classType]
    !superClassName
    !@outletDeclarationList {}
    !["" nowhere] # No root entity
    !attributeList
    !@relationshipList {}
    !classArrayList
    !classTransientList
    !@controllerList {}
    !@lstringlist {} # No action
  ] ;
end rule ;

#----------------------------------------------------------------------------*

rule <attribute_declaration>
  ?!@attributeList ioAttributeList
:
  $attribute$ ;
  $Identifier$ ?@lstring attributeTypeName ;
  $identifier$ ?@lstring attributeName ;
  $default$ ;
  <explicit_value> ?@abstractDefaultValue defaultValue ;
  $;$ ;
  ioAttributeList +=
    !attributeTypeName
    !attributeName
    !defaultValue
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <transient_declaration>
  ?!@transientList ioTransientList
:
  $transient$ ;
  $Identifier$ ?@lstring transientTypeName ;
  $identifier$ ? @lstring transientName ;
  $dependsFrom$ ;
  @dependanceList dependanceList [emptyList] ;
  repeat
    select
      $root$ ;
      $.$ ;
      $signature$ ;
      dependanceList += ![@transientRootSignDependency new !here] ;
    or
      $self$ ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      <count_option> ?@bool namesCountOption ;
      dependanceList += ![@transientLocalDependency new !masterName !namesCountOption] ;
    or
      $root$ ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      <count_option> ?@bool namesCountOption ;
      dependanceList += ![@transientRootDependency new !masterName !namesCountOption] ;
    or
      $identifier$ ?@lstring controllerName ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      dependanceList += ![@transientControllerDependency new !controllerName !masterName] ;
    or
      $Identifier$ ?@lstring preferenceName ;
      $.$ ;
      $identifier$ ? @lstring masterName ;
      dependanceList += ![@transientPreferenceDependency new !preferenceName !masterName] ;
    end select ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
  ioTransientList += !transientTypeName !transientName !dependanceList ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioTreeControllerList
:
  $treeController$ ;
  $Identifier$ ?@lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $($ ;
  $identifier$ ? @lstring childRelationshipName ;
  $)$ ;
  $;$ ;
  ioTreeControllerList +=
    ![@controllerKind treeController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
    !childRelationshipName
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $controller$ ;
  $Identifier$ ? @lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind simpleController]
    !controllerClassName
    !controllerName
    ![@lbool new !false !here] # Any value, no controlled object
    ![@lstring new !"" ! here] # No controlled Object
    ![@outletBindingOptionList emptyList]
    !controllerBindingList
    !["" nowhere]
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $arrayController$ ;
  $Identifier$ ?@lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind arrayController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
    !["" nowhere]
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $entityArrayController$ ;
  $Identifier$ ?@lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind entityArrayController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
    !["" nowhere]
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $objectController$ ;
  $Identifier$ ? @lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind objectController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
    !["" nowhere]
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <controller_declaration>
  ?!@controllerList ioControllerList
:
  $entityController$ ;
  $Identifier$ ? @lstring controllerClassName ;
  $identifier$ ? @lstring controllerName ;
  $:$ ;
  @lbool isRoot ;
  select
    $root$ ;
    isRoot := [@lbool new !true !here] ;
  or
    $self$ ;
    isRoot := [@lbool new !false !here] ;
  end select ;
  $.$ ;
  $identifier$ ?@lstring controlledObject ;
  <binding_options> ?@outletBindingOptionList controlledObjectBindingOptionList ;
  <bindings> ?@bindingList controllerBindingList ;
  $;$ ;
  ioControllerList +=
    ![@controllerKind entityController]
    !controllerClassName
    !controllerName
    !isRoot
    !controlledObject
    !controlledObjectBindingOptionList
    !controllerBindingList
    !["" nowhere]
  ;
end rule ;

#----------------------------------------------------------------------------*

rule <entity_declaration>
  ??@bool inIsUserDefined
  ?!@astDeclarationList ioDeclarationList
:
  $entity$ ;
  $Identifier$ ? @lstring entityName ;
  @lstring superEntityName ;
  select
    superEntityName := ["" nowhere] ;
  or
    $:$ ;
    $Identifier$ ? superEntityName ;
  end select ;
  ${$ ;
  @attributeList attributeList [emptyList] ;
  @transientList classTransientList [emptyList] ;
  @relationshipList relationshipList [emptyList] ;
  @lstringlist signList [emptyList] ;
  repeat
  while
    $signature$ ;
    repeat
      $identifier$ ? @lstring propertyName ;
      signList += !propertyName ;
    while
      $,$ ;
    end repeat ;
    $;$ ;
  while
    <attribute_declaration> !?attributeList ;
  while
    <transient_declaration> !?classTransientList ;
  while
    @bool isToMany ;
    select
      $toOne$ ;
      isToMany := false ;
    or
      $toMany$ ;
      isToMany := true ;
    end select ;
    $Identifier$ ? @lstring destinationEntityName ;
    $identifier$ ? @lstring relationshipName ;
    $inverse$ ;
    @bool inverseIsToMany ;
    select
      $toOne$ ;
      inverseIsToMany := false ;
    or
      $toMany$ ;
      inverseIsToMany := true ;
    end select ;
    $identifier$ ? @lstring inverseRelationshipName ;
    @deleteRuleEnum deleteRule ;
    select
      $nullify$ ;
      deleteRule := [@deleteRuleEnum nullifyDeleteRule] ;
    or
      $cascade$ ;
      deleteRule := [@deleteRuleEnum cascadeDeleteRule] ;
    or
      $deny$ ;
      deleteRule := [@deleteRuleEnum denyDeleteRule] ;
    end select ;
    $;$ ;
    relationshipList +=
      !isToMany
      !destinationEntityName
      !relationshipName
      !inverseRelationshipName
      !inverseIsToMany
      !deleteRule
    ;
  end repeat ;
  $}$ ;
  ioDeclarationList += ![@unifiedTypeDeclaration new
    !inIsUserDefined
    !entityName
    ![@typeKind entityType]
    !superEntityName
    !@outletDeclarationList {}
    !["" nowhere] # No root entity
    !attributeList
    !relationshipList
    !@classArrayList {}
    !classTransientList
    !@controllerList {}
    !@lstringlist {} # No action
  ] ;
end rule ;

#----------------------------------------------------------------------------*

#rule <type_list>
#  !@lstringlist outEasyBindingTypeList
#:
#  outEasyBindingTypeList := [@lstringlist emptyList] ;
#  repeat
#    select
#      $Identifier$ ?@lstring bindingTypeName ;
#      outEasyBindingTypeList += !bindingTypeName ;
#    or
#      $AnyScalar$ ;
#      outEasyBindingTypeList += ![@lstring new !"Integer" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"UInteger" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"Bool" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"enum" !here] ;
#    or
#      $AnyNumber$ ;
#      outEasyBindingTypeList += ![@lstring new !"Double" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"Integer" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"UInteger" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"Bool" !here] ;
#      outEasyBindingTypeList += ![@lstring new !"enum" !here] ;
#    end select ;
#  while
#    $,$ ;
#  end repeat ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <formatter> 
#  !@formatterEnum outRequiredFormatter
#:
#  select
#    outRequiredFormatter := [@formatterEnum noFormatter] ;
#  or
#    $NSDateFormatter$ ;
#    outRequiredFormatter := [@formatterEnum dateFormatter] ;
#  or
#    $NSNumberFormatter$ ;
#    outRequiredFormatter := [@formatterEnum numberFormatter] ;
#  end select ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <type_formatter_list>
#  !@attributeASTTypeAndFormatterList outEasyBindingTypeFormatterList
#:
#  outEasyBindingTypeFormatterList := [@attributeASTTypeAndFormatterList emptyList] ;
#  repeat
#    select
#      $Identifier$ ?@lstring typeName ;
#      <formatter> ?@formatterEnum requiredFormatter ;
#      outEasyBindingTypeFormatterList += !typeName !requiredFormatter ;
#    or
#      $AnyScalar$ ;
#      <formatter> ?@formatterEnum requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Integer" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"UInteger" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Bool" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"enum" !here] !requiredFormatter ;
#    or
#      $AnyNumber$ ;
#      <formatter> ?@formatterEnum requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Double" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Integer" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"UInteger" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"Bool" !here] !requiredFormatter ;
#      outEasyBindingTypeFormatterList += ![@lstring new !"enum" !here] !requiredFormatter ;
#    end select ;
#  while
#    $,$ ;
#  end repeat ;
#end rule ;

#----------------------------------------------------------------------------*

rule <outlet_class_declaration>
  ??@bool inIsUserDefined
  ?!@outletClassDeclarationList ioOutletClassDeclarationList
:
  $outletClass$ ;
  $Identifier$ ??@lstring outletClassName ;
  $;$ ;
  ioOutletClassDeclarationList +=
    !inIsUserDefined
    !outletClassName
  ;
end rule ;

#----------------------------------------------------------------------------*

#rule <protocol_declaration>
#  ??@bool inIsUserDefined
#  !@protocolDeclaration outEXDeclaration
#  ?!@astDeclarationList unused ioDeclarationList
#:
#  @bool isPredefined ;
#  select
#    $extern$ ; isPredefined := false ;
#  or
#    $predefined$ ; isPredefined := true ;
#  end select ;
#  $protocol$ ;
#  $Identifier$ ? @lstring protocolName ;
#  $;$ ;
#  outEXDeclaration := [@protocolDeclaration new
#    !inIsUserDefined
#    !isPredefined
#    !protocolName
#  ] ;
#end rule ;
#
#----------------------------------------------------------------------------*

#rule <cursor_declaration>
#  ?!@cursorList ioCursorList
#:
#  $cursor$ ;
#  $identifier$ ? @lstring cursorName ;
#  $($ ;
#  $literal_double$ ?@ldouble hotSpotX ?* ;
#  $,$ ;
#  $literal_double$ ?@ldouble hotSpotY ?* ;
#  $)$ ;
#  $;$ ;
#  ioCursorList += !cursorName !hotSpotX !hotSpotY ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <enum_declaration>
#  ??@bool inIsUserDefined
#  ?!@astDeclarationList ioDeclarationList
#:
#  $enum$ ;
#  $Identifier$ ? @lstring enumName ;
#  ${$ ;
#  @lstringlist enumConstants [emptyList] ;
#  repeat
#    $identifier$ ? @lstring constantName ;
#    enumConstants += !constantName ;
#  while
#    $,$ ;
#  end repeat ;
#  $}$ ;
#  ioDeclarationList += ![@enumDeclaration new !inIsUserDefined !enumName !enumConstants] ;
#end rule ;

#----------------------------------------------------------------------------*

#rule <controller_class_declaration>
#  ??@bool inIsUserDefined
#  ?!@astDeclarationList ioDeclarationList
#:
#  @generationKind generationKind ;
#  select
#    generationKind := [@generationKind fullGeneration] ;
#  or
#    $predefined$ ;
#    generationKind := [@generationKind noGeneration] ;
#  or
#    $extern$ ;
#    generationKind := [@generationKind generateImport] ;
#  end select ;
#  @controllerKind controllerKind ;
#  @lstring controllerClassName ;
#  @bindingOptionList controlledObjectBindingOptionList [emptyList] ;
#  select
#    $controller$ ;
#    controllerKind := [@controllerKind simpleController] ;
#    $Identifier$ ?controllerClassName ;
#  or
#    $objectController$ ;
#    controllerKind := [@controllerKind objectController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $entityController$ ;
#    controllerKind := [@controllerKind entityController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $arrayController$ ;
#    controllerKind := [@controllerKind arrayController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $entityArrayController$ ;
#    controllerKind := [@controllerKind entityArrayController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  or
#    $treeController$ ;
#    controllerKind := [@controllerKind treeController] ;
#    $Identifier$ ?controllerClassName ;
#    ${$ ;
#    repeat
#    while
#      $Identifier$ ? @lstring optionName ;
#      $:$ ;
#      <type_list> ?@lstringlist optionTypeList ;
#      $;$ ;
#      controlledObjectBindingOptionList += !optionName !optionTypeList ;
#    end repeat ;
#    $}$ ;
#  end select ;
#  ${$ ;
#  @outletClassBindingList controllerClassBindingList [emptyList] ;
#  @lstringlist actionDeclarationList [emptyList] ;
#  @controllerObservablePropertyList controllerObservablePropertyList [emptyList] ;
#  repeat
#  while
#    $attribute$ ;
#    $Identifier$ ? @lstring attributeTypeName ;
#    $identifier$ ? @lstring attributeName ;
#    $;$ ;
#    controllerObservablePropertyList += !attributeTypeName !attributeName ;
#  while
#    <action_declaration> !?actionDeclarationList ;
#  while
#    @lstring bindingName ;
#    select
#      $binding$ ? bindingName ;
#    or
#      $hidden$ ;
#      bindingName := [@lstring new !"hidden" !here] ;
#    or
#      $editable$ ;
#      bindingName := [@lstring new !"editable" !here] ;
#    or
#      $enabled$ ;
#      bindingName := [@lstring new !"enabled" !here] ;
#    end select ;
#    $:$ ;
#    <type_formatter_list> ?@attributeASTTypeAndFormatterList easyBindingTypeFormatterList ;
#    @bindingOptionList bindingOptionList [emptyList] ;
#    select
#      $;$ ;
#    or
#      ${$ ;
#      repeat
#      while
#        $Identifier$ ? @lstring optionName ;
#        $:$ ;
#        <type_list> ?@lstringlist optionTypeList ;
#        $;$ ;
#        bindingOptionList += !optionName !optionTypeList ;
#      end repeat ;
#      $}$ ;
#    end select ;
#    controllerClassBindingList += !bindingName !easyBindingTypeFormatterList !bindingOptionList ;
#  end repeat ;
#  $}$ ;
#  ioDeclarationList += ![@controllerClassDeclaration new
#    !inIsUserDefined
#    !controllerKind
#    !controllerClassName
#    !controlledObjectBindingOptionList
#    !generationKind
#    !controllerClassBindingList
#    !actionDeclarationList
#    !controllerObservablePropertyList
#  ] ;
#end rule ;

#----------------------------------------------------------------------------*

end syntax ;
