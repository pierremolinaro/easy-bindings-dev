semantics attributeDeclarationAnalysis :
#  import "transientAnalysis.gSemantics" ;
#  import "bindingSemanticAnalysis.gSemantics" ;
  import "decoratedTypes.gSemantics" ;

#----------------------------------------------------------------------------*

#routine attributeDeclarationEnterType
#  ??@attributeList inAttributeList
#  ??@classArrayList inArrayList
#  ??@string inObjectName # "document." . documentName
#  ?!@unifiedTypeMap ioUnifiedTypeMap 
#  ?!@observablePropertyMap ioObservablePropertyMap
#:
##--- Attributes
#  foreach inAttributeList do
#    [@unifiedTypeProxy makeProxy
#      !?ioUnifiedTypeMap
#      !mAttributeTypeName
#      ?@unifiedTypeProxy attributeTypeProxy
#    ] ;
#    [!?ioObservablePropertyMap insertKey
#      !mAttributeName
#      !attributeTypeProxy
#      !false # is not transient
#      !inObjectName . "." . mAttributeName
#      !false # Is not a collection
#    ] ;
#  end foreach ;
##--- Arraies
#  foreach inArrayList do
#    [@unifiedTypeProxy makeProxy
#      !?ioUnifiedTypeMap
#      !mElementClassName
#      ?@unifiedTypeProxy type
#    ] ;
#    [!?ioObservablePropertyMap insertKey
#      !mArrayName
#      !type
#      !false # is not transient
#      !inObjectName . "." . mArrayName
#      !true # Is a collection
#    ] ;
#  end foreach ;
#end routine ;

#----------------------------------------------------------------------------*

routine analyzeAttributeDeclaration
  ??@attributeList inAttributeList
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@fileInclusionSet ioFileInclusionSet
  !@attributeListForImplementation outAttributeListForImplementation
  ?!@attributeListForImplementation ioAttributeListForInitHeader
:
  outAttributeListForImplementation := [@attributeListForImplementation emptyList] ;
  foreach inAttributeList do
    [inUnifiedTypeMap searchKey !mAttributeTypeName ?@ebType type ?*] ;
    [mDefaultValue analyzeDefaultValueType
      ![@ebTypeList listWithValue !type]
      !ioContextAnalysisStruct
      ?@string directDefaultValueAsString
      ?@string objectiveCDefaultValueAsString
      !?ioFileInclusionSet
    ] ;
    outAttributeListForImplementation +=
      !type
      ![mAttributeName string]
      !objectiveCDefaultValueAsString
      !directDefaultValueAsString
    ;
    ioAttributeListForInitHeader +=
       !type
       ![mAttributeName string]
       !objectiveCDefaultValueAsString
       !directDefaultValueAsString
    ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

routine buildObservablePropertyMap
  ??@attributeList inAttributeList
  ??@classArrayList inArrayList
  ??@transientList inTransientList
  ??@controllerList inControllerList
  ??@controllerObservablePropertyList inControllerObservablePropertyList
  ?!@observablePropertyMapMap unused ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@string inObjectName # "document." . documentName
  ?!@observablePropertyMap ioSelfObservableAttributeMap
:
#--- Attributes
  foreach inAttributeList do
    [inUnifiedTypeMap searchKey !mAttributeTypeName ?@ebType type ?*] ;
    const @lstring observationDependencyKey [new
      !inObjectName . "." . mAttributeName
      !mAttributeName->location
    ] ;
    [!?ioSelfObservableAttributeMap insertKey
      !mAttributeName
      !type
      !false # is not transient
      !observationDependencyKey
      !false # Is not collection
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#--- Arraies
  foreach inArrayList do
    [inUnifiedTypeMap searchKey !mElementClassName ?@ebType type ?*] ;
    const @lstring observationDependencyKey [new
      !inObjectName . "." . mArrayName
      !mArrayName->location
    ] ;
    [!?ioSelfObservableAttributeMap insertKey
      !mArrayName
      !type
      !false # is not transient
      !observationDependencyKey
      !false # Is not collection
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#--- Transients
  foreach inTransientList do
    [inUnifiedTypeMap searchKey !mTransientTypeName ?@ebType type ?*] ;
    const @lstring observationDependencyKey [new
      !inObjectName . "." . mTransientName
      !mTransientName->location
    ] ;
    [!?ioSelfObservableAttributeMap insertKey
      !mTransientName
      !type
      !true # is transient
      !observationDependencyKey
      !false # Is not collection
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#--- Controllers
  foreach inControllerList do
    [inUnifiedTypeMap searchKey !mControllerClassName ?@ebType type ?*] ;
    const @lstring observationDependencyKey [new
      !inObjectName . "." . mControllerName
      !mControllerName->location
    ] ;
    [!?ioSelfObservableAttributeMap insertKey
      !mControllerName
      !type
      !false # is not transient
      !observationDependencyKey
      !false # Is not collection
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#--- Controller attributes
  foreach inControllerObservablePropertyList do
    [inUnifiedTypeMap searchKey !mTypeName ?@ebType type ?*] ;
    const @lstring observationDependencyKey [new
      !inObjectName . "." . mPropertyName
      !mPropertyName->location
    ] ;
    [!?ioSelfObservableAttributeMap insertKey
      !mPropertyName
      !type
      !false # is not transient
      !observationDependencyKey
      !false # Is not collection
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
