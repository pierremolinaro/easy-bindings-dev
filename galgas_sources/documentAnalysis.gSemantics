semantics documentAnalysis :
  import "transientAnalysis.gSemantics" ;
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

#local routine analyzeControllers
#  ??@controllerList inControllerList
#  ??@controllerClassMap inControllerClassMap
#  ??@entityMap inEntityMap
#  ??@relationshipMap inRootObjectRelationshipMap
#  ??@observablePropertyMap inRootEntityObservableAttributeMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@fileInclusionSet ioFileInclusionSet
#  !@controllerMap outControllerMap
#:
#  outControllerMap := [@controllerMap emptyMap] ;
#  foreach inControllerList do
#    [inControllerClassMap searchKey
#      !mControllerClassName
#      ?@controllerKind controllerKind
#      ?@generationKind generationKind
#      ?@EXoutletClassBindingMap controllerClassBindingMap
#      ?@actionMap controllerActionMap
#      ?@observablePropertyMap controllerObservablePropertyMap
#      ?@EXoutletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
#    ] ;
#  #---
#    if generationKind != [@generationKind noGeneration] then
#      ioFileInclusionSet->mHeaderPredeclarationSet += !mControllerClassName->string ;
#      ioFileInclusionSet->mImplementationFileInclusionSet += !mControllerClassName->string ;
#    end if ;
#  #---
#    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
#    @lstring destinationEntityName ;
#    switch controllerKind
#    when simpleController :
#      destinationEntityName := ["" nowhere] ;
#    when objectController :
#      error mControllerName : "use an entityController, as PMEntityController" : destinationEntityName ;
#    when entityController :
#      if not mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'root' is allowed here"
#        ;
#      end if ;
#      [inRootObjectRelationshipMap searchKey
#        !mControlledObjectName
#        ?@bool isToMany
#        ?destinationEntityName
#        ?3*
#      ] ;
#      if isToMany then
#        error mControlledObjectName: "this should be a single object" ;
#      end if ;
#      [inEntityMap searchKey
#        !destinationEntityName
#        ?8*
#        ?@propertyMap controlledObjectAllPropertyMap
#        ?4*
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?ioFileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentObject"
#        ![@formatterEnum noFormatter]
#        !"self.rootObject"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    when arrayController :
#      error mControllerName : "use an entityArrayController, as PMEntityArrayController" : destinationEntityName ;
#    when entityArrayController :
#      if not mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'root' is allowed here"
#        ;
#      end if ;
#      [inRootObjectRelationshipMap searchKey
#        !mControlledObjectName
#        ?@bool isToMany
#        ?destinationEntityName
#        ?3*
#      ] ;
#      ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
#      if not isToMany then
#        error mControlledObjectName: "this should be a collection" ;
#      end if ;
#      [inEntityMap searchKey
#        !destinationEntityName
#        ?8*
#        ?@propertyMap controlledObjectAllPropertyMap
#        ?4*
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?ioFileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentArray"
#        ![@formatterEnum noFormatter]
#        !"self.rootObject"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    end switch ;
#    ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
#  #---
#    foreach mControllerBindingList do
#      [mBinding analyzeOutletBinding
#        !inRootEntityObservableAttributeMap
#        ![@observablePropertyMap emptyMap] # No self observable attributes
#        ![@preferencesMap emptyMap]
#        !inEntityMap
#        ![@classMap emptyMap]
#        !controllerClassBindingMap
#        !outControllerMap
#        !controllerActionMap
#        !false # No tableValue binding
#        !inContextAnalysisStruct
#        !?bindingListForGeneration
#        !?ioFileInclusionSet
#      ] ;
#    end foreach ;
#    [!?outControllerMap insertKey
#      !mControllerName
#      !mControllerClassName->string
#      !destinationEntityName
#      !true # Is an entity
#      !bindingListForGeneration
#      !controllerActionMap
#      !controllerObservablePropertyMap
#    ] ;
#  end foreach ;
#end routine ;

#----------------------------------------------------------------------------*

override method @documentDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#------------------------------------------------ Root Entity
  [@unifiedTypeProxy makeProxy
    !?ioUnifiedTypeMap
    !mRootEntityName
    ?@unifiedTypeProxy rootEntityType
  ] ;
  [!?ioUnifiedTypeMap enterEdge !mDocumentName !mRootEntityName] ;
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
  [!?ioUnifiedTypeMap enterEdge !mDocumentName !mAttributeTypeName] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  [!?ioUnifiedTypeMap enterEdge !mDocumentName !mTransientTypeName] ;
  end foreach ;
#-------------------------------------------------- Analyze controllers
  foreach mControllerList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mControllerClassName
      ?*
    ] ;
  [!?ioUnifiedTypeMap enterEdge !mDocumentName !mControllerClassName] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !mDocumentName
    ![@ebType new !mDocumentName ![@typeKind documentType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @documentDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  @observablePropertyMap observablePropertyMap [emptyMap] ;
#----------------------------------
  buildObservablePropertyMap
    !mAttributeList
    ![@classArrayList emptyList]
    !mTransientList
    !mControllerList
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"document." . mDocumentName
    !?observablePropertyMap
  ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mDocumentName
    ![@typeKind documentType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @documentDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#------------------------------------------------ Get root object features
  [ioContextAnalysisStruct->mEntityMap searchKey
    !mRootEntityName
    ?*
    ?8*
    ?@relationshipMap rootObjectRelationshipMap
    ?2*
  ] ;
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !mRootEntityName
    ?*
    ?@observablePropertyMap rootObjectObservablePropertyMap
  ] ;
#------------------------------------------------ Document observable properties
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
    !mDocumentName
    ?*
    ?@observablePropertyMap selfObservableAttributeMap
  ] ;
#-------------------------------------------------- Analyze attributes
  @fileInclusionSet fileInclusionSet [new ![@stringset emptySet] ![@stringset emptySet] ![@stringset emptySet]] ;
  @attributeListForImplementation attributeListForInitHeader [emptyList] ;
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?attributeListForInitHeader # Unused
  ;
#-------------------------------------------------- Analyze controllers
  analyzeControllers
    !mControllerList
    !rootObjectRelationshipMap
    !rootObjectObservablePropertyMap
    !ioContextAnalysisStruct
    !?fileInclusionSet
    ?@controllerMap controllerMap
  ;
#-------------------------------------------------- Analyze transient properties
  analyzeTransientProperties
    !mTransientList
    !rootObjectObservablePropertyMap
    !?ioContextAnalysisStruct
    !mRootEntityName->string
    !selfObservableAttributeMap
    !?fileInclusionSet
    ?@transientListForImplementation transientListForImplementation
  ;
#--------------------------------------------------- Analyze actions
  @actionMap documentActionMap [emptyMap] ;
  for actionName in mActionDeclarationList do
    [!?documentActionMap insertKey !actionName->mValue] ;
  end for ;
#--------------------------------------------------- Analyze outlets and bindings
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach mOutletDeclarationList do
    [ioContextAnalysisStruct->mOutletClassMap searchKey
      !mOutletType
      ?@generationKind generationKind
      ?2*
      ?@bool implementsDeallocProtocol
      ?@outletClassBindingMap bindingMap
      ?*
      ?@bool hasTableValueBinding
    ] ;
    if generationKind != [@generationKind noGeneration] then
      fileInclusionSet->mHeaderPredeclarationSet += !mOutletType->string ;
      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
    end if ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        !rootObjectObservablePropertyMap
        !selfObservableAttributeMap
        !bindingMap
        !controllerMap
        !documentActionMap
        !hasTableValueBinding
        !ioContextAnalysisStruct
        !?outletBindingList
        !?fileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList +=
      ![mOutletType string]
      ![mOutletName string]
      !outletBindingList
      !implementsDeallocProtocol
    ;
  end foreach ;
#-------------------------------- Generation
  ioGenerationList += ![@documentGeneration new
    !mDocumentName->string
    !mRootEntityName->string
    !outletGenerationList
    !controllerMap
    !mActionDeclarationList
    !transientListForImplementation
    !fileInclusionSet
    !attributeListForImplementation
  ] ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzeControllers
  ??@controllerList inControllerList
  ??@relationshipMap inRootObjectRelationshipMap
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@contextAnalysisStruct inContextAnalysisStruct
  ?!@fileInclusionSet ioFileInclusionSet
  !@controllerMap outControllerMap
:
  outControllerMap := [@controllerMap emptyMap] ;
  foreach inControllerList do
    [inContextAnalysisStruct->mControllerClassMap searchKey
      !mControllerClassName
      ?@controllerKind controllerKind
      ?@generationKind generationKind
      ?@outletClassBindingMap controllerClassBindingMap
      ?@actionMap controllerActionMap
      ?@observablePropertyMap controllerObservablePropertyMap
      ?@outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
    ] ;
  #---
    if generationKind != [@generationKind noGeneration] then
      ioFileInclusionSet->mHeaderPredeclarationSet += !mControllerClassName->string ;
      ioFileInclusionSet->mImplementationFileInclusionSet += !mControllerClassName->string ;
    end if ;
  #---
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    @lstring destinationEntityName ;
    switch controllerKind
    when simpleController :
      destinationEntityName := ["" nowhere] ;
    when objectController :
      error mControllerName : "use an entityController, as PMEntityController" : destinationEntityName ;
    when entityController :
      if not mIsRootObject->bool then
        error mIsRootObject
        : "only 'root' is allowed here"
        ;
      end if ;
      [inRootObjectRelationshipMap searchKey
        !mControlledObjectName
        ?@bool isToMany
        ?destinationEntityName
        ?3*
      ] ;
      if isToMany then
        error mControlledObjectName: "this should be a single object" ;
      end if ;
      [inContextAnalysisStruct->mEntityMap searchKey
        !destinationEntityName
        ?7*
        ?@propertyMap controlledObjectAllPropertyMap
        ?4*
      ] ;
      checkBindingOptions
        !inContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@2stringlist controlledObjectBindingOptionListForGeneration
        !?ioFileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentObject"
        ![@formatterEnum noFormatter]
        !"self.rootObject"
        !mControlledObjectName->string
        !controlledObjectBindingOptionListForGeneration
      ] ;
    when arrayController :
      error mControllerName : "use an entityArrayController, as PMEntityArrayController" : destinationEntityName ;
    when entityArrayController :
      if not mIsRootObject->bool then
        error mIsRootObject
        : "only 'root' is allowed here"
        ;
      end if ;
      [inRootObjectRelationshipMap searchKey
        !mControlledObjectName
        ?@bool isToMany
        ?destinationEntityName
        ?3*
      ] ;
      ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
      if not isToMany then
        error mControlledObjectName: "this should be a collection" ;
      end if ;
      [inContextAnalysisStruct->mEntityMap searchKey
        !destinationEntityName
        ?7*
        ?@propertyMap controlledObjectAllPropertyMap
        ?4*
      ] ;
      checkBindingOptions
        !inContextAnalysisStruct
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@2stringlist controlledObjectBindingOptionListForGeneration
        !?ioFileInclusionSet
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self.rootObject"
        !mControlledObjectName->string
        !controlledObjectBindingOptionListForGeneration
      ] ;
    end switch ;
    ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
  #---
    foreach mControllerBindingList do
      [mBinding analyzeOutletBinding
        !inRootEntityObservableAttributeMap
        ![@observablePropertyMap emptyMap] # No self observable attributes
        !controllerClassBindingMap
        !outControllerMap
        !controllerActionMap
        !false # No tableValue binding
        !inContextAnalysisStruct
        !?bindingListForGeneration
        !?ioFileInclusionSet
      ] ;
    end foreach ;
    [!?outControllerMap insertKey
      !mControllerName
      !mControllerClassName->string
      !destinationEntityName
      !true # Is an entity
      !bindingListForGeneration
      !controllerActionMap
      !controllerObservablePropertyMap
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

#local routine analyzeControllers
#  ??@controllerList inControllerList
#  ??@controllerClassMap inControllerClassMap
#  ??@entityMap inEntityMap
#  ??@relationshipMap inRootObjectRelationshipMap
#  ??@observablePropertyMap inRootEntityObservableAttributeMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@fileInclusionSet ioFileInclusionSet
#  !@controllerMap outControllerMap
#:
#  outControllerMap := [@controllerMap emptyMap] ;
#  foreach inControllerList do
#    [inControllerClassMap searchKey
#      !mControllerClassName
#      ?@controllerKind controllerKind
#      ?@generationKind generationKind
#      ?@EXoutletClassBindingMap controllerClassBindingMap
#      ?@actionMap controllerActionMap
#      ?@observablePropertyMap controllerObservablePropertyMap
#      ?@EXoutletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
#    ] ;
#  #---
#    if generationKind != [@generationKind noGeneration] then
#      ioFileInclusionSet->mHeaderPredeclarationSet += !mControllerClassName->string ;
#      ioFileInclusionSet->mImplementationFileInclusionSet += !mControllerClassName->string ;
#    end if ;
#  #---
#    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
#    @lstring destinationEntityName ;
#    switch controllerKind
#    when simpleController :
#      destinationEntityName := ["" nowhere] ;
#    when objectController :
#      error mControllerName : "use an entityController, as PMEntityController" : destinationEntityName ;
#    when entityController :
#      if not mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'root' is allowed here"
#        ;
#      end if ;
#      [inRootObjectRelationshipMap searchKey
#        !mControlledObjectName
#        ?@bool isToMany
#        ?destinationEntityName
#        ?3*
#      ] ;
#      if isToMany then
#        error mControlledObjectName: "this should be a single object" ;
#      end if ;
#      [inEntityMap searchKey
#        !destinationEntityName
#        ?8*
#        ?@propertyMap controlledObjectAllPropertyMap
#        ?4*
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?ioFileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentObject"
#        ![@formatterEnum noFormatter]
#        !"self.rootObject"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    when arrayController :
#      error mControllerName : "use an entityArrayController, as PMEntityArrayController" : destinationEntityName ;
#    when entityArrayController :
#      if not mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'root' is allowed here"
#        ;
#      end if ;
#      [inRootObjectRelationshipMap searchKey
#        !mControlledObjectName
#        ?@bool isToMany
#        ?destinationEntityName
#        ?3*
#      ] ;
#      ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
#      if not isToMany then
#        error mControlledObjectName: "this should be a collection" ;
#      end if ;
#      [inEntityMap searchKey
#        !destinationEntityName
#        ?8*
#        ?@propertyMap controlledObjectAllPropertyMap
#        ?4*
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?ioFileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentArray"
#        ![@formatterEnum noFormatter]
#        !"self.rootObject"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    end switch ;
#    ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
#  #---
#    foreach mControllerBindingList do
#      [mBinding analyzeOutletBinding
#        !inRootEntityObservableAttributeMap
#        ![@observablePropertyMap emptyMap] # No self observable attributes
#        ![@preferencesMap emptyMap]
#        !inEntityMap
#        ![@classMap emptyMap]
#        !controllerClassBindingMap
#        !outControllerMap
#        !controllerActionMap
#        !false # No tableValue binding
#        !inContextAnalysisStruct
#        !?bindingListForGeneration
#        !?ioFileInclusionSet
#      ] ;
#    end foreach ;
#    [!?outControllerMap insertKey
#      !mControllerName
#      !mControllerClassName->string
#      !destinationEntityName
#      !true # Is an entity
#      !bindingListForGeneration
#      !controllerActionMap
#      !controllerObservablePropertyMap
#    ] ;
#  end foreach ;
#end routine ;

#----------------------------------------------------------------------------*

#local routine analyzeDocument
#  ??@documentDeclarationList.element inDocument
#  ??@outletClassMap inOutletClassMap
#  ??@controllerClassMap inControllerClassMap
#  ??@entityMap inEntityMap
#  ??@preferencesMap inPreferencesMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@documentMap ioDocumentMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
##------------------------------------------------ Get root object features
#  [inEntityMap searchKey
#    !inDocument->mRootEntityName
#    ?*
#    ?@observablePropertyMap rootObjectObservablePropertyMap
#    ?8*
#    ?@relationshipMap rootObjectRelationshipMap
#    ?2*
#  ] ;
##-------------------------------------------------- Analyze attributes
#  @fileInclusionSet fileInclusionSet [new ![@stringset emptySet] ![@stringset emptySet] ![@stringset emptySet]] ;
#  @observablePropertyMap selfObservableAttributeMap [emptyMap] ;
#  @attributeListForImplementation attributeListForInitHeader [emptyList] ;
#  analyzeAttributeDeclaration
#    !inDocument->mAttributeList
#    !inContextAnalysisStruct
#    !"document." . inDocument->mDocumentName
#    !?ioTransientDependencyGraph
#    !?fileInclusionSet
#    !?selfObservableAttributeMap
#    ?@attributeListForImplementation attributeListForImplementation
#    !?attributeListForInitHeader # Unused
#  ;
##-------------------------------------------------- Analyze controllers
#  analyzeControllers
#    !inDocument->mControllerList
#    !inControllerClassMap
#    !inEntityMap
#    !rootObjectRelationshipMap
#    !rootObjectObservablePropertyMap
#    !inContextAnalysisStruct
#    !?fileInclusionSet
#    ?@controllerMap controllerMap
#  ;
##-------------------------------------------------- Analyze transient properties
#  analyzeTransientProperties
#    !inPreferencesMap
#    !"document." . inDocument->mDocumentName . "."
#    !inDocument->mTransientList
#    !rootObjectObservablePropertyMap
#    !inContextAnalysisStruct
#    !inDocument->mRootEntityName->string
#    !controllerMap
#    !?selfObservableAttributeMap
#    !?fileInclusionSet
#    ?@transientListForImplementation transientListForImplementation
#    !?ioTransientDependencyGraph
#  ;
##--------------------------------------------------- Analyze actions
#  @actionMap documentActionMap [emptyMap] ;
#  for actionName in inDocument->mActionDeclarationList do
#    [!?documentActionMap insertKey !actionName->mValue] ;
#  end for ;
##--------------------------------------------------- Analyze outlets and bindings
#  @outletGenerationList outletGenerationList [emptyList] ;
#  foreach inDocument->mOutletDeclarationList do
#    [inOutletClassMap searchKey
#      !mOutletType
#      ?@generationKind generationKind
#      ?2*
#      ?@bool implementsDeallocProtocol
#      ?@EXoutletClassBindingMap bindingMap
#      ?*
#      ?@bool hasTableValueBinding
#    ] ;
#    if generationKind != [@generationKind noGeneration] then
#      fileInclusionSet->mHeaderPredeclarationSet += !mOutletType->string ;
#      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
#    end if ;
#    @outletBindingListForGeneration outletBindingList [emptyList] ;
#    foreach mOutletBindingList do
#      [mBinding analyzeOutletBinding
#        !rootObjectObservablePropertyMap
#        !selfObservableAttributeMap
#        !inPreferencesMap
#        !inEntityMap
#        ![@classMap emptyMap]
#        !bindingMap
#        !controllerMap
#        !documentActionMap
#        !hasTableValueBinding
#        !inContextAnalysisStruct
#        !?outletBindingList
#        !?fileInclusionSet
#      ] ;
#    end foreach ;
#    outletGenerationList +=
#      ![mOutletType string]
#      ![mOutletName string]
#      !outletBindingList
#      !implementsDeallocProtocol
#    ;
#  end foreach ;
##--------------------------------------------------- Enter in document map
#  [!?fileInclusionSet->mImplementationFileInclusionSet removeKey !""] ;
#  [!?ioDocumentMap insertKey
#    !inDocument->mDocumentName
#    !inDocument->mRootEntityName->string
#    !outletGenerationList
#    !controllerMap
#    !inDocument->mActionDeclarationList
#    !transientListForImplementation
#    !fileInclusionSet
#    !attributeListForImplementation
#  ] ;
#end routine ;

#----------------------------------------------------------------------------*

#routine analyzeDocuments
#  ??@documentDeclarationList inDocumentDeclarationList
#  ??@outletClassMap inOutletClassMap
#  ??@controllerClassMap inControllerClassMap
#  ??@entityMap inEntityMap
#  ??@preferencesMap inPreferencesMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  !@documentMap outDocumentMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
#  outDocumentMap := [@documentMap emptyMap] ;
#  for document in inDocumentDeclarationList do
#    analyzeDocument
#      !document
#      !inOutletClassMap
#      !inControllerClassMap
#      !inEntityMap
#      !inPreferencesMap
#      !inContextAnalysisStruct
#      !?outDocumentMap
#      !?ioTransientDependencyGraph
#    ;
#  end for ;
#end routine ;

#----------------------------------------------------------------------------*

end semantics ;
