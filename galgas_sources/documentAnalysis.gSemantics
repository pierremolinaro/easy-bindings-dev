semantics documentAnalysis :
  import "transientAnalysis.gSemantics" ;
  import "bindingSemanticAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

local routine analyzeControllers
  ??@controllerList inControllerList
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@relationshipMap inRootObjectRelationshipMap
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@stringset ioHeaderFilePredeclarationSet
  ?!@stringset ioImplementationFileInclusionSet
  !@controllerMap outControllerMap
:
  outControllerMap := [@controllerMap emptyMap] ;
  foreach inControllerList do
    [inControllerClassMap searchKey
      !mControllerClassName
      ?@controllerKind controllerKind
      ?@generationKind generationKind
      ?@outletClassBindingMap controllerClassBindingMap
      ?@actionMap controllerActionMap
      ?@observablePropertyMap controllerObservablePropertyMap
      ?@outletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
    ] ;
  #---
    if generationKind != [@generationKind noGeneration] then
      ioHeaderFilePredeclarationSet += !mControllerClassName->string ;
      ioImplementationFileInclusionSet += !mControllerClassName->string ;
    end if ;
  #---
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    @lstring destinationEntityName ;
    switch controllerKind
    when simpleController :
      destinationEntityName := ["" nowhere] ;
    when objectController :
      error mControllerName : "use an entityController, as PMEntityController" : destinationEntityName ;
    when entityController :
      if not mIsRootObject->bool then
        error mIsRootObject
        : "only 'root' is allowed here"
        ;
      end if ;
      [inRootObjectRelationshipMap searchKey
        !mControlledObjectName
        ?@bool isToMany
        ?destinationEntityName
        ?3*
      ] ;
      if isToMany then
        error mControlledObjectName: "this should be a single object" ;
      end if ;
      [inEntityMap searchKey
        !destinationEntityName
        ?8*
        ?@propertyMap controlledObjectAllPropertyMap
        ?5*
      ] ;
      checkBindingOptions
        !inGlobalEnumConstantMap
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@2stringlist controlledObjectBindingOptionListForGeneration
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentObject"
        ![@formatterEnum noFormatter]
        !"self.rootObject"
        !mControlledObjectName->string
        !controlledObjectBindingOptionListForGeneration
      ] ;
    when arrayController :
      error mControllerName : "use an entityArrayController, as PMEntityArrayController" : destinationEntityName ;
    when entityArrayController :
      if not mIsRootObject->bool then
        error mIsRootObject
        : "only 'root' is allowed here"
        ;
      end if ;
      [inRootObjectRelationshipMap searchKey
        !mControlledObjectName
        ?@bool isToMany
        ?destinationEntityName
        ?3*
      ] ;
      ioImplementationFileInclusionSet += !destinationEntityName->string ;
      if not isToMany then
        error mControlledObjectName: "this should be a collection" ;
      end if ;
      [inEntityMap searchKey
        !destinationEntityName
        ?8*
        ?@propertyMap controlledObjectAllPropertyMap
        ?5*
      ] ;
      checkBindingOptions
        !inGlobalEnumConstantMap
        !mControlledObjectBindingOptionList
        !controlledObjectAvailableBindingOptionMap
        ?@2stringlist controlledObjectBindingOptionListForGeneration
      ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentArray"
        ![@formatterEnum noFormatter]
        !"self.rootObject"
        !mControlledObjectName->string
        !controlledObjectBindingOptionListForGeneration
      ] ;
    end switch ;
    ioImplementationFileInclusionSet += !destinationEntityName->string ;
  #---
    foreach mControllerBindingList do
      [mBinding analyzeOutletBinding
        !inRootEntityObservableAttributeMap
        ![@observablePropertyMap emptyMap] # No self observable attributes
        ![@preferencesMap emptyMap]
        !inEntityMap
        ![@classMap emptyMap]
        !controllerClassBindingMap
        !outControllerMap
        !controllerActionMap
        !false # No tableValue binding
        !inGlobalEnumConstantMap
        !?bindingListForGeneration
        !?ioImplementationFileInclusionSet
      ] ;
    end foreach ;
    [!?outControllerMap insertKey
      !mControllerName
      !mControllerClassName->string
      !destinationEntityName
      !true # Is an entity
      !bindingListForGeneration
      !controllerActionMap
      !controllerObservablePropertyMap
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeDocument
  ??@documentDeclarationList.element inDocument
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@preferencesMap inPreferencesMap
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@documentMap ioDocumentMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------------------------ Get root object features
  [inEntityMap searchKey
    !inDocument->mRootEntityName
    ?*
    ?@observablePropertyMap rootObjectObservablePropertyMap
    ?9*
    ?@relationshipMap rootObjectRelationshipMap
    ?2*
  ] ;
#-------------------------------------------------- Analyze controllers
  @stringset implementationFileInclusionSet [emptySet] ;
  @stringset headerFilePredeclarationSet [emptySet] ;
  analyzeControllers
    !inDocument->mControllerList
    !inControllerClassMap
    !inEntityMap
    !rootObjectRelationshipMap
    !rootObjectObservablePropertyMap
    !inGlobalEnumConstantMap
    !?headerFilePredeclarationSet
    !?implementationFileInclusionSet
    ?@controllerMap controllerMap
  ;
#-------------------------------------------------- Analyze transient properties
  @observablePropertyMap observablePropertyMap [emptyMap] ;
  analyzeTransientProperties
    !inPreferencesMap
    !"document." . inDocument->mDocumentName . "."
    !inDocument->mTransientList
    !rootObjectObservablePropertyMap
    !inDocument->mRootEntityName->string
    !controllerMap
    !?observablePropertyMap
    !?implementationFileInclusionSet
    ?@transientListForImplementation transientListForImplementation
    !?ioTransientDependencyGraph
  ;
#--------------------------------------------------- Analyze actions
  @actionMap documentActionMap [emptyMap] ;
  for actionName in inDocument->mActionDeclarationList do
    [!?documentActionMap insertKey !actionName->mValue] ;
  end for ;
#--------------------------------------------------- Analyze outlets and bindings
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach inDocument->mOutletDeclarationList do
    [inOutletClassMap searchKey
      !mOutletType
      ?@generationKind generationKind
      ?2*
      ?@bool implementsDeallocProtocol
      ?@outletClassBindingMap bindingMap
      ?*
      ?@bool hasTableValueBinding
    ] ;
    if generationKind != [@generationKind noGeneration] then
      headerFilePredeclarationSet += !mOutletType->string ;
      implementationFileInclusionSet += !mOutletType->string ;
    end if ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        !rootObjectObservablePropertyMap
        !observablePropertyMap
        !inPreferencesMap
        !inEntityMap
        ![@classMap emptyMap]
        !bindingMap
        !controllerMap
        !documentActionMap
        !hasTableValueBinding
        !inGlobalEnumConstantMap
        !?outletBindingList
        !?implementationFileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList +=
      ![mOutletType string]
      ![mOutletName string]
      !outletBindingList
      !implementsDeallocProtocol
    ;
  end foreach ;
#--------------------------------------------------- Enter in document map
  [!?implementationFileInclusionSet removeKey !""] ;
  [!?ioDocumentMap insertKey
    !inDocument->mDocumentName
    !inDocument->mRootEntityName->string
    !outletGenerationList
    !controllerMap
    !inDocument->mActionDeclarationList
    !headerFilePredeclarationSet
    !transientListForImplementation
    !implementationFileInclusionSet
  ] ;
end routine ;

#----------------------------------------------------------------------------*

routine analyzeDocuments
  ??@documentDeclarationList inDocumentDeclarationList
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@preferencesMap inPreferencesMap
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  !@documentMap outDocumentMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outDocumentMap := [@documentMap emptyMap] ;
  for document in inDocumentDeclarationList do
    analyzeDocument
      !document
      !inOutletClassMap
      !inControllerClassMap
      !inEntityMap
      !inPreferencesMap
      !inGlobalEnumConstantMap
      !?outDocumentMap
      !?ioTransientDependencyGraph
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
