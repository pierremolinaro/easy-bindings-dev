semantics documentAnalysis :
  import "transientAnalysis.gSemantics" ;
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

#local routine analyzeControllers
#  ??@controllerList inControllerList
#  ??@controllerClassMap inControllerClassMap
#  ??@entityMap inEntityMap
#  ??@relationshipMap inRootObjectRelationshipMap
#  ??@observablePropertyMap inRootEntityObservableAttributeMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@fileInclusionSet ioFileInclusionSet
#  !@controllerMap outControllerMap
#:
#  outControllerMap := [@controllerMap emptyMap] ;
#  foreach inControllerList do
#    [inControllerClassMap searchKey
#      !mControllerClassName
#      ?@controllerKind controllerKind
#      ?@generationKind generationKind
#      ?@EXoutletClassBindingMap controllerClassBindingMap
#      ?@actionMap controllerActionMap
#      ?@observablePropertyMap controllerObservablePropertyMap
#      ?@EXoutletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
#    ] ;
#  #---
#    if generationKind != [@generationKind noGeneration] then
#      ioFileInclusionSet->mHeaderPredeclarationSet += !mControllerClassName->string ;
#      ioFileInclusionSet->mImplementationFileInclusionSet += !mControllerClassName->string ;
#    end if ;
#  #---
#    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
#    @lstring destinationEntityName ;
#    switch controllerKind
#    when simpleController :
#      destinationEntityName := ["" nowhere] ;
#    when objectController :
#      error mControllerName : "use an entityController, as PMEntityController" : destinationEntityName ;
#    when entityController :
#      if not mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'root' is allowed here"
#        ;
#      end if ;
#      [inRootObjectRelationshipMap searchKey
#        !mControlledObjectName
#        ?@bool isToMany
#        ?destinationEntityName
#        ?3*
#      ] ;
#      if isToMany then
#        error mControlledObjectName: "this should be a single object" ;
#      end if ;
#      [inEntityMap searchKey
#        !destinationEntityName
#        ?8*
#        ?@propertyMap controlledObjectAllPropertyMap
#        ?4*
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?ioFileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentObject"
#        ![@formatterEnum noFormatter]
#        !"self.rootObject"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    when arrayController :
#      error mControllerName : "use an entityArrayController, as PMEntityArrayController" : destinationEntityName ;
#    when entityArrayController :
#      if not mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'root' is allowed here"
#        ;
#      end if ;
#      [inRootObjectRelationshipMap searchKey
#        !mControlledObjectName
#        ?@bool isToMany
#        ?destinationEntityName
#        ?3*
#      ] ;
#      ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
#      if not isToMany then
#        error mControlledObjectName: "this should be a collection" ;
#      end if ;
#      [inEntityMap searchKey
#        !destinationEntityName
#        ?8*
#        ?@propertyMap controlledObjectAllPropertyMap
#        ?4*
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?ioFileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentArray"
#        ![@formatterEnum noFormatter]
#        !"self.rootObject"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    end switch ;
#    ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
#  #---
#    foreach mControllerBindingList do
#      [mBinding analyzeOutletBinding
#        !inRootEntityObservableAttributeMap
#        ![@observablePropertyMap emptyMap] # No self observable attributes
#        ![@preferencesMap emptyMap]
#        !inEntityMap
#        ![@classMap emptyMap]
#        !controllerClassBindingMap
#        !outControllerMap
#        !controllerActionMap
#        !false # No tableValue binding
#        !inContextAnalysisStruct
#        !?bindingListForGeneration
#        !?ioFileInclusionSet
#      ] ;
#    end foreach ;
#    [!?outControllerMap insertKey
#      !mControllerName
#      !mControllerClassName->string
#      !destinationEntityName
#      !true # Is an entity
#      !bindingListForGeneration
#      !controllerActionMap
#      !controllerObservablePropertyMap
#    ] ;
#  end foreach ;
#end routine ;

#----------------------------------------------------------------------------*

local routine documentEnterType
  ??@documentDeclarationList.element inDocument
  ?!@unifiedTypeMap ioUnifiedTypeMap 
:
#------------------------------------------------ Root Entity
  [@unifiedTypeProxy makeProxy
    !?ioUnifiedTypeMap
    !inDocument->mRootEntityName
    ?@unifiedTypeProxy rootEntityType
  ] ;
#---------------------------------- Analyze attributes
  @observablePropertyMap observablePropertyMap [emptyMap] ;
  attributeDeclarationEnterType
    !inDocument->mAttributeList
    ![@classArrayList emptyList]
    !"document." . inDocument->mDocumentName
    !?ioUnifiedTypeMap
    !?observablePropertyMap
  ;
#---------------------------------- Analyze transient properties
  transientDeclarationEnterType
    !inDocument->mTransientList
    !"document." . inDocument->mDocumentName
    !?ioUnifiedTypeMap
    !?observablePropertyMap
  ;
#-------------------------------------------------- Analyze controllers
  foreach inDocument->mControllerList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mControllerClassName
      ?@unifiedTypeProxy type
    ] ;
    [!?observablePropertyMap insertKey
      !mControllerName
      !type
      !false # is not transient
      !"document." . inDocument->mDocumentName . "." . mControllerName
      !false # Is not a collection
    ] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !inDocument->mDocumentName
    ![@documentType new
      !rootEntityType
      !observablePropertyMap
    ]
  ] ;
end routine ;

#----------------------------------------------------------------------------*

routine documentsEnterTypes
  ??@documentDeclarationList inDocumentDeclarationList
  ?!@unifiedTypeMap ioUnifiedTypeMap 
:
  for document in inDocumentDeclarationList do
    documentEnterType
      !document
      !?ioUnifiedTypeMap
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

#local routine analyzeControllers
#  ??@controllerList inControllerList
#  ??@controllerClassMap inControllerClassMap
#  ??@entityMap inEntityMap
#  ??@relationshipMap inRootObjectRelationshipMap
#  ??@observablePropertyMap inRootEntityObservableAttributeMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@fileInclusionSet ioFileInclusionSet
#  !@controllerMap outControllerMap
#:
#  outControllerMap := [@controllerMap emptyMap] ;
#  foreach inControllerList do
#    [inControllerClassMap searchKey
#      !mControllerClassName
#      ?@controllerKind controllerKind
#      ?@generationKind generationKind
#      ?@EXoutletClassBindingMap controllerClassBindingMap
#      ?@actionMap controllerActionMap
#      ?@observablePropertyMap controllerObservablePropertyMap
#      ?@EXoutletClassBindingOptionMap controlledObjectAvailableBindingOptionMap
#    ] ;
#  #---
#    if generationKind != [@generationKind noGeneration] then
#      ioFileInclusionSet->mHeaderPredeclarationSet += !mControllerClassName->string ;
#      ioFileInclusionSet->mImplementationFileInclusionSet += !mControllerClassName->string ;
#    end if ;
#  #---
#    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
#    @lstring destinationEntityName ;
#    switch controllerKind
#    when simpleController :
#      destinationEntityName := ["" nowhere] ;
#    when objectController :
#      error mControllerName : "use an entityController, as PMEntityController" : destinationEntityName ;
#    when entityController :
#      if not mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'root' is allowed here"
#        ;
#      end if ;
#      [inRootObjectRelationshipMap searchKey
#        !mControlledObjectName
#        ?@bool isToMany
#        ?destinationEntityName
#        ?3*
#      ] ;
#      if isToMany then
#        error mControlledObjectName: "this should be a single object" ;
#      end if ;
#      [inEntityMap searchKey
#        !destinationEntityName
#        ?8*
#        ?@propertyMap controlledObjectAllPropertyMap
#        ?4*
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?ioFileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentObject"
#        ![@formatterEnum noFormatter]
#        !"self.rootObject"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    when arrayController :
#      error mControllerName : "use an entityArrayController, as PMEntityArrayController" : destinationEntityName ;
#    when entityArrayController :
#      if not mIsRootObject->bool then
#        error mIsRootObject
#        : "only 'root' is allowed here"
#        ;
#      end if ;
#      [inRootObjectRelationshipMap searchKey
#        !mControlledObjectName
#        ?@bool isToMany
#        ?destinationEntityName
#        ?3*
#      ] ;
#      ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
#      if not isToMany then
#        error mControlledObjectName: "this should be a collection" ;
#      end if ;
#      [inEntityMap searchKey
#        !destinationEntityName
#        ?8*
#        ?@propertyMap controlledObjectAllPropertyMap
#        ?4*
#      ] ;
#      checkBindingOptions
#        !inContextAnalysisStruct
#        !mControlledObjectBindingOptionList
#        !controlledObjectAvailableBindingOptionMap
#        ?@2stringlist controlledObjectBindingOptionListForGeneration
#        !?ioFileInclusionSet
#      ;
#      bindingListForGeneration += ![@regularBindingForGeneration new
#        !"contentArray"
#        ![@formatterEnum noFormatter]
#        !"self.rootObject"
#        !mControlledObjectName->string
#        !controlledObjectBindingOptionListForGeneration
#      ] ;
#    end switch ;
#    ioFileInclusionSet->mImplementationFileInclusionSet += !destinationEntityName->string ;
#  #---
#    foreach mControllerBindingList do
#      [mBinding analyzeOutletBinding
#        !inRootEntityObservableAttributeMap
#        ![@observablePropertyMap emptyMap] # No self observable attributes
#        ![@preferencesMap emptyMap]
#        !inEntityMap
#        ![@classMap emptyMap]
#        !controllerClassBindingMap
#        !outControllerMap
#        !controllerActionMap
#        !false # No tableValue binding
#        !inContextAnalysisStruct
#        !?bindingListForGeneration
#        !?ioFileInclusionSet
#      ] ;
#    end foreach ;
#    [!?outControllerMap insertKey
#      !mControllerName
#      !mControllerClassName->string
#      !destinationEntityName
#      !true # Is an entity
#      !bindingListForGeneration
#      !controllerActionMap
#      !controllerObservablePropertyMap
#    ] ;
#  end foreach ;
#end routine ;

#----------------------------------------------------------------------------*

#local routine analyzeDocument
#  ??@documentDeclarationList.element inDocument
#  ??@outletClassMap inOutletClassMap
#  ??@controllerClassMap inControllerClassMap
#  ??@entityMap inEntityMap
#  ??@preferencesMap inPreferencesMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@documentMap ioDocumentMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
##------------------------------------------------ Get root object features
#  [inEntityMap searchKey
#    !inDocument->mRootEntityName
#    ?*
#    ?@observablePropertyMap rootObjectObservablePropertyMap
#    ?8*
#    ?@relationshipMap rootObjectRelationshipMap
#    ?2*
#  ] ;
##-------------------------------------------------- Analyze attributes
#  @fileInclusionSet fileInclusionSet [new ![@stringset emptySet] ![@stringset emptySet] ![@stringset emptySet]] ;
#  @observablePropertyMap selfObservableAttributeMap [emptyMap] ;
#  @attributeListForImplementation attributeListForInitHeader [emptyList] ;
#  analyzeAttributeDeclaration
#    !inDocument->mAttributeList
#    !inContextAnalysisStruct
#    !"document." . inDocument->mDocumentName
#    !?ioTransientDependencyGraph
#    !?fileInclusionSet
#    !?selfObservableAttributeMap
#    ?@attributeListForImplementation attributeListForImplementation
#    !?attributeListForInitHeader # Unused
#  ;
##-------------------------------------------------- Analyze controllers
#  analyzeControllers
#    !inDocument->mControllerList
#    !inControllerClassMap
#    !inEntityMap
#    !rootObjectRelationshipMap
#    !rootObjectObservablePropertyMap
#    !inContextAnalysisStruct
#    !?fileInclusionSet
#    ?@controllerMap controllerMap
#  ;
##-------------------------------------------------- Analyze transient properties
#  analyzeTransientProperties
#    !inPreferencesMap
#    !"document." . inDocument->mDocumentName . "."
#    !inDocument->mTransientList
#    !rootObjectObservablePropertyMap
#    !inContextAnalysisStruct
#    !inDocument->mRootEntityName->string
#    !controllerMap
#    !?selfObservableAttributeMap
#    !?fileInclusionSet
#    ?@transientListForImplementation transientListForImplementation
#    !?ioTransientDependencyGraph
#  ;
##--------------------------------------------------- Analyze actions
#  @actionMap documentActionMap [emptyMap] ;
#  for actionName in inDocument->mActionDeclarationList do
#    [!?documentActionMap insertKey !actionName->mValue] ;
#  end for ;
##--------------------------------------------------- Analyze outlets and bindings
#  @outletGenerationList outletGenerationList [emptyList] ;
#  foreach inDocument->mOutletDeclarationList do
#    [inOutletClassMap searchKey
#      !mOutletType
#      ?@generationKind generationKind
#      ?2*
#      ?@bool implementsDeallocProtocol
#      ?@EXoutletClassBindingMap bindingMap
#      ?*
#      ?@bool hasTableValueBinding
#    ] ;
#    if generationKind != [@generationKind noGeneration] then
#      fileInclusionSet->mHeaderPredeclarationSet += !mOutletType->string ;
#      fileInclusionSet->mImplementationFileInclusionSet += !mOutletType->string ;
#    end if ;
#    @outletBindingListForGeneration outletBindingList [emptyList] ;
#    foreach mOutletBindingList do
#      [mBinding analyzeOutletBinding
#        !rootObjectObservablePropertyMap
#        !selfObservableAttributeMap
#        !inPreferencesMap
#        !inEntityMap
#        ![@classMap emptyMap]
#        !bindingMap
#        !controllerMap
#        !documentActionMap
#        !hasTableValueBinding
#        !inContextAnalysisStruct
#        !?outletBindingList
#        !?fileInclusionSet
#      ] ;
#    end foreach ;
#    outletGenerationList +=
#      ![mOutletType string]
#      ![mOutletName string]
#      !outletBindingList
#      !implementsDeallocProtocol
#    ;
#  end foreach ;
##--------------------------------------------------- Enter in document map
#  [!?fileInclusionSet->mImplementationFileInclusionSet removeKey !""] ;
#  [!?ioDocumentMap insertKey
#    !inDocument->mDocumentName
#    !inDocument->mRootEntityName->string
#    !outletGenerationList
#    !controllerMap
#    !inDocument->mActionDeclarationList
#    !transientListForImplementation
#    !fileInclusionSet
#    !attributeListForImplementation
#  ] ;
#end routine ;

#----------------------------------------------------------------------------*

#routine analyzeDocuments
#  ??@documentDeclarationList inDocumentDeclarationList
#  ??@outletClassMap inOutletClassMap
#  ??@controllerClassMap inControllerClassMap
#  ??@entityMap inEntityMap
#  ??@preferencesMap inPreferencesMap
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  !@documentMap outDocumentMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
#  outDocumentMap := [@documentMap emptyMap] ;
#  for document in inDocumentDeclarationList do
#    analyzeDocument
#      !document
#      !inOutletClassMap
#      !inControllerClassMap
#      !inEntityMap
#      !inPreferencesMap
#      !inContextAnalysisStruct
#      !?outDocumentMap
#      !?ioTransientDependencyGraph
#    ;
#  end for ;
#end routine ;

#----------------------------------------------------------------------------*

end semantics ;
