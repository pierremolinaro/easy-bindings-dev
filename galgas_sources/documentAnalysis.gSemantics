semantics documentAnalysis :
  import "transientAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

local routine analyzeControllers
  ??@controllerList inControllerList
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@relationshipMap inRootObjectRelationshipMap
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
  !@controllerMap outControllerMap
:
  outControllerMap := [@controllerMap emptyMap] ;
  foreach inControllerList do
    [inControllerClassMap searchKey
      !mControllerClassName
      ?@controllerKind controllerKind
      ?*
      ?@outletClassBindingMap controllerClassBindingMap
      ?@actionMap controllerActionMap
      ?@observablePropertyMap controllerObservablePropertyMap
    ] ;
  #---
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    @lstring destinationEntityName ;
    switch controllerKind
    when simpleController :
      destinationEntityName := ["" nowhere] ;
    when objectController :
      [inRootObjectRelationshipMap searchKey
        !mControlledObjectName
        ?@bool isToMany
        ?destinationEntityName
        ?2*
      ] ;
      if isToMany then
        error mControlledObjectName: "this should be a single object" ;
      end if ;
      [inEntityMap searchKey
        !destinationEntityName
        ?10*
        ?@propertyMap controlledObjectAllPropertyMap
        ?4*
      ] ;
    when arrayController :
      [inRootObjectRelationshipMap searchKey
        !mControlledObjectName
        ?@bool isToMany
        ?destinationEntityName
        ?2*
      ] ;
      if not isToMany then
        error mControlledObjectName: "this should be a collection" ;
      end if ;
      [inEntityMap searchKey
        !destinationEntityName
        ?10*
        ?@propertyMap controlledObjectAllPropertyMap
        ?4*
      ] ;
      bindingListForGeneration += ![@regularBindingForGeneration new
        !"contentSet"
        ![@formatterEnum noFormatter]
        !"mRootObject"
        !mControlledObjectName->string
        ![@2stringlist emptyList]
      ] ;
    end switch ;
  #---
    foreach mControllerBindingList do
      [mBinding analyzeOutletBinding
        !inRootEntityObservableAttributeMap
        ![@observablePropertyMap emptyMap] # No self observable attributes
        ![@preferencesMap emptyMap]
        !inEntityMap
        ![@classMap emptyMap]
        !controllerClassBindingMap
        !outControllerMap
        !controllerActionMap
        !false # No tableValue binding
        !inGlobalEnumConstantMap
        !?ioBindingListForGeneration
        !?ioImplementationFileInclusionSet
      ] ;
    end foreach ;
    [!?outControllerMap insertKey
      !mControllerName
      !mControllerClassName->string
      !destinationEntityName->string
      !true # Is an entity
      !bindingListForGeneration
      !controllerActionMap
      !controllerObservablePropertyMap
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeDocument
  ??@documentDeclarationList.element inDocument
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@preferencesMap inPreferencesMap
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@documentMap ioDocumentMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------------------------ Get root object features
  [inEntityMap searchKey
    !inDocument->mRootEntityName
    ?*
    ?@string rootEntityImplementationClassName
    ?*
    ?@observablePropertyMap rootObjectObservablePropertyMap
    ?9*
    ?@relationshipMap rootObjectRelationshipMap
    ?*
  ] ;
#-------------------------------------------------- Analyze controllers
  @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
  @stringset implementationFileInclusionSet [emptySet] ;
  analyzeControllers
    !inDocument->mControllerList
    !inControllerClassMap
    !inEntityMap
    !rootObjectRelationshipMap
    !rootObjectObservablePropertyMap
    !inGlobalEnumConstantMap
    !?bindingListForGeneration
    !?implementationFileInclusionSet
    ?@controllerMap controllerMap
  ;
#-------------------------------------------------- Analyze transient properties
  @observablePropertyMap observablePropertyMap [emptyMap] ;
  analyzeTransientProperties
    !inPreferencesMap
    !"document." . inDocument->mDocumentName . "."
    !inDocument->mTransientList
    !rootObjectObservablePropertyMap
    !inDocument->mRootEntityName->string
    !controllerMap
    !?observablePropertyMap
    !?implementationFileInclusionSet
    ?@transientListForImplementation transientListForImplementation
    !?ioTransientDependencyGraph
  ;
#--------------------------------------------------- Analyze actions
  @actionMap documentActionMap [emptyMap] ;
  for actionName in inDocument->mActionDeclarationList do
    [!?documentActionMap insertKey !actionName->mValue] ;
  end for ;
#--------------------------------------------------- Analyze outlets and bindings
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach inDocument->mOutletDeclarationList do
    [inOutletClassMap searchKey
      !mOutletType
      ?@generationKind generationKind
      ?2*
      ?@outletClassBindingMap bindingMap
      ?@bool hasTableValueBinding
    ] ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        !rootObjectObservablePropertyMap
        !observablePropertyMap
        !inPreferencesMap
        !inEntityMap
        ![@classMap emptyMap]
        !bindingMap
        !controllerMap
        !documentActionMap
        !hasTableValueBinding
        !inGlobalEnumConstantMap
        !?outletBindingList
        !?implementationFileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList += ![mOutletType string] !generationKind ![mOutletName string] !outletBindingList ;
  end foreach ;
#--------------------------------------------------- Enter in document map
  [!?implementationFileInclusionSet removeKey !""] ;
  [!?ioDocumentMap insertKey
    !inDocument->mDocumentName
    !inDocument->mRootEntityName->string
    !rootEntityImplementationClassName
    !outletGenerationList
    !controllerMap
    !inDocument->mActionDeclarationList
    !transientListForImplementation
    !implementationFileInclusionSet
  ] ;
end routine ;

#----------------------------------------------------------------------------*

routine analyzeDocuments
  ??@documentDeclarationList inDocumentDeclarationList
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@preferencesMap inPreferencesMap
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  !@documentMap outDocumentMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outDocumentMap := [@documentMap emptyMap] ;
  for document in inDocumentDeclarationList do
    analyzeDocument
      !document
      !inOutletClassMap
      !inControllerClassMap
      !inEntityMap
      !inPreferencesMap
      !inGlobalEnumConstantMap
      !?outDocumentMap
      !?ioTransientDependencyGraph
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
