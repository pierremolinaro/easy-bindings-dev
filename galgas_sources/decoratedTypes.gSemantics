semantics decoratedTypes :
  import "abstractSyntaxTypes.gSemantics" ;

#----------------------------------------------------------------------------*

abstract method @astDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
;

#----------------------------------------------------------------------------*

struct @ebType {
  @lstring mTypeName ;
  @typeKind mKind ;
}

#----------------------------------------------------------------------------*

list @ebTypeList {
  @ebType mType ;
}

#----------------------------------------------------------------------------*

reader @ebType isPODtype -> @bool outResult :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType, stringType,
       colorType, dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := false ;
  when enumType, structType, boolType,
       integerType, uintegerType, doubleType :
    outResult := true ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @ebType ebTypeName -> @string outResult :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType, stringType,
       colorType, dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType,
       enumType, structType :
    outResult := mTypeName->string ;
  when boolType :
    outResult := "BOOL" ;
  when integerType :
    outResult := "NSInteger" ;
  when uintegerType :
    outResult := "NSUInteger" ;
  when doubleType :
    outResult := "double" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   equalExpression                                                           *
#-----------------------------------------------------------------------------*

reader @ebType equalExpression
  ??@string inExp1
  ??@string inExp2
  -> @string outResult
 :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType,
       colorType, dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := "[" . inExp1 . " isEqual:" . inExp2 . "]" ;
  when stringType :
    outResult := "[" . inExp1 . " isEqualToString:" . inExp2 . "]" ;
  when structType :
    outResult := "equal" . mTypeName . "s (" . inExp1 . ", " . inExp2 . ")" ;
  when integerType, uintegerType, boolType, doubleType, enumType :
    outResult := inExp1 . " == " . inExp2 ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   ocTypeName                                                                *
#-----------------------------------------------------------------------------*

reader @ebType ocTypeName
  -> @string outResult
 :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType,
       colorType, dataType, dateType, fontType, stringType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := mTypeName->string . " *" ;
  when structType, enumType :
    outResult := mTypeName->string ;
  when boolType :
    outResult := "BOOL" ;
  when integerType :
    outResult := "NSInteger" ;
  when uintegerType :
    outResult := "NSUInteger" ;
  when doubleType :
    outResult := "double" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   propertyAttributeString                                                   *
#-----------------------------------------------------------------------------*

reader @ebType propertyAttributeString
  -> @string outResult
 :
  switch mKind
  when colorType, dataType, dateType, fontType, stringType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := " (copy)" ;
  when nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType,
       doubleType, uintegerType, integerType, boolType, structType,
       enumType :
    outResult := "" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   copyOnAssign                                                              *
#-----------------------------------------------------------------------------*

reader @ebType copyOnAssign
  -> @bool outResult
 :
  switch mKind
  when stringType, bezierPathType, menuType :
    outResult := true ;
  when colorType, dataType, dateType, fontType,
       imageType, protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType,
       doubleType, uintegerType, integerType, boolType, structType,
       enumType :
    outResult := false ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   requiredCellTypeInTableColumnBinding                                      *
#-----------------------------------------------------------------------------*

reader @ebType requiredCellTypeInTableColumnBinding
  -> @string outResult
 :
  switch mKind
  when dateType :
    outResult := "NSDateFieldCell" ;
  when imageType :
    outResult := "NSImageCell" ;
  when boolType :
    outResult := "NSButtonCell" ;
  when integerType, uintegerType, doubleType, stringType :
    outResult := "NSTextFieldCell" ;
  when bezierPathType, menuType,
       colorType, dataType, fontType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType,
       structType,
       enumType :
    outResult := "" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   preferencesGetterTransformerFunctionName                                  *
#-----------------------------------------------------------------------------*

reader @ebType preferencesGetterTransformerFunctionName
  -> @string outResult
 :
  switch mKind
  when boolType :
    outResult := "boolFromNSNumber" ;
  when integerType :
    outResult := "NSIntegerFromNSNumber" ;
  when enumType :
    outResult := "(" . mTypeName . ") NSIntegerFromNSNumber" ;
  when doubleType :
    outResult := "doubleFromNSNumber" ;
  when fontType :
    outResult := "fontFromData" ;
  when colorType, bezierPathType :
    outResult := "valueFromData" ;
  when structType :
    outResult := mTypeName->string . "FromData" ;
  when dateType, imageType, uintegerType, stringType, menuType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType :
    outResult := "" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   preferencesSetterTransformerFunctionName                                  *
#-----------------------------------------------------------------------------*

reader @ebType preferencesSetterTransformerFunctionName
  -> @string outResult
 :
  switch mKind
  when boolType :
    outResult := "numberEncodedBool" ;
  when integerType, enumType :
    outResult := "numberEncodedNSInteger" ;
  when doubleType :
    outResult := "numberEncodedDouble" ;
  when fontType :
    outResult := "dataFromFont" ;
  when colorType, bezierPathType, menuType :
    outResult := "dataEncodedValue" ;
  when structType :
    outResult := "dataEncoded" . mTypeName->string ;
  when dateType, imageType, uintegerType, stringType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType :
    outResult := "" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   isClass                                                                   *
#-----------------------------------------------------------------------------*

reader @ebType isClass
  -> @bool outResult
 :
  switch mKind
  when boolType, integerType, uintegerType, enumType, doubleType, structType :
    outResult := false ;
  when fontType, colorType, bezierPathType, menuType,
       dateType, imageType, stringType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType :
    outResult := true ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   functionForComputingSignature                                             *
#-----------------------------------------------------------------------------*

reader @ebType functionForComputingSignature
  -> @string outResult
 :
  switch mKind
  when boolType, integerType, uintegerType, enumType, doubleType, structType :
    outResult := "computeIntegerSignature" ;
  when stringType :
    outResult := "computeNSStringSignature" ;
  when entityType :
    outResult := "computeToOneEntitySignature" ;
  when fontType, colorType, bezierPathType, menuType,
       dateType, imageType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType :
    outResult := "" ;
  end switch ;
end reader ;
#override reader @toManyEntitiesType functionForComputingSignature -> @string outResult : outResult := "computeToManyEntitySignature" ; end reader ;

#-----------------------------------------------------------------------------*
#   addInclusionInHeaderFile                                                  *
#-----------------------------------------------------------------------------*

method @ebType addInclusionInHeaderFile
  ?!@stringset ioInclusionSet
:
  switch mKind
  when boolType, integerType, uintegerType, doubleType,
       entityType, fontType, colorType, bezierPathType, menuType,
       dateType, imageType,
       dataType, stringType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType :

  when structType, enumType :
    ioInclusionSet += !mTypeName->string ;
  end switch ;
end method ;

#-----------------------------------------------------------------------------*
#   addInclusionInImplementationFile                                          *
#-----------------------------------------------------------------------------*

method @ebType addInclusionInImplementationFile
  ?!@stringset ioInclusionSet
:
  switch mKind
  when boolType, integerType, uintegerType, doubleType,
       fontType, colorType, bezierPathType, menuType,
       dateType, imageType, structType, enumType,
       dataType, stringType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType :

  when entityType :
    ioInclusionSet += !mTypeName->string ;
  end switch ;
end method ;

#----------------------------------------------------------------------------*

uniquemap @unifiedTypeMap {
  insert insertKey error message "the '%K' type is already declared" ;
  search searchKey error message "the '%K' type is not declared" ;
#---
  @ebType mTypeKind ;
  @astDeclaration mDeclaration ;
}

#----------------------------------------------------------------------------*

mapproxy @unifiedTypeProxy (@unifiedTypeMap) ;

#----------------------------------------------------------------------------*

list @unifiedTypeProxyList {
  @unifiedTypeProxy mTypeProxy ;
}

#----------------------------------------------------------------------------*

list @ebTypeAndFormatterList {
  @ebType mType ;
  @formatterEnum mRequiredFormatter ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingOptionMap {
  @ebTypeList mAcceptableTypeList ;
  insert insertKey error message "the '%K' binding option is already declared" ;
  search searchKey error message "the '%K' binding option is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingMap {
  @ebTypeAndFormatterList mAcceptableTypeList ;
  @outletClassBindingOptionMap mOutletClassBindingOptionMap ;
  insert insertKey error message "the '%K' binding is already declared" ;
  search searchKey error message "the '%K' binding is not declared" ;
}

#----------------------------------------------------------------------------*

list @structFieldList {
  @ebType mFieldType ;
  @string mFieldName ;
}

#----------------------------------------------------------------------------*

map @enumConstantMap {
  insert insertKey error message "the '%K' enumeration constant is already declared" ;
  search searchKey error message "the '%K' enumeration constant is not declared" ;
}

#-----------------------------------------------------------------------------*

#abstract reader @easyBindingType ebTypeName -> @string outResult ;
#
#override reader @boolType ebTypeName -> @string outResult : outResult := "BOOL" ; end reader ;
#override reader @integerType ebTypeName -> @string outResult : outResult := "NSInteger" ; end reader ;
#override reader @uintegerType ebTypeName -> @string outResult : outResult := "NSUInteger" ; end reader ;
#override reader @doubleType ebTypeName -> @string outResult : outResult := "double" ; end reader ;
#override reader @stringType ebTypeName -> @string outResult : outResult := "NSString" ; end reader ;
#override reader @dataType ebTypeName -> @string outResult : outResult := "NSData" ; end reader ;
#override reader @dateType ebTypeName -> @string outResult : outResult := "NSDate" ; end reader ;
#override reader @fontType ebTypeName -> @string outResult : outResult := "NSFont" ; end reader ;
#override reader @imageType ebTypeName -> @string outResult : outResult := "NSImage" ; end reader ;
#override reader @colorType ebTypeName -> @string outResult : outResult := "NSColor" ; end reader ;
#override reader @bezierPathType ebTypeName -> @string outResult : outResult := "NSBezierPath" ; end reader ;
#override reader @menuType ebTypeName -> @string outResult : outResult := "NSMenu" ; end reader ;
#override reader @enumType ebTypeName -> @string outResult : outResult := mEnumTypeName->string ; end reader ;
#override reader @structType ebTypeName -> @string outResult : outResult := mStructTypeName->string ; end reader ;

#-----------------------------------------------------------------------------*
#   ebTypeIdentifier                                                          *
#-----------------------------------------------------------------------------*

#abstract reader @easyBindingType ebTypeIdentifier -> @string outResult ;
#
#override reader @boolType ebTypeIdentifier -> @string outResult : outResult := "bool" ; end reader ;
#override reader @integerType ebTypeIdentifier -> @string outResult : outResult := "integer" ; end reader ;
#override reader @uintegerType ebTypeIdentifier -> @string outResult : outResult := "unsignedInteger" ; end reader ;
#override reader @doubleType ebTypeIdentifier -> @string outResult : outResult := "double" ; end reader ;
#override reader @stringType ebTypeIdentifier -> @string outResult : outResult := "NSString" ; end reader ;
#override reader @dataType ebTypeIdentifier -> @string outResult : outResult := "NSData" ; end reader ;
#override reader @dateType ebTypeIdentifier -> @string outResult : outResult := "NSDate" ; end reader ;
#override reader @fontType ebTypeIdentifier -> @string outResult : outResult := "NSFont" ; end reader ;
#override reader @imageType ebTypeIdentifier -> @string outResult : outResult := "NSImage" ; end reader ;
#override reader @colorType ebTypeIdentifier -> @string outResult : outResult := "NSColor" ; end reader ;
#override reader @menuType ebTypeIdentifier -> @string outResult : outResult := "NSMenu" ; end reader ;
#override reader @bezierPathType ebTypeIdentifier -> @string outResult : outResult := "NSBezierPath" ; end reader ;
#override reader @toOneEntityType ebTypeIdentifier -> @string outResult : outResult := "toOne[" . mEntityName . "]" ; end reader ;
#override reader @toManyEntitiesType ebTypeIdentifier -> @string outResult : outResult := "toMany[" . mEntityName . "]" ; end reader ;
#override reader @objectArrayType ebTypeIdentifier -> @string outResult : outResult := "array[" . mClassName . "]" ; end reader ;
#
#override reader @enumType ebTypeIdentifier -> @string outResult : outResult := "enum[" . mEnumTypeName . "]" ; end reader ;
#override reader @structType ebTypeIdentifier -> @string outResult : outResult := "struct[" . mStructTypeName . "]" ; end reader ;

#-----------------------------------------------------------------------------*

#reader @easyBindingType ebGenericTypeIdentifier ??@string unused inTypeName -> @string outResult
#:
#  outResult := [selfcopy ebTypeIdentifier] ;
#end reader ;
#
##------------
#
#override reader @toManyEntitiesType ebGenericTypeIdentifier ??@string inTypeName -> @string outResult
#:
#  outResult := "toMany[" . inTypeName . "]" ;
#end reader ;
#
##------------
#
#override reader @objectArrayType ebGenericTypeIdentifier ??@string inTypeName -> @string outResult
#:
#  outResult := "array[" . inTypeName . "]" ;
#end reader ;
#
##------------
#
#override reader @enumType ebGenericTypeIdentifier ??@string inTypeName -> @string outResult
#:
#  outResult := "enum[" . inTypeName . "]" ;
#end reader ;

#-----------------------------------------------------------------------------*

#abstract reader @easyBindingType ocClassName -> @string outResult ;
#
#override reader @boolType ocClassName -> @string outResult : outResult := "NSNumber" ; end reader ;
#override reader @integerType ocClassName -> @string outResult : outResult := "NSNumber" ; end reader ;
#override reader @uintegerType ocClassName -> @string outResult : outResult := "NSNumber" ; end reader ;
#override reader @doubleType ocClassName -> @string outResult : outResult := "NSNumber" ; end reader ;
#override reader @stringType ocClassName -> @string outResult : outResult := "NSString" ; end reader ;
#override reader @fontType ocClassName -> @string outResult : outResult := "NSFont" ; end reader ;
#override reader @imageType ocClassName -> @string outResult : outResult := "NSImage" ; end reader ;
#override reader @colorType ocClassName -> @string outResult : outResult := "NSColor" ; end reader ;
#override reader @dataType ocClassName -> @string outResult : outResult := "NSData" ; end reader ;
#override reader @dateType ocClassName -> @string outResult : outResult := "NSDate" ; end reader ;
#override reader @objectArrayType ocClassName -> @string outResult : outResult := "NSArray" ; end reader ;
#override reader @menuType ocClassName -> @string outResult : outResult := "NSMenu" ; end reader ;
#override reader @bezierPathType ocClassName -> @string outResult : outResult := "NSBezierPath" ; end reader ;
#override reader @toOneEntityType ocClassName -> @string outResult : outResult := "??" ; end reader ;
#override reader @toManyEntitiesType ocClassName -> @string outResult : outResult := "??" ; end reader ;
#override reader @enumType ocClassName -> @string outResult : outResult := mEnumTypeName->string ; end reader ;
#override reader @structType ocClassName -> @string outResult : outResult := mStructTypeName->string ; end reader ;

#-----------------------------------------------------------------------------*

#method @easyBindingType addEnumAndStructType
#  ?!@stringset unused ioSet
#:
#end method ;
#
#
#override method @enumType addEnumAndStructType
#  ?!@stringset ioSet
#:
#  ioSet += !mEnumTypeName->string ;
#end method ;
#
#override method @structType addEnumAndStructType
#  ?!@stringset ioSet
#:
#  ioSet += !mStructTypeName->string ;
#end method ;

#----------------------------------------------------------------------------*

struct @fileInclusionSet {
  @stringset mHeaderPredeclarationSet ;
  @stringset mHeaderFileInclusionSet ;
  @stringset mImplementationFileInclusionSet ;
}

#-----------------------------------------------------------------------------*

map @globalEnumConstantMap {
  @lstring mEnumTypeName ;
  insert insertKey error message "the '%K' enumeration constant is already declared" ;
  search searchKey error message "the '%K' enumeration constant is not declared" ;
}

#----------------------------------------------------------------------------*

map @enumMap {
  @lstringlist mConstantOrderedList ;
  @enumConstantMap mEnumConstantMap ;
  insert insertKey error message "the '%K' enumeration is already declared" ;
  search searchKey error message "the '%K' enumeration is not declared" ;
}

#----------------------------------------------------------------------------*

map @userCursorMap {
  @double mHotSpotX ;
  @double mHotSpotY ;
  insert insertKey error message "the '%K' cursor is already declared" ;
  search searchKey error message "the '%K' cursor is not declared" ;
}

#----------------------------------------------------------------------------*

map @structTypeMap {
  @structFieldList mFieldList ;
  insert insertKey error message "the '%K' struct is already declared" ;
  search searchKey error message "the '%K' struct is not declared" ;
}

#----------------------------------------------------------------------------*

struct @contextAnalysisStruct {
  @observablePropertyMapMap mObservablePropertyMapMap ;
  @structTypeMap mStructTypeMap ;
  @enumMap mEnumMap ;
  @globalEnumConstantMap mGlobalEnumConstantMap ;
  @userCursorMap mUserCursorMap ;
  @classMap mClassMap ;
  @protocolMap mProtocolMap ;
  @preferencesMap mPreferencesMap ;
  @entityMap mEntityMap ;
  @controllerClassMap mControllerClassMap ;
  @outletClassMap mOutletClassMap ;
  @transientDependencyGraph mTransientDependencyGraph ;
}

#----------------------------------------------------------------------------*

map @classMap {
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @propertyArrayMap mAllArrayPropertyForImplementation ;
  insert insertKey error message "the '%K' class is already declared" ;
  search searchKey error message "the '%K' class is not declared" ;
}

#----------------------------------------------------------------------------*

map @entityMap {
  @string mSuperEntityName ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @relationshipList mAllRelationshipList ;
  @propertyMap mAllPropertyMap ;
  @relationshipMap mCurrentRelationshipMap ;
  @relationshipMap mAllRelationshipMap ;
  @fileInclusionSet mFileInclusionSet ;
  @signListForGeneration mSignList ;
  insert insertKey error message "the '%K' entity is already declared" ;
  search searchKey error message "the '%K' entity is not declared" ;
}

#----------------------------------------------------------------------------*

list @signListForGeneration {
  @string mPropertyName ;
  @ebType mPropertyType ;
}

#----------------------------------------------------------------------------*

list @entityListForGeneration {
  @string mEntityName ;
  @string mSuperEntityName ;
  @observablePropertyMap mObservablePropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @relationshipList mAllRelationshipList ;
  @propertyMap mAllPropertyMap ;
  @relationshipMap mCurrentRelationshipMap ;
  @relationshipMap mAllRelationshipMap ;
  @2stringlist mToManyRelationshipList ;
  @fileInclusionSet mFileInclusionSet ;
  @2stringlist mToOneRelationshipList ;
  @signListForGeneration mSignList ;
}

#----------------------------------------------------------------------------*

class @runBindingForGeneration extends @abstractBindingForGeneration {
  @string mTargetName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*

class @regularBindingForGeneration extends @abstractBindingForGeneration {
  @string mBindingName ;
  @formatterEnum mRequiredFormatter ;
  @string mObservedObjectName ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

list @columnBindingForTableValueBindingForGeneration {
  @string mColumnIdentifier ;
  @string mRequiredCellClass ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

class @tableValueBindingForGeneration extends @abstractBindingForGeneration {
  @string mControllerName ;
  @columnBindingForTableValueBindingForGeneration mColumnBindingForTableValueBindingForGeneration ;
}

#----------------------------------------------------------------------------*

map @protocolMap {
  @bool mIsPredefined ; # Generate import otherwise
  insert insertKey error message "the '%K' protocol is already declared" ;
  search searchKey error message "the '%K' protocol is not declared" ;
}

#----------------------------------------------------------------------------*

list @protocolList {
  @bool mNeedsInclusionInHeader ;
  @string mProtocolName ;
}

#----------------------------------------------------------------------------*

map @outletClassMap {
  @generationKind mGenerationKind ;
  @string mSuperClassName ;
  @protocolList mAdoptedProtocolList ;
  @bool mImplementsDeallocProtocol ;
  @outletClassBindingMap mAllBindingMap ;
  @outletClassBindingMap mCurrentBindingMap ;
  @bool mHasTableValueBinding ;
  insert insertKey error message "the '%K' outlet class is already declared" ;
  search searchKey error message "the '%K' outlet class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerClassMap {
  @controllerKind mControllerKind ;
  @generationKind mGenerationKind ;
  @outletClassBindingMap mBindingMap ;
  @actionMap mActionMap ;
  @observablePropertyMap mObservablePropertyMap ;
  @outletClassBindingOptionMap mControlledObjectAvailableBindingOptionMap ;
  insert insertKey error message "the '%K' controller class is already declared" ;
  search searchKey error message "the '%K' controller class is not declared" ;
}

#----------------------------------------------------------------------------*

map @relationshipMap {
  @bool mIsToMany ;
  @lstring mDestinationEntityName ;
  @lstring mInverseRelationshipName ;
  @bool mInverseIsToMany ;
  @deleteRuleEnum mDeleteRule ;
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
}

#----------------------------------------------------------------------------*

map @propertyMap {
  insert insertKey error message "there is already a '%K' property (attribute, transient or relationship)" ;
}

#----------------------------------------------------------------------------*

list @attributeListForImplementation {
  @ebType mType ;
  @string mAttributeName ;
  @string mDefaultValueAsObjectiveCObject ;
  @string mDirectDefaultValue ;
}

#----------------------------------------------------------------------------*

abstract class @abstractBindingForGeneration {
}

#----------------------------------------------------------------------------*

list @outletBindingListForGeneration {
  @abstractBindingForGeneration mBinding ;
}

#----------------------------------------------------------------------------*

list @outletGenerationList {
  @string mOutletType ;
  @string mOutletName ;
  @outletBindingListForGeneration mOutletBindingList ;
  @bool mImplementsDeallocProtocol ;
}

#----------------------------------------------------------------------------*

map @propertyArrayMap {
  @ebType mElementType ;
  insert insertKey error message "the '%K' array is already declared" ;
  search searchKey error message "the '%K' array is not declared" ;
}

#----------------------------------------------------------------------------*

map @preferencesPropertyArrayMap {
  @ebType mElementType ;
  @attributeListForImplementation mAttributeListForImplementation ;
  insert insertKey error message "the '%K' array is already declared" ;
  search searchKey error message "the '%K' array is not declared" ;
}

#----------------------------------------------------------------------------*

map @preferencesMap {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @observablePropertyMap mObservablePropertyMap ;
  @fileInclusionSet mFileInclusionSet ;
  @controllerMap mControllerMap ;
  insert insertKey error message "the '%K' preference is already declared" ;
  search searchKey error message "the '%K' preference is not declared" ;
}

#----------------------------------------------------------------------------*

map @nibClassMap {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @observablePropertyMap mObservablePropertyMap ;
  @fileInclusionSet mFileInclusionSet ;
  @controllerMap mControllerMap ;
  @propertyArrayMap mArrayMap ;
  insert insertKey error message "the '%K' nib class is already declared" ;
  search searchKey error message "the '%K' nib class is not declared" ;
}

#----------------------------------------------------------------------------*

map @observablePropertyMap {
  @ebType mType ;
  @bool mIsTransient ;
  @lstring mPropertySignature ;
  @bool mIsCollection ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#----------------------------------------------------------------------------*

map @observableObjectMap {
  @string mObservableObjectOCName ;
  @string mObservableObjectTypeOCName ;
  @string mIncludeFileName ; # Empty string if no file to include
  @observablePropertyMap mObservableProperties ;
  insert insertKey error message "the '%K' observable object is already declared" ;
  search searchKey error message "the '%K' observable object is not declared" ;
}

#----------------------------------------------------------------------------*

map @actionMap {
  insert insertKey error message "there is already a '%K' action" ;
  search searchKey error message "the '%K' action is not defined" ;
}

#----------------------------------------------------------------------------*

map @controllerMap {
  @string mControllerClassName ;
  @lstring mControlledClassOrEntityName ;
  @bool mIsEntity ;
  @outletBindingListForGeneration mControllerBindingList ;
  @actionMap mActionMap ;
  @observablePropertyMap mObservableAttributeMap ;
  insert insertKey error message "the '%K' controller is already declared" ;
  search searchKey error message "the '%K' controller is not declared" ;
}

#----------------------------------------------------------------------------*

abstract class @abstractTransientDependencyForImplementation {
  @ebType mMasterAttributeType ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromSelfForImplementation extends @abstractTransientDependencyForImplementation {
  @string mMasterAttributeName ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromControllerForImplementation extends @abstractTransientDependencyForImplementation {
  @string mControllerName ;
  @string mMasterAttributeName ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromRootForImplementation extends @abstractTransientDependencyForImplementation {
  @string mMasterAttributeName ;
  @bool mNamesCountOption ;
  @string mTriggerRoutineName ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromPreferenceForImplementation extends @abstractTransientDependencyForImplementation {
  @string mPreferenceName ;
  @string mMasterAttributeName ;
  @bool mMasterIsTransient ;
}

#----------------------------------------------------------------------------*

list @directDependancyList {
  @abstractTransientDependencyForImplementation mDependency ;
}

#----------------------------------------------------------------------------*

list @transientListForImplementation {
  @ebType mTransientType ;
  @string mTransientName ;
  @directDependancyList mDependencyList ;
  @stringlist mRootSignDependencyList ;
}

#----------------------------------------------------------------------------*

graph @transientDependencyGraph (@stringlist) {
  insert addNode error message "the '%K' transient is already declared at %L" ;
}

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeOutletBinding
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@observablePropertyMap inSelfObservableAttributeMap
  ??@outletClassBindingMap inBoundObjectBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool inHasTableValueBinding
  ??@contextAnalysisStruct inContextAnalysisStruct
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@fileInclusionSet ioFileInclusionSet
;

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateRemoveBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

abstract method @abstractDefaultValue analyzeDefaultValueType 
  ??@ebTypeList inAttributeActualTypeList
  ??@contextAnalysisStruct inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  ?!@fileInclusionSet ioFileInclusionSet
;

#----------------------------------------------------------------------------*
  
override method @boolAsDefaultValue analyzeDefaultValueType 
  ??@ebTypeList inAttributeActualTypeList
  ??@contextAnalysisStruct unused inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@typeKind boolType] then
      outDirectDefaultValueAsString := if mValue->bool then "YES" else "NO" end ;
      outObjectiveCDefaultValueAsString := "[NSNumber numberWithBool:" . outDirectDefaultValueAsString . "]" ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a boolean attribute can be initialized by YES or NO"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @integerAsDefaultValue analyzeDefaultValueType 
  ??@ebTypeList inAttributeActualTypeList
  ??@contextAnalysisStruct unused inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@typeKind integerType] then
      outDirectDefaultValueAsString := [mValue->uint string] ;
      outObjectiveCDefaultValueAsString := "[NSNumber numberWithInteger:" . outDirectDefaultValueAsString . "]" ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only an integer attribute can be initialized by an integer constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @doubleAsDefaultValue analyzeDefaultValueType 
  ??@ebTypeList inAttributeActualTypeList
  ??@contextAnalysisStruct unused inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@typeKind doubleType] then
      outDirectDefaultValueAsString := [mValue->double string] ;
      outObjectiveCDefaultValueAsString := "[NSNumber numberWithDouble:" . outDirectDefaultValueAsString . "]" ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a double attribute can be initialized by a floating point constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @stringAsDefaultValue analyzeDefaultValueType 
  ??@ebTypeList inAttributeActualTypeList
  ??@contextAnalysisStruct unused inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@typeKind stringType] then
      outDirectDefaultValueAsString := "@" . [mValue->string utf8Representation] ;
      outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a string attribute can be initialized by a string constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

local once predefinedColors -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"blackColor" ;
  outResult += !"blueColor" ;
  outResult += !"brownColor" ;
  outResult += !"clearColor" ;
  outResult += !"controlColor" ;
  outResult += !"controlDarkShadowColor" ;
  outResult += !"controlHighlightColor" ;
  outResult += !"controlLightHighlightColor" ;
  outResult += !"controlShadowColor" ;
  outResult += !"controlTextColor" ;
  outResult += !"cyanColor" ;
  outResult += !"darkGrayColor" ;
  outResult += !"disabledControlTextColor" ;
  outResult += !"grayColor" ;
  outResult += !"greenColor" ;
  outResult += !"gridColor" ;
  outResult += !"headerColor" ;
  outResult += !"headerTextColor" ;
  outResult += !"highlightColor" ;
  outResult += !"keyboardFocusIndicatorColor" ;
  outResult += !"knobColor" ;
  outResult += !"lightGrayColor" ;
  outResult += !"magentaColor" ;
  outResult += !"orangeColor" ;
  outResult += !"purpleColor" ;
  outResult += !"redColor" ;
  outResult += !"scrollBarColor" ;
  outResult += !"selectedControlColor" ;
  outResult += !"selectedControlTextColor" ;
  outResult += !"selectedKnobColor" ;
  outResult += !"selectedMenuItemColor" ;
  outResult += !"selectedMenuItemTextColor" ;
  outResult += !"selectedTextBackgroundColor" ;
  outResult += !"selectedTextColor" ;
  outResult += !"shadowColor" ;
  outResult += !"textBackgroundColor" ;
  outResult += !"textColor" ;
  outResult += !"whiteColor" ;
  outResult += !"windowBackgroundColor" ;
  outResult += !"windowFrameColor" ;
  outResult += !"windowFrameTextColor" ;
  outResult += !"yellowColor" ;
end once ;

#----------------------------------------------------------------------------*

local once predefinedDates -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"date" ;
end once ;

#----------------------------------------------------------------------------*
  
override method @identifierAsDefaultValue analyzeDefaultValueType 
  ??@ebTypeList inAttributeActualTypeList
  ??@contextAnalysisStruct inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  ?!@fileInclusionSet ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@typeKind colorType] then
      found := true ;
      if [predefinedColors [] hasKey !mValue->string] then
        outDirectDefaultValueAsString := "[NSColor " . mValue->string . "]" ;
        outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
      else
        error mValue
        : "unknown predefined color"
        : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
        ;  
      end if ;
    elsif mType->mKind == [@typeKind dateType] then
      found := true ;
      if [predefinedDates [] hasKey !mValue->string] then
        outDirectDefaultValueAsString := "[NSDate " . mValue->string . "]" ;
        outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
      else
        error mValue
        : "unknown predefined date"
        : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
        ;  
      end if ;
    elsif mType->mKind == [@typeKind enumType] then
      found := true ;
      if [inContextAnalysisStruct->mGlobalEnumConstantMap hasKey !mValue->string] then
        [inContextAnalysisStruct->mGlobalEnumConstantMap searchKey !mValue ?@lstring inEnumTypeName] ;
        ioFileInclusionSet->mHeaderFileInclusionSet += !inEnumTypeName->string ;
        if [mType ebTypeName] == inEnumTypeName->string then
          outDirectDefaultValueAsString := mValue->string ;
          outObjectiveCDefaultValueAsString := "[NSNumber numberWithInteger:" . mValue->string . "]" ; ;
        else
          error mValue
          : "bad enum constant, belongs to the '" . inEnumTypeName . "' enum type"
          : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
          ;  
        end if ;
      else
        error mValue
        : "the '" . [mType ebTypeName] . "' enumeration does not define '" . mValue . "' constant"
        : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
        ;  
      end if ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "unknow type for this identifier"
    : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

local once predefinedFonts -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"boldSystemFontOfSize" ;
  outResult += !"controlContentFontOfSize" ;
  outResult += !"labelFontOfSize" ;
  outResult += !"menuFontOfSize" ;
  outResult += !"menuBarFontOfSize" ;
  outResult += !"messageFontOfSize" ;
  outResult += !"paletteFontOfSize" ;
  outResult += !"systemFontOfSize" ;
  outResult += !"titleBarFontOfSize" ;
  outResult += !"toolTipsFontOfSize" ;
end once ;

#----------------------------------------------------------------------------*
 
override method @listAsDefaultValue analyzeDefaultValueType 
  ??@ebTypeList inAttributeActualTypeList
  ??@contextAnalysisStruct inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  ?!@fileInclusionSet ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@typeKind structType] then
      found := true ;
      ioFileInclusionSet->mHeaderFileInclusionSet += ![mType ebTypeName] ;
      [inContextAnalysisStruct->mStructTypeMap searchKey
        !mType->mTypeName
        ?@structFieldList fieldList
      ] ;
      if [mDefaultValueList length] != [fieldList length] then
        error mStartLocation : "the '" . [mType ebTypeName] . "' struct needs " . [fieldList length] . " values for initialization" ;
      else
        outDirectDefaultValueAsString := "make" . [mType ebTypeName] . " (" ;
        foreach mDefaultValueList, fieldList
        do
          [mDefaultValue analyzeDefaultValueType
            ![@ebTypeList listWithValue !mFieldType]
            !inContextAnalysisStruct
            ?@string directDefaultValueAsString
            ?*
            !?ioFileInclusionSet
          ] ;
          outDirectDefaultValueAsString .= directDefaultValueAsString ;
        between
          outDirectDefaultValueAsString .= ", " ;
        end foreach ; 
        outDirectDefaultValueAsString .= ")" ;     
      end if ;
    elsif mType->mKind == [@typeKind fontType] then
      found := true ;
      const @string errorMessage := "an NSFont should be initialized by a (fontName, fontSize) value" ;
      if [mDefaultValueList length] != 2 then
        error mStartLocation : errorMessage ; 
      else
        const @abstractDefaultValue v0 := [mDefaultValueList mDefaultValueAtIndex !0] ; 
        const @abstractDefaultValue v1 := [mDefaultValueList mDefaultValueAtIndex !1] ;
        @identifierAsDefaultValue fontName ;
        if (v0 is @identifierAsDefaultValue) then 
          fontName := (cast v0 : @identifierAsDefaultValue) ;
        else
          error mStartLocation : errorMessage : fontName ;
        end if ;
        @integerAsDefaultValue fontSize ;
        if (v1 is @integerAsDefaultValue) then 
          fontSize := (cast v1 : @integerAsDefaultValue) ;
        else
          error mStartLocation : errorMessage : fontSize ;
        end if ;
        if [predefinedFonts [] hasKey ![fontName mValue]->string] then
          outDirectDefaultValueAsString := "[NSFont " . [fontName mValue]->string . ":" . [[fontSize mValue]->uint string] . "]" ;
          outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
        else
          error [fontName mValue]
          : "unknown predefined font name"
          : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
          ;  
        end if ;
      end if ;
    end if ;
  end foreach ;
  if not found then
    error mStartLocation
    : "invalid initialization value"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

map @observablePropertyMapMap {
  @typeKind mType ;
  @observablePropertyMap mObservablePropertyMap ;
  insert insertKey error message "the '%K' key is already declared" ;
  search searchKey error message "the '%K' key is not declared" ;
}

#----------------------------------------------------------------------------*

abstract method @astDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
;

#----------------------------------------------------------------------------*

abstract class @generation {
  @string mGenerationName ;
}

#----------------------------------------------------------------------------*

list @generationList {
  @generation mGeneration ;
}

#----------------------------------------------------------------------------*

abstract method @astDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
;

#----------------------------------------------------------------------------*

abstract method @generation generate
  ??@string inOutputDirectory
;

#----------------------------------------------------------------------------*

class @structTypeGeneration extends @generation {
  @structFieldList mFieldList ;
  @stringset mHeaderFileInclusionSet ;
}

#----------------------------------------------------------------------------*

class @enumTypeGeneration extends @generation {
  @lstringlist mConstantOrderedList ;
}

#----------------------------------------------------------------------------*

class @classTypeGeneration extends @generation {
  @string mSuperClassName ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @propertyArrayMap mAllArrayPropertyForImplementation ;
  @propertyArrayMap mCurrentArrayPropertyForImplementation ;
  @fileInclusionSet mInclusionSet ;
}

#----------------------------------------------------------------------------*

class @nibClassTypeGeneration extends @generation {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @observablePropertyMap mObservablePropertyMap ;
  @fileInclusionSet mFileInclusionSet ;
  @controllerMap mControllerMap ;
  @propertyArrayMap mArrayMap ;
}

#----------------------------------------------------------------------------*

class @preferenceTypeGeneration extends @generation {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @fileInclusionSet mFileInclusionSet ;
  @controllerMap mControllerMap ;
  @preferencesPropertyArrayMap mArrayMap ;
}

#----------------------------------------------------------------------------*

class @entityGeneration extends @generation {
  @string mSuperEntityName ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @fileInclusionSet mFileInclusionSet ;
  @signListForGeneration mSignList ;
  @2stringlist mToManyRelationshipList ;
  @2stringlist mToOneRelationshipList ;
}

#----------------------------------------------------------------------------*

class @documentGeneration extends @generation {
  @string mRootEntityName ;
  @outletGenerationList mOutletDeclarationList ;
  @controllerMap mControllerMap ;
  @lstringlist mActionList ;
  @transientListForImplementation mTransientListForImplementation ;
  @fileInclusionSet mFileInclusionSet ;
  @attributeListForImplementation mAttributeListForImplementation ;
}

#----------------------------------------------------------------------------*

end semantics ;
