semantics decoratedTypes :
  import "abstractSyntaxTypes.gSemantics" ;
  import "easyBindings_options.gOptions" ;

#----------------------------------------------------------------------------*

list @unifiedTypeProxySelectorList {
  @unifiedTypeProxy mType ;
  @lstring mSelector ;
}

#----------------------------------------------------------------------------*

list @unifiedTypeProxyList {
  @unifiedTypeProxy mType ;
}

#----------------------------------------------------------------------------*

map @arrayControllerMap {
  @abstractObservablePropertyAST mBoundModel ;
  @lstring mTableViewOutletName ;
  @arrayControllerBoundColumnListAST mArrayControllerBoundColumnListAST ;
  @actionMap mActionMap ;
  insert insertKey error message "the '%K' controller is already declared" ;
  search searchKey error message "there is no '%K' controller" ;
}

#----------------------------------------------------------------------------*

uniquemap @unifiedTypeMap @unifiedTypeProxy {
  insert insertKey error message "the '%K' type is already declared" ;
  search searchKey error message "the '%K' type is not declared" ;

  @typeKind mTypeKind ;
  @unifiedTypeProxy mSuperType ;
  @unifiedTypeProxy mRootEntityType ;
  @decoratedAttributeMap mDecoratedAttributeMap ;
  @decoratedTransientMap mDecoratedTransientMap ;
  @decoratedOutletMap mDecoratedOutletMap ;
  @decoratedObservablePropertyMap mObservablePropertyMap ;
  @decoratedEntityRelationshipMap mCurrentRelationshipMap ;
  @actionMap mActionMap ;
  @bindingList mBindingList ;
  @lstringlist mEnumConstantList ;
  @enumConstantMap mEnumConstantMap ;
  @arrayControllerMap mArrayControllerMap ;
}

#----------------------------------------------------------------------------*

map @enumConstantMap {
  insert insertKey error message "there is already a '%K' constant" ;
  search searchKey error message "the '%K' constant is not defined" ;
}

#----------------------------------------------------------------------------*

map @actionMap {
  insert insertKey error message "there is already a '%K' action" ;
  search searchKey error message "the '%K' action is not defined" ;
}

#----------------------------------------------------------------------------*

map @decoratedEntityRelationshipMap {
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
  @bool mIsToMany ;
  @unifiedTypeProxy mRelationshipType ;
  @lstring mOppositeRelationshipName ;
}

#----------------------------------------------------------------------------*

map @decoratedTransientMap {
  insert insertKey error message "the '%K' transient is already declared" ;
  search searchKey error message "the '%K' transient is not declared" ;
  @unifiedTypeProxy mTransientType ;
  @lstring mTransientSignature ;
  @dependanceList mDependencyList ;
}

#----------------------------------------------------------------------------*

map @decoratedOutletMap {
  insert insertKey error message "the '%K' transient is already declared" ;
  search searchKey error message "the '%K' transient is not declared" ;
  @lstring mOutletTypeName ;
  @lstring mRunTargetName ;
  @lstring mRunActionName ;
}

#----------------------------------------------------------------------------*

map @decoratedAttributeMap {
  @unifiedTypeProxy mAttributeType ;
  @abstractDefaultValue mDefaultValue ;
  insert insertKey error message "the '%K' attribute is already declared in %L" ;
  search searchKey error message "there is no '%K' attribute" ;
}

#----------------------------------------------------------------------------*

map @outletClassMap {
  @bool mHandlesRunAction ;
  insert insertKey error message "the '%K' outlet class is already declared in %L" ;
  search searchKey error message "there is no '%K' outlet class" ;
}

#----------------------------------------------------------------------------*

map @decoratedObservablePropertyMap {
  @unifiedTypeProxy mPropertyType ;
  @bool mIsTransient ;
  @lstring mPropertySignature ;
  @bool mIsCollection ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#----------------------------------------------------------------------------*

abstract method @astDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
;

#----------------------------------------------------------------------------*

list @transientDependencyGraphNodeInfoList {
  @string mSignature ;
  @bool mIsTransient ;
}

#----------------------------------------------------------------------------*

graph @transientDependencyGraph (@transientDependencyGraphNodeInfoList) {
  insert addNode error message "the '%K' property is already declared at %L" ;
}

#----------------------------------------------------------------------------*

reader @typeKind kindName -> @string outResult :
  switch selfcopy
  when classType : outResult := "class" ;
  when controllerClassType : outResult := "controller" ;
  when documentType : outResult := "document" ;
  when entityType : outResult := "entity" ;
  when preferencesType : outResult := "preference" ;
#--- Predefined Type
  when boolType, integerType, uintegerType, doubleType, stringType,
  colorType, dataType, dateType, fontType, imageType, menuType, bezierPathType,
  structType, enumType, nibClassType, outletClassType, protocolType :
    outResult := "<kindName ??>" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @typeKind suitableForObservableProperty -> @bool outResult :
  switch selfcopy
  when classType, controllerClassType, documentType,
  entityType, preferencesType,
  nibClassType, outletClassType, protocolType : outResult := false ;
#--- Predefined Type
  when boolType, integerType, uintegerType, doubleType, stringType,
  colorType, dataType, dateType, fontType, imageType, menuType, bezierPathType,
  structType, enumType :
    outResult := true ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

list @transientDependencyListForGeneration {
  @unifiedTypeProxy mMasterType ;
  @string mMasterName ;
}

#----------------------------------------------------------------------------*

list @transientListForGeneration {
  @string mTransientSignature ;
  @unifiedTypeProxy mTransientType ;
  @transientDependencyListForGeneration mTransientDependencyListForGeneration ;
}

#----------------------------------------------------------------------------*

list @actionListForGeneration {
  @string mClassName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*

list @arrayControllerBoundColumnListForGeneration {
  @string mColumnName ;
  @string mColumnOutletTypeName ;
  @string mObservablePropertyName ;
  @unifiedTypeProxy mPropertyType ;
  @bindingOptionList mBindingOptionList ;
}

#----------------------------------------------------------------------------*

list @arrayControllerForGeneration {
  @string mControllerName ;
  @string mObjectTypeName ;
  @string mTomanyRelationshipName ;
  @string mElementTypeName ;
  @string mTableViewOutletName ;
  @arrayControllerBoundColumnListForGeneration mArrayControllerBoundColumnListForGeneration ;
}

#----------------------------------------------------------------------------*

list @targetActionList {
  @string mOutletName ;
  @string mTargetName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*
















##----------------------------------------------------------------------------*
#
#map @enumConstantMap {
#  insert insertKey error message "the '%K' enumeration constant is already declared" ;
#  search searchKey error message "the '%K' enumeration constant is not declared" ;
#}
#
#
##----------------------------------------------------------------------------*
#
#struct @fileInclusionSet {
#  @stringset mHeaderPredeclarationSet ;
#  @stringset mHeaderFileInclusionSet ;
#  @stringset mImplementationFileInclusionSet ;
#}
#
##-----------------------------------------------------------------------------*
#
#map @globalEnumConstantMap {
#  @lstring mEnumTypeName ;
#  insert insertKey error message "the '%K' enumeration constant is already declared" ;
#  search searchKey error message "the '%K' enumeration constant is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @enumMap {
#  @lstringlist mConstantOrderedList ;
#  @enumConstantMap mEnumConstantMap ;
#  insert insertKey error message "the '%K' enumeration is already declared" ;
#  search searchKey error message "the '%K' enumeration is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @userCursorMap {
#  @double mHotSpotX ;
#  @double mHotSpotY ;
#  insert insertKey error message "the '%K' cursor is already declared" ;
#  search searchKey error message "the '%K' cursor is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @structTypeMap {
##  @structFieldList mFieldList ;
#  insert insertKey error message "the '%K' struct is already declared" ;
#  search searchKey error message "the '%K' struct is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#struct @EXcontextAnalysisStruct {
#  @EXobservablePropertyMapMap mObservablePropertyMapMap ;
#  @structTypeMap mStructTypeMap ;
#  @enumMap mEnumMap ;
#  @globalEnumConstantMap mGlobalEnumConstantMap ;
#  @userCursorMap mUserCursorMap ;
#  @classMap mClassMap ;
#  @protocolMap mProtocolMap ;
#  @preferencesMap mPreferencesMap ;
#  @entityMap mEntityMap ;
#  @controllerClassMap mControllerClassMap ;
#  @outletClassMap mOutletClassMap ;
#  @EXtransientDependencyGraph mTransientDependencyGraph ;
#  @bool mContainsDocument ;
#}
#
##----------------------------------------------------------------------------*
#
#map @classMap {
#  @attributeListForImplementation mAttributeListForInitMethodHeader ;
#  @propertyArrayMap mAllArrayPropertyForImplementation ;
#  insert insertKey error message "the '%K' class is already declared" ;
#  search searchKey error message "the '%K' class is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @entityMap {
#  @string mSuperEntityName ;
#  @attributeListForImplementation mAttributeListForInitMethodHeader ;
#  @attributeListForImplementation mInheritedAttributeListForImplementation ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @relationshipList mCurrentRelationshipList ;
#  @relationshipList mAllRelationshipList ;
#  @propertyMap mAllPropertyMap ;
#  @relationshipMap mCurrentRelationshipMap ;
#  @relationshipMap mAllRelationshipMap ;
#  @fileInclusionSet mFileInclusionSet ;
##  @signListForGeneration mSignList ;
#  insert insertKey error message "the '%K' entity is already declared" ;
#  search searchKey error message "the '%K' entity is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#list @entityListForGeneration {
#  @string mEntityName ;
#  @string mSuperEntityName ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#  @attributeListForImplementation mAttributeListForInitMethodHeader ;
#  @attributeListForImplementation mInheritedAttributeListForImplementation ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @relationshipList mCurrentRelationshipList ;
#  @relationshipList mAllRelationshipList ;
#  @propertyMap mAllPropertyMap ;
#  @relationshipMap mCurrentRelationshipMap ;
#  @relationshipMap mAllRelationshipMap ;
#  @2stringlist mToManyRelationshipList ;
#  @fileInclusionSet mFileInclusionSet ;
#  @2stringlist mToOneRelationshipList ;
##  @signListForGeneration mSignList ;
#}
#
##----------------------------------------------------------------------------*
#
#class @runBindingForGeneration extends @abstractBindingForGeneration {
#  @string mTargetName ;
#  @string mActionName ;
#}
#
##----------------------------------------------------------------------------*
#
#class @treeControllerForGeneration extends @abstractBindingForGeneration {
#  @string mChildrenKeyPathName ;
#}
#
##----------------------------------------------------------------------------*
#
#list @bindingOptionListForGeneration {
#  @string mOptionName ;
#  @string mObjectiveCOptionString ;
#  @string mSwiftOptionString ;
#}
#
##----------------------------------------------------------------------------*
#
#class @regularBindingForGeneration extends @abstractBindingForGeneration {
##  @EXebType mObservableAttributeType ;
#  @string mBindingName ;
#  @formatterEnum mRequiredFormatter ;
#  @string mObservedObjectName ;
#  @string mObservableAttributeName ;
#  @bool mRequiresInterrogationMark ;
#  @bindingOptionListForGeneration mOutletBindingOptionList ;
#}
#
##----------------------------------------------------------------------------*
#
#list @columnBindingForTableValueBindingForGeneration {
#  @string mColumnIdentifier ;
#  @string mRequiredCellClass ;
#  @string mObservableAttributeName ;
#  @2stringlist mOutletBindingOptionList ;
#}
#
##----------------------------------------------------------------------------*
#
#class @tableValueBindingForGeneration extends @abstractBindingForGeneration {
#  @string mControllerName ;
#  @columnBindingForTableValueBindingForGeneration mColumnBindingForTableValueBindingForGeneration ;
#}
#
##----------------------------------------------------------------------------*
#
#map @protocolMap {
#  @bool mIsPredefined ; # Generate import otherwise
#  insert insertKey error message "the '%K' protocol is already declared" ;
#  search searchKey error message "the '%K' protocol is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#list @protocolList {
#  @bool mNeedsInclusionInHeader ;
#  @string mProtocolName ;
#}
#
##----------------------------------------------------------------------------*
#
#map @outletClassMap {
#  @generationKind mGenerationKind ;
#  @string mSuperClassName ;
#  @protocolList mAdoptedProtocolList ;
#  @bool mImplementsDeallocProtocol ;
##  @outletClassBindingMap mAllBindingMap ;
##  @outletClassBindingMap mCurrentBindingMap ;
#  @bool mHasTableValueBinding ;
#  insert insertKey error message "the '%K' outlet class is already declared" ;
#  search searchKey error message "the '%K' outlet class is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @controllerClassMap {
#  @controllerKind mControllerKind ;
#  @generationKind mGenerationKind ;
##  @outletClassBindingMap mBindingMap ;
#  @actionMap mActionMap ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
##  @outletClassBindingOptionMap mControlledObjectAvailableBindingOptionMap ;
#  insert insertKey error message "the '%K' controller class is already declared" ;
#  search searchKey error message "the '%K' controller class is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @relationshipMap {
#  @bool mIsToMany ;
#  @lstring mDestinationEntityName ;
#  @lstring mInverseRelationshipName ;
#  @bool mInverseIsToMany ;
#  @deleteRuleEnum mDeleteRule ;
#  insert insertKey error message "the '%K' relationship is already declared" ;
#  search searchKey error message "the '%K' relationship is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @propertyMap {
#  insert insertKey error message "there is already a '%K' property (attribute, transient or relationship)" ;
#}
#
##----------------------------------------------------------------------------*
#
#list @attributeListForImplementation {
##  @EXebType mType ;
#  @string mAttributeName ;
#  @string mDefaultValueAsObjectiveCObject ;
#  @string mDirectOCDefaultValue ;
#  @string mDirectSwiftDefaultValue ;
#}
#
##----------------------------------------------------------------------------*
#
#abstract class @abstractBindingForGeneration {
#}
#
##----------------------------------------------------------------------------*
#
#list @outletBindingListForGeneration {
#  @abstractBindingForGeneration mBinding ;
#}
#
##----------------------------------------------------------------------------*
#
#list @outletGenerationList {
#  @string mOutletType ;
#  @string mOutletName ;
#  @outletBindingListForGeneration mOutletBindingList ;
#  @bool mImplementsDeallocProtocol ;
#}
#
##----------------------------------------------------------------------------*
#
#map @preferencesMap {
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @outletGenerationList mOutletDeclarationList ;
#  @lstringlist mActionList ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#  @fileInclusionSet mFileInclusionSet ;
#  @controllerMap mControllerMap ;
#  insert insertKey error message "the '%K' preference is already declared" ;
#  search searchKey error message "the '%K' preference is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @nibClassMap {
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @outletGenerationList mOutletDeclarationList ;
#  @lstringlist mActionList ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#  @fileInclusionSet mFileInclusionSet ;
#  @controllerMap mControllerMap ;
#  @propertyArrayMap mArrayMap ;
#  insert insertKey error message "the '%K' nib class is already declared" ;
#  search searchKey error message "the '%K' nib class is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @observableObjectMap {
#  @string mObservableObjectOCName ;
#  @string mObservableObjectTypeOCName ;
#  @string mIncludeFileName ; # Empty string if no file to include
#  @EXobservablePropertyMap mObservableProperties ;
#  insert insertKey error message "the '%K' observable object is already declared" ;
#  search searchKey error message "the '%K' observable object is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#map @controllerMap {
#  @string mControllerClassName ;
#  @lstring mControlledClassOrEntityName ;
#  @bool mIsEntity ;
#  @outletBindingListForGeneration mControllerBindingList ;
#  @actionMap mActionMap ;
#  @EXobservablePropertyMap mObservableAttributeMap ;
#  insert insertKey error message "the '%K' controller is already declared" ;
#  search searchKey error message "the '%K' controller is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#abstract class @abstractTransientDependencyForImplementation {
#  @EXebType mMasterAttributeType ;
#}
#
##----------------------------------------------------------------------------*
#
#class @transientDependencyFromSelfForImplementation extends @abstractTransientDependencyForImplementation {
#  @string mMasterAttributeName ;
#  @bool mNamesCountOption ;
#}
#
##----------------------------------------------------------------------------*
#
#class @transientDependencyFromControllerForImplementation extends @abstractTransientDependencyForImplementation {
#  @string mControllerName ;
#  @string mMasterAttributeName ;
#}
#
##----------------------------------------------------------------------------*
#
#class @transientDependencyFromRootForImplementation extends @abstractTransientDependencyForImplementation {
#  @string mMasterAttributeName ;
#  @bool mNamesCountOption ;
#  @string mTriggerRoutineName ;
#}
#
##----------------------------------------------------------------------------*
#
#class @transientDependencyFromPreferenceForImplementation extends @abstractTransientDependencyForImplementation {
#  @string mPreferenceName ;
#  @string mMasterAttributeName ;
#  @bool mMasterIsTransient ;
#}
#
##----------------------------------------------------------------------------*
#
#list @directDependancyList {
#  @abstractTransientDependencyForImplementation mDependency ;
#}
#
##----------------------------------------------------------------------------*
#
#list @transientListForImplementation {
#  @EXebType mTransientType ;
#  @string mTransientName ;
#  @directDependancyList mDependencyList ;
#  @stringlist mRootSignDependencyList ;
#}
#
##----------------------------------------------------------------------------*
#
#graph @EXtransientDependencyGraph (@stringlist) {
#  insert addNode error message "the '%K' transient is already declared at %L" ;
#}
#
##----------------------------------------------------------------------------*
#
#abstract reader @abstractBindingForGeneration generateObjectiveCBinding
#  ??@string inOutletName
#  -> @string outResult
#;
#
##----------------------------------------------------------------------------*
#
#abstract reader @abstractBindingForGeneration generateSwiftBinding
#  ??@string inOutletName
#  -> @string outResult
#;
#
##----------------------------------------------------------------------------*
#
#abstract method @abstractBinding analyzeOutletBinding
#  ??@EXobservablePropertyMap inRootEntityObservableAttributeMap
#  ??@EXobservablePropertyMap inSelfObservableAttributeMap
#  ??@outletClassBindingMap inBoundObjectBindingMap
#  ??@controllerMap inControllerMap
#  ??@actionMap inActionMap
#  ??@bool inHasTableValueBinding
#  ??@EXcontextAnalysisStruct inContextAnalysisStruct
#  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
#  ?!@fileInclusionSet ioFileInclusionSet
#;
#
##----------------------------------------------------------------------------*
#
#abstract reader @abstractBindingForGeneration generateObjectiveCRemoveBinding
#  ??@string inOutletName
#  -> @string outResult
#;
#
##----------------------------------------------------------------------------*
#
#abstract reader @abstractBindingForGeneration generateSwiftRemoveBinding
#  ??@string inOutletName
#  -> @string outResult
#;
#
#----------------------------------------------------------------------------*

abstract method @abstractDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@contextAnalysisStruct inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
;

#----------------------------------------------------------------------------*
  
override method @boolAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind boolType] then
      outSwiftDefaultValueAsString := if mValue->bool then "true" else "false" end ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a boolean attribute can be initialized by YES or NO"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @integerAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind integerType] then
      outSwiftDefaultValueAsString := [mValue->uint string]  ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only an integer attribute can be initialized by an integer constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @doubleAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind doubleType] then
      outSwiftDefaultValueAsString := [mValue->double string] ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a double attribute can be initialized by a floating point constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @stringAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind stringType] then
      outSwiftDefaultValueAsString := "\"". mValue->string . "\"" ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a string attribute can be initialized by a string constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

once predefinedColors -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"blackColor" ;
  outResult += !"blueColor" ;
  outResult += !"brownColor" ;
  outResult += !"clearColor" ;
  outResult += !"controlColor" ;
  outResult += !"controlDarkShadowColor" ;
  outResult += !"controlHighlightColor" ;
  outResult += !"controlLightHighlightColor" ;
  outResult += !"controlShadowColor" ;
  outResult += !"controlTextColor" ;
  outResult += !"cyanColor" ;
  outResult += !"darkGrayColor" ;
  outResult += !"disabledControlTextColor" ;
  outResult += !"grayColor" ;
  outResult += !"greenColor" ;
  outResult += !"gridColor" ;
  outResult += !"headerColor" ;
  outResult += !"headerTextColor" ;
  outResult += !"highlightColor" ;
  outResult += !"keyboardFocusIndicatorColor" ;
  outResult += !"knobColor" ;
  outResult += !"lightGrayColor" ;
  outResult += !"magentaColor" ;
  outResult += !"orangeColor" ;
  outResult += !"purpleColor" ;
  outResult += !"redColor" ;
  outResult += !"scrollBarColor" ;
  outResult += !"selectedControlColor" ;
  outResult += !"selectedControlTextColor" ;
  outResult += !"selectedKnobColor" ;
  outResult += !"selectedMenuItemColor" ;
  outResult += !"selectedMenuItemTextColor" ;
  outResult += !"selectedTextBackgroundColor" ;
  outResult += !"selectedTextColor" ;
  outResult += !"shadowColor" ;
  outResult += !"textBackgroundColor" ;
  outResult += !"textColor" ;
  outResult += !"whiteColor" ;
  outResult += !"windowBackgroundColor" ;
  outResult += !"windowFrameColor" ;
  outResult += !"windowFrameTextColor" ;
  outResult += !"yellowColor" ;
end once ;

#----------------------------------------------------------------------------*

once predefinedDates -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"date" ;
end once ;

#----------------------------------------------------------------------------*
  
override method @identifierAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind colorType] then
      found := true ;
      if [predefinedColors [] hasKey !mValue->string] then
        outSwiftDefaultValueAsString := "NSColor." . mValue->string . " ()" ;
      else
        error mValue
        : "unknown predefined color"
        ;  
      end if ;
    elsif [mType mTypeKind] == [@typeKind dateType] then
      found := true ;
      if [predefinedDates [] hasKey !mValue->string] then
        outSwiftDefaultValueAsString := "NSDate ()" ;
      else
        error mValue
        : "unknown predefined date"
        ;  
      end if ;
    elsif [mType mTypeKind] == [@typeKind enumType] then
      found := true ;
      if [[mType mEnumConstantMap] hasKey !mValue->string] then
          outSwiftDefaultValueAsString := [mType lkey]->string . "." . mValue->string ;
      else
        error mValue
        : "the '" . [mType lkey] . "' enumeration does not define '" . mValue . "' constant"
        : outSwiftDefaultValueAsString
        ;  
      end if ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "unknow type for this identifier"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

once predefinedFonts -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"boldSystemFontOfSize" ;
  outResult += !"controlContentFontOfSize" ;
  outResult += !"labelFontOfSize" ;
  outResult += !"menuFontOfSize" ;
  outResult += !"menuBarFontOfSize" ;
  outResult += !"messageFontOfSize" ;
  outResult += !"paletteFontOfSize" ;
  outResult += !"systemFontOfSize" ;
  outResult += !"titleBarFontOfSize" ;
  outResult += !"toolTipsFontOfSize" ;
end once ;

#----------------------------------------------------------------------------*
 
override method @listAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList unused inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
#  foreach inAttributeActualTypeList while not found do
#    if [mType mTypeKind] == [@typeKind structType] then
#      found := true ;
#      ioFileInclusionSet->mHeaderFileInclusionSet += ![mType ebTypeName] ;
#      [inContextAnalysisStruct->mStructTypeMap searchKey
#        !mType->mTypeName
#        ?@structFieldList fieldList
#      ] ;
#      if [mDefaultValueList length] != [fieldList length] then
#        error mStartLocation : "the '" . [mType ebTypeName] . "' struct needs " . [fieldList length] . " values for initialization" ;
#      else
#        outDirectDefaultValueAsString := "make" . [mType ebTypeName] . " (" ;
#        foreach mDefaultValueList, fieldList
#        do
#          [mDefaultValue analyzeDefaultValueType
#            ![@EXebTypeList listWithValue !mFieldType]
#            !inContextAnalysisStruct
#            ?@string directDefaultValueAsString
#            ?2*
#            !?ioFileInclusionSet
#          ] ;
#          outDirectDefaultValueAsString .= directDefaultValueAsString ;
#        between
#          outDirectDefaultValueAsString .= ", " ;
#        end foreach ; 
#        outDirectDefaultValueAsString .= ")" ;     
#      end if ;
#    elsif mType->mKind == [@EXTypeKind fontType] then
#      found := true ;
#      const @string errorMessage := "an NSFont should be initialized by a (fontName, fontSize) value" ;
#      if [mDefaultValueList length] != 2 then
#        error mStartLocation : errorMessage ; 
#      else
#        const @abstractDefaultValue v0 := [mDefaultValueList mDefaultValueAtIndex !0] ; 
#        const @abstractDefaultValue v1 := [mDefaultValueList mDefaultValueAtIndex !1] ;
#        @identifierAsDefaultValue fontName ;
#        if (v0 is == @identifierAsDefaultValue) then 
#          fontName := (cast v0 : @identifierAsDefaultValue) ;
#        else
#          error mStartLocation : errorMessage : fontName ;
#        end if ;
#        @integerAsDefaultValue fontSize ;
#        if (v1 is == @integerAsDefaultValue) then 
#          fontSize := (cast v1 : @integerAsDefaultValue) ;
#        else
#          error mStartLocation : errorMessage : fontSize ;
#        end if ;
#        if [predefinedFonts [] hasKey ![fontName mValue]->string] then
#          outDirectDefaultValueAsString := "[NSFont " . [fontName mValue]->string . ":" . [[fontSize mValue]->uint string] . "]" ;
#          outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
#          outSwiftDefaultValueAsString := "NSFont (" . [fontName mValue]->string . ", " . [[fontSize mValue]->uint string] . ")" ;
#        else
#          error [fontName mValue]
#          : "unknown predefined font name"
#          : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
#          ;  
#        end if ;
#      end if ;
#    end if ;
#  end foreach ;
  if not found then
    error mStartLocation
    : "invalid initialization value"
    ;  
  end if ;
end method ;

##----------------------------------------------------------------------------*
#
#map @EXobservablePropertyMapMap {
#  @bool mUserDefined ;
#  @EXTypeKind mType ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#  insert insertKey error message "the '%K' key is already declared" ;
#  search searchKey error message "the '%K' key is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#abstract method @EXastDeclaration buildObservablePropertyMap
#  ??@EXunifiedTypeMap inUnifiedTypeMap
#  ?!@EXobservablePropertyMapMap ioObservablePropertyMapMap
#  ?!@EXtransientDependencyGraph ioTransientDependencyGraph
#;
#
##----------------------------------------------------------------------------*
#
#abstract class @generation {
#  @string mGenerationName ;
#}
#
##----------------------------------------------------------------------------*
#
#list @generationList {
#  @generation mGeneration ;
#}
#
##----------------------------------------------------------------------------*
#
#abstract method @EXastDeclaration semanticAnalysis
#  ??@EXunifiedTypeMap inUnifiedTypeMap
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@generationList ioGenerationList
#;
#
##----------------------------------------------------------------------------*
#
#abstract method @generation generate
#  ??@string inOutputDirectory
#;
#
##----------------------------------------------------------------------------*
#
#class @structTypeGeneration extends @generation {
#  @structFieldList mFieldList ;
#  @stringset mHeaderFileInclusionSet ;
#}
#
##----------------------------------------------------------------------------*
#
#class @enumTypeGeneration extends @generation {
#  @lstringlist mConstantOrderedList ;
#}
#
##----------------------------------------------------------------------------*
#
#class @classTypeGeneration extends @generation {
#  @string mSuperClassName ;
#  @attributeListForImplementation mAttributeListForInitMethodHeader ;
#  @attributeListForImplementation mInheritedAttributeListForImplementation ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @propertyArrayMap mAllArrayPropertyForImplementation ;
#  @propertyArrayMap mCurrentArrayPropertyForImplementation ;
#  @fileInclusionSet mInclusionSet ;
#}
#
##----------------------------------------------------------------------------*
#
#class @nibClassTypeGeneration extends @generation {
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @outletGenerationList mOutletDeclarationList ;
#  @lstringlist mActionList ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#  @fileInclusionSet mFileInclusionSet ;
#  @controllerMap mControllerMap ;
#  @propertyArrayMap mArrayMap ;
#}
#
##----------------------------------------------------------------------------*
#
#class @preferenceTypeGeneration extends @generation {
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @outletGenerationList mOutletDeclarationList ;
#  @lstringlist mActionList ;
#  @fileInclusionSet mFileInclusionSet ;
#  @controllerMap mControllerMap ;
#  @preferencesPropertyArrayMap mArrayMap ;
#}
#
##----------------------------------------------------------------------------*
#
#class @entityGeneration extends @generation {
#  @string mSuperEntityName ;
#  @attributeListForImplementation mAttributeListForInitMethodHeader ;
#  @attributeListForImplementation mInheritedAttributeListForImplementation ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @relationshipList mCurrentRelationshipList ;
#  @fileInclusionSet mFileInclusionSet ;
#  @signListForGeneration mSignList ;
#  @EXentityRelationshipMap mCurrentRelationshipMap ;
#  @2stringlist mToManyRelationshipList ;
#  @2stringlist mToOneRelationshipList ;
#}
#
##----------------------------------------------------------------------------*
#
#class @documentGeneration extends @generation {
#  @string mRootEntityName ;
#  @outletGenerationList mOutletDeclarationList ;
#  @controllerMap mControllerMap ;
#  @lstringlist mActionList ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @fileInclusionSet mFileInclusionSet ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#}
#
##----------------------------------------------------------------------------*
#
#class @outletClassGeneration extends @generation {
#  @string mSuperClassName ;
#  @protocolList mAdoptedProtocolList ;
#  @bool mImplementsDeallocProtocol ;
#  @outletClassBindingMap mCurrentBindingMap ;
#}
#
##----------------------------------------------------------------------------*
#
#class @controllerClassGeneration extends @generation {
#  @outletClassBindingMap mBindingMap ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#}
#
#----------------------------------------------------------------------------*

end semantics ;
