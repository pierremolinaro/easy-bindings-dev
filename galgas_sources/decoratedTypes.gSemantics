semantics decoratedTypes :
  import "abstractSyntaxTypes.gSemantics" ;
  import "easyBindings_options.gOptions" ;

#----------------------------------------------------------------------------*

abstract class @abstractBooleanMultipleBindingExpressionForGeneration {
}

#----------------------------------------------------------------------------*

class @observablePropertyAsBooleanMultipleBindingExpressionForGeneration extends @abstractBooleanMultipleBindingExpressionForGeneration {
  @string mObservedObject ;
  @string mObservedModel ;
  @string mObservedTypeName ;
  @uint mIndex ; # In expression
}

#----------------------------------------------------------------------------*

class @negateBooleanMultipleBindingExpressionForGeneration extends @abstractBooleanMultipleBindingExpressionForGeneration {
  @abstractBooleanMultipleBindingExpressionForGeneration mBinding ;
}

#----------------------------------------------------------------------------*

class @orBooleanMultipleBindingExpressionForGeneration,
       @andBooleanMultipleBindingExpressionForGeneration extends @abstractBooleanMultipleBindingExpressionForGeneration {
  @abstractBooleanMultipleBindingExpressionForGeneration mLeftBinding ;
  @abstractBooleanMultipleBindingExpressionForGeneration mRightBinding ;
}

#----------------------------------------------------------------------------*

list @unifiedTypeProxySelectorList {
  @unifiedTypeMap-proxy mType ;
  @lstring mSelector ;
}

#----------------------------------------------------------------------------*

list @unifiedTypeProxyList {
  @unifiedTypeMap-proxy mType ;
}

#----------------------------------------------------------------------------*

map @arrayControllerMap {
  @abstractObservablePropertyAST mBoundModel ;
  @lstring mTableViewOutletName ;
  @arrayControllerBoundColumnListAST mArrayControllerBoundColumnListAST ;
  @actionMap mActionMap ;
  @decoratedObservablePropertyMap mObservablePropertyMap ;
  @lstring mPropertySignature ; # Array controller signature for transient dependency graph : document.MyDoc.arrayControllerName
  @string mArrayControllerTypeName ;
  insert insertKey error message "the '%K' controller is already declared" ;
  search searchKey error message "there is no '%K' controller" ;
}

#----------------------------------------------------------------------------*

sharedmap @unifiedTypeMap {
  insert insertKey error message "the '%K' type is already declared" ;
  search searchKey error message "the '%K' type is not declared" ;

  @typeKind mTypeKind ;
  @unifiedTypeMap-proxy mSuperType ;
  @unifiedTypeMap-proxy mRootEntityType ;
  @decoratedAttributeMap mDecoratedAttributeMap ;
  @decoratedTransientMap mDecoratedTransientMap ;
  @decoratedOutletMap mDecoratedOutletMap ;
  @decoratedObservablePropertyMap mObservablePropertyMap ;
  @decoratedEntityRelationshipMap mCurrentRelationshipMap ;
  @actionMap mActionMap ;
  @bindingList mBindingList ;
  @lstringlist mEnumConstantList ;
  @enumConstantMap mEnumConstantMap ;
  @arrayControllerMap mArrayControllerMap ;
}

#----------------------------------------------------------------------------*

map @enumConstantMap {
  insert insertKey error message "there is already a '%K' constant" ;
  search searchKey error message "the '%K' constant is not defined" ;
}

#----------------------------------------------------------------------------*

map @actionMap {
  insert insertKey error message "there is already a '%K' action" ;
  search searchKey error message "the '%K' action is not defined" ;
}

#----------------------------------------------------------------------------*

map @decoratedEntityRelationshipMap {
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
  @bool mIsToMany ;
  @unifiedTypeMap-proxy mRelationshipType ;
  @lstring mOppositeRelationshipName ;
}

#----------------------------------------------------------------------------*

list @dependanceListForGeneration {
  @abstractTransientDependencyForGeneration mDependency ;
}

#----------------------------------------------------------------------------*

map @decoratedTransientMap {
  insert insertKey error message "the '%K' transient is already declared" ;
  search searchKey error message "the '%K' transient is not declared" ;
  @unifiedTypeMap-proxy mTransientType ;
  @lstring mTransientSignature ;
  @dependanceList mDependencyList ;
}

#----------------------------------------------------------------------------*

list @transientDefinitionListForGeneration {
  @string mTransientName ;
  @unifiedTypeMap-proxy mTransientType ;
  @lstring mTransientSignature ;
  @dependanceListForGeneration mDependencyList ;
}

#----------------------------------------------------------------------------*

map @decoratedOutletMap {
  insert insertKey error message "the '%K' transient is already declared" ;
  search searchKey error message "the '%K' transient is not declared" ;
  @lstring mOutletTypeName ;
  @runActionDescriptor mRunActionDescriptor ;
  @enabledBindingDescriptor mEnabledBindingDescriptor ;
}

#----------------------------------------------------------------------------*

map @decoratedAttributeMap {
  @unifiedTypeMap-proxy mAttributeType ;
  @abstractDefaultValue mDefaultValue ;
  @bool mNeedsValidation ;
  insert insertKey error message "the '%K' attribute is already declared in %L" ;
  search searchKey error message "there is no '%K' attribute" ;
}

#----------------------------------------------------------------------------*

map @outletClassMap {
  @bool mHandlesRunAction ;
  insert insertKey error message "the '%K' outlet class is already declared in %L" ;
  search searchKey error message "there is no '%K' outlet class" ;
}

#----------------------------------------------------------------------------*

map @decoratedObservablePropertyMap {
  @unifiedTypeMap-proxy mPropertyType ;
  @bool mIsTransient ;
  @lstring mPropertySignature ;
  @bool mIsCollection ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#----------------------------------------------------------------------------*

abstract method @astDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
;

#----------------------------------------------------------------------------*

list @transientDependencyGraphNodeInfoList {
  @string mSignature ;
  @bool mIsTransient ;
}

#----------------------------------------------------------------------------*

graph @transientDependencyGraph (@transientDependencyGraphNodeInfoList) {
  insert addNode error message "the '%K' property is already declared at %L" ;
}

#----------------------------------------------------------------------------*

reader @typeKind kindName -> @string outResult :
  switch selfcopy
  when classType : outResult := "class" ;
  when controllerClassType : outResult := "controller" ;
  when documentType : outResult := "document" ;
  when entityType : outResult := "entity" ;
  when preferencesType : outResult := "preference" ;
#--- Predefined Type
  when boolType, integerType, uintegerType, doubleType, stringType,
  colorType, dataType, dateType, fontType, imageType, menuType, bezierPathType,
  structType, enumType, nibClassType, outletClassType, protocolType :
    outResult := "<kindName ??>" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @typeKind suitableForObservableProperty -> @bool outResult :
  switch selfcopy
  when classType, controllerClassType, documentType,
  entityType, preferencesType,
  nibClassType, outletClassType, protocolType : outResult := false ;
#--- Predefined Type
  when boolType, integerType, uintegerType, doubleType, stringType,
  colorType, dataType, dateType, fontType, imageType, menuType, bezierPathType,
  structType, enumType :
    outResult := true ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

list @transientDependencyListForGeneration {
  @string mSwiftTypeNameForComputeFunctionFormalArgument ;
  @string mComputeFunctionFormalArgumentName ;
}

#----------------------------------------------------------------------------*

list @transientListForGeneration {
  @string mTransientSignature ;
  @unifiedTypeMap-proxy mTransientType ;
  @transientDependencyListForGeneration mTransientDependencyListForGeneration ;
}

#----------------------------------------------------------------------------*

list @actionListForGeneration {
  @string mClassName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*

list @arrayControllerBoundColumnListForGeneration {
  @string mColumnName ;
  @string mColumnOutletTypeName ;
  @string mObservablePropertyName ;
  @unifiedTypeMap-proxy mPropertyType ;
  @bindingOptionList mBindingOptionList ;
}

#----------------------------------------------------------------------------*

list @arrayControllerForGeneration {
  @string mControllerName ;
  @string mObjectTypeName ;
  @string mTomanyRelationshipName ;
  @string mElementTypeName ;
  @string mTableViewOutletName ;
  @arrayControllerBoundColumnListForGeneration mArrayControllerBoundColumnListForGeneration ;
}

#----------------------------------------------------------------------------*

list @targetActionList {
  @string mOutletName ;
  @string mTargetName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*

abstract class @abstractTransientDependencyForGeneration {
}

#----------------------------------------------------------------------------*

class @transientRootSignDependencyForGeneration extends @abstractTransientDependencyForGeneration {
  @location mDeclarationLocation ;
}

#----------------------------------------------------------------------------*

class @transientLocalDependencyForGeneration extends @abstractTransientDependencyForGeneration {
  @lstring mMasterName ;
  @bool mNamesCountOption ;
}

#----------------------------------------------------------------------------*

class @transientRootDependencyForGeneration extends @abstractTransientDependencyForGeneration {
  @lstring mMasterName ;
  @bool mNamesCountOption ;
}

#----------------------------------------------------------------------------*

class @transientRootRelationshipDependencyForGeneration extends @abstractTransientDependencyForGeneration {
  @unifiedTypeMap-proxy mElementType ;
  @lstring mRelationshipName ;
  @lstring mMasterName ;
}

#----------------------------------------------------------------------------*

class @transientControllerDependencyForGeneration extends @abstractTransientDependencyForGeneration {
  @lstring mControllerName ;
  @lstring mMasterName ;
}

#----------------------------------------------------------------------------*

class @transientPreferenceDependencyForGeneration extends @abstractTransientDependencyForGeneration {
  @lstring mPreferencesName ;
  @lstring mMasterName ;
}

#----------------------------------------------------------------------------*
















#----------------------------------------------------------------------------*

abstract method @abstractDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@contextAnalysisStruct inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
;

#----------------------------------------------------------------------------*
  
override method @boolAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind boolType] then
      outSwiftDefaultValueAsString := if mValue->bool then "true" else "false" end ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a boolean attribute can be initialized by YES or NO"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @integerAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind integerType] then
      outSwiftDefaultValueAsString := [mValue->uint string]  ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only an integer attribute can be initialized by an integer constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @doubleAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind doubleType] then
      outSwiftDefaultValueAsString := [mValue->double string] ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a double attribute can be initialized by a floating point constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @stringAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind stringType] then
      outSwiftDefaultValueAsString := "\"". mValue->string . "\"" ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a string attribute can be initialized by a string constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

once predefinedColors -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"blackColor" ;
  outResult += !"blueColor" ;
  outResult += !"brownColor" ;
  outResult += !"clearColor" ;
  outResult += !"controlColor" ;
  outResult += !"controlDarkShadowColor" ;
  outResult += !"controlHighlightColor" ;
  outResult += !"controlLightHighlightColor" ;
  outResult += !"controlShadowColor" ;
  outResult += !"controlTextColor" ;
  outResult += !"cyanColor" ;
  outResult += !"darkGrayColor" ;
  outResult += !"disabledControlTextColor" ;
  outResult += !"grayColor" ;
  outResult += !"greenColor" ;
  outResult += !"gridColor" ;
  outResult += !"headerColor" ;
  outResult += !"headerTextColor" ;
  outResult += !"highlightColor" ;
  outResult += !"keyboardFocusIndicatorColor" ;
  outResult += !"knobColor" ;
  outResult += !"lightGrayColor" ;
  outResult += !"magentaColor" ;
  outResult += !"orangeColor" ;
  outResult += !"purpleColor" ;
  outResult += !"redColor" ;
  outResult += !"scrollBarColor" ;
  outResult += !"selectedControlColor" ;
  outResult += !"selectedControlTextColor" ;
  outResult += !"selectedKnobColor" ;
  outResult += !"selectedMenuItemColor" ;
  outResult += !"selectedMenuItemTextColor" ;
  outResult += !"selectedTextBackgroundColor" ;
  outResult += !"selectedTextColor" ;
  outResult += !"shadowColor" ;
  outResult += !"textBackgroundColor" ;
  outResult += !"textColor" ;
  outResult += !"whiteColor" ;
  outResult += !"windowBackgroundColor" ;
  outResult += !"windowFrameColor" ;
  outResult += !"windowFrameTextColor" ;
  outResult += !"yellowColor" ;
end once ;

#----------------------------------------------------------------------------*

once predefinedDates -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"date" ;
end once ;

#----------------------------------------------------------------------------*
  
override method @identifierAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if [mType mTypeKind] == [@typeKind colorType] then
      found := true ;
      if [predefinedColors [] hasKey !mValue->string] then
        outSwiftDefaultValueAsString := "NSColor." . mValue->string . " ()" ;
      else
        error mValue
        : "unknown predefined color"
        ;  
      end if ;
    elsif [mType mTypeKind] == [@typeKind dateType] then
      found := true ;
      if [predefinedDates [] hasKey !mValue->string] then
        outSwiftDefaultValueAsString := "NSDate ()" ;
      else
        error mValue
        : "unknown predefined date"
        ;  
      end if ;
    elsif [mType mTypeKind] == [@typeKind enumType] then
      found := true ;
      if [[mType mEnumConstantMap] hasKey !mValue->string] then
          outSwiftDefaultValueAsString := [mType lkey]->string . "." . mValue->string ;
      else
        error mValue
        : "the '" . [mType lkey] . "' enumeration does not define '" . mValue . "' constant"
        : outSwiftDefaultValueAsString
        ;  
      end if ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "unknow type for this identifier"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

once predefinedFonts -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"boldSystemFontOfSize" ;
  outResult += !"controlContentFontOfSize" ;
  outResult += !"labelFontOfSize" ;
  outResult += !"menuFontOfSize" ;
  outResult += !"menuBarFontOfSize" ;
  outResult += !"messageFontOfSize" ;
  outResult += !"paletteFontOfSize" ;
  outResult += !"systemFontOfSize" ;
  outResult += !"titleBarFontOfSize" ;
  outResult += !"toolTipsFontOfSize" ;
end once ;

#----------------------------------------------------------------------------*
 
override method @listAsDefaultValue analyzeDefaultValueType 
  ??@unifiedTypeProxyList unused inAttributeActualTypeList
#  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outSwiftDefaultValueAsString
#  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
#  foreach inAttributeActualTypeList while not found do
#    if [mType mTypeKind] == [@typeKind structType] then
#      found := true ;
#      ioFileInclusionSet->mHeaderFileInclusionSet += ![mType ebTypeName] ;
#      [inContextAnalysisStruct->mStructTypeMap searchKey
#        !mType->mTypeName
#        ?@structFieldList fieldList
#      ] ;
#      if [mDefaultValueList length] != [fieldList length] then
#        error mStartLocation : "the '" . [mType ebTypeName] . "' struct needs " . [fieldList length] . " values for initialization" ;
#      else
#        outDirectDefaultValueAsString := "make" . [mType ebTypeName] . " (" ;
#        foreach mDefaultValueList, fieldList
#        do
#          [mDefaultValue analyzeDefaultValueType
#            ![@EXebTypeList listWithValue !mFieldType]
#            !inContextAnalysisStruct
#            ?@string directDefaultValueAsString
#            ?2*
#            !?ioFileInclusionSet
#          ] ;
#          outDirectDefaultValueAsString .= directDefaultValueAsString ;
#        between
#          outDirectDefaultValueAsString .= ", " ;
#        end foreach ; 
#        outDirectDefaultValueAsString .= ")" ;     
#      end if ;
#    elsif mType->mKind == [@EXTypeKind fontType] then
#      found := true ;
#      const @string errorMessage := "an NSFont should be initialized by a (fontName, fontSize) value" ;
#      if [mDefaultValueList length] != 2 then
#        error mStartLocation : errorMessage ; 
#      else
#        const @abstractDefaultValue v0 := [mDefaultValueList mDefaultValueAtIndex !0] ; 
#        const @abstractDefaultValue v1 := [mDefaultValueList mDefaultValueAtIndex !1] ;
#        @identifierAsDefaultValue fontName ;
#        if (v0 is == @identifierAsDefaultValue) then 
#          fontName := (cast v0 : @identifierAsDefaultValue) ;
#        else
#          error mStartLocation : errorMessage : fontName ;
#        end if ;
#        @integerAsDefaultValue fontSize ;
#        if (v1 is == @integerAsDefaultValue) then 
#          fontSize := (cast v1 : @integerAsDefaultValue) ;
#        else
#          error mStartLocation : errorMessage : fontSize ;
#        end if ;
#        if [predefinedFonts [] hasKey ![fontName mValue]->string] then
#          outDirectDefaultValueAsString := "[NSFont " . [fontName mValue]->string . ":" . [[fontSize mValue]->uint string] . "]" ;
#          outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
#          outSwiftDefaultValueAsString := "NSFont (" . [fontName mValue]->string . ", " . [[fontSize mValue]->uint string] . ")" ;
#        else
#          error [fontName mValue]
#          : "unknown predefined font name"
#          : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
#          ;  
#        end if ;
#      end if ;
#    end if ;
#  end foreach ;
  if not found then
    error mStartLocation
    : "invalid initialization value"
    ;  
  end if ;
end method ;

##----------------------------------------------------------------------------*
#
#map @EXobservablePropertyMapMap {
#  @bool mUserDefined ;
#  @EXTypeKind mType ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#  insert insertKey error message "the '%K' key is already declared" ;
#  search searchKey error message "the '%K' key is not declared" ;
#}
#
##----------------------------------------------------------------------------*
#
#abstract method @EXastDeclaration buildObservablePropertyMap
#  ??@EXunifiedTypeMap inUnifiedTypeMap
#  ?!@EXobservablePropertyMapMap ioObservablePropertyMapMap
#  ?!@EXtransientDependencyGraph ioTransientDependencyGraph
#;
#
##----------------------------------------------------------------------------*
#
#abstract class @generation {
#  @string mGenerationName ;
#}
#
##----------------------------------------------------------------------------*
#
#list @generationList {
#  @generation mGeneration ;
#}
#
##----------------------------------------------------------------------------*
#
#abstract method @EXastDeclaration semanticAnalysis
#  ??@EXunifiedTypeMap inUnifiedTypeMap
#  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
#  ?!@generationList ioGenerationList
#;
#
##----------------------------------------------------------------------------*
#
#abstract method @generation generate
#  ??@string inOutputDirectory
#;
#
##----------------------------------------------------------------------------*
#
#class @structTypeGeneration extends @generation {
#  @structFieldList mFieldList ;
#  @stringset mHeaderFileInclusionSet ;
#}
#
##----------------------------------------------------------------------------*
#
#class @enumTypeGeneration extends @generation {
#  @lstringlist mConstantOrderedList ;
#}
#
##----------------------------------------------------------------------------*
#
#class @classTypeGeneration extends @generation {
#  @string mSuperClassName ;
#  @attributeListForImplementation mAttributeListForInitMethodHeader ;
#  @attributeListForImplementation mInheritedAttributeListForImplementation ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @propertyArrayMap mAllArrayPropertyForImplementation ;
#  @propertyArrayMap mCurrentArrayPropertyForImplementation ;
#  @fileInclusionSet mInclusionSet ;
#}
#
##----------------------------------------------------------------------------*
#
#class @nibClassTypeGeneration extends @generation {
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @outletGenerationList mOutletDeclarationList ;
#  @lstringlist mActionList ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#  @fileInclusionSet mFileInclusionSet ;
#  @controllerMap mControllerMap ;
#  @propertyArrayMap mArrayMap ;
#}
#
##----------------------------------------------------------------------------*
#
#class @preferenceTypeGeneration extends @generation {
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @outletGenerationList mOutletDeclarationList ;
#  @lstringlist mActionList ;
#  @fileInclusionSet mFileInclusionSet ;
#  @controllerMap mControllerMap ;
#  @preferencesPropertyArrayMap mArrayMap ;
#}
#
##----------------------------------------------------------------------------*
#
#class @entityGeneration extends @generation {
#  @string mSuperEntityName ;
#  @attributeListForImplementation mAttributeListForInitMethodHeader ;
#  @attributeListForImplementation mInheritedAttributeListForImplementation ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @relationshipList mCurrentRelationshipList ;
#  @fileInclusionSet mFileInclusionSet ;
#  @signListForGeneration mSignList ;
#  @EXentityRelationshipMap mCurrentRelationshipMap ;
#  @2stringlist mToManyRelationshipList ;
#  @2stringlist mToOneRelationshipList ;
#}
#
##----------------------------------------------------------------------------*
#
#class @documentGeneration extends @generation {
#  @string mRootEntityName ;
#  @outletGenerationList mOutletDeclarationList ;
#  @controllerMap mControllerMap ;
#  @lstringlist mActionList ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @fileInclusionSet mFileInclusionSet ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#}
#
##----------------------------------------------------------------------------*
#
#class @outletClassGeneration extends @generation {
#  @string mSuperClassName ;
#  @protocolList mAdoptedProtocolList ;
#  @bool mImplementsDeallocProtocol ;
#  @outletClassBindingMap mCurrentBindingMap ;
#}
#
##----------------------------------------------------------------------------*
#
#class @controllerClassGeneration extends @generation {
#  @outletClassBindingMap mBindingMap ;
#  @EXobservablePropertyMap mObservablePropertyMap ;
#}
#
#----------------------------------------------------------------------------*

end semantics ;
