semantics decoratedTypes :
  import "abstractSyntaxTypes.gSemantics" ;
  import "easyBindings_options.gOptions" ;

#----------------------------------------------------------------------------*

uniquemap @unifiedTypeMap @unifiedTypeProxy {
  insert insertKey error message "the '%K' type is already declared" ;
  search searchKey error message "the '%K' type is not declared" ;

  @typeKind mTypeKind ;
  @unifiedTypeProxy mSuperType ;
  @unifiedTypeProxy mRootEntityType ;
  @decoratedAttributeMap mDecoratedAttributeMap ;
  @decoratedTransientMap mDecoratedTransientMap ;
  @decoratedOutletMap mDecoratedOutletMap ;
  @decoratedObservablePropertyMap mObservablePropertyMap ;
  @decoratedEntityRelationshipMap mCurrentRelationshipMap ;
}

#----------------------------------------------------------------------------*

map @decoratedEntityRelationshipMap {
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
  @bool mIsToMany ;
  @unifiedTypeProxy mRelationshipType ;
  @lstring mOppositeRelationshipName ;
}

#----------------------------------------------------------------------------*

map @decoratedTransientMap {
  insert insertKey error message "the '%K' transient is already declared" ;
  search searchKey error message "the '%K' transient is not declared" ;
  @unifiedTypeProxy mTransientType ;
  @lstring mTransientSignature ;
  @dependanceList mDependencyList ;
}

#----------------------------------------------------------------------------*

map @decoratedOutletMap {
  insert insertKey error message "the '%K' transient is already declared" ;
  search searchKey error message "the '%K' transient is not declared" ;
  @unifiedTypeProxy mOutletType ;
  @bindingList mOutletBindingList ;
}

#----------------------------------------------------------------------------*

map @decoratedAttributeMap {
  @unifiedTypeProxy mAttributeType ;
  @abstractDefaultValue mDefaultValue ;
  insert insertKey error message "the '%K' attribute is already declared in %L" ;
  search searchKey error message "there is no '%K' attribute" ;
}

#----------------------------------------------------------------------------*

map @decoratedObservablePropertyMap {
  @unifiedTypeProxy mPropertyType ;
  @bool mIsTransient ;
  @lstring mPropertySignature ;
  @bool mIsCollection ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#----------------------------------------------------------------------------*

abstract method @astDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
;

#----------------------------------------------------------------------------*

list @transientDependencyGraphNodeInfoList {
  @string mSignature ;
  @bool mIsTransient ;
}

#----------------------------------------------------------------------------*

graph @transientDependencyGraph (@transientDependencyGraphNodeInfoList) {
  insert addNode error message "the '%K' property is already declared at %L" ;
}

#----------------------------------------------------------------------------*

reader @typeKind kindName -> @string outResult :
  switch selfcopy
  when classType : outResult := "class" ;
  when controllerClassType : outResult := "controller" ;
  when documentType : outResult := "document" ;
  when entityType : outResult := "entity" ;
  when preferencesType : outResult := "preference" ;
#--- Predefined Type
  when boolType, integerType, uintegerType, doubleType, stringType,
  colorType, dataType, dateType, fontType, imageType, menuType, bezierPathType,
  structType, enumType, nibClassType, outletClassType, protocolType :
    outResult := "<kindName ??>" ;
  end switch ;
end reader ;


















#----------------------------------------------------------------------------*

abstract method @EXastDeclaration EXTypeInventory
  ?!@EXunifiedTypeMap ioUnifiedTypeMap
;

#----------------------------------------------------------------------------*

struct @EXebType {
  @lstring mTypeName ;
  @EXTypeKind mKind ;
}

#----------------------------------------------------------------------------*

list @EXebTypeList {
  @EXebType mType ;
}

#----------------------------------------------------------------------------*

reader @EXebType isPODtype -> @bool outResult :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType, stringType,
       colorType, dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := false ;
  when enumType, structType, boolType,
       integerType, uintegerType, doubleType :
    outResult := true ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @EXebType ebTypeName -> @string outResult :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType, stringType,
       colorType, dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType,
       enumType, structType :
    outResult := mTypeName->string ;
  when boolType :
    outResult := "BOOL" ;
  when integerType :
    outResult := "NSInteger" ;
  when uintegerType :
    outResult := "NSUInteger" ;
  when doubleType :
    outResult := "double" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   equalExpression                                                           *
#-----------------------------------------------------------------------------*

reader @EXebType equalExpression
  ??@string inExp1
  ??@string inExp2
  -> @string outResult
 :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType,
       colorType, dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := "[" . inExp1 . " isEqual:" . inExp2 . "]" ;
  when stringType :
    outResult := "[" . inExp1 . " isEqualToString:" . inExp2 . "]" ;
  when structType :
    outResult := "equal" . mTypeName . "s (" . inExp1 . ", " . inExp2 . ")" ;
  when integerType, uintegerType, boolType, doubleType, enumType :
    outResult := inExp1 . " == " . inExp2 ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   ocTypeName                                                                *
#-----------------------------------------------------------------------------*

reader @EXebType ocTypeName
  -> @string outResult
 :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType,
       colorType, dataType, dateType, fontType, stringType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := mTypeName->string . " *" ;
  when structType, enumType :
    outResult := mTypeName->string ;
  when boolType :
    outResult := "BOOL" ;
  when integerType :
    outResult := "NSInteger" ;
  when uintegerType :
    outResult := "NSUInteger" ;
  when doubleType :
    outResult := "double" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   swiftTypeName                                                             *
#-----------------------------------------------------------------------------*

reader @EXebType swiftTypeName
  -> @string outResult
 :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType,
       colorType, dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := mTypeName->string ;
  when stringType :
    outResult := "String" ;
  when structType, enumType :
    outResult := mTypeName->string ;
  when boolType :
    outResult := "Bool" ;
  when integerType :
    outResult := "Int64" ;
  when uintegerType :
    outResult := "UInt" ;
  when doubleType :
    outResult := "Double" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   swiftDefaultValue                                                         *
#-----------------------------------------------------------------------------*

reader @EXebType swiftDefaultValue
  -> @string outResult
 :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType,
       colorType, dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := "nil" ;
  when stringType :
    outResult := "\"\"" ;
  when structType, enumType :
    outResult := mTypeName->string ;
  when boolType :
    outResult := "false" ;
  when integerType :
    outResult := "0" ;
  when uintegerType :
    outResult := "0" ;
  when doubleType :
    outResult := "0.0" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   dictionarySaverTransformerName                                            *
#-----------------------------------------------------------------------------*

reader @EXebType dictionarySaverTransformerName
  ?@string inName
  -> @string outResult
 :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType,
       dataType, dateType, fontType,
       imageType,  menuType, bezierPathType, protocolType,
       stringType, structType, boolType, uintegerType, doubleType :
    outResult := inName ;
  when enumType :
    outResult := inName . ".toRaw ()" ;
  when integerType :
    outResult := "NSNumber (longLong:" . inName . ")" ;
  when colorType :
    outResult := "NSArchiver.archivedDataWithRootObject (" . inName . ")" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   valueForUndoManager                                                       *
#-----------------------------------------------------------------------------*

reader @EXebType valueForUndoManager
  ?@string inName
  -> @string outResult
 :
  switch mKind
  when classType, controllerClassType, documentType, entityType,
       nibClassType, outletClassType, preferencesType,
       dataType, dateType, fontType, enumType, colorType,
       imageType,  menuType, bezierPathType, protocolType,
       stringType, structType, boolType, uintegerType, doubleType :
    outResult := inName ;
  when integerType :
    outResult := "NSNumber (longLong:" . inName . ")" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   propertyAttributeString                                                   *
#-----------------------------------------------------------------------------*

reader @EXebType propertyAttributeString
  -> @string outResult
 :
  switch mKind
  when colorType, dataType, dateType, fontType, stringType,
       imageType,  menuType, bezierPathType, protocolType :
    outResult := " (copy)" ;
  when nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType,
       doubleType, uintegerType, integerType, boolType, structType,
       enumType :
    outResult := "" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   copyOnAssign                                                              *
#-----------------------------------------------------------------------------*

reader @EXebType copyOnAssign
  -> @bool outResult
 :
  switch mKind
  when stringType, bezierPathType, menuType :
    outResult := true ;
  when colorType, dataType, dateType, fontType,
       imageType, protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType,
       doubleType, uintegerType, integerType, boolType, structType,
       enumType :
    outResult := false ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   requiredCellTypeInTableColumnBinding                                      *
#-----------------------------------------------------------------------------*

reader @EXebType requiredCellTypeInTableColumnBinding
  -> @string outResult
 :
  switch mKind
  when dateType :
    outResult := "NSDateFieldCell" ;
  when imageType :
    outResult := "NSImageCell" ;
  when boolType :
    outResult := "NSButtonCell" ;
  when integerType, uintegerType, doubleType, stringType :
    outResult := "NSTextFieldCell" ;
  when bezierPathType, menuType,
       colorType, dataType, fontType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType,
       structType,
       enumType :
    outResult := "" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   preferencesGetterTransformerFunctionName                                  *
#-----------------------------------------------------------------------------*

reader @EXebType preferencesGetterTransformerFunctionName
  -> @string outResult
 :
  switch mKind
  when boolType :
    outResult := "boolFromNSNumber" ;
  when integerType :
    outResult := "NSIntegerFromNSNumber" ;
  when enumType :
    outResult := "(" . mTypeName . ") NSIntegerFromNSNumber" ;
  when doubleType :
    outResult := "doubleFromNSNumber" ;
  when fontType :
    outResult := "fontFromData" ;
  when colorType, bezierPathType :
    outResult := "valueFromData" ;
  when structType :
    outResult := mTypeName->string . "FromData" ;
  when dateType, imageType, uintegerType, stringType, menuType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType :
    outResult := "" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   preferencesSwiftGetter                                                    *
#-----------------------------------------------------------------------------*

reader @EXebType preferencesSwiftGetter
  -> @string outResult
 :
  switch mKind
  when boolType :
    outResult := "(value as NSNumber).boolValue" ;
  when integerType :
    outResult := "(value as NSNumber).longLongValue" ;
  when enumType :
    outResult := "(" . mTypeName . ") NSIntegerFromNSNumber" ;
  when doubleType :
    outResult := "(value as NSNumber).doubleValue" ;
  when fontType :
    outResult := "NSUnarchiver.unarchiveObjectWithData (value as NSData) as NSFont" ;
  when colorType, bezierPathType :
    outResult := "NSUnarchiver.unarchiveObjectWithData (value as NSData) as NSColor" ;
  when structType :
    outResult := mTypeName->string . "FromData" ;
  when dateType, imageType, uintegerType, stringType, menuType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType :
    outResult := "value as " . mTypeName->string ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   preferencesSwiftSetter                                                    *
#-----------------------------------------------------------------------------*

reader @EXebType preferencesSwiftSetter
  ??@string inValueName
  -> @string outResult
 :
  switch mKind
  when boolType :
    outResult := "NSNumber.numberWithBool (" . inValueName . ")" ;
  when integerType :
    outResult := "NSNumber.numberWithLongLong (" . inValueName . ")" ;
  when enumType :
    outResult := "(" . mTypeName . ") NSIntegerFromNSNumber" ;
  when doubleType :
    outResult := "NSNumber.numberWithDouble (" . inValueName . ")" ;
  when fontType, colorType, bezierPathType :
    outResult := "NSArchiver.archivedDataWithRootObject (" . inValueName . ")" ;
  when structType :
    outResult := mTypeName->string . "FromData" ;
  when dateType, imageType, uintegerType, stringType, menuType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType :
    outResult := inValueName ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   preferencesSetterTransformerFunctionName                                  *
#-----------------------------------------------------------------------------*

reader @EXebType preferencesSetterTransformerFunctionName
  -> @string outResult
 :
  switch mKind
  when boolType :
    outResult := "numberEncodedBool" ;
  when integerType, enumType :
    outResult := "numberEncodedNSInteger" ;
  when doubleType :
    outResult := "numberEncodedDouble" ;
  when fontType :
    outResult := "dataFromFont" ;
  when colorType, bezierPathType, menuType :
    outResult := "dataEncodedValue" ;
  when structType :
    outResult := "dataEncoded" . mTypeName->string ;
  when dateType, imageType, uintegerType, stringType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType :
    outResult := "" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   isClass                                                                   *
#-----------------------------------------------------------------------------*

reader @EXebType isClass
  -> @bool outResult
 :
  switch mKind
  when boolType, integerType, uintegerType, enumType, doubleType, structType :
    outResult := false ;
  when fontType, colorType, bezierPathType, menuType,
       dateType, imageType, stringType,
       dataType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType, entityType :
    outResult := true ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   functionForComputingSignature                                             *
#-----------------------------------------------------------------------------*

reader @EXebType functionForComputingSignature
  ??@bool inIsToMany
  -> @string outResult
 :
  if inIsToMany then
    outResult := "computeToManyEntitySignature" ;
  else
    switch mKind
    when boolType, integerType, uintegerType, enumType, doubleType, structType :
      outResult := "computeIntegerSignature" ;
    when stringType :
      outResult := "computeNSStringSignature" ;
    when entityType :
      outResult := "computeToOneEntitySignature" ;
    when fontType, colorType, bezierPathType, menuType,
         dateType, imageType,
         dataType,
         protocolType,
         nibClassType, outletClassType, preferencesType,
         classType, controllerClassType, documentType :
      outResult := "" ;
    end switch ;
  end if ;
end reader ;

#-----------------------------------------------------------------------------*
#   addInclusionInHeaderFile                                                  *
#-----------------------------------------------------------------------------*

method @EXebType addInclusionInHeaderFile
  ?!@stringset ioInclusionSet
:
  switch mKind
  when boolType, integerType, uintegerType, doubleType,
       entityType, fontType, colorType, bezierPathType, menuType,
       dateType, imageType,
       dataType, stringType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType :

  when structType, enumType :
    ioInclusionSet += !mTypeName->string ;
  end switch ;
end method ;

#-----------------------------------------------------------------------------*
#   addInclusionInImplementationFile                                          *
#-----------------------------------------------------------------------------*

method @EXebType addInclusionInImplementationFile
  ?!@stringset ioInclusionSet
:
  switch mKind
  when boolType, integerType, uintegerType, doubleType,
       fontType, colorType, bezierPathType, menuType,
       dateType, imageType, structType, enumType,
       dataType, stringType,
       protocolType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType :

  when entityType :
    ioInclusionSet += !mTypeName->string ;
  end switch ;
end method ;

#-----------------------------------------------------------------------------*
#   valueAccessorForExplorerWindow                                            *
#-----------------------------------------------------------------------------*

reader @EXebType valueAccessorForExplorerWindow
  ??@string inName
  ->@string outResult
:
  switch mKind
  when uintegerType, doubleType,
       fontType, bezierPathType, menuType,
       dateType, imageType, structType,
       dataType, stringType,
       protocolType, entityType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType :
    outResult := inName ;
  when enumType :
    outResult := inName . ".string ()" ;
  when colorType :
    outResult := inName . ".description" ;
  when integerType :
    outResult := "NSString (format:\"%lld\", " . inName . ")" ;
  when boolType :
    outResult := inName . " ? \"true\" : \"false\"" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   keyPathForObservable                                                      *
#-----------------------------------------------------------------------------*

reader @EXebType keyPathForObservable
  ??@string inName
  ->@string outResult
:
  switch mKind
  when boolType, integerType, uintegerType, doubleType,
       fontType, bezierPathType, menuType,
       dateType, imageType, structType,
       dataType, stringType, colorType,
       protocolType, entityType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType :
    outResult := inName ;
  when enumType :
    outResult := inName . "__as__number" ;
  end switch ;
end reader ;

#-----------------------------------------------------------------------------*
#   ocClassName                                                               *
#-----------------------------------------------------------------------------*

reader @EXebType ocClassName
  ->@string outResult
:
  switch mKind
  when boolType, integerType, uintegerType, doubleType :
    outResult := "NSNumber" ;
  when fontType :
    outResult := "NSFont" ;
  when stringType :
    outResult := "NSString" ;
  when imageType :
    outResult := "NSImage" ;
  when dataType :
    outResult := "NSData" ;
  when colorType :
    outResult := "NSColor" ;
  when dateType :
    outResult := "NSDate" ;
  when menuType :
    outResult := "NSMenu" ;
  when bezierPathType :
    outResult := "NSBezierPath" ;
  when structType, enumType :
    outResult := mTypeName->string ;
  when protocolType, entityType,
       nibClassType, outletClassType, preferencesType,
       classType, controllerClassType, documentType :
    outResult := "**@EXebType ocClassName**" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

map @EXentityRelationshipMap {
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
  @bool mIsToMany ;
  @EXunifiedTypeProxy mRelationshipType ;
  @lstring mOppositeRelationshipName ;
}

#----------------------------------------------------------------------------*

uniquemap @EXunifiedTypeMap @EXunifiedTypeProxy {
  insert insertKey error message "the '%K' type is already declared" ;
  search searchKey error message "the '%K' type is not declared" ;
#---
  @EXebType mTypeKind ;
  @EXastDeclaration mDeclaration ;
  @EXentityRelationshipMap mEntityCurrentRelationshipMap ;
}

#----------------------------------------------------------------------------*

list @EXunifiedTypeProxyList {
  @EXunifiedTypeProxy mTypeProxy ;
}

#----------------------------------------------------------------------------*

list @EXebTypeAndFormatterList {
  @EXebType mType ;
  @formatterEnum mRequiredFormatter ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingOptionMap {
  @EXebTypeList mAcceptableTypeList ;
  insert insertKey error message "the '%K' binding option is already declared" ;
  search searchKey error message "the '%K' binding option is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingMap {
  @EXebTypeAndFormatterList mAcceptableTypeList ;
  @outletClassBindingOptionMap mOutletClassBindingOptionMap ;
  insert insertKey error message "the '%K' binding is already declared" ;
  search searchKey error message "the '%K' binding is not declared" ;
}

#----------------------------------------------------------------------------*

list @structFieldList {
  @EXebType mFieldType ;
  @string mFieldName ;
}

#----------------------------------------------------------------------------*

map @enumConstantMap {
  insert insertKey error message "the '%K' enumeration constant is already declared" ;
  search searchKey error message "the '%K' enumeration constant is not declared" ;
}


#----------------------------------------------------------------------------*

struct @fileInclusionSet {
  @stringset mHeaderPredeclarationSet ;
  @stringset mHeaderFileInclusionSet ;
  @stringset mImplementationFileInclusionSet ;
}

#-----------------------------------------------------------------------------*

map @globalEnumConstantMap {
  @lstring mEnumTypeName ;
  insert insertKey error message "the '%K' enumeration constant is already declared" ;
  search searchKey error message "the '%K' enumeration constant is not declared" ;
}

#----------------------------------------------------------------------------*

map @enumMap {
  @lstringlist mConstantOrderedList ;
  @enumConstantMap mEnumConstantMap ;
  insert insertKey error message "the '%K' enumeration is already declared" ;
  search searchKey error message "the '%K' enumeration is not declared" ;
}

#----------------------------------------------------------------------------*

map @userCursorMap {
  @double mHotSpotX ;
  @double mHotSpotY ;
  insert insertKey error message "the '%K' cursor is already declared" ;
  search searchKey error message "the '%K' cursor is not declared" ;
}

#----------------------------------------------------------------------------*

map @structTypeMap {
  @structFieldList mFieldList ;
  insert insertKey error message "the '%K' struct is already declared" ;
  search searchKey error message "the '%K' struct is not declared" ;
}

#----------------------------------------------------------------------------*

struct @EXcontextAnalysisStruct {
  @EXobservablePropertyMapMap mObservablePropertyMapMap ;
  @structTypeMap mStructTypeMap ;
  @enumMap mEnumMap ;
  @globalEnumConstantMap mGlobalEnumConstantMap ;
  @userCursorMap mUserCursorMap ;
  @classMap mClassMap ;
  @protocolMap mProtocolMap ;
  @preferencesMap mPreferencesMap ;
  @entityMap mEntityMap ;
  @controllerClassMap mControllerClassMap ;
  @outletClassMap mOutletClassMap ;
  @EXtransientDependencyGraph mTransientDependencyGraph ;
  @bool mContainsDocument ;
}

#----------------------------------------------------------------------------*

map @classMap {
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @propertyArrayMap mAllArrayPropertyForImplementation ;
  insert insertKey error message "the '%K' class is already declared" ;
  search searchKey error message "the '%K' class is not declared" ;
}

#----------------------------------------------------------------------------*

map @entityMap {
  @string mSuperEntityName ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @relationshipList mAllRelationshipList ;
  @propertyMap mAllPropertyMap ;
  @relationshipMap mCurrentRelationshipMap ;
  @relationshipMap mAllRelationshipMap ;
  @fileInclusionSet mFileInclusionSet ;
  @signListForGeneration mSignList ;
  insert insertKey error message "the '%K' entity is already declared" ;
  search searchKey error message "the '%K' entity is not declared" ;
}

#----------------------------------------------------------------------------*

list @signListForGeneration {
  @string mPropertyName ;
  @EXebType mPropertyType ;
  @bool mIsToMany ;
}

#----------------------------------------------------------------------------*

list @entityListForGeneration {
  @string mEntityName ;
  @string mSuperEntityName ;
  @EXobservablePropertyMap mObservablePropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @relationshipList mAllRelationshipList ;
  @propertyMap mAllPropertyMap ;
  @relationshipMap mCurrentRelationshipMap ;
  @relationshipMap mAllRelationshipMap ;
  @2stringlist mToManyRelationshipList ;
  @fileInclusionSet mFileInclusionSet ;
  @2stringlist mToOneRelationshipList ;
  @signListForGeneration mSignList ;
}

#----------------------------------------------------------------------------*

class @runBindingForGeneration extends @abstractBindingForGeneration {
  @string mTargetName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*

class @treeControllerForGeneration extends @abstractBindingForGeneration {
  @string mChildrenKeyPathName ;
}

#----------------------------------------------------------------------------*

list @bindingOptionListForGeneration {
  @string mOptionName ;
  @string mObjectiveCOptionString ;
  @string mSwiftOptionString ;
}

#----------------------------------------------------------------------------*

class @regularBindingForGeneration extends @abstractBindingForGeneration {
  @EXebType mObservableAttributeType ;
  @string mBindingName ;
  @formatterEnum mRequiredFormatter ;
  @string mObservedObjectName ;
  @string mObservableAttributeName ;
  @bool mRequiresInterrogationMark ;
  @bindingOptionListForGeneration mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

list @columnBindingForTableValueBindingForGeneration {
  @string mColumnIdentifier ;
  @string mRequiredCellClass ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

class @tableValueBindingForGeneration extends @abstractBindingForGeneration {
  @string mControllerName ;
  @columnBindingForTableValueBindingForGeneration mColumnBindingForTableValueBindingForGeneration ;
}

#----------------------------------------------------------------------------*

map @protocolMap {
  @bool mIsPredefined ; # Generate import otherwise
  insert insertKey error message "the '%K' protocol is already declared" ;
  search searchKey error message "the '%K' protocol is not declared" ;
}

#----------------------------------------------------------------------------*

list @protocolList {
  @bool mNeedsInclusionInHeader ;
  @string mProtocolName ;
}

#----------------------------------------------------------------------------*

map @outletClassMap {
  @generationKind mGenerationKind ;
  @string mSuperClassName ;
  @protocolList mAdoptedProtocolList ;
  @bool mImplementsDeallocProtocol ;
  @outletClassBindingMap mAllBindingMap ;
  @outletClassBindingMap mCurrentBindingMap ;
  @bool mHasTableValueBinding ;
  insert insertKey error message "the '%K' outlet class is already declared" ;
  search searchKey error message "the '%K' outlet class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerClassMap {
  @controllerKind mControllerKind ;
  @generationKind mGenerationKind ;
  @outletClassBindingMap mBindingMap ;
  @actionMap mActionMap ;
  @EXobservablePropertyMap mObservablePropertyMap ;
  @outletClassBindingOptionMap mControlledObjectAvailableBindingOptionMap ;
  insert insertKey error message "the '%K' controller class is already declared" ;
  search searchKey error message "the '%K' controller class is not declared" ;
}

#----------------------------------------------------------------------------*

map @relationshipMap {
  @bool mIsToMany ;
  @lstring mDestinationEntityName ;
  @lstring mInverseRelationshipName ;
  @bool mInverseIsToMany ;
  @deleteRuleEnum mDeleteRule ;
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
}

#----------------------------------------------------------------------------*

map @propertyMap {
  insert insertKey error message "there is already a '%K' property (attribute, transient or relationship)" ;
}

#----------------------------------------------------------------------------*

list @attributeListForImplementation {
  @EXebType mType ;
  @string mAttributeName ;
  @string mDefaultValueAsObjectiveCObject ;
  @string mDirectOCDefaultValue ;
  @string mDirectSwiftDefaultValue ;
}

#----------------------------------------------------------------------------*

abstract class @abstractBindingForGeneration {
}

#----------------------------------------------------------------------------*

list @outletBindingListForGeneration {
  @abstractBindingForGeneration mBinding ;
}

#----------------------------------------------------------------------------*

list @outletGenerationList {
  @string mOutletType ;
  @string mOutletName ;
  @outletBindingListForGeneration mOutletBindingList ;
  @bool mImplementsDeallocProtocol ;
}

#----------------------------------------------------------------------------*

map @propertyArrayMap {
  @EXebType mElementType ;
  insert insertKey error message "the '%K' array is already declared" ;
  search searchKey error message "the '%K' array is not declared" ;
}

#----------------------------------------------------------------------------*

map @preferencesPropertyArrayMap {
  @EXebType mElementType ;
  @attributeListForImplementation mAttributeListForImplementation ;
  insert insertKey error message "the '%K' array is already declared" ;
  search searchKey error message "the '%K' array is not declared" ;
}

#----------------------------------------------------------------------------*

map @preferencesMap {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @EXobservablePropertyMap mObservablePropertyMap ;
  @fileInclusionSet mFileInclusionSet ;
  @controllerMap mControllerMap ;
  insert insertKey error message "the '%K' preference is already declared" ;
  search searchKey error message "the '%K' preference is not declared" ;
}

#----------------------------------------------------------------------------*

map @nibClassMap {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @EXobservablePropertyMap mObservablePropertyMap ;
  @fileInclusionSet mFileInclusionSet ;
  @controllerMap mControllerMap ;
  @propertyArrayMap mArrayMap ;
  insert insertKey error message "the '%K' nib class is already declared" ;
  search searchKey error message "the '%K' nib class is not declared" ;
}

#----------------------------------------------------------------------------*

map @EXobservablePropertyMap {
  @EXebType mType ;
  @bool mIsTransient ;
  @lstring mPropertySignature ;
  @bool mIsCollection ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#----------------------------------------------------------------------------*

map @observableObjectMap {
  @string mObservableObjectOCName ;
  @string mObservableObjectTypeOCName ;
  @string mIncludeFileName ; # Empty string if no file to include
  @EXobservablePropertyMap mObservableProperties ;
  insert insertKey error message "the '%K' observable object is already declared" ;
  search searchKey error message "the '%K' observable object is not declared" ;
}

#----------------------------------------------------------------------------*

map @actionMap {
  insert insertKey error message "there is already a '%K' action" ;
  search searchKey error message "the '%K' action is not defined" ;
}

#----------------------------------------------------------------------------*

map @controllerMap {
  @string mControllerClassName ;
  @lstring mControlledClassOrEntityName ;
  @bool mIsEntity ;
  @outletBindingListForGeneration mControllerBindingList ;
  @actionMap mActionMap ;
  @EXobservablePropertyMap mObservableAttributeMap ;
  insert insertKey error message "the '%K' controller is already declared" ;
  search searchKey error message "the '%K' controller is not declared" ;
}

#----------------------------------------------------------------------------*

abstract class @abstractTransientDependencyForImplementation {
  @EXebType mMasterAttributeType ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromSelfForImplementation extends @abstractTransientDependencyForImplementation {
  @string mMasterAttributeName ;
  @bool mNamesCountOption ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromControllerForImplementation extends @abstractTransientDependencyForImplementation {
  @string mControllerName ;
  @string mMasterAttributeName ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromRootForImplementation extends @abstractTransientDependencyForImplementation {
  @string mMasterAttributeName ;
  @bool mNamesCountOption ;
  @string mTriggerRoutineName ;
}

#----------------------------------------------------------------------------*

class @transientDependencyFromPreferenceForImplementation extends @abstractTransientDependencyForImplementation {
  @string mPreferenceName ;
  @string mMasterAttributeName ;
  @bool mMasterIsTransient ;
}

#----------------------------------------------------------------------------*

list @directDependancyList {
  @abstractTransientDependencyForImplementation mDependency ;
}

#----------------------------------------------------------------------------*

list @transientListForImplementation {
  @EXebType mTransientType ;
  @string mTransientName ;
  @directDependancyList mDependencyList ;
  @stringlist mRootSignDependencyList ;
}

#----------------------------------------------------------------------------*

graph @EXtransientDependencyGraph (@stringlist) {
  insert addNode error message "the '%K' transient is already declared at %L" ;
}

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateObjectiveCBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateSwiftBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeOutletBinding
  ??@EXobservablePropertyMap inRootEntityObservableAttributeMap
  ??@EXobservablePropertyMap inSelfObservableAttributeMap
  ??@outletClassBindingMap inBoundObjectBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool inHasTableValueBinding
  ??@EXcontextAnalysisStruct inContextAnalysisStruct
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@fileInclusionSet ioFileInclusionSet
;

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateObjectiveCRemoveBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateSwiftRemoveBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

abstract method @abstractDefaultValue analyzeDefaultValueType 
  ??@EXebTypeList inAttributeActualTypeList
  ??@EXcontextAnalysisStruct inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  !@string outSwiftDefaultValueAsString
  ?!@fileInclusionSet ioFileInclusionSet
;

#----------------------------------------------------------------------------*
  
override method @boolAsDefaultValue analyzeDefaultValueType 
  ??@EXebTypeList inAttributeActualTypeList
  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  !@string outSwiftDefaultValueAsString
  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@EXTypeKind boolType] then
      outDirectDefaultValueAsString := if mValue->bool then "YES" else "NO" end ;
      outObjectiveCDefaultValueAsString := "[NSNumber numberWithBool:" . outDirectDefaultValueAsString . "]" ;
      outSwiftDefaultValueAsString := if mValue->bool then "true" else "false" end ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a boolean attribute can be initialized by YES or NO"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @integerAsDefaultValue analyzeDefaultValueType 
  ??@EXebTypeList inAttributeActualTypeList
  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  !@string outSwiftDefaultValueAsString
  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@EXTypeKind integerType] then
      outDirectDefaultValueAsString := [mValue->uint string] ;
      outObjectiveCDefaultValueAsString := "[NSNumber numberWithInteger:" . outDirectDefaultValueAsString . "]" ;
      outSwiftDefaultValueAsString := outDirectDefaultValueAsString  ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only an integer attribute can be initialized by an integer constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @doubleAsDefaultValue analyzeDefaultValueType 
  ??@EXebTypeList inAttributeActualTypeList
  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  !@string outSwiftDefaultValueAsString
  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@EXTypeKind doubleType] then
      outDirectDefaultValueAsString := [mValue->double string] ;
      outObjectiveCDefaultValueAsString := "[NSNumber numberWithDouble:" . outDirectDefaultValueAsString . "]" ;
      outSwiftDefaultValueAsString := outDirectDefaultValueAsString ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a double attribute can be initialized by a floating point constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*
  
override method @stringAsDefaultValue analyzeDefaultValueType 
  ??@EXebTypeList inAttributeActualTypeList
  ??@EXcontextAnalysisStruct unused inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  !@string outSwiftDefaultValueAsString
  ?!@fileInclusionSet unused ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@EXTypeKind stringType] then
      outDirectDefaultValueAsString := "@" . [mValue->string utf8Representation] ;
      outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
      outSwiftDefaultValueAsString := "\"". mValue->string . "\"" ;
      found := true ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "only a string attribute can be initialized by a string constant"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

once predefinedColors -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"blackColor" ;
  outResult += !"blueColor" ;
  outResult += !"brownColor" ;
  outResult += !"clearColor" ;
  outResult += !"controlColor" ;
  outResult += !"controlDarkShadowColor" ;
  outResult += !"controlHighlightColor" ;
  outResult += !"controlLightHighlightColor" ;
  outResult += !"controlShadowColor" ;
  outResult += !"controlTextColor" ;
  outResult += !"cyanColor" ;
  outResult += !"darkGrayColor" ;
  outResult += !"disabledControlTextColor" ;
  outResult += !"grayColor" ;
  outResult += !"greenColor" ;
  outResult += !"gridColor" ;
  outResult += !"headerColor" ;
  outResult += !"headerTextColor" ;
  outResult += !"highlightColor" ;
  outResult += !"keyboardFocusIndicatorColor" ;
  outResult += !"knobColor" ;
  outResult += !"lightGrayColor" ;
  outResult += !"magentaColor" ;
  outResult += !"orangeColor" ;
  outResult += !"purpleColor" ;
  outResult += !"redColor" ;
  outResult += !"scrollBarColor" ;
  outResult += !"selectedControlColor" ;
  outResult += !"selectedControlTextColor" ;
  outResult += !"selectedKnobColor" ;
  outResult += !"selectedMenuItemColor" ;
  outResult += !"selectedMenuItemTextColor" ;
  outResult += !"selectedTextBackgroundColor" ;
  outResult += !"selectedTextColor" ;
  outResult += !"shadowColor" ;
  outResult += !"textBackgroundColor" ;
  outResult += !"textColor" ;
  outResult += !"whiteColor" ;
  outResult += !"windowBackgroundColor" ;
  outResult += !"windowFrameColor" ;
  outResult += !"windowFrameTextColor" ;
  outResult += !"yellowColor" ;
end once ;

#----------------------------------------------------------------------------*

once predefinedDates -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"date" ;
end once ;

#----------------------------------------------------------------------------*
  
override method @identifierAsDefaultValue analyzeDefaultValueType 
  ??@EXebTypeList inAttributeActualTypeList
  ??@EXcontextAnalysisStruct inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  !@string outSwiftDefaultValueAsString
  ?!@fileInclusionSet ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  outSwiftDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@EXTypeKind colorType] then
      found := true ;
      if [predefinedColors [] hasKey !mValue->string] then
        outDirectDefaultValueAsString := "[NSColor " . mValue->string . "]" ;
        outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
        outSwiftDefaultValueAsString := "NSColor." . mValue->string . " ()" ;
      else
        error mValue
        : "unknown predefined color"
        : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
        ;  
      end if ;
    elsif mType->mKind == [@EXTypeKind dateType] then
      found := true ;
      if [predefinedDates [] hasKey !mValue->string] then
        outDirectDefaultValueAsString := "[NSDate " . mValue->string . "]" ;
        outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
        outSwiftDefaultValueAsString := "NSDate ()" ;
      else
        error mValue
        : "unknown predefined date"
        : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
        ;  
      end if ;
    elsif mType->mKind == [@EXTypeKind enumType] then
      found := true ;
      if [inContextAnalysisStruct->mGlobalEnumConstantMap hasKey !mValue->string] then
        [inContextAnalysisStruct->mGlobalEnumConstantMap searchKey !mValue ?@lstring inEnumTypeName] ;
        ioFileInclusionSet->mHeaderFileInclusionSet += !inEnumTypeName->string ;
        if [mType ebTypeName] == inEnumTypeName->string then
          outDirectDefaultValueAsString := mValue->string ;
          outObjectiveCDefaultValueAsString := "[NSNumber numberWithInteger:" . mValue->string . "]" ; ;
          outSwiftDefaultValueAsString := inEnumTypeName->string . "." . mValue->string ;
        else
          error mValue
          : "bad enum constant, belongs to the '" . inEnumTypeName . "' enum type"
          : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
          ;  
        end if ;
      else
        error mValue
        : "the '" . [mType ebTypeName] . "' enumeration does not define '" . mValue . "' constant"
        : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
        ;  
      end if ;
    end if ;
  end foreach ;
  if not found then
    error mValue
    : "unknow type for this identifier"
    : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

once predefinedFonts -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"boldSystemFontOfSize" ;
  outResult += !"controlContentFontOfSize" ;
  outResult += !"labelFontOfSize" ;
  outResult += !"menuFontOfSize" ;
  outResult += !"menuBarFontOfSize" ;
  outResult += !"messageFontOfSize" ;
  outResult += !"paletteFontOfSize" ;
  outResult += !"systemFontOfSize" ;
  outResult += !"titleBarFontOfSize" ;
  outResult += !"toolTipsFontOfSize" ;
end once ;

#----------------------------------------------------------------------------*
 
override method @listAsDefaultValue analyzeDefaultValueType 
  ??@EXebTypeList inAttributeActualTypeList
  ??@EXcontextAnalysisStruct inContextAnalysisStruct
  !@string outDirectDefaultValueAsString
  !@string outObjectiveCDefaultValueAsString
  !@string outSwiftDefaultValueAsString
  ?!@fileInclusionSet ioFileInclusionSet
:
  outObjectiveCDefaultValueAsString := "" ;
  outSwiftDefaultValueAsString := "" ;
  outDirectDefaultValueAsString := "" ;
  @bool found := false ;
  foreach inAttributeActualTypeList while not found do
    if mType->mKind == [@EXTypeKind structType] then
      found := true ;
      ioFileInclusionSet->mHeaderFileInclusionSet += ![mType ebTypeName] ;
      [inContextAnalysisStruct->mStructTypeMap searchKey
        !mType->mTypeName
        ?@structFieldList fieldList
      ] ;
      if [mDefaultValueList length] != [fieldList length] then
        error mStartLocation : "the '" . [mType ebTypeName] . "' struct needs " . [fieldList length] . " values for initialization" ;
      else
        outDirectDefaultValueAsString := "make" . [mType ebTypeName] . " (" ;
        foreach mDefaultValueList, fieldList
        do
          [mDefaultValue analyzeDefaultValueType
            ![@EXebTypeList listWithValue !mFieldType]
            !inContextAnalysisStruct
            ?@string directDefaultValueAsString
            ?2*
            !?ioFileInclusionSet
          ] ;
          outDirectDefaultValueAsString .= directDefaultValueAsString ;
        between
          outDirectDefaultValueAsString .= ", " ;
        end foreach ; 
        outDirectDefaultValueAsString .= ")" ;     
      end if ;
    elsif mType->mKind == [@EXTypeKind fontType] then
      found := true ;
      const @string errorMessage := "an NSFont should be initialized by a (fontName, fontSize) value" ;
      if [mDefaultValueList length] != 2 then
        error mStartLocation : errorMessage ; 
      else
        const @abstractDefaultValue v0 := [mDefaultValueList mDefaultValueAtIndex !0] ; 
        const @abstractDefaultValue v1 := [mDefaultValueList mDefaultValueAtIndex !1] ;
        @identifierAsDefaultValue fontName ;
        if (v0 is == @identifierAsDefaultValue) then 
          fontName := (cast v0 : @identifierAsDefaultValue) ;
        else
          error mStartLocation : errorMessage : fontName ;
        end if ;
        @integerAsDefaultValue fontSize ;
        if (v1 is == @integerAsDefaultValue) then 
          fontSize := (cast v1 : @integerAsDefaultValue) ;
        else
          error mStartLocation : errorMessage : fontSize ;
        end if ;
        if [predefinedFonts [] hasKey ![fontName mValue]->string] then
          outDirectDefaultValueAsString := "[NSFont " . [fontName mValue]->string . ":" . [[fontSize mValue]->uint string] . "]" ;
          outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
          outSwiftDefaultValueAsString := "NSFont (" . [fontName mValue]->string . ", " . [[fontSize mValue]->uint string] . ")" ;
        else
          error [fontName mValue]
          : "unknown predefined font name"
          : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
          ;  
        end if ;
      end if ;
    end if ;
  end foreach ;
  if not found then
    error mStartLocation
    : "invalid initialization value"
    ;  
  end if ;
end method ;

#----------------------------------------------------------------------------*

map @EXobservablePropertyMapMap {
  @bool mUserDefined ;
  @EXTypeKind mType ;
  @EXobservablePropertyMap mObservablePropertyMap ;
  insert insertKey error message "the '%K' key is already declared" ;
  search searchKey error message "the '%K' key is not declared" ;
}

#----------------------------------------------------------------------------*

abstract method @EXastDeclaration buildObservablePropertyMap
  ??@EXunifiedTypeMap inUnifiedTypeMap
  ?!@EXobservablePropertyMapMap ioObservablePropertyMapMap
  ?!@EXtransientDependencyGraph ioTransientDependencyGraph
;

#----------------------------------------------------------------------------*

abstract class @generation {
  @string mGenerationName ;
}

#----------------------------------------------------------------------------*

list @generationList {
  @generation mGeneration ;
}

#----------------------------------------------------------------------------*

abstract method @EXastDeclaration semanticAnalysis
  ??@EXunifiedTypeMap inUnifiedTypeMap
  ?!@EXcontextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
;

#----------------------------------------------------------------------------*

abstract method @generation generate
  ??@string inOutputDirectory
;

#----------------------------------------------------------------------------*

class @structTypeGeneration extends @generation {
  @structFieldList mFieldList ;
  @stringset mHeaderFileInclusionSet ;
}

#----------------------------------------------------------------------------*

class @enumTypeGeneration extends @generation {
  @lstringlist mConstantOrderedList ;
}

#----------------------------------------------------------------------------*

class @classTypeGeneration extends @generation {
  @string mSuperClassName ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @propertyArrayMap mAllArrayPropertyForImplementation ;
  @propertyArrayMap mCurrentArrayPropertyForImplementation ;
  @fileInclusionSet mInclusionSet ;
}

#----------------------------------------------------------------------------*

class @nibClassTypeGeneration extends @generation {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @EXobservablePropertyMap mObservablePropertyMap ;
  @fileInclusionSet mFileInclusionSet ;
  @controllerMap mControllerMap ;
  @propertyArrayMap mArrayMap ;
}

#----------------------------------------------------------------------------*

class @preferenceTypeGeneration extends @generation {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @fileInclusionSet mFileInclusionSet ;
  @controllerMap mControllerMap ;
  @preferencesPropertyArrayMap mArrayMap ;
}

#----------------------------------------------------------------------------*

class @entityGeneration extends @generation {
  @string mSuperEntityName ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @fileInclusionSet mFileInclusionSet ;
  @signListForGeneration mSignList ;
  @EXentityRelationshipMap mCurrentRelationshipMap ;
  @2stringlist mToManyRelationshipList ;
  @2stringlist mToOneRelationshipList ;
}

#----------------------------------------------------------------------------*

class @documentGeneration extends @generation {
  @string mRootEntityName ;
  @outletGenerationList mOutletDeclarationList ;
  @controllerMap mControllerMap ;
  @lstringlist mActionList ;
  @transientListForImplementation mTransientListForImplementation ;
  @fileInclusionSet mFileInclusionSet ;
  @attributeListForImplementation mAttributeListForImplementation ;
}

#----------------------------------------------------------------------------*

class @outletClassGeneration extends @generation {
  @string mSuperClassName ;
  @protocolList mAdoptedProtocolList ;
  @bool mImplementsDeallocProtocol ;
  @outletClassBindingMap mCurrentBindingMap ;
}

#----------------------------------------------------------------------------*

class @controllerClassGeneration extends @generation {
  @outletClassBindingMap mBindingMap ;
  @EXobservablePropertyMap mObservablePropertyMap ;
}

#----------------------------------------------------------------------------*

end semantics ;
