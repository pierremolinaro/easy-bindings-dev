program easyBindings_program :
import "easyBindings_grammar.gGrammar" ;

import "cursorAnalysis.gSemantics" ;
import "cursorGeneration.gSemantics" ;
import "transientGeneration.gSemantics" ;
import "easyBindings_options.gOption" ;
import "entityGeneration.gSemantics" ;
import "typeAnalysis.gSemantics" ;
import "actionGeneration.gSemantics" ;
import "outletClassGeneration.gSemantics" ;
import "controllerClassAnalysis.gSemantics" ;
import "controllerClassGeneration.gSemantics" ;

#----------------------------------------------------------------------------*

filewrapper predefinedOutletClasses in "../generation-templates" {
}{
}{
  template sourceFile "predefinedOutletClasses.easyBindings" ;
}

#----------------------------------------------------------------------------*

filewrapper objective_c_sources in "../generation-templates/objective-c-sources" {
  "m", "h", "xib", "swift"
}{
}{
}

#----------------------------------------------------------------------------*

when . "easyBindings"
message "a source text file with the .easyBindings extension"
??@lstring inSourceFile {
#--- Parse predefined outlets
  @astDeclarationStruct declarationStruct [default] ;
  grammar easyBindings_grammar on [filewrapper predefinedOutletClasses.sourceFile]
    !userDefined:false
    !?declarationStruct
    ?*
  ;
#--- Parse source file
  grammar easyBindings_grammar in inSourceFile
    !userDefined:true
    !?declarationStruct
    ?@location endOfSourceFile
  ;
#--- Enter predefined types
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"String" ![@typeKind stringType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"NSColor" ![@typeKind colorType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"NSData" ![@typeKind dataType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"NSDate" ![@typeKind dateType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"NSFont" ![@typeKind fontType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"NSImage" ![@typeKind imageType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"NSMenu" ![@typeKind menuType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"NSBezierPath" ![@typeKind bezierPathType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Integer" ![@typeKind integerType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"UInteger" ![@typeKind uintegerType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Bool" ![@typeKind boolType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Double" ![@typeKind doubleType]] ;
#------------------------------------------------------- Type Inventory
   @unifiedTypeMap unifiedTypeMap [emptyMap] ;
  foreach declarationStruct->mDeclarationList do
    [mDeclaration typeInventory !?unifiedTypeMap] ;
  end foreach ;
  if [option easyBindings_options.outputClassDependencyGraph value] then
    const s := [unifiedTypeMap edgeGraphvizRepresentation] ;
    const path := inSourceFile->string . ".classDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#------------------------------------------- Check all types are defined
  const unsolvedProxyList := [unifiedTypeMap unsolvedProxyList] ;
  foreach unsolvedProxyList do
    error mValue :"type " . mValue . " is undefined" ;
  end foreach ;
#------------------------------------------- Topological sort types and continue
  if [unsolvedProxyList length] == 0 then
    [unifiedTypeMap topologicalSort
      ?@lstringlist sortedTypeNames
      ?@lstringlist unsortedTypeNames
    ] ;
    if [unsortedTypeNames length] > 0 then
      var s := "cannot sort types ; the following types are involved in circular dependence:" ;
      foreach unsortedTypeNames do
        s .= "\n-- " . mValue ;
      end foreach ;
      error here : s ;
    else
      semanticAnalysis
        !unifiedTypeMap
        !sortedTypeNames
        !inSourceFile->string
        !declarationStruct
        ??@transientDependencyGraphNodeInfoList sortedTransientAndObservablePropertyNodes
        ??@structForGeneration generation
      ;
      if [@uint errorCount] == 0 then
        generateCode
          !sortedTransientAndObservablePropertyNodes
          !generation
          !inSourceFile->string
        ;
      end if ;
    end if ;
  end if ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#   S E M A N T I C    A N A L Y S I S                                       *
#                                                                            *
#----------------------------------------------------------------------------*

local routine semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstringlist unused inSortedKeys
  ??@string inSourceFile
  ??@astDeclarationStruct inAstDeclarationStruct
  !@transientDependencyGraphNodeInfoList outSortedTransientAndObservablePropertyNodes
  !@structForGeneration outGeneration
:
#--- Build transient dependancy graph
  buildTransientDependencyGraph
    !inUnifiedTypeMap
    !inSourceFile
    ?outSortedTransientAndObservablePropertyNodes
  ;
#--- Build controller template map
  buildControllerTemplateMap
    !inUnifiedTypeMap
    !inAstDeclarationStruct->mControllerTemplateList
    ??@templateControllerMap templateControllerMap
  ;
#--- Build outlet class map
  @outletClassMap outletClassMap := {} ;
  for () in inAstDeclarationStruct->mOutletClassDeclarationList do
    [!?outletClassMap insertKey !mOutletClassName] ;
  end for ;
#--- Type analysis
  if [@uint errorCount] == 0 then
    typeAnalysis
      !inUnifiedTypeMap
      !outletClassMap
      !templateControllerMap
      ?outGeneration
    ;
  else
    outGeneration := [@structForGeneration default] ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#   G E N E R A T E    C O D E                                               *
#                                                                            *
#----------------------------------------------------------------------------*

local routine generateCode
  ??@transientDependencyGraphNodeInfoList inSortedTransientAndObservablePropertyNodes
  ??@structForGeneration inGeneration
  ??@string inSourceFile
:
  generateTransients
    !inSourceFile
    !inSortedTransientAndObservablePropertyNodes
    !inGeneration->mTransientListForGeneration
  ;
  generateActions
    !inSourceFile
    !inGeneration->mActionListForGeneration
  ;
  const outputDirectory := [inSourceFile stringByDeletingLastPathComponent] ;
  generatePreferences
    !inGeneration->mPreferenceListForGeneration
    !outputDirectory
  ;
  generateOutletClasses
    !inGeneration->mNeededOutletClasses
    !outputDirectory
  ;
  generateControllerClasses
    !inGeneration->mControllerGenerationString
    !outputDirectory
  ;
end routine ;

#----------------------------------------------------------------------------*

end program ;
