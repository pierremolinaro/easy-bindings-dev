program easyBindings_program :
import "easyBindings_grammar.gGrammar" ;

import "transientGeneration.gSemantics" ;
import "easyBindings_options.gOption" ;
import "entityGeneration.gSemantics" ;
import "typeAnalysis.gSemantics" ;
import "actionGeneration.gSemantics" ;
import "outletClassGeneration.gSemantics" ;
import "controllerClassAnalysis.gSemantics" ;
import "controllerClassGeneration.gSemantics" ;
import "transientAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

filewrapper predefinedOutletClasses in "../generation-templates" {
}{
}{
  template sourceFile "predefinedOutletClasses.easyBindings" ;
}

#----------------------------------------------------------------------------*

when . "easyBindings"
message "a source text file with the .easyBindings extension"
??@lstring inSourceFile {
#--- Parse predefined outlets
  @astDeclarationStruct declarationStruct [default] ;
  grammar easyBindings_grammar on [filewrapper predefinedOutletClasses.sourceFile]
    !userDefined:false
    !?declarationStruct
    ?*
  ;
#--- Parse source file
  grammar easyBindings_grammar in inSourceFile
    !userDefined:true
    !?declarationStruct
    ?@location endOfSourceFile
  ;
#--- Enter predefined types
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"String" ![@typeKind stringType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Color" ![@typeKind colorType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Enum" ![@typeKind enumType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Date" ![@typeKind dateType]] ;
#  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Font" ![@typeKind fontType]] ;
#  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Image" ![@typeKind imageType]] ;
#  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Menu" ![@typeKind menuType]] ;
#  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"BezierPath" ![@typeKind bezierPathType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Integer" ![@typeKind integerType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"UInteger" ![@typeKind uintegerType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Bool" ![@typeKind boolType]] ;
  declarationStruct->mDeclarationList += ![@predefinedTypeDeclaration new !false !"Double" ![@typeKind doubleType]] ;
#------------------------------------------------------- Type Inventory
   @unifiedTypeMap unifiedTypeMap [emptyMap] ;
  foreach declarationStruct->mDeclarationList do
    [mDeclaration typeInventory !?unifiedTypeMap] ;
  end foreach ;
  if [option easyBindings_options.outputClassDependencyGraph value] then
    const s := [unifiedTypeMap edgeGraphvizRepresentation] ;
    const path := inSourceFile->string . ".classDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#------------------------------------------- Check all types are defined
  const unsolvedProxyList := [unifiedTypeMap unsolvedProxyList] ;
  foreach unsolvedProxyList do
    error mValue :"type " . mValue . " is undefined" ;
  end foreach ;
#------------------------------------------- Topological sort types and continue
  if [unsolvedProxyList length] == 0 then
    [unifiedTypeMap topologicalSort
      ?@lstringlist sortedTypeNames
      ?@lstringlist unsortedTypeNames
    ] ;
    if [unsortedTypeNames length] > 0 then
      var s := "cannot sort types ; the following types are involved in circular dependence:" ;
      foreach unsortedTypeNames do
        s .= "\n-- " . mValue ;
      end foreach ;
      error here : s ;
    else
      semanticAnalysis
        !unifiedTypeMap
        !sortedTypeNames
        !inSourceFile->string
        !declarationStruct
        ??@transientDependencyGraphNodeInfoList sortedTransientAndObservablePropertyNodes
        ??@structForGeneration generation
      ;
      if [@uint errorCount] == 0 then
        generateCode
          !sortedTransientAndObservablePropertyNodes
          !generation
          !inSourceFile->string
        ;
      end if ;
    end if ;
  end if ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#   S E M A N T I C    A N A L Y S I S                                       *
#                                                                            *
#----------------------------------------------------------------------------*

local routine semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstringlist unused inSortedKeys
  ??@string inSourceFile
  ??@astDeclarationStruct inAstDeclarationStruct
  !@transientDependencyGraphNodeInfoList outSortedTransientAndObservablePropertyNodes
  !@structForGeneration outGeneration
:
#--- Build transient dependancy graph
  buildTransientDependencyGraph
    !inUnifiedTypeMap
    !inSourceFile
    ?outSortedTransientAndObservablePropertyNodes
  ;
#--- Build controller template map
  buildControllerTemplateMap
    !inUnifiedTypeMap
    !inAstDeclarationStruct->mControllerTemplateList
    ??@templateControllerMap templateControllerMap
  ;
#--- Build outlet class map
  @outletClassMap outletClassMap := {} ;
  for () in inAstDeclarationStruct->mOutletClassDeclarationList do
    [!?outletClassMap insertKey !mOutletClassName] ;
  end for ;
#--- Type analysis
  if [@uint errorCount] == 0 then
    typeAnalysis
      !inUnifiedTypeMap
      !outletClassMap
      !templateControllerMap
      ?outGeneration
    ;
  else
    outGeneration := [@structForGeneration default] ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*
#                                                                            *
#   G E N E R A T E    C O D E                                               *
#                                                                            *
#----------------------------------------------------------------------------*

local routine generateCode
  ??@transientDependencyGraphNodeInfoList inSortedTransientAndObservablePropertyNodes
  ??@structForGeneration inGeneration
  ??@string inSourceFile
:
  generateTransients
    !inSourceFile
    !inSortedTransientAndObservablePropertyNodes
    !inGeneration->mTransientListForGeneration
  ;
  generateActions
    !inSourceFile
    !inGeneration->mActionListForGeneration
  ;
  const outputDirectory := [inSourceFile stringByDeletingLastPathComponent] ;
  generatePreferences
    !inGeneration->mPreferenceListForGeneration
    !outputDirectory
  ;
  generateOutletClasses
    !inGeneration->mNeededOutletClasses
    !outputDirectory
  ;
  generateControllerClasses
    !inGeneration->mControllerGenerationStringSet
    !outputDirectory
  ;
  generateEntities
    !inGeneration->mEntityListForGeneration
    !outputDirectory
  ;
  generateEnums
    !inGeneration->mEnumListForGeneration
    !outputDirectory
  ;
  generateDocuments
    !inGeneration->mDocumentListForGeneration
    !outputDirectory
  ;
  generateSwiftApplicationFiles
    !outputDirectory
    ![inGeneration->mEntityListForGeneration length] > 0
  ;
end routine ;

#----------------------------------------------------------------------------*

filewrapper swift_sources in "../generation-templates/swift-sources" {
  "xib", "swift"
}{
}{
}

#----------------------------------------------------------------------------*

local routine generateSwiftApplicationFiles
  ??@string inOutputDirectory
  ??@bool inHasEntities
:
  @stringlist swiftFiles := {!"PMAllocationDebug", !"easy-bindings-utilities"} ;
  if inHasEntities then
    swiftFiles += !"PMObjectManager" ;
    swiftFiles += !"PMManagedObject" ;
    swiftFiles += !"PMManagedDocument" ;
    swiftFiles += !"PMUndoManager" ;
    swiftFiles += !"PMDataScanner" ;
  end if ;
  @stringlist xibFiles := {!"PMAllocationDebug"} ;
  var fw := [filewrapper swift_sources] ;
  for (@string s) in swiftFiles do
    const contents := [fw textFileContentsAtPath !s + ".swift"] ;
    [@string generateFile
      !inOutputDirectory
      !s + ".swift"
      !contents
    ] ;
  end for ;
  for (@string s) in xibFiles do
    const contents := [fw textFileContentsAtPath !s + ".xib"] ;
    [@string generateFile
      !inOutputDirectory
      !s + ".xib"
      !contents
    ] ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

end program ;
