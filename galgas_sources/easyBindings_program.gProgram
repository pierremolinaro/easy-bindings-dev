program easyBindings_program :
import "easyBindings_grammar.gGrammar" ;

import "cursorAnalysis.gSemantics" ;
import "cursorGeneration.gSemantics" ;
import "transientGeneration.gSemantics" ;
import "easyBindings_options.gOption" ;
import "entityGeneration.gSemantics" ;

#----------------------------------------------------------------------------*

filewrapper predefinedOutletClasses in "../generation-templates/predefined-outlet-classes" {
}{
}{
  template sourceFile "predefinedOutletClasses.easyBindings" ;
}

#----------------------------------------------------------------------------*

filewrapper objective_c_sources in "../generation-templates/objective-c-sources" {
  "m", "h", "xib", "swift"
}{
}{
}

#----------------------------------------------------------------------------*

when . "easyBindings"
message "a source text file with the .easyBindings extension"
??@lstring inSourceFile {
#--- Parse predefined outlets
  @astDeclarationList declarationList [emptyList] ;

  @cursorList cursorList [emptyList] ;
  grammar easyBindings_grammar on [filewrapper predefinedOutletClasses.sourceFile]
    !userDefined:false
    !?declarationList
    !?cursorList
    ?*
  ;
#--- Parse source file
  grammar easyBindings_grammar in inSourceFile
    !userDefined:true
    !?declarationList
    !?cursorList
    ?@location endOfSourceFile
  ;
#--- Enter predefined types
  declarationList += ![@predefinedTypeDeclaration new !false !"NSString" ![@typeKind stringType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"NSColor" ![@typeKind colorType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"NSData" ![@typeKind dataType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"NSDate" ![@typeKind dateType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"NSFont" ![@typeKind fontType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"NSImage" ![@typeKind imageType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"NSMenu" ![@typeKind menuType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"NSBezierPath" ![@typeKind bezierPathType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"Integer" ![@typeKind integerType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"UInteger" ![@typeKind uintegerType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"Bool" ![@typeKind boolType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"Double" ![@typeKind doubleType]] ;
  declarationList += ![@predefinedTypeDeclaration new !false !"enum" ![@typeKind enumType]] ;
#------------------------------------------------------- Type Inventory
   @unifiedTypeMap unifiedTypeMap [emptyMap] ;
#----
  foreach declarationList do
    [mDeclaration typeInventory !?unifiedTypeMap] ;
  end foreach ;
  if [option easyBindings_options.outputClassDependencyGraph value] then
    const s := [unifiedTypeMap edgeGraphvizRepresentation] ;
    const path := inSourceFile->string . ".classDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#------------------------------------------- Check all types are defined
  const unsolvedProxyList := [unifiedTypeMap unsolvedProxyList] ;
  foreach unsolvedProxyList do
    error mValue :"type " . mValue . " is undefined" ;
  end foreach ;
#------------------------------------------- Topological sort types and continue
  if [unsolvedProxyList length] == 0 then
    [unifiedTypeMap topologicalSort
      ?@lstringlist sortedTypeNames
      ?@lstringlist unsortedTypeNames
    ] ;
    if [unsortedTypeNames length] > 0 then
      var s := "cannot sort types ; the following types are involved in circular dependence:" ;
      foreach unsortedTypeNames do
        s .= "\n-- " . mValue ;
      end foreach ;
      error here : s ;
    else
#      @string s := "Sorted types:" ;
#      foreach sortedKeys do
#        s .= "\n-- " . mValue ;
#      end foreach ;
#      message s ;
      semanticAnalysis
        !unifiedTypeMap
        !sortedTypeNames
        !inSourceFile->string
        !cursorList
        !endOfSourceFile
      ;
    end if ;
  end if ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#   S E M A N T I C    A N A L Y S I S                                       *
#                                                                            *
#----------------------------------------------------------------------------*

local routine semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstringlist inSortedKeys
  ??@string inSourceFile
  ??@cursorList inCursorList
  ??@location inEndOfSourceFile
:
  const outputDirectory := [inSourceFile stringByDeletingLastPathComponent] ;
#--- Build observable property map
  @observablePropertyMapMap observablePropertyMapMap [emptyMap] ;
  @transientDependencyGraph transientDependencyGraph [emptyGraph] ;
  foreach inSortedKeys do
    [inUnifiedTypeMap searchKey
      !mValue
      ?*
      ?@astDeclaration declaration
    ] ;
    [declaration buildObservablePropertyMap
      !inUnifiedTypeMap
      !?observablePropertyMapMap
      !?transientDependencyGraph
    ] ;
  end foreach ;
   @contextAnalysisStruct contextAnalysisStruct [default] ;
   contextAnalysisStruct->mObservablePropertyMapMap := observablePropertyMapMap ;
   contextAnalysisStruct->mTransientDependencyGraph := transientDependencyGraph ;
#--- Cursors
  cursorAnalysis
    !inCursorList
    !?contextAnalysisStruct
    ?@stringlist predefinedCursorList
  ;
#--- Semantic analysis
  @generationList generationList [emptyList] ;
  foreach inSortedKeys do
    [inUnifiedTypeMap searchKey
      !mValue
      ?*
      ?@astDeclaration declaration
    ] ;
    [declaration semanticAnalysis
      !inUnifiedTypeMap
      !?contextAnalysisStruct
      !?generationList
    ] ;
  end foreach ;
#------------------------------- Check relationships
  if [@uint errorCount] == 0 then
    foreach contextAnalysisStruct->mEntityMap do
      foreach mCurrentRelationshipMap do
        [contextAnalysisStruct->mEntityMap searchKey
          !mDestinationEntityName
          ?9*
          ?@relationshipMap destinationEntityRelationshipMap
          ?2*
        ] ;
        [destinationEntityRelationshipMap searchKey
          !mInverseRelationshipName
          ?2*
          ?@lstring inverseOfInverseRelationshipName
          ?@bool inverseIsToMany
          ?*
        ] ;
        if lkey->string != inverseOfInverseRelationshipName->string then
          error mInverseRelationshipName : "the inverse relationship does not name '" . lkey . "' relationship as inverse" ;
        end if ;
        if mIsToMany != inverseIsToMany then
          error mInverseRelationshipName : "the inverse relationship is " . if inverseIsToMany then "to many" else "to one" end ;
        end if ;
      end foreach ;
    end foreach ;
  end if ;
#--- Generation
  if [@uint errorCount] == 0 then
    foreach generationList do
      [mGeneration generate !outputDirectory] ;
    end foreach ;
    generateCursorCode
      !contextAnalysisStruct->mUserCursorMap
      !predefinedCursorList
      !outputDirectory
    ;
    generateEntityFactory !contextAnalysisStruct->mEntityMap !outputDirectory ;
  end if ;
#--- Output graphviz file ?
  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
    const @string s := [contextAnalysisStruct->mTransientDependencyGraph graphviz] ;
    const @string path := inSourceFile . ".transientDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#--- Analyze transient dependencies
  var transientDependencyArcList := [contextAnalysisStruct->mTransientDependencyGraph edges] ;
  var sortedTransientOrderedList := [@stringlist emptyList] ;
  if [@uint errorCount] == 0 then
    if [contextAnalysisStruct->mTransientDependencyGraph undefinedNodeCount] > 0 then
      foreach [contextAnalysisStruct->mTransientDependencyGraph undefinedNodeKeyList] do
        error inEndOfSourceFile : "the '" . mValue . "' property is not defined" ;
      end foreach ;
    else
      [contextAnalysisStruct->mTransientDependencyGraph topologicalSort
        ?sortedTransientOrderedList
        ?*
        ?@stringlist unsortedTransientList
        ?*
      ] ;
      if [unsortedTransientList length] > 0 then
        @string s := [[unsortedTransientList length] string] . " transient declarations are involved in circular dependancies:" ;
        foreach unsortedTransientList do
          s .= "\n-  " . mValue ;
        end foreach ;
        error inEndOfSourceFile : s ;
      else # all defined, no circularity
      end if ;
    end if ;
  end if ;
#------------------------------ Generate protocols for property observers
  generateObserverProtocols
    !observablePropertyMapMap
    !outputDirectory
  ;
#------------------------------ Output dependency order definition file
  generateTransientTrigersAndApplication
    !transientDependencyArcList
    !outputDirectory
    !sortedTransientOrderedList
  ;
#--- Extensions
  @stringset extensionSet [setWithString !"xib"] ;
  if [option easyBindings_options.outputSwift value] then
    extensionSet += !"swift" ;
  else
    extensionSet += !"m" ;
    extensionSet += !"h" ;
  end if ;
#--- Add embedded sources
  @stringset generateSet [emptySet] ;
  generateSet += !"easy-bindings-utilities" ;
  generateSet += !"PMAllocationDebug" ;
  if contextAnalysisStruct->mContainsDocument then
    generateSet += !"PMUndoManager" ;
    generateSet += !"PMManagedDocument" ;
    generateSet += !"NSData+BZ2compression" ;
    generateSet += !"NSData+BZ2compression" ;
    generateSet += !"NSData+PMGZcompression" ;
    generateSet += !"NSMutableData+PMWrites" ;
    generateSet += !"PMDataScanner" ;
  end if ;
  if [contextAnalysisStruct->mEntityMap count] > 0 then
    generateSet += !"load-store-functions" ;
    generateSet += !"PMManagedObject" ;
    generateSet += !"PMObjectManager" ;
    generateSet += !"PMAttributeDescription" ;
    generateSet += !"PMRelationshipDescription" ;
    generateSet += !"PMEntityArrayController" ;
    generateSet += !"PMEntityController" ;
  end if ;
#---
  @filewrapper fw := [filewrapper objective_c_sources] ;
  foreach [fw allTextFilePathes] do
    const @string sourceName := [mValue lastPathComponent] ;
    if [generateSet hasKey ![sourceName stringByDeletingPathExtension]] & [extensionSet hasKey ![sourceName pathExtension]] then
      [@string generateFile
        !outputDirectory . [mValue stringByDeletingLastPathComponent]
        !sourceName
        ![fw textFileContentsAtPath !mValue]
       ] ;
     end if ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine generateObserverProtocols
  ??@observablePropertyMapMap inObservablePropertyMapMap
  ??@string inOutputDirectory
:
  if [@uint errorCount] == 0 then
    var contents := "" ;
 #   log inObservablePropertyMapMap ;
    for (* @bool userDefined * @observablePropertyMap observablePropertyMap) in inObservablePropertyMapMap do
      if userDefined then
        for () in observablePropertyMap do
          const signature := [mPropertySignature identifierRepresentation] ;
          contents += "@objc(protocol_" + signature + ") protocol protocol_" + signature + " {\n"
                    + "  func " + signature + "_didChange ()\n"
                    + "}\n\n" ;
        end for ;
      end if ;
    end for ;
    [@string generateFile
      !inOutputDirectory
      !"observer-protocols.swift"
      !contents
     ] ;
  end if ;
end routine  ;

#----------------------------------------------------------------------------*

end program ;
