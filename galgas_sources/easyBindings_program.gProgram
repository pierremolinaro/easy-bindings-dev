program easyBindings_program :
import "decoratedTypes.gSemantics" ;
import "easyBindings_grammar.gGrammar" ;

import "cursorAnalysis.gSemantics" ;

#import "outletClassGeneration.gSemantics" ;
#import "classGeneration.gSemantics" ;
#import "entityGeneration.gSemantics" ;
#import "preferencesGeneration.gSemantics" ;
#import "documentGeneration.gSemantics" ;
#import "easyBindings_grammar.gGrammar" ;
#import "cursorGeneration.gSemantics" ;
#import "enumGeneration.gSemantics" ;
#import "structGeneration.gSemantics" ;
#import "controllerClassGeneration.gSemantics" ;
#import "nibClassGeneration.gSemantics" ;

#----------------------------------------------------------------------------*

local filewrapper predefinedOutletClasses in "../generation-templates/predefined-outlet-classes" {
}{
}{
  template sourceFile "predefinedOutletClasses.easyBindings" ;
}

#----------------------------------------------------------------------------*

local filewrapper objective_c_sources in "../generation-templates/objective-c-sources" {
  "m", "h", "xib"
}{
}{
}

#----------------------------------------------------------------------------*

local routine enterPredefinedType
  ?!@astDeclarationList ioDeclarationList
  ??@string inTypeName
:
  ioDeclarationList += ![@predefinedTypeDeclaration new ![inTypeName nowhere]] ;
end routine ;

#----------------------------------------------------------------------------*

when . "easyBindings"
message "a source text file with the .easyBindings extension"
??@lstring inSourceFile {
#--- Parse predefined outlets
  @astDeclarationList declarationList [emptyList] ;

  @cursorList cursorList [emptyList] ;
  grammar easyBindings_grammar on [filewrapper predefinedOutletClasses.sourceFile]
    !?declarationList
    !?cursorList
    ?*
  ;
#--- Parse source file
  grammar easyBindings_grammar in inSourceFile
    !?declarationList
    !?cursorList
    ?@location endOfSourceFile
  ;
#--- Enter predefined types
   enterPredefinedType !?declarationList !"NSString" ;
   enterPredefinedType !?declarationList !"NSColor" ;
   enterPredefinedType !?declarationList !"NSData" ;
   enterPredefinedType !?declarationList !"NSDate" ;
   enterPredefinedType !?declarationList !"NSFont" ;
   enterPredefinedType !?declarationList !"NSImage" ;
   enterPredefinedType !?declarationList !"NSMenu" ;
   enterPredefinedType !?declarationList !"NSBezierPath" ;
   enterPredefinedType !?declarationList !"Integer" ;
   enterPredefinedType !?declarationList !"UInteger" ;
   enterPredefinedType !?declarationList !"Bool" ;
   enterPredefinedType !?declarationList !"Double" ;
   enterPredefinedType !?declarationList !"AnyScalar" ;
   enterPredefinedType !?declarationList !"AnyNumber" ;

#------------------------------------------------------- Type Inventory
   @unifiedTypeMap unifiedTypeMap [emptyMap] ;
#----
  foreach declarationList do
    [mDeclaration typeInventory !?unifiedTypeMap] ;
  end foreach ;
  if [option easyBindings_options.outputClassDependencyGraph value] then
    const @string s := [unifiedTypeMap edgeGraphvizRepresentation] ;
    const @string path := inSourceFile->string . ".classDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#------------------------------------------- Check all types are defined
  const @lstringlist unsolvedProxyList := [unifiedTypeMap unsolvedProxyList] ;
  foreach unsolvedProxyList do
    error mValue :"type " . mValue . " is undefined" ;
  end foreach ;
#------------------------------------------- Topological sort and continue
  if [unsolvedProxyList length] == 0 then
    [unifiedTypeMap topologicalSort ?@lstringlist sortedKeys ?@lstringlist unsortedKeys] ;
    if [unsortedKeys length] > 0 then
      @string s := "cannot sort types ; the following types are involved in circular dependence:" ;
      foreach unsortedKeys do
        s .= "\n-- " . mValue ;
      end foreach ;
      error here : s ;
    else
      semanticAnalysis !unifiedTypeMap !sortedKeys ;
    end if ;
  end if ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#   S E M A N T I C    A N A L Y S I S                                       *
#                                                                            *
#----------------------------------------------------------------------------*

routine semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstringlist inSortedKeys
:
#--- Semantic analysis
  foreach inSortedKeys do
    [inUnifiedTypeMap searchKey
      !mValue
      ?@astDeclaration declaration
    ] ;
  
  
  end foreach ;

end routine ;
##------------------------------------------------------- Semantic Analysis
#   @contextAnalysisStruct contextAnalysisStruct [default] ;
##--- Cursors
#  cursorAnalysis
#    !cursorList
#    !?contextAnalysisStruct
#    ?@stringlist predefinedCursorList
#  ;
##--- Enumerations
#  enumAnalysis
#    !enumList
#    !?contextAnalysisStruct
#  ;
##--- Struct analysis
#  structAnalysis
#    !structTypeList
#    !?contextAnalysisStruct
#  ;
##--- Protocol
#  @protocolMap protocolMap [emptyMap] ;
#  foreach protocolList do
#    [!?protocolMap insertKey !mProtocolName !mIsPredefined] ;
#  end foreach ;
##--- Outlet Classes
#  @stringlist sortedTransientOrderedList [emptyList] ;
#  @transientDependencyGraph transientDependencyGraph [emptyGraph] ;
#  analyzeOutletClasses
#    !outletClassList
#    !contextAnalysisStruct
#    !protocolMap
#    ?@outletClassMap outletClassMap
#  ;
##--- Controller classes
#  analyzeControllerClasses
#    !controllerClassList
#    !contextAnalysisStruct
#    !?transientDependencyGraph
#    ?@controllerClassMap controllerClassMap
#  ;
##--- Classes
#  analyzeClasses 
#    !classList
#    !contextAnalysisStruct
#    ?@classMap classMap
#    !?transientDependencyGraph
#  ;
##--- Preferences
#  analyzePreferences
#    !preferencesList
#    !controllerClassMap
#    !classMap
#    !outletClassMap
#    !contextAnalysisStruct
#    ?@preferencesMap preferencesMap
#    !?transientDependencyGraph
#  ;
##--- nib classes
#  analyzeNibClasses
#    !nibClassList
#    !controllerClassMap
#    !classMap
#    !outletClassMap
#    !contextAnalysisStruct
#    ?@nibClassMap nibClassMap
#    !preferencesMap
#    !?transientDependencyGraph
#  ;
##--- Entities
#  analyzeEntities
#    !entityList
#    !contextAnalysisStruct
#    ?@entityMap entityMap
#    ?@entityListForGeneration entityListForGeneration
#    !preferencesMap
#    !?transientDependencyGraph
#  ;
##--- Documents
#  analyzeDocuments
#    !documentDeclarationList
#    !outletClassMap
#    !controllerClassMap
#    !entityMap
#    !preferencesMap
#    !contextAnalysisStruct
#    ?@documentMap documentMap
#    !?transientDependencyGraph
#  ;
##--- Output graphviz file ?
#  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
#    const @string s := [transientDependencyGraph graphviz] ;
#    const @string path := inSourceFile->string . ".transientDependancyGraph.dot" ;
#    [s writeToFileWhenDifferentContents !path ?*] ;
#  end if ;
##--- Analyze transient dependencies
#  @2stringlist transientDependencyArcList := [transientDependencyGraph arcs] ;
#  if [@uint errorCount] == 0 then
#    if [transientDependencyGraph undefinedNodeCount] > 0 then
#      foreach [transientDependencyGraph undefinedNodeKeyList] do
#        error endOfSourceFile : "the '" . mValue . "' property is not defined" ;
#      end foreach ;
#    else
#      @stringlist unsortedTransientList ;
#      [transientDependencyGraph topologicalSort
#        ?sortedTransientOrderedList
#        ?*
#        ?unsortedTransientList
#        ?*
#      ] ;
#      if [unsortedTransientList length] > 0 then
#        @string s := [[unsortedTransientList length] string] . " transient declarations are involved in circular dependancies:" ;
#        foreach unsortedTransientList do
#          s .= "\n-  " . mValue ;
#        end foreach ;
#        error endOfSourceFile : s ;
#      else # all defined, no circularity
#      end if ;
#    end if ;
#  end if ;
##----------------------------------------------------- Code generation
#  const @string sourceDirectoryPath := [inSourceFile stringByDeletingLastPathComponent] ;
#  generateEnumerations !contextAnalysisStruct->mEnumMap !sourceDirectoryPath ;
#  generateStructures !contextAnalysisStruct->mStructTypeMap !sourceDirectoryPath ;
#  generateOutletClassCode !outletClassMap !sourceDirectoryPath ;
#  generateClassCode !transientDependencyArcList !classMap !sourceDirectoryPath ;
#  generateEntityCode !transientDependencyArcList !entityListForGeneration !sourceDirectoryPath ;
#  generatePreferencesCode !transientDependencyArcList !preferencesMap !sourceDirectoryPath ;
#  generateNibClassCode !transientDependencyArcList !nibClassMap !sourceDirectoryPath ;
#  generateDocumentCode !transientDependencyArcList !documentMap !sourceDirectoryPath ;
#  generateCursorCode !contextAnalysisStruct->mUserCursorMap !predefinedCursorList !sourceDirectoryPath ;
#  generateControllerCode !controllerClassMap !sourceDirectoryPath ;
##------------------------------ Output dependency order definition file
#  generateTransientDependencyFiles
#    !transientDependencyArcList
#    !sourceDirectoryPath
#    !sortedTransientOrderedList
#  ;
##--- Add embedded sources
#  @stringset generateSet [emptySet] ;
#  generateSet += !"easy-bindings-utilities" ;
#  generateSet += !"PMAllocationDebug" ;
#  if [documentMap count] > 0 then
#    generateSet += !"PMUndoManager" ;
#    generateSet += !"PMManagedDocument" ;
#    generateSet += !"NSData+BZ2compression" ;
#    generateSet += !"NSData+BZ2compression" ;
#    generateSet += !"NSData+PMGZcompression" ;
#    generateSet += !"NSMutableData+PMWrites" ;
#    generateSet += !"PMDataScanner" ;
#  end if ;
#  if [entityListForGeneration length] > 0 then
#    generateSet += !"load-store-functions" ;
#    generateSet += !"PMManagedEntity" ;
#    generateSet += !"PMEntityManager" ;
#    generateSet += !"PMAttributeDescription" ;
#    generateSet += !"PMRelationshipDescription" ;
#    generateSet += !"PMEntityArrayController" ;
#    generateSet += !"PMEntityController" ;
#  end if ;
##---
#  @filewrapper fw := [filewrapper objective_c_sources] ;
#  foreach [fw allTextFilePathes] do
#    const @string sourceName := [mValue lastPathComponent] ;
#    if [generateSet hasKey ![sourceName stringByDeletingPathExtension]] then
#      [@string generateFile
#        !sourceDirectoryPath . [mValue stringByDeletingLastPathComponent]
#        !sourceName
#        ![fw textFileContentsAtPath !mValue]
#       ] ;
#     end if ;
#  end foreach ;
#}

#----------------------------------------------------------------------------*

end program ;
