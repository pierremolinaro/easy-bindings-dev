program easyBindings_program :
import "decoratedTypes.gSemantics" ;
import "easyBindings_grammar.gGrammar" ;

import "cursorAnalysis.gSemantics" ;
import "cursorGeneration.gSemantics" ;
import "transientGeneration.gSemantics" ;
import "easyBindings_options.gOption" ;

#----------------------------------------------------------------------------*

local filewrapper predefinedOutletClasses in "../generation-templates/predefined-outlet-classes" {
}{
}{
  template sourceFile "predefinedOutletClasses.easyBindings" ;
}

#----------------------------------------------------------------------------*

local filewrapper objective_c_sources in "../generation-templates/objective-c-sources" {
  "m", "h", "xib", "swift"
}{
}{
}

#----------------------------------------------------------------------------*

when . "easyBindings"
message "a source text file with the .easyBindings extension"
??@lstring inSourceFile {
#--- Parse predefined outlets
  @astDeclarationList declarationList [emptyList] ;

  @cursorList cursorList [emptyList] ;
  grammar easyBindings_grammar on [filewrapper predefinedOutletClasses.sourceFile]
    !?declarationList
    !?cursorList
    ?*
  ;
#--- Parse source file
  grammar easyBindings_grammar in inSourceFile
    !?declarationList
    !?cursorList
    ?@location endOfSourceFile
  ;
#--- Enter predefined types
  declarationList += ![@predefinedTypeDeclaration new !"NSString" ![@typeKind stringType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"NSColor" ![@typeKind colorType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"NSData" ![@typeKind dataType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"NSDate" ![@typeKind dateType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"NSFont" ![@typeKind fontType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"NSImage" ![@typeKind imageType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"NSMenu" ![@typeKind menuType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"NSBezierPath" ![@typeKind bezierPathType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"Integer" ![@typeKind integerType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"UInteger" ![@typeKind uintegerType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"Bool" ![@typeKind boolType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"Double" ![@typeKind doubleType]] ;
  declarationList += ![@predefinedTypeDeclaration new !"enum" ![@typeKind enumType]] ;
#------------------------------------------------------- Type Inventory
   @unifiedTypeMap unifiedTypeMap [emptyMap] ;
#----
  foreach declarationList do
    [mDeclaration typeInventory !?unifiedTypeMap] ;
  end foreach ;
  if [option easyBindings_options.outputClassDependencyGraph value] then
    const @string s := [unifiedTypeMap edgeGraphvizRepresentation] ;
    const @string path := inSourceFile->string . ".classDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#------------------------------------------- Check all types are defined
  const @lstringlist unsolvedProxyList := [unifiedTypeMap unsolvedProxyList] ;
  foreach unsolvedProxyList do
    error mValue :"type " . mValue . " is undefined" ;
  end foreach ;
#------------------------------------------- Topological sort and continue
  if [unsolvedProxyList length] == 0 then
    [unifiedTypeMap topologicalSort ?@lstringlist sortedKeys ?@lstringlist unsortedKeys] ;
    if [unsortedKeys length] > 0 then
      @string s := "cannot sort types ; the following types are involved in circular dependence:" ;
      foreach unsortedKeys do
        s .= "\n-- " . mValue ;
      end foreach ;
      error here : s ;
    else
#      @string s := "Sorted types:" ;
#      foreach sortedKeys do
#        s .= "\n-- " . mValue ;
#      end foreach ;
#      message s ;
      semanticAnalysis
        !unifiedTypeMap
        !sortedKeys
        !inSourceFile->string
        !cursorList
        !endOfSourceFile
      ;
    end if ;
  end if ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#   S E M A N T I C    A N A L Y S I S                                       *
#                                                                            *
#----------------------------------------------------------------------------*

local routine semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstringlist inSortedKeys
  ??@string inSourceFile
  ??@cursorList inCursorList
  ??@location inEndOfSourceFile
:
  const @string outputDirectory := [inSourceFile stringByDeletingLastPathComponent] ;
#--- Build observable property map
  @observablePropertyMapMap observablePropertyMapMap [emptyMap] ;
  @transientDependencyGraph transientDependencyGraph [emptyGraph] ;
  foreach inSortedKeys do
    [inUnifiedTypeMap searchKey
      !mValue
      ?*
      ?@astDeclaration declaration
    ] ;
    [declaration buildObservablePropertyMap
      !inUnifiedTypeMap
      !?observablePropertyMapMap
      !?transientDependencyGraph
    ] ;
  end foreach ;
   @contextAnalysisStruct contextAnalysisStruct [default] ;
   contextAnalysisStruct->mObservablePropertyMapMap := observablePropertyMapMap ;
   contextAnalysisStruct->mTransientDependencyGraph := transientDependencyGraph ;
#--- Cursors
  cursorAnalysis
    !inCursorList
    !?contextAnalysisStruct
    ?@stringlist predefinedCursorList
  ;
#--- Semantic analysis
  @generationList generationList [emptyList] ;
  foreach inSortedKeys do
    [inUnifiedTypeMap searchKey
      !mValue
      ?*
      ?@astDeclaration declaration
    ] ;
    [declaration semanticAnalysis
      !inUnifiedTypeMap
      !?contextAnalysisStruct
      !?generationList
    ] ;
  end foreach ;
#------------------------------- Check relationships
  if [@uint errorCount] == 0 then
    foreach contextAnalysisStruct->mEntityMap do
      foreach mCurrentRelationshipMap do
        [contextAnalysisStruct->mEntityMap searchKey
          !mDestinationEntityName
          ?9*
          ?@relationshipMap destinationEntityRelationshipMap
          ?2*
        ] ;
        [destinationEntityRelationshipMap searchKey
          !mInverseRelationshipName
          ?2*
          ?@lstring inverseOfInverseRelationshipName
          ?@bool inverseIsToMany
          ?*
        ] ;
        if lkey->string != inverseOfInverseRelationshipName->string then
          error mInverseRelationshipName : "the inverse relationship does not name '" . lkey . "' relationship as inverse" ;
        end if ;
        if mIsToMany != inverseIsToMany then
          error mInverseRelationshipName : "the inverse relationship is " . if inverseIsToMany then "to many" else "to one" end ;
        end if ;
      end foreach ;
    end foreach ;
  end if ;
#--- Generation
  if [@uint errorCount] == 0 then
    foreach generationList do
      [mGeneration generate !outputDirectory] ;
    end foreach ;
    generateCursorCode
      !contextAnalysisStruct->mUserCursorMap
      !predefinedCursorList
      !outputDirectory
    ;
  end if ;
#--- Output graphviz file ?
  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
    const @string s := [contextAnalysisStruct->mTransientDependencyGraph graphviz] ;
    const @string path := inSourceFile . ".transientDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#--- Analyze transient dependencies
  @2stringlist transientDependencyArcList := [contextAnalysisStruct->mTransientDependencyGraph edges] ;
  @stringlist sortedTransientOrderedList [emptyList] ;
  if [@uint errorCount] == 0 then
    if [contextAnalysisStruct->mTransientDependencyGraph undefinedNodeCount] > 0 then
      foreach [contextAnalysisStruct->mTransientDependencyGraph undefinedNodeKeyList] do
        error inEndOfSourceFile : "the '" . mValue . "' property is not defined" ;
      end foreach ;
    else
      [contextAnalysisStruct->mTransientDependencyGraph topologicalSort
        ?sortedTransientOrderedList
        ?*
        ?@stringlist unsortedTransientList
        ?*
      ] ;
      if [unsortedTransientList length] > 0 then
        @string s := [[unsortedTransientList length] string] . " transient declarations are involved in circular dependancies:" ;
        foreach unsortedTransientList do
          s .= "\n-  " . mValue ;
        end foreach ;
        error inEndOfSourceFile : s ;
      else # all defined, no circularity
      end if ;
    end if ;
  end if ;
#------------------------------ Output dependency order definition file
  generateTransientDependencyFiles
    !transientDependencyArcList
    !outputDirectory
    !sortedTransientOrderedList
  ;
#--- Extensions
  @stringset extensionSet [setWithString !"xib"] ;
  if [option easyBindings_options.outputSwift value] then
    extensionSet += !"swift" ;
  else
    extensionSet += !"m" ;
    extensionSet += !"h" ;
  end if ;
#--- Add embedded sources
  @stringset generateSet [emptySet] ;
  generateSet += !"easy-bindings-utilities" ;
  generateSet += !"PMAllocationDebug" ;
  if contextAnalysisStruct->mContainsDocument then
    generateSet += !"PMUndoManager" ;
    generateSet += !"PMManagedDocument" ;
    generateSet += !"NSData+BZ2compression" ;
    generateSet += !"NSData+BZ2compression" ;
    generateSet += !"NSData+PMGZcompression" ;
    generateSet += !"NSMutableData+PMWrites" ;
    generateSet += !"PMDataScanner" ;
  end if ;
  if [contextAnalysisStruct->mEntityMap count] > 0 then
    generateSet += !"load-store-functions" ;
    generateSet += !"PMManagedEntity" ;
    generateSet += !"PMEntityManager" ;
    generateSet += !"PMAttributeDescription" ;
    generateSet += !"PMRelationshipDescription" ;
    generateSet += !"PMEntityArrayController" ;
    generateSet += !"PMEntityController" ;
  end if ;
#---
  @filewrapper fw := [filewrapper objective_c_sources] ;
  foreach [fw allTextFilePathes] do
    const @string sourceName := [mValue lastPathComponent] ;
    if [generateSet hasKey ![sourceName stringByDeletingPathExtension]] & [extensionSet hasKey ![sourceName pathExtension]] then
      [@string generateFile
        !outputDirectory . [mValue stringByDeletingLastPathComponent]
        !sourceName
        ![fw textFileContentsAtPath !mValue]
       ] ;
     end if ;
  end foreach ;
end routine ;

##------------------------------------------------------- Semantic Analysis
#   @contextAnalysisStruct contextAnalysisStruct [default] ;
##--- Enumerations
#  enumAnalysis
#    !enumList
#    !?contextAnalysisStruct
#  ;
##--- Struct analysis
#  structAnalysis
#    !structTypeList
#    !?contextAnalysisStruct
#  ;
##--- Protocol
#  @protocolMap protocolMap [emptyMap] ;
#  foreach protocolList do
#    [!?protocolMap insertKey !mProtocolName !mIsPredefined] ;
#  end foreach ;
##--- Outlet Classes
#  @stringlist sortedTransientOrderedList [emptyList] ;
#  @transientDependencyGraph transientDependencyGraph [emptyGraph] ;
#  analyzeOutletClasses
#    !outletClassList
#    !contextAnalysisStruct
#    !protocolMap
#    ?@outletClassMap outletClassMap
#  ;
##--- Controller classes
#  analyzeControllerClasses
#    !controllerClassList
#    !contextAnalysisStruct
#    !?transientDependencyGraph
#    ?@controllerClassMap controllerClassMap
#  ;
##--- Classes
#  analyzeClasses 
#    !classList
#    !contextAnalysisStruct
#    ?@classMap classMap
#    !?transientDependencyGraph
#  ;
##--- Preferences
#  analyzePreferences
#    !preferencesList
#    !controllerClassMap
#    !classMap
#    !outletClassMap
#    !contextAnalysisStruct
#    ?@preferencesMap preferencesMap
#    !?transientDependencyGraph
#  ;
##--- nib classes
#  analyzeNibClasses
#    !nibClassList
#    !controllerClassMap
#    !classMap
#    !outletClassMap
#    !contextAnalysisStruct
#    ?@nibClassMap nibClassMap
#    !preferencesMap
#    !?transientDependencyGraph
#  ;
##--- Entities
#  analyzeEntities
#    !entityList
#    !contextAnalysisStruct
#    ?@entityMap entityMap
#    ?@entityListForGeneration entityListForGeneration
#    !preferencesMap
#    !?transientDependencyGraph
#  ;
##--- Documents
#  analyzeDocuments
#    !documentDeclarationList
#    !outletClassMap
#    !controllerClassMap
#    !entityMap
#    !preferencesMap
#    !contextAnalysisStruct
#    ?@documentMap documentMap
#    !?transientDependencyGraph
#  ;
##--- Output graphviz file ?
#  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
#    const @string s := [transientDependencyGraph graphviz] ;
#    const @string path := inSourceFile->string . ".transientDependancyGraph.dot" ;
#    [s writeToFileWhenDifferentContents !path ?*] ;
#  end if ;
##--- Analyze transient dependencies
#  @2stringlist transientDependencyArcList := [transientDependencyGraph arcs] ;
#  if [@uint errorCount] == 0 then
#    if [transientDependencyGraph undefinedNodeCount] > 0 then
#      foreach [transientDependencyGraph undefinedNodeKeyList] do
#        error endOfSourceFile : "the '" . mValue . "' property is not defined" ;
#      end foreach ;
#    else
#      @stringlist unsortedTransientList ;
#      [transientDependencyGraph topologicalSort
#        ?sortedTransientOrderedList
#        ?*
#        ?unsortedTransientList
#        ?*
#      ] ;
#      if [unsortedTransientList length] > 0 then
#        @string s := [[unsortedTransientList length] string] . " transient declarations are involved in circular dependancies:" ;
#        foreach unsortedTransientList do
#          s .= "\n-  " . mValue ;
#        end foreach ;
#        error endOfSourceFile : s ;
#      else # all defined, no circularity
#      end if ;
#    end if ;
#  end if ;
##----------------------------------------------------- Code generation
#  const @string sourceDirectoryPath := [inSourceFile stringByDeletingLastPathComponent] ;
#  generateEnumerations !contextAnalysisStruct->mEnumMap !sourceDirectoryPath ;
#  generateStructures !contextAnalysisStruct->mStructTypeMap !sourceDirectoryPath ;
#  generateOutletClassCode !outletClassMap !sourceDirectoryPath ;
#  generateClassCode !transientDependencyArcList !classMap !sourceDirectoryPath ;
#  generateEntityCode !transientDependencyArcList !entityListForGeneration !sourceDirectoryPath ;
#  generatePreferencesCode !transientDependencyArcList !preferencesMap !sourceDirectoryPath ;
#  generateNibClassCode !transientDependencyArcList !nibClassMap !sourceDirectoryPath ;
#  generateDocumentCode !transientDependencyArcList !documentMap !sourceDirectoryPath ;
#  generateControllerCode !controllerClassMap !sourceDirectoryPath ;
##------------------------------ Output dependency order definition file
#  generateTransientDependencyFiles
#    !transientDependencyArcList
#    !sourceDirectoryPath
#    !sortedTransientOrderedList
#  ;
##--- Add embedded sources
#  @stringset generateSet [emptySet] ;
#  generateSet += !"easy-bindings-utilities" ;
#  generateSet += !"PMAllocationDebug" ;
#  if [documentMap count] > 0 then
#    generateSet += !"PMUndoManager" ;
#    generateSet += !"PMManagedDocument" ;
#    generateSet += !"NSData+BZ2compression" ;
#    generateSet += !"NSData+BZ2compression" ;
#    generateSet += !"NSData+PMGZcompression" ;
#    generateSet += !"NSMutableData+PMWrites" ;
#    generateSet += !"PMDataScanner" ;
#  end if ;
#  if [entityListForGeneration length] > 0 then
#    generateSet += !"load-store-functions" ;
#    generateSet += !"PMManagedEntity" ;
#    generateSet += !"PMEntityManager" ;
#    generateSet += !"PMAttributeDescription" ;
#    generateSet += !"PMRelationshipDescription" ;
#    generateSet += !"PMEntityArrayController" ;
#    generateSet += !"PMEntityController" ;
#  end if ;
##---
#  @filewrapper fw := [filewrapper objective_c_sources] ;
#  foreach [fw allTextFilePathes] do
#    const @string sourceName := [mValue lastPathComponent] ;
#    if [generateSet hasKey ![sourceName stringByDeletingPathExtension]] then
#      [@string generateFile
#        !sourceDirectoryPath . [mValue stringByDeletingLastPathComponent]
#        !sourceName
#        ![fw textFileContentsAtPath !mValue]
#       ] ;
#     end if ;
#  end foreach ;
#}

#----------------------------------------------------------------------------*

end program ;
