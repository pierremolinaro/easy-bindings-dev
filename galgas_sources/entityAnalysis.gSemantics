semantics entityAnalysis :
  import "transientAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*
#   ANALYZE ENTITIES                                                         *
#----------------------------------------------------------------------------*

local routine analyzeEntity
  ??@entityList.element inEntity
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  ?!@entityMap ioEntityMap
  ??@preferencesMap inPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#--------------------------------------------- Get super entity (if any)
  @observablePropertyMap observablePropertyMap ;
  @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
  @relationshipList allRelationshipList ;
  @string implementationSuperClassName ;
  @propertyMap allPropertyMap ;
  @relationshipMap allRelationshipMap ;
  if [inEntity->mSuperEntityName string] != "" then
    [ioEntityMap searchKey
      !inEntity->mSuperEntityName
      ?*
      ?implementationSuperClassName
      ?*
      ?observablePropertyMap
      ?propertyListForInitMethodHeader
      ?4*
      ?allRelationshipList
      ?allPropertyMap
      ?2*
      ?allRelationshipMap
      ?*
    ] ;
  else
    observablePropertyMap := [@observablePropertyMap emptyMap] ;
    propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
    implementationSuperClassName := "" ;
    allRelationshipList := [@relationshipList emptyList] ;
    allPropertyMap := [@propertyMap emptyMap] ;
    allRelationshipMap := [@relationshipMap emptyMap] ;
  end if ;
  @attributeListForImplementation attributeListForImplementation [emptyList] ;
  const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
#--------------------------------------- Analyze attributes
  @stringset headerFileInclusionSet [emptySet] ;
  foreach inEntity->mAttributeList do
    [mDefaultValue analyzeDefaultValueType
      ![@easyBindingTypeList listWithValue !mType]
      !inGlobalEnumConstantMap
      ?@string directDefaultValueAsString
      ?@string objectiveCDefaultValueAsString
    ] ;
    [mType addFileInclusion !?headerFileInclusionSet] ;
    [!?allPropertyMap insertKey !mAttributeName] ;
    attributeListForImplementation += !mType ![mAttributeName string] !objectiveCDefaultValueAsString !directDefaultValueAsString ;
    propertyListForInitMethodHeader += !mType ![mAttributeName string] !objectiveCDefaultValueAsString !directDefaultValueAsString ;
    const @lstring observationDependencyKey [new
      !"entity." . inEntity->mEntityName . "." . mAttributeName
      !mAttributeName->location
    ] ;
    [!?observablePropertyMap insertKey
      !mAttributeName
      !mType
      !false # is not transient
      !observationDependencyKey->string
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#---------------------------------------- Analyze relationship (only check name is unique)
  @relationshipMap currentRelationshipMap [emptyMap] ;
  foreach inEntity->mRelationshipList do
    [!?allRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !mDestinationEntityName
      !mInverseRelationshipName
      !mDeleteRule
    ] ;
    [!?currentRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !mDestinationEntityName
      !mInverseRelationshipName
      !mDeleteRule
    ] ;
    [!?allPropertyMap insertKey !mRelationshipName] ;
    const @lstring observationDependencyKey [new
      !"entity." . inEntity->mEntityName . "." . mRelationshipName
      !mRelationshipName->location
    ] ;
    [!?observablePropertyMap insertKey
      !mRelationshipName
      ![@toManyEntitiesType new !inEntity->mEntityName->string]
      !false # is not transient
      !observationDependencyKey->string
    ] ;    
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#----------------------------------------- Analyze transient properties
  @stringset implementationFileInclusionSet [emptySet] ;
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    !inPreferencesMap
    !"entity." . inEntity->mEntityName . "."
    !inEntity->mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !"" # No Root entity
    ![@controllerMap emptyMap]
    !?observablePropertyMap
    !?implementationFileInclusionSet
    ?transientListForImplementation
    !?ioTransientDependencyGraph
  ;
#----------------------------------------- Enter entity in entity map
  [!?implementationFileInclusionSet removeKey !""] ;
  [!?ioEntityMap insertKey
    !inEntity->mEntityName
    !inEntity->mSuperEntityName->string
    !inEntity->mImplementationClassName->string
    !implementationSuperClassName
    !observablePropertyMap
    !propertyListForInitMethodHeader
    !inheritedAttributeListForImplementation
    !attributeListForImplementation
    !transientListForImplementation
    !inEntity->mRelationshipList
    !allRelationshipList . inEntity->mRelationshipList
    !allPropertyMap
    !currentRelationshipMap
    !headerFileInclusionSet
    !allRelationshipMap
    !implementationFileInclusionSet
  ] ;
end routine ;

#----------------------------------------------------------------------------*

routine analyzeEntities
  ??@entityList inEntityList
  ??@globalEnumConstantMap inGlobalEnumConstantMap
  !@entityMap outEntityMap
  !@entityListForGeneration outEntityListForGeneration
  ??@preferencesMap inPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Analyze entities
  outEntityMap := [@entityMap emptyMap] ;
  for entity in inEntityList do
    analyzeEntity
      !entity
      !inGlobalEnumConstantMap
      !?outEntityMap
      !inPreferencesMap
      !?ioTransientDependencyGraph
    ;
  end for ;
#------------------------------- Check relationships
  foreach outEntityMap do
    foreach mCurrentRelationshipMap do
      @relationshipMap destinationEntityRelationshipMap ;
      [outEntityMap searchKey !mDestinationEntityName ?13* ?destinationEntityRelationshipMap ?*] ;
      @lstring inverseOfInverseRelationshipName ;
      [destinationEntityRelationshipMap searchKey !mInverseRelationshipName ?2* ?inverseOfInverseRelationshipName ?*] ;
      if lkey->string != inverseOfInverseRelationshipName->string then
        error mInverseRelationshipName : "the inverse relationship does not name '" . lkey . "' relationship as inverse" ;
      end if ;
    end foreach ;
  end foreach ;
#------------------------------- Generation List
  outEntityListForGeneration := [@entityListForGeneration emptyList] ;
  foreach outEntityMap do
    @2stringlist toManyRelationshipList [emptyList] ;
    @2stringlist toOneRelationshipList [emptyList] ;
    @stringset headerFileInclusionSet := mHeaderFileInclusionSet ;
    @stringset headerFilePredeclarationSet [emptySet] ;
    @stringset implementationFileInclusionSet := mImplementationFileInclusionSet ;
    foreach mCurrentRelationshipMap do
      if mIsToMany then
        toManyRelationshipList += !lkey->string !mDestinationEntityName->string ;
      else
        [outEntityMap searchKey !mDestinationEntityName ?* ?@string implementationClassName ?13*] ;
        toOneRelationshipList += !lkey->string !implementationClassName ;
        headerFilePredeclarationSet += !implementationClassName ;
        implementationFileInclusionSet += !implementationClassName ;
      end if ;
    end foreach ;
    outEntityListForGeneration +=
      !lkey->string
      !mSuperEntityName
      !mImplementationClassName
      !mSuperImplementationClassName
      !mObservablePropertyMap
      !mAttributeListForInitMethodHeader
      !mInheritedAttributeListForImplementation
      !mAttributeListForImplementation
      !mTransientListForImplementation
      !mCurrentRelationshipList
      !mAllRelationshipList
      !mAllPropertyMap
      !mCurrentRelationshipMap
      !mAllRelationshipMap
      !headerFilePredeclarationSet
      !toManyRelationshipList
      !headerFileInclusionSet
      !implementationFileInclusionSet
      !toOneRelationshipList
    ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
