semantics entityAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "transientAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*
#   ANALYZE ENTITIES                                                         *
#----------------------------------------------------------------------------*

override method @entityDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#--------------------------------------------- Get super entity (if any)
  @unifiedTypeProxy superClassProxy ;
  if mSuperEntityName->string == "" then
    superClassProxy := [@unifiedTypeProxy null] ;
  else
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mSuperEntityName
      ?superClassProxy
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mEntityName !mSuperEntityName] ;
  end if ;
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mEntityName !mAttributeTypeName] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#---------------------------------------- Analyze relationship (only check name is unique)
  foreach mRelationshipList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mDestinationEntityName
      ?*
    ] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !mEntityName
    ![@ebType new !mEntityName ![@typeKind entityType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @entityDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Super entity ?
  @observablePropertyMap observablePropertyMap ;
  if [mSuperEntityName string] != "" then
    [ioObservablePropertyMapMap searchKey
       !mSuperEntityName
       ?@typeKind kind
       ?observablePropertyMap
     ] ;
     if kind != [@typeKind entityType] then
       error mSuperEntityName : "'" . mSuperEntityName . "' is not an entity" ;
     end if ;
  else
    observablePropertyMap := [@observablePropertyMap emptyMap] ;
  end if ;
#---------------------------------- Attributes, transients
  buildObservablePropertyMap
    !mAttributeList
    ![@classArrayList emptyList]
    !mTransientList
    ![@controllerList emptyList]
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"entity." . mEntityName
    !?observablePropertyMap
  ;
#---------------------------------- Relationships
  foreach mRelationshipList do
    const observationDependencyKey := [@lstring new
      !"entity." . mEntityName . "." . mRelationshipName
      !mRelationshipName->location
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
    [inUnifiedTypeMap searchKey !mDestinationEntityName ?@ebType type ?*] ;
    [!?observablePropertyMap insertKey
      !mRelationshipName
      !type
      !false # is not transient
      !observationDependencyKey
      !mIsToMany
    ] ;
  end foreach ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mEntityName
    ![@typeKind entityType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @entityDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#------------------------------- Get Observable property map
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
     !mEntityName
     ?*
     ?@observablePropertyMap selfObservablePropertyMap
   ] ;
#--------------------------------------------- Get super entity (if any)
  @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
  @relationshipList allRelationshipList ;
  @propertyMap allPropertyMap ;
  @relationshipMap allRelationshipMap ;
  if [mSuperEntityName string] != "" then
    [ioContextAnalysisStruct->mEntityMap searchKey
      !mSuperEntityName
      ?*
      ?propertyListForInitMethodHeader
      ?4*
      ?allRelationshipList
      ?allPropertyMap
      ?*
      ?allRelationshipMap
      ?2*
    ] ;
  else
    propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
    allRelationshipList := [@relationshipList emptyList] ;
    allPropertyMap := [@propertyMap emptyMap] ;
    allRelationshipMap := [@relationshipMap emptyMap] ;
  end if ;
  const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
#--------------------------------------- Analyze attributes
  @fileInclusionSet fileInclusionSet [default] ;
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?propertyListForInitMethodHeader
  ;
#---------------------------------------- Analyze relationship (only check name is unique)
  @2stringlist toManyRelationshipList [emptyList] ;
  @2stringlist toOneRelationshipList [emptyList] ;
  @relationshipMap currentRelationshipMap [emptyMap] ;
  foreach mRelationshipList do
    [!?allRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !mDestinationEntityName
      !mInverseRelationshipName
      !mInverseRelationIsToMany
      !mDeleteRule
    ] ;
    [!?currentRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !mDestinationEntityName
      !mInverseRelationshipName
      !mInverseRelationIsToMany
      !mDeleteRule
    ] ;
    [!?allPropertyMap insertKey !mRelationshipName] ;
    fileInclusionSet->mHeaderPredeclarationSet += !mDestinationEntityName->string ;
    fileInclusionSet->mImplementationFileInclusionSet += !mDestinationEntityName->string ;
    if mIsToMany then
      toManyRelationshipList += !mRelationshipName->string !mDestinationEntityName->string ;
    else
      toOneRelationshipList += !mRelationshipName->string !mDestinationEntityName->string ;
    end if ;
  end foreach ;
#---------------------------------------- Analyze sign list
  @signListForGeneration signList [emptyList] ;
  foreach mSignList do
    [selfObservablePropertyMap searchKey
      !mValue
      ?@ebType type
      ?* # Transient ?
      ?@lstring dependancyKey
      ?@bool isToMany
    ] ;
    signList += !mValue->string !type !isToMany ;
  end foreach ;
  if [mSignList length] > 0 then
    const @string key := "entity." . mEntityName . ".sign" ;
    [!?ioContextAnalysisStruct->mTransientDependencyGraph addNode
      ![@lstring new !key !mEntityName->location]
      !key
    ] ;
  end if ;
#---------------------------------------- Analyze transient properties
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    !mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !?ioContextAnalysisStruct
    !"" # No Root entity
    !selfObservablePropertyMap
    !?fileInclusionSet
    ?transientListForImplementation
  ;
#----------------------------------------- Enter entity in entity map
  [!?ioContextAnalysisStruct->mEntityMap insertKey
    !mEntityName
    !mSuperEntityName->string
    !propertyListForInitMethodHeader
    !inheritedAttributeListForImplementation
    !attributeListForImplementation
    !transientListForImplementation
    !mRelationshipList
    !allRelationshipList . mRelationshipList
    !allPropertyMap
    !currentRelationshipMap
    !allRelationshipMap
    !fileInclusionSet
    !signList
  ] ;
#----------------------------------------- Generation

#  @string mSuperEntityName ;
#  @attributeListForImplementation mAttributeListForInitMethodHeader ;
#  @attributeListForImplementation mInheritedAttributeListForImplementation ;
#  @attributeListForImplementation mAttributeListForImplementation ;
#  @transientListForImplementation mTransientListForImplementation ;
#  @relationshipList mCurrentRelationshipList ;
#  @fileInclusionSet mFileInclusionSet ;
#  @signListForGeneration mSignList ;
#  @2stringlist mToManyRelationshipList ;
#  @2stringlist mToOneRelationshipList ;

  ioGenerationList += ![@entityGeneration new
    !mEntityName->string
    !mSuperEntityName->string
    !propertyListForInitMethodHeader
    !inheritedAttributeListForImplementation
    !attributeListForImplementation
    !transientListForImplementation
    !mRelationshipList
    !fileInclusionSet
    !signList
    !toManyRelationshipList
    !toOneRelationshipList
  ] ;
end method ;

#----------------------------------------------------------------------------*
#   ANALYZE ENTITIES                                                         *
#----------------------------------------------------------------------------*

#local routine analyzeEntity
#  ??@entityList.element inEntity
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  ?!@entityMap ioEntityMap
#  ??@preferencesMap inPreferencesMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
##--------------------------------------------- Get super entity (if any)
#  @observablePropertyMap observablePropertyMap ;
#  @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
#  @relationshipList allRelationshipList ;
#  @propertyMap allPropertyMap ;
#  @relationshipMap allRelationshipMap ;
#  if [inEntity->mSuperEntityName string] != "" then
#    [ioEntityMap searchKey
#      !inEntity->mSuperEntityName
#      ?*
#      ?observablePropertyMap
#      ?propertyListForInitMethodHeader
#      ?4*
#      ?allRelationshipList
#      ?allPropertyMap
#      ?*
#      ?allRelationshipMap
#      ?2*
#    ] ;
#  else
#    observablePropertyMap := [@observablePropertyMap emptyMap] ;
#    propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
#    allRelationshipList := [@relationshipList emptyList] ;
#    allPropertyMap := [@propertyMap emptyMap] ;
#    allRelationshipMap := [@relationshipMap emptyMap] ;
#  end if ;
#  @attributeListForImplementation attributeListForImplementation [emptyList] ;
#  const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
##--------------------------------------- Analyze attributes
#  @fileInclusionSet fileInclusionSet [new ![@stringset emptySet] ![@stringset emptySet] ![@stringset emptySet]] ;
#  foreach inEntity->mAttributeList do
#    @easyBindingType type := [mType analyze !inContextAnalysisStruct] ;
#    [mDefaultValue analyzeDefaultValueType
#      ![@easyBindingTypeList listWithValue !type]
#      !inContextAnalysisStruct
#      ?@string directDefaultValueAsString
#      ?@string objectiveCDefaultValueAsString
#      !?fileInclusionSet
#    ] ;
##    [mType addFileInclusion !?fileInclusionSet] ;
#    [!?allPropertyMap insertKey !mAttributeName] ;
#    attributeListForImplementation += !type ![mAttributeName string] !objectiveCDefaultValueAsString !directDefaultValueAsString ;
#    propertyListForInitMethodHeader += !type ![mAttributeName string] !objectiveCDefaultValueAsString !directDefaultValueAsString ;
#    const @lstring observationDependencyKey [new
#      !"entity." . inEntity->mEntityName . "." . mAttributeName
#      !mAttributeName->location
#    ] ;
#    [!?observablePropertyMap insertKey
#      !mAttributeName
#      !type
#      !false # is not transient
#      !observationDependencyKey->string
#    ] ;
#    [!?ioTransientDependencyGraph addNode
#      !observationDependencyKey
#      !observationDependencyKey->string
#    ] ;
#  end foreach ;
##---------------------------------------- Analyze relationship (only check name is unique)
#  @relationshipMap currentRelationshipMap [emptyMap] ;
#  foreach inEntity->mRelationshipList do
#    [!?allRelationshipMap insertKey
#      !mRelationshipName
#      !mIsToMany
#      !mDestinationEntityName
#      !mInverseRelationshipName
#      !mInverseRelationIsToMany
#      !mDeleteRule
#    ] ;
#    [!?currentRelationshipMap insertKey
#      !mRelationshipName
#      !mIsToMany
#      !mDestinationEntityName
#      !mInverseRelationshipName
#      !mInverseRelationIsToMany
#      !mDeleteRule
#    ] ;
#    [!?allPropertyMap insertKey !mRelationshipName] ;
#    const @lstring observationDependencyKey [new
#      !"entity." . inEntity->mEntityName . "." . mRelationshipName
#      !mRelationshipName->location
#    ] ;
#    @easyBindingType type ;
#    if mIsToMany then 
#      type := [@toManyEntitiesType new !mDestinationEntityName->string] ;
#    else
#      type := [@toOneEntityType new !mDestinationEntityName->string] ;
#    end if ;
#    [!?observablePropertyMap insertKey
#      !mRelationshipName
#      !type
#      !false # is not transient
#      !observationDependencyKey->string
#    ] ;    
#    [!?ioTransientDependencyGraph addNode
#      !observationDependencyKey
#      !observationDependencyKey->string
#    ] ;
#  end foreach ;
##---------------------------------------- Analyze sign list
#  @signListForGeneration signList [emptyList] ;
#  foreach inEntity->mSignList do
#    [observablePropertyMap searchKey
#      !mValue
#      ?@easyBindingType type
#      ?* # Transient ?
#      ?@string dependancyKey
#    ] ;
#    signList += !mValue->string !type ;
#  end foreach ;
#  if [inEntity->mSignList length] > 0 then
#    const @string key := "entity." . inEntity->mEntityName . ".sign" ;
#    [!?ioTransientDependencyGraph addNode
#      ![@lstring new !key !inEntity->mEntityName->location]
#      !key
#    ] ;
#  end if ;
##---------------------------------------- Analyze transient properties
#  @transientListForImplementation transientListForImplementation ;
#  analyzeTransientProperties
#    !inPreferencesMap
#    !"entity." . inEntity->mEntityName . "."
#    !inEntity->mTransientList
#    ![@observablePropertyMap emptyMap] # Root property map
#    !inContextAnalysisStruct
#    !"" # No Root entity
#    ![@controllerMap emptyMap]
#    !?observablePropertyMap
#    !?fileInclusionSet
#    ?transientListForImplementation
#    !?ioTransientDependencyGraph
#  ;
##----------------------------------------- Enter entity in entity map
#  [!?fileInclusionSet->mImplementationFileInclusionSet removeKey !""] ;
#  [!?ioEntityMap insertKey
#    !inEntity->mEntityName
#    !inEntity->mSuperEntityName->string
#    !observablePropertyMap
#    !propertyListForInitMethodHeader
#    !inheritedAttributeListForImplementation
#    !attributeListForImplementation
#    !transientListForImplementation
#    !inEntity->mRelationshipList
#    !allRelationshipList . inEntity->mRelationshipList
#    !allPropertyMap
#    !currentRelationshipMap
#    !allRelationshipMap
#    !fileInclusionSet
#    !signList
#  ] ;
#end routine ;

#----------------------------------------------------------------------------*

#routine analyzeEntities
#  ??@entityList inEntityList
#  ??@contextAnalysisStruct inContextAnalysisStruct
#  !@entityMap outEntityMap
#  !@entityListForGeneration outEntityListForGeneration
#  ??@preferencesMap inPreferencesMap
#  ?!@transientDependencyGraph ioTransientDependencyGraph
#:
##------------------------------- Analyze entities
#  outEntityMap := [@entityMap emptyMap] ;
#  for entity in inEntityList do
#    analyzeEntity
#      !entity
#      !inContextAnalysisStruct
#      !?outEntityMap
#      !inPreferencesMap
#      !?ioTransientDependencyGraph
#    ;
#  end for ;
##------------------------------- Check relationships
#  foreach outEntityMap do
#    foreach mCurrentRelationshipMap do
#      [outEntityMap searchKey
#        !mDestinationEntityName
#        ?10*
#        ?@relationshipMap destinationEntityRelationshipMap
#        ?2*
#      ] ;
#      [destinationEntityRelationshipMap searchKey
#        !mInverseRelationshipName
#        ?2*
#        ?@lstring inverseOfInverseRelationshipName
#        ?@bool inverseIsToMany
#        ?*
#      ] ;
#      if lkey->string != inverseOfInverseRelationshipName->string then
#        error mInverseRelationshipName : "the inverse relationship does not name '" . lkey . "' relationship as inverse" ;
#      end if ;
#      if mIsToMany != inverseIsToMany then
#        error mInverseRelationshipName : "the inverse relationship is " . if inverseIsToMany then "to many" else "to one" end ;
#      end if ;
#    end foreach ;
#  end foreach ;
##------------------------------- Generation List
#  outEntityListForGeneration := [@entityListForGeneration emptyList] ;
#  foreach outEntityMap do
#    @2stringlist toManyRelationshipList [emptyList] ;
#    @2stringlist toOneRelationshipList [emptyList] ;
#    @fileInclusionSet fileInclusionSet := mFileInclusionSet ;
#    foreach mCurrentRelationshipMap do
#      if mIsToMany then
#        toManyRelationshipList += !lkey->string !mDestinationEntityName->string ;
#        fileInclusionSet->mHeaderPredeclarationSet += !mDestinationEntityName->string ;
#        fileInclusionSet->mImplementationFileInclusionSet += !mDestinationEntityName->string ;
#      else
#        toOneRelationshipList += !lkey->string !mDestinationEntityName->string ;
#        fileInclusionSet->mHeaderPredeclarationSet += !mDestinationEntityName->string ;
#        fileInclusionSet->mImplementationFileInclusionSet += !mDestinationEntityName->string ;
#      end if ;
#    end foreach ;
#    outEntityListForGeneration +=
#      !lkey->string
#      !mSuperEntityName
#      !mObservablePropertyMap
#      !mAttributeListForInitMethodHeader
#      !mInheritedAttributeListForImplementation
#      !mAttributeListForImplementation
#      !mTransientListForImplementation
#      !mCurrentRelationshipList
#      !mAllRelationshipList
#      !mAllPropertyMap
#      !mCurrentRelationshipMap
#      !mAllRelationshipMap
#      !toManyRelationshipList
#      !fileInclusionSet
#      !toOneRelationshipList
#      !mSignList
#    ;
#  end foreach ;
#end routine ;

#----------------------------------------------------------------------------*

end semantics ;
