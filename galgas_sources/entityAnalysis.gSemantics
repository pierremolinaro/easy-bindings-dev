semantics entityAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "transientAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*
#   ANALYZE ENTITIES                                                         *
#----------------------------------------------------------------------------*

override method @entityDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
:
#--------------------------------------------- Get super entity (if any)
  @unifiedTypeProxy superClassProxy ;
  if mSuperEntityName->string == "" then
    superClassProxy := [@unifiedTypeProxy null] ;
  else
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mSuperEntityName
      ?superClassProxy
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mEntityName !mSuperEntityName] ;
  end if ;
#---------------------------------- Analyze attributes
  foreach mAttributeList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?*
    ] ;
    [!?ioUnifiedTypeMap enterEdge !mEntityName !mAttributeTypeName] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  foreach mTransientList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?*
    ] ;
  end foreach ;
#---------------------------------------- Analyze relationship (only check name is unique)
  foreach mRelationshipList do
    [@unifiedTypeProxy makeProxy
      !?ioUnifiedTypeMap
      !mDestinationEntityName
      ?*
    ] ;
  end foreach ;
#----------------------------------
  [!?ioUnifiedTypeMap insertKey
    !mEntityName
    ![@ebType new !mEntityName ![@typeKind entityType]]
    !selfcopy
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @entityDeclaration buildObservablePropertyMap
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMapMap ioObservablePropertyMapMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Super entity ?
  @observablePropertyMap observablePropertyMap ;
  if [mSuperEntityName string] != "" then
    [ioObservablePropertyMapMap searchKey
       !mSuperEntityName
       ?@typeKind kind
       ?observablePropertyMap
     ] ;
     if kind != [@typeKind entityType] then
       error mSuperEntityName : "'" . mSuperEntityName . "' is not an entity" ;
     end if ;
  else
    observablePropertyMap := [@observablePropertyMap emptyMap] ;
  end if ;
#---------------------------------- Attributes, transients
  buildObservablePropertyMap
    !mAttributeList
    ![@classArrayList emptyList]
    !mTransientList
    ![@controllerList emptyList]
    ![@controllerObservablePropertyList emptyList]
    !?ioObservablePropertyMapMap
    !?ioTransientDependencyGraph
    !inUnifiedTypeMap
    !"entity." . mEntityName
    !?observablePropertyMap
  ;
#---------------------------------- Relationships
  foreach mRelationshipList do
    const observationDependencyKey := [@lstring new
      !"entity." . mEntityName . "." . mRelationshipName
      !mRelationshipName->location
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
    [inUnifiedTypeMap searchKey !mDestinationEntityName ?@ebType type ?*] ;
    [!?observablePropertyMap insertKey
      !mRelationshipName
      !type
      !false # is not transient
      !observationDependencyKey
      !mIsToMany
    ] ;
  end foreach ;
#---------------------------------- Enter class in observable map
  [!?ioObservablePropertyMapMap insertKey
    !mEntityName
    ![@typeKind entityType]
    !observablePropertyMap
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @entityDeclaration semanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ?!@contextAnalysisStruct ioContextAnalysisStruct
  ?!@generationList ioGenerationList
:
#------------------------------- Get Observable property map
  [ioContextAnalysisStruct->mObservablePropertyMapMap searchKey
     !mEntityName
     ?*
     ?@observablePropertyMap selfObservablePropertyMap
   ] ;
#--------------------------------------------- Get super entity (if any)
  @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
  @relationshipList allRelationshipList ;
  @propertyMap allPropertyMap ;
  @relationshipMap allRelationshipMap ;
  if [mSuperEntityName string] != "" then
    [ioContextAnalysisStruct->mEntityMap searchKey
      !mSuperEntityName
      ?*
      ?propertyListForInitMethodHeader
      ?4*
      ?allRelationshipList
      ?allPropertyMap
      ?*
      ?allRelationshipMap
      ?2*
    ] ;
  else
    propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
    allRelationshipList := [@relationshipList emptyList] ;
    allPropertyMap := [@propertyMap emptyMap] ;
    allRelationshipMap := [@relationshipMap emptyMap] ;
  end if ;
  const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
#--------------------------------------- Analyze attributes
  @fileInclusionSet fileInclusionSet [default] ;
  analyzeAttributeDeclaration
    !mAttributeList
    !?ioContextAnalysisStruct
    !inUnifiedTypeMap
    !?fileInclusionSet
    ?@attributeListForImplementation attributeListForImplementation
    !?propertyListForInitMethodHeader
  ;
#---------------------------------------- Analyze relationship (only check name is unique)
  @2stringlist toManyRelationshipList [emptyList] ;
  @2stringlist toOneRelationshipList [emptyList] ;
  @relationshipMap currentRelationshipMap [emptyMap] ;
  foreach mRelationshipList do
    [!?allRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !mDestinationEntityName
      !mInverseRelationshipName
      !mInverseRelationIsToMany
      !mDeleteRule
    ] ;
    [!?currentRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !mDestinationEntityName
      !mInverseRelationshipName
      !mInverseRelationIsToMany
      !mDeleteRule
    ] ;
    [!?allPropertyMap insertKey !mRelationshipName] ;
    fileInclusionSet->mHeaderPredeclarationSet += !mDestinationEntityName->string ;
    fileInclusionSet->mImplementationFileInclusionSet += !mDestinationEntityName->string ;
    if mIsToMany then
      toManyRelationshipList += !mRelationshipName->string !mDestinationEntityName->string ;
    else
      toOneRelationshipList += !mRelationshipName->string !mDestinationEntityName->string ;
    end if ;
  end foreach ;
#---------------------------------------- Analyze sign list
  @signListForGeneration signList [emptyList] ;
  foreach mSignList do
    [selfObservablePropertyMap searchKey
      !mValue
      ?@ebType type
      ?* # Transient ?
      ?@lstring dependancyKey
      ?@bool isToMany
    ] ;
    signList += !mValue->string !type !isToMany ;
  end foreach ;
  if [mSignList length] > 0 then
    const @string key := "entity." . mEntityName . ".sign" ;
    [!?ioContextAnalysisStruct->mTransientDependencyGraph addNode
      ![@lstring new !key !mEntityName->location]
      !key
    ] ;
  end if ;
#---------------------------------------- Analyze transient properties
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    !mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !?ioContextAnalysisStruct
    !"" # No Root entity
    !selfObservablePropertyMap
    !?fileInclusionSet
    ?transientListForImplementation
  ;
#----------------------------------------- Enter entity in entity map
  [!?ioContextAnalysisStruct->mEntityMap insertKey
    !mEntityName
    !mSuperEntityName->string
    !propertyListForInitMethodHeader
    !inheritedAttributeListForImplementation
    !attributeListForImplementation
    !transientListForImplementation
    !mRelationshipList
    !allRelationshipList + mRelationshipList
    !allPropertyMap
    !currentRelationshipMap
    !allRelationshipMap
    !fileInclusionSet
    !signList
  ] ;
#----------------------------------------- Generation
  ioGenerationList += ![@entityGeneration new
    !mEntityName->string
    !mSuperEntityName->string
    !propertyListForInitMethodHeader
    !inheritedAttributeListForImplementation
    !attributeListForImplementation
    !transientListForImplementation
    !mRelationshipList
    !fileInclusionSet
    !signList
    !toManyRelationshipList
    !toOneRelationshipList
  ] ;
end method ;

#----------------------------------------------------------------------------*

end semantics ;
