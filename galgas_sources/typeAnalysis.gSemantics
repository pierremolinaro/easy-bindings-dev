semantics typeAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;
  import "preferencesGeneration.gSemantics" ;
import "controllerClassAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

struct @structForGeneration{
  @transientListForGeneration mTransientListForGeneration ;
  @actionListForGeneration mActionListForGeneration ;
  @preferenceListForGeneration mPreferenceListForGeneration ;
  @stringset mNeededOutletClasses ;
  @string mControllerGenerationString ;
}
#----------------------------------------------------------------------------*

routine typeAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@outletClassMap inOutletClassMap
  ??@templateControllerMap inTemplateControllerMap
  !@structForGeneration outGeneration
:
  outGeneration := [@structForGeneration default] ;
  for (@lstring lkey
       @typeKind typeKind
       @unifiedTypeProxy superType
       @unifiedTypeProxy rootEntityType
       @decoratedAttributeMap decoratedAttributeMap
       @decoratedTransientMap decoratedTransientMap
       @decoratedOutletMap decoratedOutletMap
       @decoratedObservablePropertyMap observablePropertyMap
       @decoratedEntityRelationshipMap currentRelationshipMap
       @actionMap actionMap
       @bindingList bindingList) in inUnifiedTypeMap do
   #--- Build all observable property map
      @decoratedObservablePropertyMap allObservableProperties := observablePropertyMap ;
      var t := superType ;
      loop [inUnifiedTypeMap count] : while not [t isNull] do
        for () super_ in [t mObservablePropertyMap] do
          [!?allObservableProperties insertKey
            !super_lkey
            !super_mPropertyType
            !super_mIsTransient
            !super_mPropertySignature
            !super_mIsCollection
         ] ;
        end for ;
        t := [t mSuperType] ;
      end loop ; 
    unifiedTypeAnalysis
      !inUnifiedTypeMap
      !inOutletClassMap
      !inTemplateControllerMap
      !lkey
      !typeKind
      !superType
      !rootEntityType
      !decoratedAttributeMap
      !decoratedTransientMap
      !decoratedOutletMap
      !observablePropertyMap
      !currentRelationshipMap
      !allObservableProperties
      !actionMap
      !bindingList
      !?outGeneration
    ;  
  end for ;
end routine ;

#----------------------------------------------------------------------------*

local routine unifiedTypeAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@outletClassMap inOutletClassMap
  ??@templateControllerMap inTemplateControllerMap
  ??@lstring inTypeName
  ??@typeKind inTypeKind
  ??@unifiedTypeProxy unused superType
  ??@unifiedTypeProxy inRootEntityType
  ??@decoratedAttributeMap decoratedAttributeMap
  ??@decoratedTransientMap decoratedTransientMap
  ??@decoratedOutletMap decoratedOutletMap
  ??@decoratedObservablePropertyMap inCurrentObservablePropertyMap
  ??@decoratedEntityRelationshipMap unused currentRelationshipMap
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ??@actionMap inActionMap
  ??@bindingList inBindingList
  ?!@structForGeneration ioGeneration
:
#--- Analyze transient dependancies
  for () in decoratedTransientMap do
    @transientDependencyListForGeneration transientDependencyListForGeneration := {} ;
    for () in mDependencyList do
      if not [[mTransientType mTypeKind] suitableForObservableProperty] then
        error lkey : "the '" . [mTransientType key] . "' type is not acceptable for transient" ;
      end if ;
      [mDependency transientDependencySemanticAnalysis
        !inUnifiedTypeMap
        !lkey
        !inAllObservablePropertyMap
        !inRootEntityType
        !mTransientSignature
        !?transientDependencyListForGeneration
      ] ;
    end for ;
    ioGeneration->mTransientListForGeneration += !mTransientSignature->string !mTransientType !transientDependencyListForGeneration ;  
  end for ;
#--- Check outlet types are declared
  for () in decoratedOutletMap do
    [inOutletClassMap searchKey !mOutletTypeName] ;
    ioGeneration->mNeededOutletClasses += !mOutletTypeName->string ;
  end for ;
#--- Analyze attribute default value
  @attributeListForGeneration attributeListForGeneration := {} ;
  for () in decoratedAttributeMap do
    [mDefaultValue analyzeDefaultValueType 
      !{!mAttributeType}
      ??@string swiftDefaultValueAsString
    ] ;
    attributeListForGeneration += !mAttributeType !lkey->string !swiftDefaultValueAsString ;
  end for ;
#--- Analyze bindings
  @stringlist controllerInstanciationStringList := {} ;
  for () in inBindingList do
    [inCurrentObservablePropertyMap searchKey
      !mObservablePropertyName
      ??@unifiedTypeProxy propertyType
      ??@bool isTransient
      ??@lstring propertySignature
      ??@bool isCollection
    ] ;
    if isCollection then
      error mObservablePropertyName : "the observable property should not be a collection" ;
    end if ;
    [decoratedOutletMap searchKey !mOutletName ??@lstring outletTypeName] ;
    const controllerTemplateName := [@lstring new !outletTypeName->string + "." + mBindingName !mBindingName->location] ;
    [inTemplateControllerMap searchKey !controllerTemplateName ??@string templateString ??@unifiedTypeProxy modelTypeProxy] ;
    if [modelTypeProxy key] != [propertyType key] then
      error mBindingName : "the type of the observable property is '" + [propertyType key] + "', but this binding requires the '" + [modelTypeProxy key] + "' type" ;    
    end if ;
  #--- Build controller string
    const controllerString := [
      [templateString stringByReplacingStringByString !"$MODEL$" !mObservablePropertyName->string] stringByReplacingStringByString !"$OBJECTCLASS$" !inTypeName->string
    ] ;
    ioGeneration->mControllerGenerationString += "//---------------------------------------------------------------------------------------------------------------------*\n" ;
    ioGeneration->mControllerGenerationString += "//   Controller " + [inTypeName->string + " " + mObservablePropertyName + " - " + outletTypeName + " $" + mBindingName stringByRightPadding !103 !' '] + "*\n" ;
    ioGeneration->mControllerGenerationString += "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
    ioGeneration->mControllerGenerationString += controllerString ;
  #--- Build controller instanciation string
    const controllerInstanciationString := "Controller_" + inTypeName + "_" + mObservablePropertyName + "_" + outletTypeName + "_" + mBindingName
       + " (object:self, outlet:" + mOutletName + ", file:__FILE__, line:__LINE__, sendContinously:false)" ;
  end for ;
#--- Build action list
  for () action_ in inActionMap do
    ioGeneration->mActionListForGeneration += !inTypeName->string !action_lkey->string ;
  end for ;
#--- Build generation lists
  switch inTypeKind
  when preferencesType :
    ioGeneration->mPreferenceListForGeneration += !inTypeName->string !attributeListForGeneration !decoratedTransientMap !decoratedOutletMap ;
  when bezierPathType, boolType, colorType, classType, controllerClassType, dataType, dateType, documentType,
       doubleType, entityType, enumType, fontType, imageType, integerType, menuType, nibClassType, outletClassType,
       protocolType, stringType, structType, uintegerType:
  end switch ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependency transientDependencySemanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring inTransientName
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
;

#----------------------------------------------------------------------------*

end semantics ;
