semantics typeAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "attributeDeclarationAnalysis.gSemantics" ;

#----------------------------------------------------------------------------*

routine typeAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  !@transientListForGeneration outTransientListForGeneration
:
  outTransientListForGeneration := {} ;
  for (@lstring lkey
       @typeKind typeKind
       @unifiedTypeProxy superType
       @unifiedTypeProxy rootEntityType
       @decoratedAttributeMap decoratedAttributeMap
       @decoratedTransientMap decoratedTransientMap
       @decoratedOutletMap decoratedOutletMap
       @decoratedObservablePropertyMap observablePropertyMap
       @decoratedEntityRelationshipMap currentRelationshipMap) in inUnifiedTypeMap do
   #--- Build all observable property map
      @decoratedObservablePropertyMap allObservableProperties := observablePropertyMap ;
      var t := superType ;
      loop [inUnifiedTypeMap count] : while not [t isNull] do
        for () super_ in [t mObservablePropertyMap] do
          [!?allObservableProperties insertKey
            !super_lkey
            !super_mPropertyType
            !super_mIsTransient
            !super_mPropertySignature
            !super_mIsCollection
         ] ;
        end for ;
        t := [t mSuperType] ;
      end loop ; 
    unifiedTypeAnalysis
      !inUnifiedTypeMap
      !lkey
      !typeKind
      !superType
      !rootEntityType
      !decoratedAttributeMap
      !decoratedTransientMap
      !decoratedOutletMap
      !observablePropertyMap
      !currentRelationshipMap
      !allObservableProperties
      !?outTransientListForGeneration
    ;  
  end for ;
end routine ;

#----------------------------------------------------------------------------*

local routine unifiedTypeAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring unused lkey
  ??@typeKind unused inTypeKind
  ??@unifiedTypeProxy unused superType
  ??@unifiedTypeProxy inRootEntityType
  ??@decoratedAttributeMap unused decoratedAttributeMap
  ??@decoratedTransientMap decoratedTransientMap
  ??@decoratedOutletMap unused decoratedOutletMap
  ??@decoratedObservablePropertyMap unused inCurrentObservablePropertyMap
  ??@decoratedEntityRelationshipMap unused currentRelationshipMap
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ?!@transientListForGeneration ioTransientListForGeneration
:
#--- Analyze transient dependancies
  for () in decoratedTransientMap do
    @transientDependencyListForGeneration transientDependencyListForGeneration := {} ;
    for () in mDependencyList do
      if not [[mTransientType mTypeKind] suitableForObservableProperty] then
        error lkey : "the '" . [mTransientType key] . "' type is not acceptable for transient" ;
      end if ;
      [mDependency transientDependencySemanticAnalysis
        !inUnifiedTypeMap
        !lkey
        !inAllObservablePropertyMap
        !inRootEntityType
        !mTransientSignature
        !?transientDependencyListForGeneration
      ] ;
    end for ;
    ioTransientListForGeneration += !mTransientSignature->string !mTransientType !transientDependencyListForGeneration ;  
  end for ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependency transientDependencySemanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring inTransientName
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
;

#----------------------------------------------------------------------------*

end semantics ;
