semantics typeAnalysis :
  import "bindingSemanticAnalysis.gSemantics" ;
  import "documentGeneration.gSemantics" ;
  import "preferencesGeneration.gSemantics" ;
  import "entityGeneration.gSemantics" ;
  import "enumGeneration.gSemantics" ;
  import "controllerClassAnalysis.gSemantics" ;
  import "arrayControllerGeneration.gSemantics" ;

#----------------------------------------------------------------------------*

list @validationStubRoutineListForGeneration {
  @string mObjectTypeName ;
  @string mModelName ;
  @string mModelTypeName ;
}

#----------------------------------------------------------------------------*

struct @structForGeneration{
  @transientListForGeneration mTransientListForGeneration ;
  @actionListForGeneration mActionListForGeneration ;
  @preferenceListForGeneration mPreferenceListForGeneration ;
  @documentListForGeneration mDocumentListForGeneration ;
  @entityListForGeneration mEntityListForGeneration ;
  @enumListForGeneration mEnumListForGeneration ;
  @stringset mNeededOutletClasses ;
  @stringset mControllerGenerationStringSet ;
  @arrayControllerForGeneration mAllArrayControllerForGeneration ;
  @validationStubRoutineListForGeneration mValidationStubRoutineListForGeneration ;
}

#----------------------------------------------------------------------------*

routine typeAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@outletClassMap inOutletClassMap
  ??@templateControllerMap inTemplateControllerMap
  !@structForGeneration outGeneration
:
  outGeneration := [@structForGeneration default] ;
  for (@lstring lkey
       @typeKind typeKind
       @unifiedTypeProxy superType
       @unifiedTypeProxy rootEntityType
       @decoratedAttributeMap decoratedAttributeMap
       @decoratedTransientMap decoratedTransientMap
       @decoratedOutletMap decoratedOutletMap
       @decoratedObservablePropertyMap observablePropertyMap
       @decoratedEntityRelationshipMap currentRelationshipMap
       @actionMap actionMap
       @bindingList bindingList
       @lstringlist enumConstantList
       @enumConstantMap enumConstantMap
       @arrayControllerMap arrayControllerMap) in inUnifiedTypeMap do
   #--- Build all observable property map
      @decoratedObservablePropertyMap allObservableProperties := observablePropertyMap ;
      var t := superType ;
      loop [inUnifiedTypeMap count] : while not [t isNull] do
        for () super_ in [t mObservablePropertyMap] do
          [!?allObservableProperties insertKey
            !super_lkey
            !super_mPropertyType
            !super_mIsTransient
            !super_mPropertySignature
            !super_mIsCollection
         ] ;
        end for ;
        t := [t mSuperType] ;
      end loop ; 
    unifiedTypeAnalysis
      !inUnifiedTypeMap
      !inOutletClassMap
      !inTemplateControllerMap
      !lkey
      !typeKind
      !superType
      !rootEntityType
      !decoratedAttributeMap
      !decoratedTransientMap
      !decoratedOutletMap
      !observablePropertyMap
      !currentRelationshipMap
      !allObservableProperties
      !actionMap
      !bindingList
      !enumConstantList
      !enumConstantMap
      !arrayControllerMap
      !?outGeneration
    ;  
  end for ;
end routine ;

#----------------------------------------------------------------------------*

local routine unifiedTypeAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@outletClassMap inOutletClassMap
  ??@templateControllerMap inTemplateControllerMap
  ??@lstring inTypeName
  ??@typeKind inTypeKind
  ??@unifiedTypeProxy inSuperType
  ??@unifiedTypeProxy inRootEntityType
  ??@decoratedAttributeMap decoratedAttributeMap
  ??@decoratedTransientMap decoratedTransientMap
  ??@decoratedOutletMap decoratedOutletMap
  ??@decoratedObservablePropertyMap inCurrentObservablePropertyMap
  ??@decoratedEntityRelationshipMap inCurrentRelationshipMap
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ??@actionMap inActionMap
  ??@bindingList inBindingList
  ??@lstringlist inEnumConstantList
  ??@enumConstantMap unused inEnumConstantMap
  ??@arrayControllerMap inArrayControllerMap
  ?!@structForGeneration ioGeneration
:
#-------------------------------------------- Outlets
  @targetActionList targetActionList := {} ;
  for () in decoratedOutletMap do
    [inOutletClassMap searchKey !mOutletTypeName ??@bool handlesRunAction] ;
    ioGeneration->mNeededOutletClasses += !mOutletTypeName->string ;
  #--- run
    switch mRunActionDescriptor
    when noAction :
    when action (@lstring target @lstring action) :
      if not handlesRunAction then
        error mOutletTypeName : "the '" . mOutletTypeName . "' type does not handle run action" ;
      elsif target->string == "self" then
        [inActionMap searchKey !action] ;
        targetActionList += !lkey->string !"self" !action->string ;
      else # It is a controller
        [inArrayControllerMap searchKey !target ?3* ??@actionMap arrayControllerActionMap ?2*] ;
        [arrayControllerActionMap searchKey !action] ;
        targetActionList += !lkey->string !target->string !action->string ;
      end if ;
    end switch ;
  #--- Enabled
    switch mEnabledBindingDescriptor
    when  noEnabledBinding :
    when enabledBinding (@abstractObservablePropertyAST property) :
      [property analyzeBoundObservablePropertyForEnabledBinding
        !inUnifiedTypeMap
        !inArrayControllerMap
        !inCurrentObservablePropertyMap
        !inRootEntityType
        ??@string observedObject
        ??@string observedModel
      ] ;
    end switch ;
  end for ;
#--- Analyze relationships
  @entityRelationshipListForGeneration entityRelationshipListForGeneration := {} ;
  for () in inCurrentRelationshipMap do
    [[mRelationshipType mCurrentRelationshipMap] searchKey
      !mOppositeRelationshipName
      ??@bool oppositeRelationIsToMany
      ??@unifiedTypeProxy oppositeRelationshipType
      ??@lstring oppositeOfOppositeRelationshipName
    ] ;
    if oppositeOfOppositeRelationshipName->string != lkey->string then
      error lkey : "the opposite relationship is '" . mOppositeRelationshipName
         . "' and names '" . oppositeOfOppositeRelationshipName . "' as opposite, instead of '" . lkey . "'" ;
    end if ;
    if [oppositeRelationshipType key] != inTypeName->string then
      error lkey : "the opposite relationship type is '" . [oppositeRelationshipType key] . "', instead of '" . lkey . "'" ;
    end if ;
    entityRelationshipListForGeneration +=
      !lkey->string
      !mIsToMany
      !mRelationshipType
      !mOppositeRelationshipName->string
      !oppositeRelationIsToMany
    ;
  end for ;
#--------------------------------------------- Analyze array controllers
  @arrayControllerForGeneration documentArrayControllerForGeneration := {} ;
  for () in inArrayControllerMap do
  #--- Check model is a tomany relationship
    [mBoundModel analyzeBoundObservablePropertyForArrayControllerBinding
      ![inRootEntityType mCurrentRelationshipMap]
      ??@unifiedTypeProxy outElementTypeProxy
      ??@lstring outBoundRootTomanyRelationshipName
    ] ;
  #--- Check outlet is a PMTableView
    [decoratedOutletMap searchKey !mTableViewOutletName ??outletTypeName ?2*] ;
    if outletTypeName->string != "PMTableView" then
      error mTableViewOutletName : "this outlet is not an instance of PMTableView" ;
    end if ;
  #--- Check colum bound models
    @arrayControllerBoundColumnListForGeneration arrayControllerBoundColumnListForGeneration := {} ;
    for () in mArrayControllerBoundColumnListAST do
      [[outElementTypeProxy mObservablePropertyMap] searchKey
        !mObservablePropertyName
        ??@unifiedTypeProxy propertyType
        ?* #?@bool boundModelIsTransient
        ?* #?@lstring mPropertySignature
        ??@bool mIsCollection
      ] ;
      if mIsCollection then
        error mObservablePropertyName : "the bound property should not be a collection" ;
      end if ;
      arrayControllerBoundColumnListForGeneration +=
        !mColumnName->string
        !mColumnOutletTypeName->string
        !mObservablePropertyName->string
        !propertyType
        !mBindingOptionList
      ;
    end for ;
    documentArrayControllerForGeneration +=
      !lkey->string
      ![inRootEntityType key]
      !outBoundRootTomanyRelationshipName->string
      ![outElementTypeProxy key]
      !mTableViewOutletName->string
      !arrayControllerBoundColumnListForGeneration
    ;
  end for ;
  ioGeneration->mAllArrayControllerForGeneration += documentArrayControllerForGeneration ;
#------------------------------------------------- Analyze transient dependancies
  @transientDefinitionListForGeneration transientDefinitionListForGeneration := {} ;
  for () in decoratedTransientMap do
    @transientDependencyListForGeneration transientDependencyListForGeneration := {} ;
    for () in mDependencyList do
      if not [[mTransientType mTypeKind] suitableForObservableProperty] then
        error lkey : "the '" . [mTransientType key] . "' type is not acceptable for transient" ;
      end if ;
      [mDependency transientDependencySemanticAnalysis
        !inUnifiedTypeMap
        !lkey
        !inAllObservablePropertyMap
        !inArrayControllerMap
        !inRootEntityType
        !mTransientSignature
        !?transientDependencyListForGeneration
      ] ;
    end for ;
    @dependanceListForGeneration dependencyListForGeneration := {} ;
    for () in mDependencyList do
      dependencyListForGeneration += ![mDependency buildDecoratedRepresentation !inRootEntityType] ;
    end for ;
    transientDefinitionListForGeneration +=
      !lkey->string
      !mTransientType
      !mTransientSignature
      !dependencyListForGeneration
    ;
    ioGeneration->mTransientListForGeneration += !mTransientSignature->string !mTransientType !transientDependencyListForGeneration ;  
  end for ;
#--- Analyze attributes default value
  @attributeListForGeneration attributeListForGeneration := {} ;
  for () in decoratedAttributeMap do
    [mDefaultValue analyzeDefaultValueType 
      !{!mAttributeType}
      ??@string swiftDefaultValueAsString
    ] ;
    attributeListForGeneration += !mAttributeType !lkey->string !swiftDefaultValueAsString !mNeedsValidation ;
    if mNeedsValidation then
      ioGeneration->mValidationStubRoutineListForGeneration +=
        !inTypeName->string
        !lkey->string
        ![mAttributeType swiftTypeName]
      ;
    end if ;
  end for ;
#---------------------------------------------------------------- Analyze bindings
  @stringlist controllerInstanciationStringList := {} ;
  for () in inBindingList do
    var controllerSignature := "" ;
    var @unifiedTypeProxySelectorList boundPropertyTypeList := {} ;
    var @2stringlist typePropertyNameList := {} ;
    var @stringlist boundObjectNameList := {} ;
    [mObservableProperty analyzeBoundObservablePropertyForSimpleBinding
      !inUnifiedTypeMap
      !inArrayControllerMap
      !mSelectorName
      !inTypeName->string
      !inCurrentObservablePropertyMap
      !inRootEntityType
      !?controllerSignature
      !?boundPropertyTypeList
      !?typePropertyNameList
      !?boundObjectNameList
      ??@bool modelIsTransient
    ] ;
    [decoratedOutletMap searchKey !mOutletName ??@lstring outletTypeName ?2*] ;
    controllerSignature := outletTypeName->string + "." + mBindingName + controllerSignature ;
    const controllerTemplateName := [@lstring new
      !controllerSignature
      !mBindingName->location
    ] ;
    [inTemplateControllerMap searchKey
      !controllerTemplateName
      ??@string templateString
      ??@unifiedTypeProxy modelTypeProxy
      ??@lstring modelSelector
      ??@bool modelShouldBeWritableProperty
      ??@controllerBindingOptionDecoratedList controllerBindingOptionDecoratedList
    ] ;
    if modelShouldBeWritableProperty & modelIsTransient then
      error mSelectorName : "the model is transient and the binding requires an writable model" ;
    end if ;
    var @unifiedTypeProxySelectorList modelPropertyTypeList := {} ;
    modelPropertyTypeList += !modelTypeProxy !modelSelector ;
  #--- Check bound models types and selectors
    if [boundPropertyTypeList length] != [modelPropertyTypeList length] then
      error mOutletName : "internal error" ;
    else
      for () model_ in modelPropertyTypeList, () bound_ in boundPropertyTypeList do
        if ([model_mType mTypeKind] == [@typeKind enumType]) & ([bound_mType mTypeKind] == [@typeKind enumType]) then
        # Always ok for any enum type
        elsif [model_mType key] != [bound_mType key] then
          error bound_mSelector : "the type of the observable property is '" + [bound_mType key]
             + "', but this binding requires the '" + [model_mType key] + "' type"
          ;    
        end if ;
        if model_mSelector->string != bound_mSelector->string then
          error bound_mSelector : "the selector of the observable property should be '" + model_mSelector + "'" ;    
        end if ;
      end for ;
    end if ;
  #--- Check options
    var bindingOptionString := "" ;
    if [controllerBindingOptionDecoratedList length] != [mBindingOptionList length] then
      @string s ;
      if [controllerBindingOptionDecoratedList length] == 0 then
        s := "this binding has no option" ;
      else 
        s := "this binding requires the following options:" ;
        for () in controllerBindingOptionDecoratedList do
          s += "\n  - " + mOptionName + " : " + [mOptionType key] ;
        end for ;
      end if ;
      error mBindingName : s ;
    else
      for () controller_ in controllerBindingOptionDecoratedList, () binding_ in mBindingOptionList do
        if controller_mOptionName->string != binding_mOptionName->string then
          error binding_mOptionName : "the option name should be '" + controller_mOptionName + "'" ;
        end if ;
        [binding_mOptionValue analyzeDefaultValueType 
          !{!controller_mOptionType}
          ??@string optionValueAsString
        ] ;
        bindingOptionString += ", " + controller_mOptionName->string + ":" + optionValueAsString ;
      end for ;
    end if ;
  #--- Build controller string
    var title := "" ;
    for () in typePropertyNameList do
      title += mValue0 + " " + mValue1 ;
    end for ;    
    var controllerString := "//" + [@string stringWithSequenceOfCharacters !'—' !117] + "*\n" ;
    controllerString += "//   Controller " + [title + " - " + outletTypeName + " $" + mBindingName stringByRightPadding !103 !' '] + "*\n" ;
    controllerString += "//" + [@string stringWithSequenceOfCharacters !'—' !117] + "*\n\n" ;
    var templateStringWithReplacements := templateString ;
    for () in typePropertyNameList do
      templateStringWithReplacements := [templateStringWithReplacements stringByReplacingStringByString !"$OBJECTCLASS$" !mValue0] ;
      templateStringWithReplacements := [templateStringWithReplacements stringByReplacingStringByString !"$MODEL$" !mValue1] ;
    end for ;    
    controllerString += templateStringWithReplacements ;
    ioGeneration->mControllerGenerationStringSet += !controllerString ;
  #--- Build controller instanciation string
    var controllerInstanciationString := "Controller" ;
    for () in typePropertyNameList do
      controllerInstanciationString += "_" + mValue0 + "_" + mValue1 ;
    end for ;    
    controllerInstanciationString += "_" + outletTypeName + "_" + mBindingName + " (" ;
    var prefix := "object" ;
    for (s) in boundObjectNameList do index idx
      controllerInstanciationString += prefix + ":" + s + ", " ;
      prefix := "object" + (idx + 1) ;
    end for ;
    controllerInstanciationString += "outlet:" + mOutletName + ", file:__FILE__, line:__LINE__" + bindingOptionString + ")" ;
    controllerInstanciationStringList += !controllerInstanciationString ;
  end for ;
#--- Build action list
  for () action_ in inActionMap do
    ioGeneration->mActionListForGeneration += !inTypeName->string !action_lkey->string ;
  end for ;
#--- Build generation lists
  switch inTypeKind
  when enumType :
    ioGeneration->mEnumListForGeneration +=
      !inTypeName->string
      !inEnumConstantList
    ;
  when entityType :
    ioGeneration->mEntityListForGeneration +=
      !inTypeName->string
      !if [inSuperType isNull] then "" else [inSuperType key] end
      !attributeListForGeneration
      !transientDefinitionListForGeneration
      !entityRelationshipListForGeneration
    ;
  when documentType :
    ioGeneration->mDocumentListForGeneration +=
      !inTypeName->string
      ![inRootEntityType key]
      !attributeListForGeneration
      !transientDefinitionListForGeneration
      !decoratedOutletMap
      !controllerInstanciationStringList
      !documentArrayControllerForGeneration
      !targetActionList
    ;
  when preferencesType :
    ioGeneration->mPreferenceListForGeneration +=
      !inTypeName->string
      !attributeListForGeneration
      !transientDefinitionListForGeneration
      !decoratedOutletMap
      !controllerInstanciationStringList
    ;
  when bezierPathType, boolType, colorType, classType, controllerClassType, dataType, dateType,
       doubleType, fontType, imageType, integerType, menuType, nibClassType, outletClassType,
       protocolType, stringType, structType, uintegerType:
  end switch ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyAST transientDependencySemanticAnalysis
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@lstring inTransientName
  ??@decoratedObservablePropertyMap inAllObservablePropertyMap
  ??@arrayControllerMap inArrayControllerMap
  ??@unifiedTypeProxy inRootEntityType
  ??@lstring inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration
;

#----------------------------------------------------------------------------*
# analyzeBoundObservablePropertyForEnabledBinding                            *
#----------------------------------------------------------------------------*

#! analyzeBoundObservablePropertyForEnabledBinding

#----------------------------------------------------------------------------*

abstract method @abstractObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@arrayControllerMap inArrayControllerMap
  ??@decoratedObservablePropertyMap inObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  !@string outObservedObject
  !@string outObservedModel
;

#----------------------------------------------------------------------------*

override method @selfObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@decoratedObservablePropertyMap inObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  !@string outObservedObject
  !@string outObservedModel
:
  [inObservablePropertyMap searchKey
    !mSelfObservablePropertyName
    ?* # ?@unifiedTypeProxy propertyType
    ?* #outModelIsTransient
    ?* #?@lstring propertySignature
    ??@bool isCollection
  ] ;
  if isCollection then
    error mSelfObservablePropertyName : "the observable property should not be a collection" ;
  end if ;
  outObservedObject := "self" ;
  outObservedModel := mSelfObservablePropertyName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @rootObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@decoratedObservablePropertyMap unused inObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  !@string outObservedObject
  !@string outObservedModel
:
  [[inRootEntityType mObservablePropertyMap] searchKey
    !mRootObservablePropertyName
    ??@unifiedTypeProxy propertyType
    ?* #outModelIsTransient
    ?* #?@lstring propertySignature
    ??@bool isCollection
  ] ;
  if not [[propertyType mTypeKind] isBoolType] then
    error mRootObservablePropertyName: "this property should be boolean" ;
  end if ;
  if isCollection & not mNamesCountOption then
    error mRootObservablePropertyName : "the observable property should not be a collection" ;
  elsif mNamesCountOption & not isCollection then
    error mRootObservablePropertyName : "the observable property should be a collection" ;
  end if ;
  outObservedObject := "rootObject" ;
  outObservedModel := mRootObservablePropertyName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @preferenceObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@decoratedObservablePropertyMap unused inObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  !@string outObservedObject
  !@string outObservedModel
:
#--- Get preference type
  [inUnifiedTypeMap searchKey
    !mPreferenceName
    ??@typeKind typeKind
    ?5*
    ??@decoratedObservablePropertyMap observablePropertyMap
    ?6*
  ] ;
  if typeKind != [@typeKind preferencesType] then
    error mPreferenceName : "there is no '" . mPreferenceName . "' preferences" ;
  end if ;
#---    
  [observablePropertyMap searchKey
    !mPreferenceObservablePropertyName
    ??@unifiedTypeProxy propertyType
    ?* #outModelIsTransient
    ?* #?@lstring propertySignature
    ??@bool isCollection
  ] ;
  if not [[propertyType mTypeKind] isBoolType] then
    error mPreferenceObservablePropertyName: "this property should be boolean" ;
  end if ;
  if isCollection then
    error mPreferenceObservablePropertyName : "the observable property should not be a collection" ;
  end if ;
  outObservedObject := "g_" + mPreferenceName ;
  outObservedModel := mPreferenceObservablePropertyName->string ;
end method ;

#----------------------------------------------------------------------------*

override method @arrayControllerObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@arrayControllerMap inArrayControllerMap
  ??@decoratedObservablePropertyMap unused inObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  !@string outObservedObject
  !@string outObservedModel
:
#--- Get preference type
  [inArrayControllerMap searchKey
    !mArrayControllerName
    ?* # ?@abstractObservablePropertyAST boundModel
    ?3*
    ??@decoratedObservablePropertyMap arrayControllerObservablePropertyMap
    ?*
  ] ;
#---    
  [arrayControllerObservablePropertyMap searchKey
    !mArrayControllerObservablePropertyName
    ??@unifiedTypeProxy propertyType
    ?* # outModelIsTransient
    ?* #?@lstring propertySignature
    ??@bool isCollection
  ] ;
  if not [[propertyType mTypeKind] isBoolType] then
    error mArrayControllerObservablePropertyName: "this property should be boolean" ;
  end if ;
  if isCollection then
    error mArrayControllerObservablePropertyName : "the observable property should not be a collection" ;
  end if ;
  outObservedObject := mArrayControllerName->string ;
  outObservedModel := mArrayControllerObservablePropertyName->string ;
end method ;

#----------------------------------------------------------------------------*
# analyzeBoundObservablePropertyForSimpleBinding                             *
#----------------------------------------------------------------------------*

#! analyzeBoundObservablePropertyForSimpleBinding

#----------------------------------------------------------------------------*

abstract method @abstractObservablePropertyAST analyzeBoundObservablePropertyForSimpleBinding
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@arrayControllerMap inArrayControllerMap
  ??@lstring inSelectorName
  ??@string inCurrentTypeName
  ??@decoratedObservablePropertyMap inObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ?!@string ioControllerSignature
  ?!@unifiedTypeProxySelectorList ioBoundPropertyTypeList
  ?!@2stringlist ioTypePropertyNameList
  ?!@stringlist ioBoundObjectNameList
  !@bool outModelIsTransient
;

#----------------------------------------------------------------------------*

override method @selfObservablePropertyAST analyzeBoundObservablePropertyForSimpleBinding
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@lstring inSelectorName
  ??@string inCurrentTypeName
  ??@decoratedObservablePropertyMap inObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ?!@string ioControllerSignature
  ?!@unifiedTypeProxySelectorList ioBoundPropertyTypeList
  ?!@2stringlist ioTypePropertyNameList
  ?!@stringlist ioBoundObjectNameList
  !@bool outModelIsTransient
:
  [inObservablePropertyMap searchKey
    !mSelfObservablePropertyName
    ??@unifiedTypeProxy propertyType
    ?outModelIsTransient
    ?* #?@lstring propertySignature
    ??@bool isCollection
  ] ;
  if isCollection then
    error mSelfObservablePropertyName : "the observable property should not be a collection" ;
  end if ;
  ioControllerSignature += "." + [propertyType typeNameForControllerTemplateName] + "." + inSelectorName ;
  ioBoundPropertyTypeList += !propertyType !inSelectorName ;
  ioTypePropertyNameList += !inCurrentTypeName !mSelfObservablePropertyName->string ;
  ioBoundObjectNameList += !"self" ;
end method ;

#----------------------------------------------------------------------------*

override method @rootObservablePropertyAST analyzeBoundObservablePropertyForSimpleBinding
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@lstring inSelectorName
  ??@string unused inCurrentTypeName
  ??@decoratedObservablePropertyMap unused inObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ?!@string ioControllerSignature
  ?!@unifiedTypeProxySelectorList ioBoundPropertyTypeList
  ?!@2stringlist ioTypePropertyNameList
  ?!@stringlist ioBoundObjectNameList
  !@bool outModelIsTransient
:
  [[inRootEntityType mObservablePropertyMap] searchKey
    !mRootObservablePropertyName
    ??@unifiedTypeProxy propertyType
    ?outModelIsTransient
    ?* #?@lstring propertySignature
    ??@bool isCollection
  ] ;
  if isCollection & not mNamesCountOption then
    error mRootObservablePropertyName : "the observable property should not be a collection" ;
  elsif mNamesCountOption & not isCollection then
    error mRootObservablePropertyName : "the observable property should be a collection" ;
  end if ;
  ioBoundObjectNameList += !"rootObject" ;
  if mNamesCountOption then
    ioControllerSignature += ".Integer." + inSelectorName ;
    ioTypePropertyNameList += ![inRootEntityType key] !mRootObservablePropertyName->string + "_count" ;  
    ioBoundPropertyTypeList += ![@unifiedTypeProxy searchKey !inUnifiedTypeMap !["Integer" nowhere]] !inSelectorName ;
  else
    ioControllerSignature += "." + [propertyType typeNameForControllerTemplateName] + "." + inSelectorName ;
    ioTypePropertyNameList += ![inRootEntityType key] !mRootObservablePropertyName->string ;  
    ioBoundPropertyTypeList += !propertyType !inSelectorName ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @preferenceObservablePropertyAST analyzeBoundObservablePropertyForSimpleBinding
  ??@unifiedTypeMap inUnifiedTypeMap
  ??@arrayControllerMap unused inArrayControllerMap
  ??@lstring inSelectorName
  ??@string unused inCurrentTypeName
  ??@decoratedObservablePropertyMap unused inObservablePropertyMap
  ??@unifiedTypeProxy unused inRootEntityType
  ?!@string ioControllerSignature
  ?!@unifiedTypeProxySelectorList ioBoundPropertyTypeList
  ?!@2stringlist ioTypePropertyNameList
  ?!@stringlist ioBoundObjectNameList
  !@bool outModelIsTransient
:
#--- Get preference type
  [inUnifiedTypeMap searchKey
    !mPreferenceName
    ??@typeKind typeKind
    ?5*
    ??@decoratedObservablePropertyMap observablePropertyMap
    ?6*
  ] ;
  if typeKind != [@typeKind preferencesType] then
    error mPreferenceName : "there is no '" . mPreferenceName . "' preferences" ;
  end if ;
#---    
  [observablePropertyMap searchKey
    !mPreferenceObservablePropertyName
    ??@unifiedTypeProxy propertyType
    ?outModelIsTransient
    ?* #?@lstring propertySignature
    ??@bool isCollection
  ] ;
  if isCollection then
    error mPreferenceObservablePropertyName : "the observable property should not be a collection" ;
  end if ;
  ioControllerSignature += "." + [propertyType typeNameForControllerTemplateName] + "." + inSelectorName ;
  ioBoundPropertyTypeList += !propertyType !inSelectorName ;
  ioTypePropertyNameList += !mPreferenceName->string !mPreferenceObservablePropertyName->string ;
  ioBoundObjectNameList += !"g_" + mPreferenceName ;
end method ;

#----------------------------------------------------------------------------*

override method @arrayControllerObservablePropertyAST analyzeBoundObservablePropertyForSimpleBinding
  ??@unifiedTypeMap unused inUnifiedTypeMap
  ??@arrayControllerMap inArrayControllerMap
  ??@lstring inSelectorName
  ??@string inCurrentTypeName
  ??@decoratedObservablePropertyMap unused inObservablePropertyMap
  ??@unifiedTypeProxy inRootEntityType
  ?!@string ioControllerSignature
  ?!@unifiedTypeProxySelectorList ioBoundPropertyTypeList
  ?!@2stringlist ioTypePropertyNameList
  ?!@stringlist ioBoundObjectNameList
  !@bool outModelIsTransient
:
#--- Get preference type
  [inArrayControllerMap searchKey
    !mArrayControllerName
    ??@abstractObservablePropertyAST boundModel
    ?3*
    ??@decoratedObservablePropertyMap arrayControllerObservablePropertyMap
    ?*
  ] ;
#---    
  [arrayControllerObservablePropertyMap searchKey
    !mArrayControllerObservablePropertyName
    ??@unifiedTypeProxy propertyType
    ?outModelIsTransient
    ?* #?@lstring propertySignature
    ??@bool isCollection
  ] ;
  if isCollection then
    error mArrayControllerObservablePropertyName : "the observable property should not be a collection" ;
  end if ;
  ioControllerSignature += "." + [propertyType typeNameForControllerTemplateName] + "." + inSelectorName ;
  ioBoundPropertyTypeList += !propertyType !inSelectorName ;
  ioBoundObjectNameList += !mArrayControllerName->string ;
  ioTypePropertyNameList +=
    !"ArrayController_" + [boundModel modelSignatureForArrayController !inRootEntityType !inCurrentTypeName]
    !mArrayControllerObservablePropertyName->string
  ;
end method ;

#----------------------------------------------------------------------------*
# analyzeBoundObservablePropertyForArrayControllerBinding                    *
#----------------------------------------------------------------------------*

#! analyzeBoundObservablePropertyForArrayControllerBinding

#----------------------------------------------------------------------------*

abstract method @abstractObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ??@decoratedEntityRelationshipMap inCurrentRelationshipMap
  !@unifiedTypeProxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName
;

#----------------------------------------------------------------------------*

override method @selfObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ??@decoratedEntityRelationshipMap unused inCurrentRelationshipMap
  !@unifiedTypeProxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName
:
  error mSelfObservablePropertyName
    : "the bound array should be a root object model"
    : outBoundRootTomanyRelationshipName, outRelationshipTypeProxy
  ;
end method ;

#----------------------------------------------------------------------------*

override method @rootObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ??@decoratedEntityRelationshipMap inCurrentRelationshipMap
  !@unifiedTypeProxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName
:
  [inCurrentRelationshipMap searchKey
    !mRootObservablePropertyName
    ??@bool mIsToMany
    ?outRelationshipTypeProxy
    ?*
  ] ;
  if not mIsToMany then
    error mRootObservablePropertyName : "the observable property should be a tomany relationship" ;
  end if ;
  outBoundRootTomanyRelationshipName := mRootObservablePropertyName ;
end method ;

#----------------------------------------------------------------------------*

override method @preferenceObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ??@decoratedEntityRelationshipMap unused inCurrentRelationshipMap
  !@unifiedTypeProxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName
:
  error mPreferenceObservablePropertyName
    : "the bound array should be a root object model"
    : outBoundRootTomanyRelationshipName, outRelationshipTypeProxy
  ;
end method ;

#----------------------------------------------------------------------------*

override method @arrayControllerObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ??@decoratedEntityRelationshipMap unused inCurrentRelationshipMap
  !@unifiedTypeProxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName
:
  error mArrayControllerObservablePropertyName
    : "the bound array should be a root object model"
    : outBoundRootTomanyRelationshipName, outRelationshipTypeProxy
  ;
end method ;

#----------------------------------------------------------------------------*
# propertySignature                                                          *
#----------------------------------------------------------------------------*

#! propertySignature

#----------------------------------------------------------------------------*

abstract reader @abstractObservablePropertyAST propertySignature
  ??@string inKind
  ??@string inSelfTypeName
  ??@unifiedTypeProxy inRootypeProxy
  -> @lstring outSignature
;

#----------------------------------------------------------------------------*

override reader @selfObservablePropertyAST propertySignature
  ??@string inKind
  ??@string inSelfTypeName
  ??@unifiedTypeProxy unused inRootypeProxy
  -> @lstring outSignature
:
  outSignature := [@lstring new
    !inKind + "." + inSelfTypeName + "." + mSelfObservablePropertyName
    !mSelfObservablePropertyName->location
  ] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @rootObservablePropertyAST propertySignature
  ??@string unused inKind
  ??@string unused inSelfTypeName
  ??@unifiedTypeProxy inRootypeProxy
  -> @lstring outSignature
:
  outSignature := [@lstring new
    !"entity." + [inRootypeProxy key] + "." + mRootObservablePropertyName
    !mRootObservablePropertyName->location
  ] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @preferenceObservablePropertyAST propertySignature
  ??@string unused inKind
  ??@string unused inSelfTypeName
  ??@unifiedTypeProxy unused inRootypeProxy
  -> @lstring outSignature
:
  outSignature := [@lstring new
    !"preferences." + mPreferenceName + "." + mPreferenceObservablePropertyName
    !mPreferenceObservablePropertyName->location
  ] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @arrayControllerObservablePropertyAST propertySignature
  ??@string inKind
  ??@string inSelfTypeName
  ??@unifiedTypeProxy unused inRootypeProxy
  -> @lstring outSignature
:
  outSignature := [@lstring new
    !inKind + "." + inSelfTypeName + "." + mArrayControllerObservablePropertyName
    !mArrayControllerObservablePropertyName->location
  ] ;
end reader ;

#----------------------------------------------------------------------------*
# modelSignatureForArrayController                                           *
#----------------------------------------------------------------------------*

#! modelSignatureForArrayController

#----------------------------------------------------------------------------*

abstract reader @abstractObservablePropertyAST modelSignatureForArrayController
  ??@unifiedTypeProxy inRootypeProxy
  ??@string inSelfTypeName
  -> @string outSignature
;

#----------------------------------------------------------------------------*

override reader @selfObservablePropertyAST modelSignatureForArrayController
  ??@unifiedTypeProxy unused inRootypeProxy
  ??@string inSelfTypeName
  -> @string outSignature
:
  outSignature := inSelfTypeName + "_" + mSelfObservablePropertyName ;
end reader ;

#----------------------------------------------------------------------------*

override reader @rootObservablePropertyAST modelSignatureForArrayController
  ??@unifiedTypeProxy inRootypeProxy
  ??@string unused inSelfTypeName
  -> @string outSignature
:
  outSignature := [inRootypeProxy key] + "_" + mRootObservablePropertyName ;
end reader ;

#----------------------------------------------------------------------------*

override reader @preferenceObservablePropertyAST modelSignatureForArrayController
  ??@unifiedTypeProxy unused inRootypeProxy
  ??@string unused inSelfTypeName
  -> @string outSignature
:
  outSignature := mPreferenceName->string + "_" + mPreferenceObservablePropertyName ;
end reader ;

#----------------------------------------------------------------------------*

override reader @arrayControllerObservablePropertyAST modelSignatureForArrayController
  ??@unifiedTypeProxy unused inRootypeProxy
  ??@string inSelfTypeName
  -> @string outSignature
:
  outSignature := inSelfTypeName + "_" + mArrayControllerObservablePropertyName ;
end reader ;

#----------------------------------------------------------------------------*
#! buildDecoratedRepresentation
#----------------------------------------------------------------------------*

abstract reader @abstractTransientDependencyAST buildDecoratedRepresentation
  ??@unifiedTypeProxy inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult
;

#----------------------------------------------------------------------------*

override reader @transientRootSignDependencyAST buildDecoratedRepresentation
  ??@unifiedTypeProxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult
:
  outResult := [@transientRootSignDependencyForGeneration new !mDeclarationLocation] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientLocalDependencyAST buildDecoratedRepresentation
  ??@unifiedTypeProxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult
:
  outResult := [@transientLocalDependencyForGeneration new !mMasterName !mNamesCountOption] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientRootDependencyAST buildDecoratedRepresentation
  ??@unifiedTypeProxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult
:
  outResult := [@transientRootDependencyForGeneration new !mMasterName !mNamesCountOption] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientRootRelationshipDependencyAST buildDecoratedRepresentation
  ??@unifiedTypeProxy inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult
:
  [[inRootEntityType mCurrentRelationshipMap] searchKey
    !mRelationshipName
    ?*
    ??@unifiedTypeProxy elementType
    ?*
  ] ;
  outResult := [@transientRootRelationshipDependencyForGeneration new !elementType !mRelationshipName !mMasterName] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientControllerDependencyAST buildDecoratedRepresentation
  ??@unifiedTypeProxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult
:
  outResult := [@transientControllerDependencyForGeneration new !mControllerName !mMasterName] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientPreferenceDependencyAST buildDecoratedRepresentation
  ??@unifiedTypeProxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult
:
  outResult := [@transientPreferenceDependencyForGeneration new !mPreferencesName !mMasterName] ;
end reader ;

#----------------------------------------------------------------------------*

end semantics ;
