semantics semanticAnalysis :
  import "easyBindings_options.gOption" ;
  import "abstractSyntaxTree.gSemantics" ;
  import "transient_analysis_generation.gSemantics" ;

#----------------------------------------------------------------------------*

reader @easyBindingType propertyAttributeString -> @string outResult :
  switch selfcopy
  when boolType, integerType, uintegerType,
       floatType, doubleType, decimalType,
       toManyEntitiesType : outResult := "" ;
  when stringType : outResult := "(copy)" ;
  when fontType, imageType, dataType : outResult := "" ;
  when colorType, dateType : outResult := "(assign)" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @easyBindingType requiredCellTypeInTableColumnBinding -> @string outResult :
  switch selfcopy
  when boolType : outResult := "" ; # Empty string: not allowed
  when integerType, uintegerType : outResult := "NSTextFieldCell" ;
  when decimalType : outResult := "NSTextFieldCell" ;
  when floatType : outResult := "NSTextFieldCell" ;
  when doubleType : outResult := "NSTextFieldCell" ;
  when stringType : outResult := "NSTextFieldCell" ;
  when dataType : outResult := "" ;
  when dateType : outResult := "NSDateFieldCell" ;
  when fontType : outResult := "" ;
  when imageType : outResult := "" ;
  when colorType : outResult := "" ;
  when toManyEntitiesType : outResult := "" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @easyBindingType equalMethod -> @string outResult :
  switch selfcopy
  when boolType : outResult := "" ; # Empty string: use == operator
  when integerType, uintegerType : outResult := "" ;
  when decimalType : outResult := "" ;
  when floatType : outResult := "" ;
  when doubleType : outResult := "" ;
  when stringType : outResult := "isEqualToString" ;
  when dataType : outResult := "isEqual" ;
  when dateType : outResult := "isEqual" ;
  when fontType : outResult := "isEqual" ;
  when imageType : outResult := "isEqual" ;
  when colorType : outResult := "isEqual" ;
  when toManyEntitiesType : outResult := "" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

map @classMap {
  @string mSuperClassName ;
  @observablePropertyMap mPropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @stringset mImplementationFileInclusionSet ;
  insert insertKey error message "the '%K' class is already declared" ;
  search searchKey error message "the '%K' class is not declared" ;
}

#----------------------------------------------------------------------------*

map @entityMap {
  @string mSuperEntityName ;
  @string mImplementationClassName ;
  @string mSuperImplementationClassName ;
  @observablePropertyMap mObservablePropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @relationshipList mAllRelationshipList ;
  @propertyMap mAllPropertyMap ;
  @relationshipMap mCurrentRelationshipMap ;
  @relationshipMap mAllRelationshipMap ;
  @stringset mImplementationFileInclusionSet ;
  @2stringlist mToManyRelationshipList ;
  insert insertKey error message "the '%K' entity is already declared" ;
  search searchKey error message "the '%K' entity is not declared" ;
}

#----------------------------------------------------------------------------*

class @runBindingForGeneration extends @abstractBindingForGeneration {
  @string mTargetName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*

class @regularBindingForGeneration extends @abstractBindingForGeneration {
  @string mBindingName ;
  @formatterEnum mRequiredFormatter ;
  @string mObservedObjectName ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

list @columnBindingForTableValueBindingForGeneration {
  @string mColumnIdentifier ;
  @string mRequiredCellClass ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

class @tableValueBindingForGeneration extends @abstractBindingForGeneration {
  @string mControllerName ;
  @columnBindingForTableValueBindingForGeneration mColumnBindingForTableValueBindingForGeneration ;
}

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

override reader @runBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "  " . inOutletName . ".target = " . mTargetName . " ;\n" ;
  outResult .= "  " . inOutletName . ".action = @selector (" . mActionName . ":) ;\n" ;  
end reader ;

#----------------------------------------------------------------------------*

override reader @tableValueBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "" ;
  for column in mColumnBindingForTableValueBindingForGeneration do
     outResult .=  "  if (nil == [" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"]) {\n"
     . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' NSTableView outlet has no formatter has no column with the " . column->mColumnIdentifier . " identifier\") ;\n"
     . "  }else{\n"
     . "    NSActionCell * cell = [" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"].dataCell ;\n"
     . "    if (! [cell isKindOfClass:[" . column->mRequiredCellClass . " class]]) {\n"
     . "      presentErrorWindow (__FILE__, __LINE__, @\"the dataCell is '" . column->mColumnIdentifier . "' column of the '" . inOutletName . "' should be an '" . column->mRequiredCellClass . " instance\") ;\n"
     . "    }\n"
     . "  }\n"
     . "  [[" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"]\n"
     . "    bind:@\"value\"\n"
     . "    toObject:" . mControllerName . "\n"
     . "    withKeyPath:@\"arrangedObjects." . column->mObservableAttributeName . "\"\n"
     . "    options:" ;
     if [column->mOutletBindingOptionList length] == 0 then
       outResult .= "nil\n" ;
     else
       outResult .= "[NSDictionary dictionaryWithObjectsAndKeys:\n" ;
       foreach column->mOutletBindingOptionList do
         outResult .= "      " . mValue1 . ", @" . [mValue0 utf8Representation] . ",\n" ;
       end foreach ;
       outResult .= "      nil\n"
                    "    ]\n" ;
     end if ;
     outResult .= "  ] ;\n" ;
   end for ;
end reader ;

#----------------------------------------------------------------------------*

override reader @regularBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "" ;
  switch mRequiredFormatter
  when noFormatter :
  when numberFormatter :
   outResult .=  "  if ((nil != " . inOutletName . ") && (nil == " . inOutletName . ".formatter)) {\n"
   . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has no formatter, it should have an NSNumberFormatter\") ;\n"
   . "  }else if ((nil != " . inOutletName . ") && ![" . inOutletName . ".formatter isKindOfClass:[NSNumberFormatter class]]) {\n"
   . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . " outlet has a formatter that is not kind of NSNumberFormatter class\") ;\n"
   . "  }\n" ;
  when dateFormatter :
    outResult .= "  if ((nil != " . inOutletName . ") && (nil == " . inOutletName . ".formatter)) {\n"
    . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has no formatter, it should have an NSDateFormatter\") ;\n"
    . "  }else if ((nil != " . inOutletName . ") && ![" . inOutletName . ".formatter isKindOfClass:[NSDateFormatter class]]) {\n"
    . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has a formatter that is not kind of NSDateFormatter class\") ;\n"
    . "  }\n" ;
  end switch ;
  outResult .= "  [" . inOutletName . "\n"
            . "    bind:@\"" . mBindingName . "\"\n"
            . "    toObject:" . mObservedObjectName . "\n"
            . "    withKeyPath:@\"" . mObservableAttributeName . "\"\n"
            . "    options:" ;
   if [mOutletBindingOptionList length] == 0 then
     outResult .= "nil\n" ;
   else
     outResult .= "[NSDictionary dictionaryWithObjectsAndKeys:\n" ;
     foreach mOutletBindingOptionList do
       outResult .= "      " . mValue1 . ", @" . [mValue0 utf8Representation] . ",\n" ;
     end foreach ;
     outResult .= "      nil\n"
                  "    ]\n" ;
   end if ;
   outResult .= "  ] ;\n" ;
end reader ;

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateRemoveBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

override reader @runBindingForGeneration generateRemoveBinding
  ??@string unused inOutletName
  -> @string outResult
:
  outResult := "" ;  
end reader ;

#----------------------------------------------------------------------------*

override reader @tableValueBindingForGeneration generateRemoveBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "" ;
  for column in mColumnBindingForTableValueBindingForGeneration do
     outResult .= "  [[" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"]\n"
     . "    unbind:@\"value\"\n"
     . "  ] ;\n" ;
   end for ;
end reader ;

#----------------------------------------------------------------------------*

override reader @regularBindingForGeneration generateRemoveBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult :=
    "  [" . inOutletName . " unbind:@\"" . mBindingName . "\"] ;\n" ;
end reader ;

#----------------------------------------------------------------------------*

map @documentMap {
  @string mRootEntityName ;
  @string mRootEntityImplementationClassName ;
  @outletGenerationList mOutletDeclarationList ;
  @controllerMap mControllerMap ;
  @lstringlist mActionList ;
  @transientListForImplementation mTransientListForImplementation ;
  @stringset mImplementationFileInclusionSet ;
  insert insertKey error message "the '%K' document is already declared" ;
  search searchKey error message "the '%K' document is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingOptionMap {
  @easyBindingTypeList mAcceptableTypeList ;
  insert insertKey error message "the '%K' binding option is already declared" ;
  search searchKey error message "the '%K' binding option is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingMap {
  @easyBindingTypeAndFormatterList mAcceptableTypeList ;
  @outletClassBindingOptionMap mOutletClassBindingOptionMap ;
  insert insertKey error message "the '%K' binding is already declared" ;
  search searchKey error message "the '%K' binding is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassMap {
  @bool mGenerateCode ;
  @string mSuperClassName ;
  @outletClassBindingMap mBindingMap ;
  @bool mHasTableValueBinding ;
  insert insertKey error message "the '%K' outlet class is already declared" ;
  search searchKey error message "the '%K' outlet class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerClassMap {
  @bool mGenerateCode ;
  @outletClassBindingMap mBindingMap ;
  @actionMap mActionMap ;
  @observablePropertyMap mObservablePropertyMap ;
  insert insertKey error message "the '%K' controller class is already declared" ;
  search searchKey error message "the '%K' controller class is not declared" ;
}

#----------------------------------------------------------------------------*

map @relationshipMap {
  @bool mIsToMany ;
  @lstring mDestinationEntityName ;
  @lstring mInverseRelationshipName ;
  @deleteRuleEnum mDeleteRule ;
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
}

#----------------------------------------------------------------------------*

map @propertyMap {
  insert insertKey error message "there is already a '%K' property (attribute, transient or relationship)" ;
}

#----------------------------------------------------------------------------*
#   ANALYZE ENTITIES                                                         *
#----------------------------------------------------------------------------*

local routine analyzeEntity
  ??@entityList.element inEntity
  ?!@entityMap ioEntityMap
  ??@preferencesMap inPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#--------------------------------------------- Get super entity (if any)
  @observablePropertyMap observablePropertyMap ;
  @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
  @relationshipList allRelationshipList ;
  @string implementationSuperClassName ;
  @propertyMap allPropertyMap ;
  @relationshipMap allRelationshipMap ;
  if [inEntity->mSuperEntityName string] != "" then
    [ioEntityMap searchKey
      !inEntity->mSuperEntityName
      ?*
      ?implementationSuperClassName
      ?*
      ?observablePropertyMap
      ?propertyListForInitMethodHeader
      ?4*
      ?allRelationshipList
      ?allPropertyMap
      ?*
      ?allRelationshipMap
      ?2*
    ] ;
  else
    observablePropertyMap := [@observablePropertyMap emptyMap] ;
    propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
    implementationSuperClassName := "" ;
    allRelationshipList := [@relationshipList emptyList] ;
    allPropertyMap := [@propertyMap emptyMap] ;
    allRelationshipMap := [@relationshipMap emptyMap] ;
  end if ;
  @attributeListForImplementation attributeListForImplementation [emptyList] ;
  const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
#--------------------------------------- Analyze attributes
  foreach inEntity->mAttributeList do
    checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
    [!?allPropertyMap insertKey !mAttributeName] ;
    attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
    propertyListForInitMethodHeader += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
    const @lstring observationDependencyKey [new
      !"entity." . inEntity->mEntityName . "." . mAttributeName
      !mAttributeName->location
    ] ;
    [!?observablePropertyMap insertKey
      !mAttributeName
      !mType
      !false # is not transient
      !observationDependencyKey->string
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#---------------------------------------- Analyze relationship (only check name is unique)
  @relationshipMap currentRelationshipMap [emptyMap] ;
  foreach inEntity->mRelationshipList do
    [!?allRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !mDestinationEntityName
      !mInverseRelationshipName
      !mDeleteRule
    ] ;
    [!?currentRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !mDestinationEntityName
      !mInverseRelationshipName
      !mDeleteRule
    ] ;
    [!?allPropertyMap insertKey !mRelationshipName] ;
    const @lstring observationDependencyKey [new
      !"entity." . inEntity->mEntityName . "." . mRelationshipName
      !mRelationshipName->location
    ] ;
    [!?observablePropertyMap insertKey
      !mRelationshipName
      ![@easyBindingType toManyEntitiesType]
      !false # is not transient
      !observationDependencyKey->string
    ] ;    
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#----------------------------------------- Analyze transient properties
  @stringset implementationFileInclusionSet [emptySet] ;
  @transientListForImplementation transientListForImplementation ;
  analyzeTransientProperties
    !inPreferencesMap
    !"entity." . inEntity->mEntityName . "."
    !inEntity->mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !"" # No Root entity
    ![@controllerMap emptyMap]
    !?observablePropertyMap
    !?implementationFileInclusionSet
    ?transientListForImplementation
    !?ioTransientDependencyGraph
  ;
#----------------------------------------- Build 'to-many' relation ship list
  @2stringlist toManyRelationshipList [emptyList] ;
  foreach inEntity->mRelationshipList do
    if mIsToMany then
      toManyRelationshipList += !mRelationshipName->string !mDestinationEntityName-> string ;
    else
    
    end if ;
  end foreach ;
#----------------------------------------- Enter entity in entity map
  [!?implementationFileInclusionSet removeKey !""] ;
  [!?ioEntityMap insertKey
    !inEntity->mEntityName
    !inEntity->mSuperEntityName->string
    !inEntity->mImplementationClassName->string
    !implementationSuperClassName
    !observablePropertyMap
    !propertyListForInitMethodHeader
    !inheritedAttributeListForImplementation
    !attributeListForImplementation
    !transientListForImplementation
    !inEntity->mRelationshipList
    !allRelationshipList . inEntity->mRelationshipList
    !allPropertyMap
    !currentRelationshipMap
    !allRelationshipMap
    !implementationFileInclusionSet
    !toManyRelationshipList
  ] ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeEntities
  ??@entityList inEntityList
  !@entityMap outEntityMap
  ??@preferencesMap inPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Analyze entities
  outEntityMap := [@entityMap emptyMap] ;
  for entity in inEntityList do
    analyzeEntity
      !entity
      !?outEntityMap
      !inPreferencesMap
      !?ioTransientDependencyGraph
    ;
  end for ;
#------------------------------- Check relationships
  foreach outEntityMap do
    foreach mCurrentRelationshipMap do
      @relationshipMap destinationEntityRelationshipMap ;
      [outEntityMap searchKey !mDestinationEntityName ?12* ?destinationEntityRelationshipMap ?2*] ;
      @lstring inverseOfInverseRelationshipName ;
      [destinationEntityRelationshipMap searchKey !mInverseRelationshipName ?2* ?inverseOfInverseRelationshipName ?*] ;
      if lkey->string != inverseOfInverseRelationshipName->string then
        error mInverseRelationshipName : "the inverse relationship does not name '" . lkey . "' relationship as inverse" ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeOutletBinding
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@observablePropertyMap inSelfObservableAttributeMap
  ??@preferencesMap inPreferencesMap
  ??@entityMap inEntityMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
;

#----------------------------------------------------------------------------*

override method @tableValueBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap inEntityMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap unused inActionMap
  ??@bool inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
  if not inHasTableValueBinding then
    error mControllerName: "this outlet does not support $tableValue binding" ;
  else
    @string controlledClassOrEntityName ;
    @outletBindingListForGeneration controllerBindingList ;
    [inControllerMap searchKey
      !mControllerName
      ?*
      ?controlledClassOrEntityName
      ?controllerBindingList
      ?*
      ?*
    ] ;
    [inEntityMap searchKey
      ![@lstring new !controlledClassOrEntityName !here]
      ?3*
      ?@observablePropertyMap observablePropertyMap
      ?11*
    ] ;
    @columnBindingForTableValueBindingForGeneration columnBindingForTableValueBindingForGeneration [emptyList] ;
    for column in mTableValueColumnBinding do
      [observablePropertyMap searchKey
        !column->mBoundPropertyName
        ?@easyBindingType type
        ?*
        ?*
      ] ;
      const @string requiredCellTypeInTableColumnBinding := [type requiredCellTypeInTableColumnBinding] ;
      if requiredCellTypeInTableColumnBinding == "" then
        error column->mBoundPropertyName:"this property cannot be named in a $tableValue binding" ;
      elsif requiredCellTypeInTableColumnBinding != column->mCellTypeName->string then
        error column->mCellTypeName:"this property requires a " . requiredCellTypeInTableColumnBinding . " cell class" ;
      end if ;
      columnBindingForTableValueBindingForGeneration +=
        !column->mColumnName->string
        !requiredCellTypeInTableColumnBinding
        !column->mBoundPropertyName->string
        ![@2stringlist emptyList]
      ;
    end for ;
    ioOutletBindingListForGeneration += ![@tableValueBindingForGeneration new
      !mControllerName->string
      !columnBindingForTableValueBindingForGeneration
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @runBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
  if mTargetName->string == "self" then
    [inActionMap searchKey !mActionName] ;
  else
    @actionMap actionMap ;
    [inControllerMap searchKey !mTargetName ?3* ?actionMap ?*] ;
    [actionMap searchKey !mActionName] ;
  end if ;
  ioOutletBindingListForGeneration += ![@runBindingForGeneration new
    !mTargetName->string
    !mActionName->string
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularControllerBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
#---------------------------------- Search binding
  [inBindingMap searchKey
    !mBindingName
    ?@easyBindingTypeAndFormatterList acceptableTypeFormatterList
    ?@outletClassBindingOptionMap outletClassBindingOptionMap
  ] ;
#---------------------------------- Search controller in controller map
  [inControllerMap searchKey
    !mControllerName
    ?4*
    ?@observablePropertyMap observableAttributeMap
  ] ;
#---------------------------------- Search property
  [observableAttributeMap searchKey
    !mControllerAttributeName
    ?@easyBindingType observablePropertyType
    ?@bool isTransient
    ?@string propertySignature
  ] ;
#------------------------------------------------- count option ?
  @string observedKeyPath := mControllerAttributeName->string ;
  if mNamesCountOption then
    observedKeyPath .= ".@count" ;
    if observablePropertyType != [@easyBindingType toManyEntitiesType] then
      error mControllerAttributeName: "the 'count' option is only allowed for to-many relationships" ;
    end if ;
  end if ;
  
#-------------------------------------------------- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mControllerAttributeName:s ;
  end if ;
#--- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !mControllerName->string
    !observedKeyPath
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularRootBinding analyzeOutletBinding
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
#--------------------------------------- Search binding in outlet class binding map
  [inBindingMap searchKey
    !mBindingName
    ?@easyBindingTypeAndFormatterList acceptableTypeFormatterList
    ?@outletClassBindingOptionMap outletClassBindingOptionMap
  ] ;
#---------------------------------------- Find observable property in root entity observable property map
  [inRootEntityObservableAttributeMap searchKey
    !mObservableAttributeName
    ?@easyBindingType observablePropertyType
    ?*
    ?*
  ] ;
  @string observableKeyPath := mObservableAttributeName->string ;
#--------------------------------------- count option ?
  if mNamesCountOption then
    if observablePropertyType == [@easyBindingType toManyEntitiesType] then
      observableKeyPath .= ".@count" ;
      observablePropertyType := [@easyBindingType uintegerType] ;
    else
      error mObservableAttributeName: "the 'count' path is only allowed for to-many relationships" ;
    end if ;
  end if ;
#----------------------------------------- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mObservableAttributeName:s ;
  end if ;
#----------------------------------------- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
#----------------------------------------- Generate binding
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !"mRootObject"
    !observableKeyPath
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularSelfBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap inSelfObservableAttributeMap
  ??@preferencesMap unused inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
#--------------------------------------- Search binding in outlet class binding map
  [inBindingMap searchKey
    !mBindingName
    ?@easyBindingTypeAndFormatterList acceptableTypeFormatterList
    ?@outletClassBindingOptionMap outletClassBindingOptionMap
  ] ;
#---------------------------------------- Find observable property in local observable property map
  [inSelfObservableAttributeMap searchKey
    !mObservableAttributeName
    ?@easyBindingType observablePropertyType
    ?*
    ?*
  ] ;
  @string observableKeyPath := mObservableAttributeName->string ;
#--------------------------------------- count option ?
  if mNamesCountOption then
    if observablePropertyType == [@easyBindingType toManyEntitiesType] then
      observableKeyPath .= ".@count" ;
      observablePropertyType := [@easyBindingType uintegerType] ;
    else
      error mObservableAttributeName: "the 'count' path is only allowed for to-many relationships" ;
    end if ;
  end if ;
#----------------------------------------- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mObservableAttributeName:s ;
  end if ;
#----------------------------------------- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
#----------------------------------------- Generate binding
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !"self"
    !observableKeyPath
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularPreferenceBinding analyzeOutletBinding
  ??@observablePropertyMap unused inRootEntityObservableAttributeMap
  ??@observablePropertyMap unused inSelfObservableAttributeMap
  ??@preferencesMap inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
:
  ioImplementationFileInclusionSet += !mPreferenceName->string ;
#--------------------------------------- Search binding in outlet class binding map
  [inBindingMap searchKey
    !mBindingName
    ?@easyBindingTypeAndFormatterList acceptableTypeFormatterList
    ?@outletClassBindingOptionMap outletClassBindingOptionMap
  ] ;
#---------------------------------------- Search preference in preferences map
  [inPreferencesMap searchKey
    !mPreferenceName
    ?4*
    ?@observablePropertyMap observablePropertyMap
    ?*
  ] ;
#---------------------------------------- Find observable property in local observable property map
  [observablePropertyMap searchKey
    !mPreferenceAttributeName
    ?@easyBindingType observablePropertyType
    ?*
    ?*
  ] ;
#----------------------------------------- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mPreferenceAttributeName:s ;
  end if ;
#----------------------------------------- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
#----------------------------------------- Generate binding
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !"g_" . mPreferenceName
    !mPreferenceAttributeName->string
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @multiValuedBinding analyzeOutletBinding
  ??@observablePropertyMap inRootEntityObservableAttributeMap
  ??@observablePropertyMap inSelfObservableAttributeMap
  ??@preferencesMap inPreferencesMap
  ??@entityMap unused inEntityMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
:
  @outletClassBindingOptionMap outletClassBindingOptionMap ;
  @easyBindingTypeAndFormatterList acceptableTypeFormatterList ;
  [inBindingMap searchKey !mBindingName ?acceptableTypeFormatterList ?outletClassBindingOptionMap] ;
#--- Find observable property
  @string generatedBindingName := mBindingName->string ;
  @uint idx := 1 ;
  foreach mMultiValuedBindingList do
    @string observedObjectName ;
    @easyBindingType observablePropertyType ;
    if mBoundObjectName->string == "root" then
      [inRootEntityObservableAttributeMap searchKey
        !mBoundPropertyName
        ?observablePropertyType
        ?*
        ?*
      ] ;
      observedObjectName := "mRootObject" ;
    elsif mBoundObjectName->string == "self" then
      [inSelfObservableAttributeMap searchKey
        !mBoundPropertyName
        ?observablePropertyType
        ?*
        ?*
      ] ;
      observedObjectName := "self" ;
    else
      [inPreferencesMap searchKey
        !mBoundObjectName
        ?4*
        ?@observablePropertyMap preferenceObservableAttributeMap
        ?*
      ] ;
      [preferenceObservableAttributeMap searchKey
        !mBoundPropertyName
        ?observablePropertyType
        ?*
        ?*
      ] ;
      observedObjectName := "g_" . mBoundObjectName ;
      ioImplementationFileInclusionSet += !mBoundObjectName->string ;
    end if ;
#    if [inObservableObjectMap hasKey !mBoundObjectName->string] then
#      @string includeFile ;
#      [inObservableObjectMap searchKey
#        ![@lstring new !mBoundObjectName->string !here]
#        ?observedObjectOCName
#        ?*
#        ?includeFile
#        ?observablePropertyMap
#       ] ;
#       ioImplementationFileInclusionSet += !includeFile ;
#    else
#      error mBoundObjectName
#        : "the '" . mBoundObjectName . "' object is not observable"
#        : observedObjectOCName, observablePropertyMap
#      ;
#    end if ;
#    @easyBindingType observablePropertyType ;
#    [observablePropertyMap searchKey !mBoundPropertyName ?observablePropertyType ?2*] ;
#    @string observableKeyPath := mBoundPropertyName->string ;
  #----------------------------------------- check model belongs to an acceptable type
    @bool found := false ;
    @formatterEnum requiredFormatter [noFormatter] ;
    foreach acceptableTypeFormatterList while not found do
      requiredFormatter := mRequiredFormatter ;
      found := mType == observablePropertyType ;
    end foreach ;
    if not found then
      @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
      foreach acceptableTypeFormatterList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mBoundPropertyName:s ;
    end if ;
  #--- Check options
    @2stringlist bindingOptionList [emptyList] ;
    if mNegate then
      bindingOptionList += !"NSValueTransformerName" !"NSNegateBooleanTransformerName" ;
    end if ;
    foreach mOutletBindingOptionList do
      @easyBindingTypeList acceptableTypeList ;
      [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
      @bool found := false ;
      foreach acceptableTypeList while not found do
        foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
          found := mType == optionValue_mType ;
        end foreach ;
      end foreach ;
      if not found then
        @string s := "the option value acceptable types are:" ;
        foreach acceptableTypeList while not found do
          s .= "\n  - '" . [mType ebTypeName] . "'" ;
        end foreach ;
        error mOptionName:s ;
      end if ;
      bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
    end foreach ;
    ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
      !generatedBindingName
      !requiredFormatter
      !observedObjectName
      !mBoundPropertyName->string
      !bindingOptionList
    ] ;
  #---
    idx ++ ;
    generatedBindingName := mBindingName->string . idx ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzePreference
  ??@preferencesDeclarationList.element inPreference
  ??@outletClassMap inOutletClassMap
  ?!@preferencesMap ioPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------------- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in inPreference->mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#------------------------------------- Analyze attributes
  @observablePropertyMap observableAttributeMap [emptyMap] ;
  @attributeListForImplementation attributeListForImplementation [emptyList] ;
  foreach inPreference->mAttributeList do
    checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
    attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
    const @lstring observationDependencyKey [new
      !"preference." . inPreference->mPreferencesName->string . "." . mAttributeName
      !mAttributeName->location
    ] ;
    [!?observableAttributeMap insertKey
      !mAttributeName
      !mType
      !false # is not transient
      !observationDependencyKey->string
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#------------------------------------- Analyze transient properties
  @transientListForImplementation transientListForImplementation ;
  @stringset implementationFileInclusionSet [emptySet] ;
  analyzeTransientProperties
    ![@preferencesMap emptyMap]
    !"preference." . inPreference->mPreferencesName . "."
    !inPreference->mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !"" # No Root entity
    ![@controllerMap emptyMap]
    !?observableAttributeMap
    !?implementationFileInclusionSet
    ?transientListForImplementation
    !?ioTransientDependencyGraph
  ;
#------------------------------------- Analyze outlets
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach inPreference->mOutletDeclarationList do
    @outletClassBindingMap bindingMap ;
    @bool hasTableValueBinding ;
    [inOutletClassMap searchKey !mOutletType ?2* ?bindingMap ?hasTableValueBinding] ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        ![@observablePropertyMap emptyMap]
        !observableAttributeMap
        ![@preferencesMap emptyMap]
        ![@entityMap emptyMap]
        !bindingMap
        ![@controllerMap emptyMap]
        !actionMap
        !hasTableValueBinding
        !?outletBindingList
        !?implementationFileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList += ![mOutletType string] ![mOutletName string] !outletBindingList ;
  end foreach ;
#------------------------------------- Enter in preference map
  [!?implementationFileInclusionSet removeKey !""] ;
  [!?ioPreferencesMap insertKey
    !inPreference->mPreferencesName
    !attributeListForImplementation
    !transientListForImplementation
    !outletGenerationList
    !inPreference->mActionDeclarationList
    !observableAttributeMap
    !implementationFileInclusionSet
  ] ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzePreferences
  ??@preferencesDeclarationList inPreferencesList
  ??@outletClassMap inOutletClassMap
  !@preferencesMap outPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outPreferencesMap := [@preferencesMap emptyMap] ;
  for preference in inPreferencesList do
    analyzePreference
      !preference
      !inOutletClassMap
      !?outPreferencesMap
      !?ioTransientDependencyGraph
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

reader @easyBindingType ebTypeIdentifier ??@string inClassOrEntityName -> @string outResult :
  switch selfcopy
  when boolType : outResult := "bool" ;
  when integerType : outResult := "integer" ;
  when uintegerType : outResult := "unsignedInteger" ;
  when decimalType : outResult := "decimal" ;
  when floatType : outResult := "float" ;
  when doubleType : outResult := "double" ;
  when stringType : outResult := "NSString" ;
  when dataType : outResult := "NSData" ;
  when dateType : outResult := "NSDate" ;
  when fontType : outResult := "NSFont" ;
  when imageType : outResult := "NSImage" ;
  when colorType : outResult := "NSColor" ;
  when toManyEntitiesType : outResult := "toMany[" . inClassOrEntityName . "]" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

local routine checkBindingOptions
  ??@outletBindingOptionList inBindingOptionListAST
  ??@outletClassBindingOptionMap inAvailableBindingOptionMap
  !@2stringlist outBindingOptionListForGeneration
:
  outBindingOptionListForGeneration := [@2stringlist emptyList] ;
  foreach inBindingOptionListAST do
    @easyBindingTypeList acceptableTypeList ;
    [inAvailableBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    outBindingOptionListForGeneration += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@observablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
;

#----------------------------------------------------------------------------*

override method @regularPreferenceBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@observablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mBindingName: "a preference does not implement the $" . mBindingName . " binding" ;
end method ;

#----------------------------------------------------------------------------*

override method @multiValuedBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@observablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mBindingName: "a controller does not implement the $" . mBindingName . " binding" ;
end method ;

#----------------------------------------------------------------------------*

override method @tableValueBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@observablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mControllerName: "a controller does not implement $tableValue binding" ;
end method ;

#----------------------------------------------------------------------------*

override method @runBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@observablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mTargetName: "a controller does not implement $run action" ;
end method ;

#----------------------------------------------------------------------------*

override method @regularControllerBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@observablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mBindingName: "a controller does not implement $" . mBindingName . " binding" ;
#  @string resultingObservedObjectName ;
#  @string resultingObservedPropertyPath ;
#  if mObservedObjectName->string == "root" then
#    resultingObservedObjectName := "mRootObjectController" ;
#    resultingObservedPropertyPath := "selection." . mObservableAttributeName ;
#  else
#    error mObservedObjectName
#    : "observed object should be 'root'"
#    : resultingObservedObjectName, resultingObservedPropertyPath
#    ;
#  end if ;
#  @string boundTypeIdentifierString ;
#  if [inAllObservablePropertyMap hasKey !mObservableAttributeName->string] then
#    @easyBindingType t ;
#    [inAllObservablePropertyMap searchKey !mObservableAttributeName ?t ?2*] ;
#    boundTypeIdentifierString := [t ebTypeIdentifier !""] ;
#  elsif [inAllRelationshipMap hasKey !mObservableAttributeName->string] then
#    @bool isToMany ;
#    @lstring destinationEntityName ;
#    [inAllRelationshipMap searchKey !mObservableAttributeName ?isToMany ?destinationEntityName ?2*] ;
#    if isToMany then
#      boundTypeIdentifierString := "toMany[" . destinationEntityName . "]" ;
#    else
#      boundTypeIdentifierString := "toOne[" . destinationEntityName . "]" ;
#    end if ;
#  else
#    error mObservableAttributeName
#    :"unknown property"
#    : boundTypeIdentifierString ;
#  end if ;
#  @easyBindingTypeAndFormatterList acceptableTypeList ;
#  @outletClassBindingOptionMap availableBindingOptionMap ;
#  [inControllerClassBindingMap searchKey !mBindingName ?acceptableTypeList ?availableBindingOptionMap] ;
#  @bool found := false ;
#  @string acceptableTypesString := "" ;
#  foreach acceptableTypeList while not found do
#     const @string acceptableType := [mType ebTypeIdentifier !inControlledClassOrEntityName->string] ;
#     acceptableTypesString .= "\n-  '" . acceptableType . "'" ;
#     found := boundTypeIdentifierString == acceptableType ;
#  end foreach ;
#  if not found then
#    error mObservableAttributeName
#    :"cannot bind: property type is '" . boundTypeIdentifierString . "', acceptable type(s):" . acceptableTypesString
#    ;
#  end if ;
#  checkBindingOptions
#    !mOutletBindingOptionList
#    !availableBindingOptionMap
#    ?@2stringlist bindingOptionListForGeneration
#  ;
#  ioBindingListForGeneration += ![@regularBindingForGeneration new
#    !mBindingName->string
#    ![@formatterEnum noFormatter]
#    !resultingObservedObjectName
#    !resultingObservedPropertyPath
#    !bindingOptionListForGeneration
#  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularRootBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@observablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
:
  @string boundTypeIdentifierString ;
  if [inAllObservablePropertyMap hasKey !mObservableAttributeName->string] then
    @easyBindingType t ;
    [inAllObservablePropertyMap searchKey !mObservableAttributeName ?t ?2*] ;
    boundTypeIdentifierString := [t ebTypeIdentifier !""] ;
  elsif [inAllRelationshipMap hasKey !mObservableAttributeName->string] then
    @bool isToMany ;
    @lstring destinationEntityName ;
    [inAllRelationshipMap searchKey !mObservableAttributeName ?isToMany ?destinationEntityName ?2*] ;
    if isToMany then
      boundTypeIdentifierString := "toMany[" . destinationEntityName . "]" ;
    else
      boundTypeIdentifierString := "toOne[" . destinationEntityName . "]" ;
    end if ;
  else
    error mObservableAttributeName
    :"unknown property"
    : boundTypeIdentifierString ;
  end if ;
  @easyBindingTypeAndFormatterList acceptableTypeList ;
  @outletClassBindingOptionMap availableBindingOptionMap ;
  [inControllerClassBindingMap searchKey !mBindingName ?acceptableTypeList ?availableBindingOptionMap] ;
  @bool found := false ;
  @string acceptableTypesString := "" ;
  foreach acceptableTypeList while not found do
     const @string acceptableType := [mType ebTypeIdentifier !inControlledClassOrEntityName->string] ;
     acceptableTypesString .= "\n-  '" . acceptableType . "'" ;
     found := boundTypeIdentifierString == acceptableType ;
  end foreach ;
  if not found then
    error mObservableAttributeName
    :"cannot bind: property type is '" . boundTypeIdentifierString . "', acceptable type(s):" . acceptableTypesString
    ;
  end if ;
  checkBindingOptions
    !mOutletBindingOptionList
    !availableBindingOptionMap
    ?@2stringlist bindingOptionListForGeneration
  ;
  ioBindingListForGeneration += ![@regularBindingForGeneration new
    !mBindingName->string
    ![@formatterEnum noFormatter]
    !"mRootObjectController"
    !"selection." . mObservableAttributeName
    !bindingOptionListForGeneration
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularSelfBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@observablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
:
  @string boundTypeIdentifierString ;
  if [inAllObservablePropertyMap hasKey !mObservableAttributeName->string] then
    @easyBindingType t ;
    [inAllObservablePropertyMap searchKey !mObservableAttributeName ?t ?2*] ;
    boundTypeIdentifierString := [t ebTypeIdentifier !""] ;
  elsif [inAllRelationshipMap hasKey !mObservableAttributeName->string] then
    @bool isToMany ;
    @lstring destinationEntityName ;
    [inAllRelationshipMap searchKey !mObservableAttributeName ?isToMany ?destinationEntityName ?2*] ;
    if isToMany then
      boundTypeIdentifierString := "toMany[" . destinationEntityName . "]" ;
    else
      boundTypeIdentifierString := "toOne[" . destinationEntityName . "]" ;
    end if ;
  else
    error mObservableAttributeName
    :"unknown property"
    : boundTypeIdentifierString ;
  end if ;
  @easyBindingTypeAndFormatterList acceptableTypeList ;
  @outletClassBindingOptionMap availableBindingOptionMap ;
  [inControllerClassBindingMap searchKey !mBindingName ?acceptableTypeList ?availableBindingOptionMap] ;
  @bool found := false ;
  @string acceptableTypesString := "" ;
  foreach acceptableTypeList while not found do
     const @string acceptableType := [mType ebTypeIdentifier !inControlledClassOrEntityName->string] ;
     acceptableTypesString .= "\n-  '" . acceptableType . "'" ;
     found := boundTypeIdentifierString == acceptableType ;
  end foreach ;
  if not found then
    error mObservableAttributeName
    :"cannot bind: property type is '" . boundTypeIdentifierString . "', acceptable type(s):" . acceptableTypesString
    ;
  end if ;
  checkBindingOptions
    !mOutletBindingOptionList
    !availableBindingOptionMap
    ?@2stringlist bindingOptionListForGeneration
  ;
  ioBindingListForGeneration += ![@regularBindingForGeneration new
    !mBindingName->string
    ![@formatterEnum noFormatter]
    !"self"
    !mObservableAttributeName->string
    !bindingOptionListForGeneration
  ] ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzeDocument
  ??@documentDeclarationList.element inDocument
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@preferencesMap inPreferencesMap
  ?!@documentMap ioDocumentMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------------------------ Get root object features
  [inEntityMap searchKey
    !inDocument->mRootEntityName
    ?*
    ?@string rootEntityImplementationClassName
    ?*
    ?@observablePropertyMap rootObjectObservablePropertyMap
    ?8*
    ?@relationshipMap allRelationshipMap
    ?2*
  ] ;
#-------------------------------------------------- Analyze controllers
  @observablePropertyMap observablePropertyMap [emptyMap] ;
  @controllerMap controllerMap [emptyMap] ;
  foreach inDocument->mControllerList do
    @outletClassBindingMap controllerClassBindingMap ;
    @actionMap controllerActionMap ;
    @observablePropertyMap controllerObservablePropertyMap ;
    [inControllerClassMap searchKey
      !mControllerClassName
      ?*
      ?controllerClassBindingMap
      ?controllerActionMap
      ?controllerObservablePropertyMap
    ] ;
    @observablePropertyMap prefixedControllerObservablePropertyMap [emptyMap] ;
    foreach controllerObservablePropertyMap do
#        const @lstring observedKey [new
#          !"controller." . mControllerName . "." . mObservationDependancyKey
#          !mObservationDependancyKey->location
#        ] ;
#        [!?prefixedControllerObservablePropertyMap insertKey
#          !lkey
#          !mType
#          !false
#        ] ;
#        [!?ioTransientDependencyGraph addNode
#          !observedKey
#          !observedKey->string
#        ] ;
    end foreach ;
#    [!?observableObjectMap insertKey
#      !mControllerName
#      !mControllerName->string
#      !"?"
#      !"" # No file to include
#      !prefixedControllerObservablePropertyMap
#    ] ;
    [inEntityMap searchKey !mControlledClassOrEntityName ?15*] ;
    @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
    foreach mControllerBindingList do
      [mBinding analyzeControllerBinding
        !allRelationshipMap
        !controllerClassBindingMap
        !mControlledClassOrEntityName
        !observablePropertyMap
        !?bindingListForGeneration
      ] ;
    end foreach ;
    [!?controllerMap insertKey
      !mControllerName
      !mControllerClassName->string
      !mControlledClassOrEntityName->string
      !bindingListForGeneration
      !controllerActionMap
      !controllerObservablePropertyMap
    ] ;
  end foreach ;
#-------------------------------------------------- Analyze transient properties
  @transientListForImplementation transientListForImplementation ;
  @stringset implementationFileInclusionSet [emptySet] ;
  analyzeTransientProperties
    !inPreferencesMap
    !"document." . inDocument->mDocumentName . "."
    !inDocument->mTransientList
    !rootObjectObservablePropertyMap
    !inDocument->mRootEntityName->string
    !controllerMap
    !?observablePropertyMap
    !?implementationFileInclusionSet
    ?transientListForImplementation
    !?ioTransientDependencyGraph
  ;
#--------------------------------------------------- Analyze actions
  @actionMap documentActionMap [emptyMap] ;
  for actionName in inDocument->mActionDeclarationList do
    [!?documentActionMap insertKey !actionName->mValue] ;
  end for ;
#--------------------------------------------------- Analyze outlets and bindings
  @outletGenerationList outletGenerationList [emptyList] ;
  foreach inDocument->mOutletDeclarationList do
    @outletClassBindingMap bindingMap ;
    @bool hasTableValueBinding ;
    [inOutletClassMap searchKey !mOutletType ?2* ?bindingMap ?hasTableValueBinding] ;
    @outletBindingListForGeneration outletBindingList [emptyList] ;
    foreach mOutletBindingList do
      [mBinding analyzeOutletBinding
        !rootObjectObservablePropertyMap
        !observablePropertyMap
        !inPreferencesMap
        !inEntityMap
        !bindingMap
        !controllerMap
        !documentActionMap
        !hasTableValueBinding
        !?outletBindingList
        !?implementationFileInclusionSet
      ] ;
    end foreach ;
    outletGenerationList += ![mOutletType string] ![mOutletName string] !outletBindingList ;
  end foreach ;
#--------------------------------------------------- Enter in document map
  [!?implementationFileInclusionSet removeKey !""] ;
  [!?ioDocumentMap insertKey
    !inDocument->mDocumentName
    !inDocument->mRootEntityName->string
    !rootEntityImplementationClassName
    !outletGenerationList
    !controllerMap
    !inDocument->mActionDeclarationList
    !transientListForImplementation
    !implementationFileInclusionSet
  ] ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeDocuments
  ??@documentDeclarationList inDocumentDeclarationList
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@preferencesMap inPreferencesMap
  !@documentMap outDocumentMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outDocumentMap := [@documentMap emptyMap] ;
  for document in inDocumentDeclarationList do
    analyzeDocument
      !document
      !inOutletClassMap
      !inControllerClassMap
      !inEntityMap
      !inPreferencesMap
      !?outDocumentMap
      !?ioTransientDependencyGraph
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

local routine checkDefaultValueType
  ??@easyBindingTypeList inDefaultValueCorrespondingAcceptableTypes
  ??@easyBindingType inAttributeActualType
  ??@lstring inAttributeName
:
  @bool found := false ;
  foreach inDefaultValueCorrespondingAcceptableTypes while not found do
    found := inAttributeActualType == mType ;
  end foreach ;
  if not found then
    error inAttributeName: "the default value is invalue for this attribute" ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeClass
  ??@classList.element inClass
  ?!@classMap ioClassMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
#------------------------------- Super class ?
  @observablePropertyMap observablePropertyMap ;
  @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
  if [inClass->mSuperClassName string] != "" then
    [ioClassMap searchKey !inClass->mSuperClassName ?* ?observablePropertyMap ?propertyListForInitMethodHeader ?4*] ;
  else
    observablePropertyMap := [@observablePropertyMap emptyMap] ;
    propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
  end if ;
#---------------------------------- Analyze attributes
  @attributeListForImplementation attributeListForImplementation [emptyList] ;
  const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
  foreach inClass->mAttributeList do
    checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
    attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
    propertyListForInitMethodHeader += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
    const @lstring observationDependencyKey [new
      !"class." . inClass->mClassName . "." . mAttributeName
      !mAttributeName->location
    ] ;
    [!?observablePropertyMap insertKey
      !mAttributeName
      !mType
      !false # is not transient
      !observationDependencyKey->string
    ] ;    
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
  end foreach ;
#---------------------------------- Analyze transient properties
  @transientListForImplementation transientListForImplementation ;
  @stringset implementationFileInclusionSet [emptySet] ;
  analyzeTransientProperties
    ![@preferencesMap emptyMap]
    !"class." . inClass->mClassName . "."
    !inClass->mTransientList
    ![@observablePropertyMap emptyMap] # Root property map
    !"" # No Root entity
    ![@controllerMap emptyMap]
    !?observablePropertyMap
    !?implementationFileInclusionSet
    ?transientListForImplementation
    !?ioTransientDependencyGraph
  ;
#----------------------------------
  [!?implementationFileInclusionSet removeKey !""] ;
  [!?ioClassMap insertKey
    !inClass->mClassName
    !inClass->mSuperClassName->string
    !observablePropertyMap
    !propertyListForInitMethodHeader
    !inheritedAttributeListForImplementation
    !attributeListForImplementation
    !transientListForImplementation
    !implementationFileInclusionSet
  ] ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeClasses
  ??@classList inClassList
  !@classMap outClassMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outClassMap := [@classMap emptyMap] ;
  for aClass in inClassList do
    analyzeClass
      !aClass
      !?outClassMap
      !?ioTransientDependencyGraph
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeOutletClasses
  ??@outletClassList inOutletClassList
  !@outletClassMap outOutletClassMap
:
  outOutletClassMap := [@outletClassMap emptyMap] ;
  foreach inOutletClassList do
  #---
    @outletClassBindingMap bindingMap [emptyMap] ;
    foreach mOutletClassBindingList do
      @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
      foreach mBindingOptionList do
        [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
#        foreach mAcceptableTypeList do
#        
#        
#        end foreach ;
      end foreach ;
      [!?bindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
    end foreach ;
  #---
    [!?outOutletClassMap insertKey
      !mOutletClassName
      !mGenerateCode
      !mSuperClassName->string
      !bindingMap
      !mHasTableValueBinding
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeControllerClass
  ??@controllerClassList.element inController
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ?!@controllerClassMap ioControllerClassMap
:
#--- Analyze actions
  @actionMap actionMap [emptyMap] ;
  for actionName in inController->mActionDeclarationList do
    [!?actionMap insertKey !actionName->mValue] ;
  end for ;
#---
  @outletClassBindingMap bindingMap [emptyMap] ;
  foreach inController->mBindingList do
    @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
    foreach mBindingOptionList do
      [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
#        foreach mAcceptableTypeList do
#        
#        
#        end foreach ;
    end foreach ;
    [!?bindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
  end foreach ;
#---
  @observablePropertyMap observablePropertyMap [emptyMap] ;
  for property in inController->mControllerObservablePropertyList do
    const @lstring observationDependencyKey [new
      !"controller." . inController->mControllerClassName . "." . property->mPropertyName
      !property->mPropertyName->location
    ] ;
    [!?ioTransientDependencyGraph addNode
      !observationDependencyKey
      !observationDependencyKey->string
    ] ;
    [!?observablePropertyMap insertKey
      !property->mPropertyName
      !property->mType
      !false # is not transient
      !observationDependencyKey->string
    ] ;
  end for ;
#---
  [!?ioControllerClassMap insertKey
    !inController->mControllerClassName
    !inController->mGenerateCode
    !bindingMap
    !actionMap
    !observablePropertyMap
  ] ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeControllerClasses
  ??@controllerClassList inControllerClassList
  ?!@transientDependencyGraph ioTransientDependencyGraph
  !@controllerClassMap outControllerClassMap
:
  outControllerClassMap := [@controllerClassMap emptyMap] ;
  for controller in inControllerClassList do
    analyzeControllerClass
      !controller
      !?ioTransientDependencyGraph
      !?outControllerClassMap
    ;
  end for ;
end routine ;

#----------------------------------------------------------------------------*

routine semanticAnalysis
  ??@ASTstruct inAST
  ?@string inSourceFilePath
  !@outletClassMap outOutletClassMap
  !@controllerClassMap outControllerClassMap
  !@classMap outClassMap
  !@entityMap outEntityMap
  !@preferencesMap outPreferencesMap
  !@documentMap outDocumentMap
  !@stringlist outSortedTransientOrderedList
  !@2stringlist outTransientDependencyArcList
:
  outSortedTransientOrderedList := [@stringlist emptyList] ;
  @transientDependencyGraph transientDependencyGraph [emptyGraph] ;
  analyzeOutletClasses !inAST->mOutletClassList ?outOutletClassMap ;
  analyzeControllerClasses !inAST->mControllerClassList !?transientDependencyGraph ?outControllerClassMap ;
  analyzePreferences
    !inAST->mPreferencesList
    !outOutletClassMap
    ?outPreferencesMap
    !?transientDependencyGraph
  ;
  analyzeClasses 
    !inAST->mClassList
    ?outClassMap
    !?transientDependencyGraph
  ;
  analyzeEntities
    !inAST->mEntityList
    ?outEntityMap
    !outPreferencesMap
    !?transientDependencyGraph
  ;
  analyzeDocuments
    !inAST->mDocumentDeclarationList
    !outOutletClassMap
    !outControllerClassMap
    !outEntityMap
    !outPreferencesMap
    ?outDocumentMap
    !?transientDependencyGraph
  ;
#--- Output graphviz file ?
  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
    const @string s := [transientDependencyGraph graphviz] ;
    const @string path := inSourceFilePath . ".transientDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#--- Analyze transient dependencies
  outTransientDependencyArcList := [transientDependencyGraph arcs] ;
  if [@uint errorCount] == 0 then
    if [transientDependencyGraph undefinedNodeCount] > 0 then
      foreach [transientDependencyGraph undefinedNodeKeyList] do
        error inAST->mEndOfSourceFile : "the '" . mValue . "' property is not defined" ;
      end foreach ;
    else
      @stringlist unsortedTransientList ;
      [transientDependencyGraph topologicalSort
        ?outSortedTransientOrderedList
        ?*
        ?unsortedTransientList
        ?*
      ] ;
      if [unsortedTransientList length] > 0 then
        @string s := [[unsortedTransientList length] string] . " transient declarations are involved in circular dependancies:" ;
        foreach unsortedTransientList do
          s .= "\n-  " . mValue ;
        end foreach ;
        error inAST->mEndOfSourceFile : s ;
      else # all defined, no circularity
      end if ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*


end semantics ;
