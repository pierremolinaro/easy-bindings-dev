semantics semanticAnalysis :
  import "easyBindings_options.gOption" ;
  import "abstractSyntaxTree.gSemantics" ;

#----------------------------------------------------------------------------*

reader @easyBindingType ocTypeName -> @string outResult :
  switch selfcopy
  when boolType : outResult := "BOOL" ;
  when integer16Type : outResult := "SInt16" ;
  when integer32Type : outResult := "SInt32" ;
  when integer64Type : outResult := "SInt64" ;
  when decimalType : outResult := "NSDecimal" ;
  when floatType : outResult := "float" ;
  when doubleType : outResult := "double" ;
  when stringType : outResult := "NSString *" ;
  when fontType : outResult := "NSFont *" ;
  when imageType : outResult := "NSImage *" ;
  when colorType : outResult := "NSColor *" ;
  when dataType : outResult := "NSData *" ;
  when dateType : outResult := "NSDate *" ;
  when toManyEntitiesType : outResult := "??" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @easyBindingType propertyAttributeString -> @string outResult :
  switch selfcopy
  when boolType, integer16Type, integer32Type, integer64Type,
       floatType, doubleType, decimalType,
       toManyEntitiesType : outResult := "" ;
  when stringType : outResult := "(copy)" ;
  when fontType, imageType, dataType : outResult := "" ;
  when colorType, dateType : outResult := "(assign)" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @easyBindingType copyOnAssign -> @bool outResult :
  switch selfcopy
  when boolType, integer16Type, integer32Type, integer64Type,
       floatType, doubleType, decimalType, toManyEntitiesType : outResult := false ;
  when stringType : outResult := true ;
  when fontType, imageType, colorType, dataType, dateType : outResult := false ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

map @classObservablePropertyMap {
  @easyBindingType mType ;
  @stringlist mPropertyDependancyList ; # Empty for a property
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#----------------------------------------------------------------------------*

list @attributeListForImplementation {
  @easyBindingType mType ;
  @string mPropertyName ;
  @string mDefaultValueAsObjectiveCObject ;
  @string mDirectDefaultValue ;
}

#----------------------------------------------------------------------------*

list @directDependancyList {
  @easyBindingType mMasterType ;
  @string mMasterName ;
}

#----------------------------------------------------------------------------*

list @transientListForImplementation {
  @easyBindingType mType ;
  @string mTransientName ;
  @directDependancyList mDependencyList ;
}

#----------------------------------------------------------------------------*

listmap @triggeredKeys (@stringlist) ;

#----------------------------------------------------------------------------*

map @classMap {
  @string mSuperClassName ;
  @classObservablePropertyMap mPropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @triggeredKeys mTriggeredKeys ;
  insert insertKey error message "the '%K' class is already declared" ;
  search searchKey error message "the '%K' class is not declared" ;
}

#----------------------------------------------------------------------------*

map @entityMap {
  @string mSuperEntityName ;
  @string mImplementationClassName ;
  @string mSuperImplementationClassName ;
  @classObservablePropertyMap mPropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @triggeredKeys mTriggeredKeys ;
  @relationshipList mCurrentRelationshipList ;
  @relationshipList mAllRelationshipList ;
  @propertyMap mAllPropertyMap ;
  @relationshipMap mCurrentRelationshipMap ;
  @relationshipMap mAllRelationshipMap ;
  insert insertKey error message "the '%K' entity is already declared" ;
  search searchKey error message "the '%K' entity is not declared" ;
}

#----------------------------------------------------------------------------*

list @outletBindingListForGeneration {
  @string mBindingName ;
  @formatterEnum mRequiredFormatter ;
  @string mObservedObjectName ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

list @outletGenerationList {
  @string mOutletType ;
  @string mOutletName ;
  @outletBindingListForGeneration mOutletBindingList ;
}

#----------------------------------------------------------------------------*

map @preferencesMap {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @triggeredKeys mTriggeredKeys ;
  @lstringlist mActionList ;
  insert insertKey error message "the '%K' preference is already declared" ;
  search searchKey error message "the '%K' preference is not declared" ;
}

#----------------------------------------------------------------------------*

map @documentMap {
  @string mRootEntityName ;
  @string mRootEntityImplementationClassName ;
  @outletGenerationList mOutletDeclarationList ;
  @controllerMap mControllerMap ;
  @lstringlist mActionList ;
  insert insertKey error message "the '%K' document is already declared" ;
  search searchKey error message "the '%K' document is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingOptionMap {
  @easyBindingTypeList mAcceptableTypeList ;
  insert insertKey error message "the '%K' binding option is already declared" ;
  search searchKey error message "the '%K' binding option is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingMap {
  @easyBindingTypeAndFormatterList mAcceptableTypeList ;
  @outletClassBindingOptionMap mOutletClassBindingOptionMap ;
  insert insertKey error message "the '%K' binding is already declared" ;
  search searchKey error message "the '%K' binding is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassMap {
  @bool mGenerateCode ;
  @string mSuperClassName ;
  @outletClassBindingMap mBindingMap ;
  insert insertKey error message "the '%K' outlet class is already declared" ;
  search searchKey error message "the '%K' outlet class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerClassMap {
  @bool mGenerateCode ;
  @outletClassBindingMap mBindingMap ;
  @actionMap mActionMap ;
  insert insertKey error message "the '%K' controller class is already declared" ;
  search searchKey error message "the '%K' controller class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerMap {
  @string mControllerClassName ;
  @string mControlledClassOrEntityName ;
  @outletBindingListForGeneration mControllerBindingList ;
  @actionMap mActionMap ;
  insert insertKey error message "the '%K' controller is already declared" ;
  search searchKey error message "the '%K' controller is not declared" ;
}

#----------------------------------------------------------------------------*

map @relationshipMap {
  @bool mIsToMany ;
  @lstring mDestinationEntityName ;
  @lstring mInverseRelationshipName ;
  @deleteRuleEnum mDeleteRule ;
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
}

#----------------------------------------------------------------------------*

map @propertyMap {
  insert insertKey error message "there is already a '%K' property (attribute, transient or relationship)" ;
}

#----------------------------------------------------------------------------*

map @actionMap {
  insert insertKey error message "there is already a '%K' action" ;
  search searchKey error message "the '%K' action is not defined" ;
}

#----------------------------------------------------------------------------*
#   ANALYZE ENTITIES                                                         *
#----------------------------------------------------------------------------*

local routine analyzeEntities
  ??@entityList inEntityList
  !@entityMap outEntityMap
:
  outEntityMap := [@entityMap emptyMap] ;
  foreach inEntityList do
    @classObservablePropertyMap classObservablePropertyMap ;
    @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
    @relationshipList allRelationshipList ;
    @string implementationSuperClassName ;
    @propertyMap allPropertyMap ;
    @relationshipMap allRelationshipMap ;
    if [mSuperEntityName string] != "" then
      [outEntityMap searchKey
        !mSuperEntityName
        ?*
        ?implementationSuperClassName
        ?*
        ?classObservablePropertyMap
        ?propertyListForInitMethodHeader
        ?5*
        ?allRelationshipList
        ?allPropertyMap
        ?*
        ?allRelationshipMap
      ] ;
    else
      classObservablePropertyMap := [@classObservablePropertyMap emptyMap] ;
      propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
      implementationSuperClassName := "" ;
      allRelationshipList := [@relationshipList emptyList] ;
      allPropertyMap := [@propertyMap emptyMap] ;
      allRelationshipMap := [@relationshipMap emptyMap] ;
    end if ;
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    @transientListForImplementation transientListForImplementation [emptyList] ;
    const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
  #--- Analyze attributes
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      [!?allPropertyMap insertKey !mAttributeName] ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      propertyListForInitMethodHeader += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      [!?classObservablePropertyMap insertKey !mAttributeName !mType ![@stringlist listWithValue![mAttributeName string]]] ;    
    end foreach ;
  #--- Analyze relationship (only check name is unique)
    @relationshipMap currentRelationshipMap [emptyMap] ;
    foreach mRelationshipList do
      [!?allRelationshipMap insertKey
        !mRelationshipName
        !mIsToMany
        !mDestinationEntityName
        !mInverseRelationshipName
        !mDeleteRule
      ] ;
      [!?currentRelationshipMap insertKey
        !mRelationshipName
        !mIsToMany
        !mDestinationEntityName
        !mInverseRelationshipName
        !mDeleteRule
      ] ;
      [!?allPropertyMap insertKey !mRelationshipName] ;
    end foreach ;
  #--- Analyze transient properties
    @triggeredKeys triggeredKeys [emptyMap] ;
    foreach mTransientList do
      [!?allPropertyMap insertKey !mTransientName] ;
      @stringlist allPropertyDependancyList [emptyList] ;
      @directDependancyList directDependancyList [emptyList] ;
      foreach mDependencyList do
        @easyBindingType type ;
        @stringlist propertyDependancyList ;
        [classObservablePropertyMap searchKey !mValue ?type ?propertyDependancyList] ;
        directDependancyList += !type ![mValue string] ;
        foreach propertyDependancyList do 
          triggeredKeys += !mValue ![mTransientName string] ;
        end foreach ;
        allPropertyDependancyList .= propertyDependancyList ;
      end foreach ;
      transientListForImplementation += !mType ![mTransientName string] !directDependancyList ;
      [!?classObservablePropertyMap insertKey !mTransientName !mType !allPropertyDependancyList] ;    
    end foreach ;
  #---
    [!?outEntityMap insertKey
      !mEntityName
      ![mSuperEntityName string]
      ![mImplementationClassName string]
      !implementationSuperClassName
      !classObservablePropertyMap
      !propertyListForInitMethodHeader
      !inheritedAttributeListForImplementation
      !attributeListForImplementation
      !transientListForImplementation
      !triggeredKeys
      !mRelationshipList
      !allRelationshipList . mRelationshipList
      !allPropertyMap
      !currentRelationshipMap
      !allRelationshipMap
    ] ;
  end foreach ;
#--- Check relationships
  foreach outEntityMap do
    foreach mCurrentRelationshipMap do
      @relationshipMap destinationEntityRelationshipMap ;
      [outEntityMap searchKey !mDestinationEntityName ?13* ?destinationEntityRelationshipMap] ;
      @lstring inverseOfInverseRelationshipName ;
      [destinationEntityRelationshipMap searchKey !mInverseRelationshipName ?2* ?inverseOfInverseRelationshipName ?*] ;
      if lkey->string != inverseOfInverseRelationshipName->string then
        error mInverseRelationshipName : "the inverse relationship does not name '" . lkey . "' relationship as inverse" ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeOutletBinding
  ??@classObservablePropertyMap inObservableAttributeMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@string inRequiredPrefix
  ??@string inRequiredPrefixErrorMessage
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
;

#----------------------------------------------------------------------------*

override method @runBinding analyzeOutletBinding
  ??@classObservablePropertyMap unused inObservableAttributeMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@string unused inRequiredPrefix
  ??@string unused inRequiredPrefixErrorMessage
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
:
  if mTargetName->string == "self" then
    [inActionMap searchKey !mActionName] ;
  else
    @actionMap actionMap ;
    [inControllerMap searchKey !mTargetName ?3* ?actionMap] ;
    [actionMap searchKey !mActionName] ;
  end if ;
  ioOutletBindingListForGeneration +=
    !"run"
    ![@formatterEnum noFormatter]
    !mTargetName->string
    !mActionName->string
    ![@2stringlist emptyList]
  ;
end method ;

#----------------------------------------------------------------------------*

override method @regularBinding analyzeOutletBinding
  ??@classObservablePropertyMap inObservableAttributeMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@string inRequiredPrefix
  ??@string inRequiredPrefixErrorMessage
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
:
  @outletClassBindingOptionMap outletClassBindingOptionMap ;
  @easyBindingTypeAndFormatterList acceptableTypeFormatterList ;
  [inBindingMap searchKey !mBindingName ?acceptableTypeFormatterList ?outletClassBindingOptionMap] ;
#--- Find preferences observable property
  if mObservedObjectName->string != inRequiredPrefix then
    error mObservedObjectName: inRequiredPrefixErrorMessage ;
  end if ;
  @easyBindingType observablePropertyType ;
  [inObservableAttributeMap searchKey !mObservableAttributeName ?observablePropertyType ?*] ;
#--- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mObservableAttributeName:s ;
  end if ;
#--- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
  ioOutletBindingListForGeneration +=
    ![mBindingName string]
    !requiredFormatter
    !"self"
    ![mObservableAttributeName string]
    !bindingOptionList
  ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzePreferences
  ??@preferencesDeclarationList inPreferencesList
  ??@outletClassMap inOutletClassMap
  !@preferencesMap outPreferencesMap
:
  outPreferencesMap := [@preferencesMap emptyMap] ;
  foreach inPreferencesList do
    @classObservablePropertyMap observableAttributeMap [emptyMap] ;
  #--- Analyze actions
    @actionMap actionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?actionMap insertKey !actionName->mValue] ;
    end for ;
  #--- Analyze attributes
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    @transientListForImplementation transientListForImplementation [emptyList] ;
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      [!?observableAttributeMap insertKey !mAttributeName !mType ![@stringlist listWithValue![mAttributeName string]]] ;
    end foreach ;
  #--- Analyze transient properties
    @triggeredKeys triggeredKeys [emptyMap] ;
    foreach mTransientList do
      @stringlist allPropertyDependancyList [emptyList] ;
      @directDependancyList directDependancyList [emptyList] ;
      foreach mDependencyList do
        @easyBindingType type ;
        @stringlist propertyDependancyList ;
        [observableAttributeMap searchKey !mValue ?type ?propertyDependancyList] ;
        directDependancyList += !type ![mValue string] ;
        foreach propertyDependancyList do 
          triggeredKeys += !mValue ![mTransientName string] ;
        end foreach ;
        allPropertyDependancyList .= propertyDependancyList ;
      end foreach ;
      transientListForImplementation += !mType ![mTransientName string] !directDependancyList ;
      [!?observableAttributeMap insertKey !mTransientName !mType !allPropertyDependancyList] ;    
    end foreach ;
  #--- Analyze outlets
    @outletGenerationList outletGenerationList [emptyList] ;
    foreach mOutletDeclarationList do
      @outletClassBindingMap bindingMap ;
      [inOutletClassMap searchKey !mOutletType ?2* ?bindingMap] ;
      @outletBindingListForGeneration outletBindingList [emptyList] ;
      foreach mOutletBindingList do
        [mBinding analyzeOutletBinding
          !observableAttributeMap
          !bindingMap
          ![@controllerMap emptyMap]
          !actionMap
          !""
          !"no prefix allowed here"
          !?outletBindingList
        ] ;
      end foreach ;
      outletGenerationList += ![mOutletType string] ![mOutletName string] !outletBindingList ;
    end foreach ;
  #---
    [!?outPreferencesMap insertKey
      !mPreferencesName
      !attributeListForImplementation
      !transientListForImplementation
      !outletGenerationList
      !triggeredKeys
      !mActionDeclarationList
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

reader @easyBindingType ebTypeIdentifier ??@string inClassOrEntityName -> @string outResult :
  switch selfcopy
  when boolType : outResult := "bool" ;
  when integer16Type : outResult := "integer16" ;
  when integer32Type : outResult := "integer32" ;
  when integer64Type : outResult := "integer64" ;
  when decimalType : outResult := "decimal" ;
  when floatType : outResult := "float" ;
  when doubleType : outResult := "double" ;
  when stringType : outResult := "NSString" ;
  when dataType : outResult := "NSData" ;
  when dateType : outResult := "NSDate" ;
  when fontType : outResult := "NSFont" ;
  when imageType : outResult := "NSImage" ;
  when colorType : outResult := "NSColor" ;
  when toManyEntitiesType : outResult := "toMany[" . inClassOrEntityName . "]" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

local routine checkBindingOptions
  ??@outletBindingOptionList inBindingOptionListAST
  ??@outletClassBindingOptionMap inAvailableBindingOptionMap
  !@2stringlist outBindingOptionListForGeneration
:
  outBindingOptionListForGeneration := [@2stringlist emptyList] ;
  foreach inBindingOptionListAST do
    @easyBindingTypeList acceptableTypeList ;
    [inAvailableBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    outBindingOptionListForGeneration += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@classObservablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
;

#----------------------------------------------------------------------------*

override method @runBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@classObservablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
:

end method ;

#----------------------------------------------------------------------------*

override method @regularBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@classObservablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
:
  @string resultingObservedObjectName ;
  @string resultingObservedPropertyPath ;
  if mObservedObjectName->string == "root" then
    resultingObservedObjectName := "mRootObjectController" ;
    resultingObservedPropertyPath := "selection." . mObservableAttributeName ;
  else
    error mObservedObjectName
    : "observed object should be 'root'"
    : resultingObservedObjectName, resultingObservedPropertyPath
    ;
  end if ;
  @string boundTypeIdentifierString ;
  if [inAllObservablePropertyMap hasKey !mObservableAttributeName->string] then
    @easyBindingType t ;
    [inAllObservablePropertyMap searchKey !mObservableAttributeName ?t ?*] ;
    boundTypeIdentifierString := [t ebTypeIdentifier !""] ;
  elsif [inAllRelationshipMap hasKey !mObservableAttributeName->string] then
    @bool isToMany ;
    @lstring destinationEntityName ;
    [inAllRelationshipMap searchKey !mObservableAttributeName ?isToMany ?destinationEntityName ?2*] ;
    if isToMany then
      boundTypeIdentifierString := "toMany[" . destinationEntityName . "]" ;
    else
      boundTypeIdentifierString := "toOne[" . destinationEntityName . "]" ;
    end if ;
  else
    error mObservableAttributeName
    :"unknown property"
    : boundTypeIdentifierString ;
  end if ;
  @easyBindingTypeAndFormatterList acceptableTypeList ;
  @outletClassBindingOptionMap availableBindingOptionMap ;
  [inControllerClassBindingMap searchKey !mBindingName ?acceptableTypeList ?availableBindingOptionMap] ;
  @bool found := false ;
  @string acceptableTypesString := "" ;
  foreach acceptableTypeList while not found do
     const @string acceptableType := [mType ebTypeIdentifier !inControlledClassOrEntityName->string] ;
     acceptableTypesString .= "\n-  '" . acceptableType . "'" ;
     found := boundTypeIdentifierString == acceptableType ;
  end foreach ;
  if not found then
    error mObservableAttributeName
    :"cannot bind: property type is '" . boundTypeIdentifierString . "', acceptable type(s):" . acceptableTypesString
    ;
  end if ;
  checkBindingOptions
    !mOutletBindingOptionList
    !availableBindingOptionMap
    ?@2stringlist bindingOptionListForGeneration
  ;
  ioBindingListForGeneration +=
    !mBindingName->string
    ![@formatterEnum noFormatter]
    !resultingObservedObjectName
    !resultingObservedPropertyPath
    !bindingOptionListForGeneration
  ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzeDocuments
  ??@documentDeclarationList inDocumentDeclarationList
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  !@documentMap outDocumentMap
:
  outDocumentMap := [@documentMap emptyMap] ;
  foreach inDocumentDeclarationList do
    @string rootEntityImplementationClassName ;
    @classObservablePropertyMap observablePropertyMap ;
    @relationshipMap allRelationshipMap ;
    [inEntityMap searchKey
      !mRootEntityName
      ?*
      ?rootEntityImplementationClassName
      ?*
      ?observablePropertyMap
      ?9*
      ?allRelationshipMap
    ] ;
  #--- Analyze actions
    @actionMap documentActionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?documentActionMap insertKey !actionName->mValue] ;
    end for ;
  #--- Analyze controllers
    @controllerMap controllerMap [emptyMap] ;
    foreach mControllerList do
      @outletClassBindingMap controllerClassBindingMap ;
      @actionMap controllerActionMap ;
      [inControllerClassMap searchKey !mControllerClassName ?* ?controllerClassBindingMap ?controllerActionMap] ;
      [inEntityMap searchKey !mControlledClassOrEntityName ?14*] ;
      @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
      foreach mControllerBindingList do
        [mBinding analyzeControllerBinding
          !allRelationshipMap
          !controllerClassBindingMap
          !mControlledClassOrEntityName
          !observablePropertyMap
          !?bindingListForGeneration
        ] ;
      end foreach ;
      [!?controllerMap insertKey
        !mControllerName
        !mControllerClassName->string
        !mControlledClassOrEntityName->string
        !bindingListForGeneration
        !controllerActionMap
      ] ;
    end foreach ;
  #--- Analyze outlets
    @outletGenerationList outletGenerationList [emptyList] ;
    foreach mOutletDeclarationList do
      @outletClassBindingMap bindingMap ;
      [inOutletClassMap searchKey !mOutletType ?2* ?bindingMap] ;
      @outletBindingListForGeneration outletBindingList [emptyList] ;
      foreach mOutletBindingList do
        [mBinding analyzeOutletBinding
          !observablePropertyMap
          !bindingMap
          !controllerMap
          !documentActionMap
          !"root"
          !"'root' prefix is required here"
          !?outletBindingList
        ] ;
      end foreach ;
      outletGenerationList += ![mOutletType string] ![mOutletName string] !outletBindingList ;
    end foreach ;
  #---
    [!?outDocumentMap insertKey
      !mDocumentName
      ![mRootEntityName string]
      !rootEntityImplementationClassName
      !outletGenerationList
      !controllerMap
      !mActionDeclarationList
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine checkDefaultValueType
  ??@easyBindingTypeList inDefaultValueCorrespondingAcceptableTypes
  ??@easyBindingType inAttributeActualType
  ??@lstring inAttributeName
:
  @bool found := false ;
  foreach inDefaultValueCorrespondingAcceptableTypes while not found do
    found := inAttributeActualType == mType ;
  end foreach ;
  if not found then
    error inAttributeName: "the default value is invalue for this attribute" ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeClasses
  ??@classList inClassList
  !@classMap outClassMap
:
  outClassMap := [@classMap emptyMap] ;
  foreach inClassList do
    @classObservablePropertyMap classObservablePropertyMap ;
    @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
    if [mSuperClassName string] != "" then
      [outClassMap searchKey !mSuperClassName ?* ?classObservablePropertyMap ?propertyListForInitMethodHeader ?4*] ;
    else
      classObservablePropertyMap := [@classObservablePropertyMap emptyMap] ;
      propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
    end if ;
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    @transientListForImplementation transientListForImplementation [emptyList] ;
    const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
    @triggeredKeys triggeredKeys [emptyMap] ;
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      propertyListForInitMethodHeader += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      [!?classObservablePropertyMap insertKey !mAttributeName !mType ![@stringlist listWithValue![mAttributeName string]]] ;    
    end foreach ;
  #--- Analyze transient properties
    foreach mTransientList do
      @stringlist allPropertyDependancyList [emptyList] ;
      @directDependancyList directDependancyList [emptyList] ;
      foreach mDependencyList do
        @easyBindingType type ;
        @stringlist propertyDependancyList ;
        [classObservablePropertyMap searchKey !mValue ?type ?propertyDependancyList] ;
        directDependancyList += !type ![mValue string] ;
        foreach propertyDependancyList do 
          triggeredKeys += !mValue ![mTransientName string] ;
        end foreach ;
        allPropertyDependancyList .= propertyDependancyList ;
      end foreach ;
      transientListForImplementation += !mType ![mTransientName string] !directDependancyList ;
      [!?classObservablePropertyMap insertKey !mTransientName !mType !allPropertyDependancyList] ;    
    end foreach ;
  #---
    [!?outClassMap insertKey
      !mClassName
      ![mSuperClassName string]
      !classObservablePropertyMap
      !propertyListForInitMethodHeader
      !inheritedAttributeListForImplementation
      !attributeListForImplementation
      !transientListForImplementation
      !triggeredKeys
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeOutletClasses
  ??@outletClassList inOutletClassList
  !@outletClassMap outOutletClassMap
:
  outOutletClassMap := [@outletClassMap emptyMap] ;
  foreach inOutletClassList do
  #---
    @outletClassBindingMap bindingMap [emptyMap] ;
    foreach mOutletClassBindingList do
      @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
      foreach mBindingOptionList do
        [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
#        foreach mAcceptableTypeList do
#        
#        
#        end foreach ;
      end foreach ;
      [!?bindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
    end foreach ;
  #---
    [!?outOutletClassMap insertKey
      !mOutletClassName
      !mGenerateCode
      !mSuperClassName->string
      !bindingMap
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeControllerClasses
  ??@controllerClassList inControllerClassList
  !@controllerClassMap outControllerClassMap
:
  outControllerClassMap := [@controllerClassMap emptyMap] ;
  foreach inControllerClassList do
  #--- Analyze actions
    @actionMap actionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?actionMap insertKey !actionName->mValue] ;
    end for ;
  #---
    @outletClassBindingMap bindingMap [emptyMap] ;
    foreach mBindingList do
      @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
      foreach mBindingOptionList do
        [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
#        foreach mAcceptableTypeList do
#        
#        
#        end foreach ;
      end foreach ;
      [!?bindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
    end foreach ;
  #---
    [!?outControllerClassMap insertKey
      !mOutletClassName
      !mGenerateCode
      !bindingMap
      !actionMap
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

routine semanticAnalysis
  ??@ASTstruct inAST
  !@outletClassMap outOutletClassMap
  !@controllerClassMap outControllerClassMap
  !@classMap outClassMap
  !@entityMap outEntityMap
  !@preferencesMap outPreferencesMap
  !@documentMap outDocumentMap
:
  analyzeOutletClasses !inAST->mOutletClassList ?outOutletClassMap ;
  analyzeControllerClasses !inAST->mControllerClassList ?outControllerClassMap ;
  analyzeClasses !inAST->mClassList ?outClassMap ;
  analyzeEntities !inAST->mEntityList ?outEntityMap ;
  analyzePreferences !inAST->mPreferencesList !outOutletClassMap ?outPreferencesMap ;
  analyzeDocuments !inAST->mDocumentDeclarationList !outOutletClassMap !outControllerClassMap !outEntityMap ?outDocumentMap ;
end routine ;

#----------------------------------------------------------------------------*


end semantics ;
