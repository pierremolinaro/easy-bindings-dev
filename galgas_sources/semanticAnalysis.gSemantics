semantics semanticAnalysis :
  import "easyBindings_options.gOption" ;
  import "abstractSyntaxTree.gSemantics" ;
  import "transient_analysis_generation.gSemantics" ;

#----------------------------------------------------------------------------*

reader @easyBindingType propertyAttributeString -> @string outResult :
  switch selfcopy
  when boolType, integer16Type, integer32Type, integer64Type, uintegerType,
       floatType, doubleType, decimalType,
       toManyEntitiesType : outResult := "" ;
  when stringType : outResult := "(copy)" ;
  when fontType, imageType, dataType : outResult := "" ;
  when colorType, dateType : outResult := "(assign)" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @easyBindingType requiredCellTypeInTableColumnBinding -> @string outResult :
  switch selfcopy
  when boolType : outResult := "" ; # Empty string: not allowed
  when integer16Type, integer32Type, integer64Type, uintegerType : outResult := "NSTextFieldCell" ;
  when decimalType : outResult := "NSTextFieldCell" ;
  when floatType : outResult := "NSTextFieldCell" ;
  when doubleType : outResult := "NSTextFieldCell" ;
  when stringType : outResult := "NSTextFieldCell" ;
  when dataType : outResult := "" ;
  when dateType : outResult := "NSDateFieldCell" ;
  when fontType : outResult := "" ;
  when imageType : outResult := "" ;
  when colorType : outResult := "" ;
  when toManyEntitiesType : outResult := "" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @easyBindingType equalMethod -> @string outResult :
  switch selfcopy
  when boolType : outResult := "" ; # Empty string: use == operator
  when integer16Type, integer32Type, integer64Type, uintegerType : outResult := "" ;
  when decimalType : outResult := "" ;
  when floatType : outResult := "" ;
  when doubleType : outResult := "" ;
  when stringType : outResult := "isEqualToString" ;
  when dataType : outResult := "isEqual" ;
  when dateType : outResult := "isEqual" ;
  when fontType : outResult := "isEqual" ;
  when imageType : outResult := "isEqual" ;
  when colorType : outResult := "isEqual" ;
  when toManyEntitiesType : outResult := "" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

list @attributeListForImplementation {
  @easyBindingType mType ;
  @string mPropertyName ;
  @string mDefaultValueAsObjectiveCObject ;
  @string mDirectDefaultValue ;
}

#----------------------------------------------------------------------------*

map @classMap {
  @string mSuperClassName ;
  @observablePropertyMap mPropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @stringset mImplementationFileInclusionSet ;
  insert insertKey error message "the '%K' class is already declared" ;
  search searchKey error message "the '%K' class is not declared" ;
}

#----------------------------------------------------------------------------*

map @entityMap {
  @string mSuperEntityName ;
  @string mImplementationClassName ;
  @string mSuperImplementationClassName ;
  @observablePropertyMap mObservablePropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @relationshipList mAllRelationshipList ;
  @propertyMap mAllPropertyMap ;
  @relationshipMap mCurrentRelationshipMap ;
  @relationshipMap mAllRelationshipMap ;
  @stringset mImplementationFileInclusionSet ;
  @2stringlist mToManyRelationshipList ;
  insert insertKey error message "the '%K' entity is already declared" ;
  search searchKey error message "the '%K' entity is not declared" ;
}

#----------------------------------------------------------------------------*

abstract class @abstractBindingForGeneration {
}

#----------------------------------------------------------------------------*

class @runBindingForGeneration extends @abstractBindingForGeneration {
  @string mTargetName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*

class @regularBindingForGeneration extends @abstractBindingForGeneration {
  @string mBindingName ;
  @formatterEnum mRequiredFormatter ;
  @string mObservedObjectName ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

list @columnBindingForTableValueBindingForGeneration {
  @string mColumnIdentifier ;
  @string mRequiredCellClass ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

class @tableValueBindingForGeneration extends @abstractBindingForGeneration {
  @string mControllerName ;
  @columnBindingForTableValueBindingForGeneration mColumnBindingForTableValueBindingForGeneration ;
}

#----------------------------------------------------------------------------*

list @outletBindingListForGeneration {
  @abstractBindingForGeneration mBinding ;
}

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

override reader @runBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "  " . inOutletName . ".target = " . mTargetName . " ;\n" ;
  outResult .= "  " . inOutletName . ".action = @selector (" . mActionName . ":) ;\n" ;  
end reader ;

#----------------------------------------------------------------------------*

override reader @tableValueBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "" ;
  for column in mColumnBindingForTableValueBindingForGeneration do
     outResult .=  "  if (nil == [" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"]) {\n"
     . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' NSTableView outlet has no formatter has no column with the " . column->mColumnIdentifier . " identifier\") ;\n"
     . "  }else{\n"
     . "    NSActionCell * cell = [" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"].dataCell ;\n"
     . "    if (! [cell isKindOfClass:[" . column->mRequiredCellClass . " class]]) {\n"
     . "      presentErrorWindow (__FILE__, __LINE__, @\"the dataCell is '" . column->mColumnIdentifier . "' column of the '" . inOutletName . "' should be an '" . column->mRequiredCellClass . " instance\") ;\n"
     . "    }\n"
     . "  }\n"
     . "  [[" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"]\n"
     . "    bind:@\"value\"\n"
     . "    toObject:" . mControllerName . "\n"
     . "    withKeyPath:@\"arrangedObjects." . column->mObservableAttributeName . "\"\n"
     . "    options:" ;
     if [column->mOutletBindingOptionList length] == 0 then
       outResult .= "nil\n" ;
     else
       outResult .= "[NSDictionary dictionaryWithObjectsAndKeys:\n" ;
       foreach column->mOutletBindingOptionList do
         outResult .= "      " . mValue1 . ", @" . [mValue0 utf8Representation] . ",\n" ;
       end foreach ;
       outResult .= "      nil\n"
                    "    ]\n" ;
     end if ;
     outResult .= "  ] ;\n" ;
   end for ;
end reader ;

#----------------------------------------------------------------------------*

override reader @regularBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "" ;
  switch mRequiredFormatter
  when noFormatter :
  when numberFormatter :
   outResult .=  "  if ((nil != " . inOutletName . ") && (nil == " . inOutletName . ".formatter)) {\n"
   . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has no formatter, it should have an NSNumberFormatter\") ;\n"
   . "  }else if ((nil != " . inOutletName . ") && ![" . inOutletName . ".formatter isKindOfClass:[NSNumberFormatter class]]) {\n"
   . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . " outlet has a formatter that is not kind of NSNumberFormatter class\") ;\n"
   . "  }\n" ;
  when dateFormatter :
    outResult .= "  if ((nil != " . inOutletName . ") && (nil == " . inOutletName . ".formatter)) {\n"
    . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has no formatter, it should have an NSDateFormatter\") ;\n"
    . "  }else if ((nil != " . inOutletName . ") && ![" . inOutletName . ".formatter isKindOfClass:[NSDateFormatter class]]) {\n"
    . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has a formatter that is not kind of NSDateFormatter class\") ;\n"
    . "  }\n" ;
  end switch ;
  outResult .= "  [" . inOutletName . "\n"
            . "    bind:@\"" . mBindingName . "\"\n"
            . "    toObject:" . mObservedObjectName . "\n"
            . "    withKeyPath:@\"" . mObservableAttributeName . "\"\n"
            . "    options:" ;
   if [mOutletBindingOptionList length] == 0 then
     outResult .= "nil\n" ;
   else
     outResult .= "[NSDictionary dictionaryWithObjectsAndKeys:\n" ;
     foreach mOutletBindingOptionList do
       outResult .= "      " . mValue1 . ", @" . [mValue0 utf8Representation] . ",\n" ;
     end foreach ;
     outResult .= "      nil\n"
                  "    ]\n" ;
   end if ;
   outResult .= "  ] ;\n" ;
end reader ;

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateRemoveBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

override reader @runBindingForGeneration generateRemoveBinding
  ??@string unused inOutletName
  -> @string outResult
:
  outResult := "" ;  
end reader ;

#----------------------------------------------------------------------------*

override reader @tableValueBindingForGeneration generateRemoveBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "" ;
  for column in mColumnBindingForTableValueBindingForGeneration do
     outResult .= "  [[" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"]\n"
     . "    unbind:@\"value\"\n"
     . "  ] ;\n" ;
   end for ;
end reader ;

#----------------------------------------------------------------------------*

override reader @regularBindingForGeneration generateRemoveBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult :=
    "  [" . inOutletName . " unbind:@\"" . mBindingName . "\"] ;\n" ;
end reader ;

#----------------------------------------------------------------------------*

list @outletGenerationList {
  @string mOutletType ;
  @string mOutletName ;
  @outletBindingListForGeneration mOutletBindingList ;
}

#----------------------------------------------------------------------------*

map @preferencesMap {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @observablePropertyMap mObservablePropertyMap ;
  @stringset mImplementationFileInclusionSet ;
  insert insertKey error message "the '%K' preference is already declared" ;
  search searchKey error message "the '%K' preference is not declared" ;
}

#----------------------------------------------------------------------------*

map @documentMap {
  @string mRootEntityName ;
  @string mRootEntityImplementationClassName ;
  @outletGenerationList mOutletDeclarationList ;
  @controllerMap mControllerMap ;
  @lstringlist mActionList ;
  @transientListForImplementation mTransientListForImplementation ;
  @stringset mImplementationFileInclusionSet ;
  insert insertKey error message "the '%K' document is already declared" ;
  search searchKey error message "the '%K' document is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingOptionMap {
  @easyBindingTypeList mAcceptableTypeList ;
  insert insertKey error message "the '%K' binding option is already declared" ;
  search searchKey error message "the '%K' binding option is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingMap {
  @easyBindingTypeAndFormatterList mAcceptableTypeList ;
  @outletClassBindingOptionMap mOutletClassBindingOptionMap ;
  insert insertKey error message "the '%K' binding is already declared" ;
  search searchKey error message "the '%K' binding is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassMap {
  @bool mGenerateCode ;
  @string mSuperClassName ;
  @outletClassBindingMap mBindingMap ;
  @bool mHasTableValueBinding ;
  insert insertKey error message "the '%K' outlet class is already declared" ;
  search searchKey error message "the '%K' outlet class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerClassMap {
  @bool mGenerateCode ;
  @outletClassBindingMap mBindingMap ;
  @actionMap mActionMap ;
  @observablePropertyMap mObservablePropertyMap ;
  insert insertKey error message "the '%K' controller class is already declared" ;
  search searchKey error message "the '%K' controller class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerMap {
  @string mControllerClassName ;
  @string mControlledClassOrEntityName ;
  @outletBindingListForGeneration mControllerBindingList ;
  @actionMap mActionMap ;
  insert insertKey error message "the '%K' controller is already declared" ;
  search searchKey error message "the '%K' controller is not declared" ;
}

#----------------------------------------------------------------------------*

map @relationshipMap {
  @bool mIsToMany ;
  @lstring mDestinationEntityName ;
  @lstring mInverseRelationshipName ;
  @deleteRuleEnum mDeleteRule ;
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
}

#----------------------------------------------------------------------------*

map @propertyMap {
  insert insertKey error message "there is already a '%K' property (attribute, transient or relationship)" ;
}

#----------------------------------------------------------------------------*

map @actionMap {
  insert insertKey error message "there is already a '%K' action" ;
  search searchKey error message "the '%K' action is not defined" ;
}

#----------------------------------------------------------------------------*
#   ANALYZE ENTITIES                                                         *
#----------------------------------------------------------------------------*

local routine analyzeEntities
  ??@entityList inEntityList
  !@entityMap outEntityMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outEntityMap := [@entityMap emptyMap] ;
  foreach inEntityList do
    @observablePropertyMap observablePropertyMap ;
    @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
    @relationshipList allRelationshipList ;
    @string implementationSuperClassName ;
    @propertyMap allPropertyMap ;
    @relationshipMap allRelationshipMap ;
    if [mSuperEntityName string] != "" then
      [outEntityMap searchKey
        !mSuperEntityName
        ?*
        ?implementationSuperClassName
        ?*
        ?observablePropertyMap
        ?propertyListForInitMethodHeader
        ?4*
        ?allRelationshipList
        ?allPropertyMap
        ?*
        ?allRelationshipMap
        ?2*
      ] ;
    else
      observablePropertyMap := [@observablePropertyMap emptyMap] ;
      propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
      implementationSuperClassName := "" ;
      allRelationshipList := [@relationshipList emptyList] ;
      allPropertyMap := [@propertyMap emptyMap] ;
      allRelationshipMap := [@relationshipMap emptyMap] ;
    end if ;
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
  #--- Analyze attributes
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      [!?allPropertyMap insertKey !mAttributeName] ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      propertyListForInitMethodHeader += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      [!?ioTransientDependencyGraph addNode ![@lstring new !"entity." . mEntityName . "." . mAttributeName !mAttributeName->location] !""] ;
      const @lstring observationDependencyKey [new
        !"entity/" . mEntityName . "/self." . mAttributeName
        !mAttributeName->location
      ] ;
      [!?observablePropertyMap insertKey
        !mAttributeName
        !mType
        ![@stringlist listWithValue![mAttributeName string]]
        !observationDependencyKey
      ] ;
      [!?ioTransientDependencyGraph addNode
        !observationDependencyKey
        !observationDependencyKey->string
      ] ;
    end foreach ;
  #--- Analyze relationship (only check name is unique)
    @relationshipMap currentRelationshipMap [emptyMap] ;
    foreach mRelationshipList do
      [!?allRelationshipMap insertKey
        !mRelationshipName
        !mIsToMany
        !mDestinationEntityName
        !mInverseRelationshipName
        !mDeleteRule
      ] ;
      [!?currentRelationshipMap insertKey
        !mRelationshipName
        !mIsToMany
        !mDestinationEntityName
        !mInverseRelationshipName
        !mDeleteRule
      ] ;
      [!?allPropertyMap insertKey !mRelationshipName] ;
      const @lstring observationDependencyKey [new
        !"entity/" . mEntityName . "/self." . mRelationshipName
        !mRelationshipName->location
      ] ;
      [!?observablePropertyMap insertKey
        !mRelationshipName
        ![@easyBindingType toManyEntitiesType]
        ![@stringlist emptyList]
        !observationDependencyKey
      ] ;    
      [!?ioTransientDependencyGraph addNode
        !observationDependencyKey
        !observationDependencyKey->string
      ] ;
    end foreach ;
  #--- Analyze transient properties
    @stringset implementationFileInclusionSet [emptySet] ;
    @transientListForImplementation transientListForImplementation ;
    analyzeTransientProperties
      !"entity/" . mEntityName . "/self."
      !mTransientList
      ![@observableObjectMap emptyMap]
      !?observablePropertyMap
      !?implementationFileInclusionSet
      ?transientListForImplementation
      !?ioTransientDependencyGraph
    ;
  #---
    @2stringlist toManyRelationshipList [emptyList] ;
    foreach mRelationshipList do
      if mIsToMany then
        toManyRelationshipList += !mRelationshipName->string !mDestinationEntityName-> string ;
      else
      
      end if ;
    end foreach ;
    [!?implementationFileInclusionSet removeKey !""] ;
    [!?outEntityMap insertKey
      !mEntityName
      ![mSuperEntityName string]
      ![mImplementationClassName string]
      !implementationSuperClassName
      !observablePropertyMap
      !propertyListForInitMethodHeader
      !inheritedAttributeListForImplementation
      !attributeListForImplementation
      !transientListForImplementation
      !mRelationshipList
      !allRelationshipList . mRelationshipList
      !allPropertyMap
      !currentRelationshipMap
      !allRelationshipMap
      !implementationFileInclusionSet
      !toManyRelationshipList
    ] ;
  end foreach ;
#--- Check relationships
  foreach outEntityMap do
    foreach mCurrentRelationshipMap do
      @relationshipMap destinationEntityRelationshipMap ;
      [outEntityMap searchKey !mDestinationEntityName ?12* ?destinationEntityRelationshipMap ?2*] ;
      @lstring inverseOfInverseRelationshipName ;
      [destinationEntityRelationshipMap searchKey !mInverseRelationshipName ?2* ?inverseOfInverseRelationshipName ?*] ;
      if lkey->string != inverseOfInverseRelationshipName->string then
        error mInverseRelationshipName : "the inverse relationship does not name '" . lkey . "' relationship as inverse" ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeOutletBinding
  ??@entityMap inEntityMap
  ??@observableObjectMap inObservableObjectMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
;

#----------------------------------------------------------------------------*

override method @tableValueBinding analyzeOutletBinding
  ??@entityMap inEntityMap
  ??@observableObjectMap unused inObservableObjectMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap unused inActionMap
  ??@bool inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
  if not inHasTableValueBinding then
    error mControllerName: "this outlet does not support $tableValue binding" ;
  else
    @string controlledClassOrEntityName ;
    @outletBindingListForGeneration controllerBindingList ;
    [inControllerMap searchKey
      !mControllerName
      ?*
      ?controlledClassOrEntityName
      ?controllerBindingList
      ?*
    ] ;
    [inEntityMap searchKey
      ![@lstring new !controlledClassOrEntityName !here]
      ?3*
      ?@observablePropertyMap observablePropertyMap
      ?11*
    ] ;
    @columnBindingForTableValueBindingForGeneration columnBindingForTableValueBindingForGeneration [emptyList] ;
    for column in mTableValueColumnBinding do
      @easyBindingType type ;
      [observablePropertyMap searchKey
        !column->mBoundPropertyName
        ?type
        ?2*
      ] ;
      const @string requiredCellTypeInTableColumnBinding := [type requiredCellTypeInTableColumnBinding] ;
      if requiredCellTypeInTableColumnBinding == "" then
        error column->mBoundPropertyName:"this property cannot be named in a $tableValue binding" ;
      elsif requiredCellTypeInTableColumnBinding != column->mCellTypeName->string then
        error column->mCellTypeName:"this property requires a " . requiredCellTypeInTableColumnBinding . " cell class" ;
      end if ;
      columnBindingForTableValueBindingForGeneration +=
        !column->mColumnName->string
        !requiredCellTypeInTableColumnBinding
        !column->mBoundPropertyName->string
        ![@2stringlist emptyList]
      ;
    end for ;
    ioOutletBindingListForGeneration += ![@tableValueBindingForGeneration new
      !mControllerName->string
      !columnBindingForTableValueBindingForGeneration
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @runBinding analyzeOutletBinding
  ??@entityMap unused inEntityMap
  ??@observableObjectMap unused inObservableObjectMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset unused ioImplementationFileInclusionSet
:
  if mTargetName->string == "self" then
    [inActionMap searchKey !mActionName] ;
  else
    @actionMap actionMap ;
    [inControllerMap searchKey !mTargetName ?3* ?actionMap] ;
    [actionMap searchKey !mActionName] ;
  end if ;
  ioOutletBindingListForGeneration += ![@runBindingForGeneration new
    !mTargetName->string
    !mActionName->string
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularBinding analyzeOutletBinding
  ??@entityMap unused inEntityMap
  ??@observableObjectMap inObservableObjectMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
:
  @outletClassBindingOptionMap outletClassBindingOptionMap ;
  @easyBindingTypeAndFormatterList acceptableTypeFormatterList ;
  [inBindingMap searchKey !mBindingName ?acceptableTypeFormatterList ?outletClassBindingOptionMap] ;
#--- Find observable property
  @string observedObjectOCName ;
  @observablePropertyMap observablePropertyMap ;
  if [inObservableObjectMap hasKey !mObservedObjectName->string] then
    @string includeFile ;
    [inObservableObjectMap searchKey
      ![@lstring new !mObservedObjectName->string !here]
      ?observedObjectOCName
      ?includeFile
      ?observablePropertyMap
     ] ;
     ioImplementationFileInclusionSet += !includeFile ;
  else
    error mObservedObjectName
      : "the '" . mObservedObjectName . "' object is not observable"
      : observedObjectOCName, observablePropertyMap
    ;
  end if ;
  @easyBindingType observablePropertyType ;
  [observablePropertyMap searchKey !mObservableAttributeName ?observablePropertyType ?2*] ;
  @string observableKeyPath := mObservableAttributeName->string ;
#--- count option ?
  if mNamesCountOption then
    if observablePropertyType == [@easyBindingType toManyEntitiesType] then
      observableKeyPath .= ".@count" ;
      observablePropertyType := [@easyBindingType uintegerType] ;
    else
      error mObservableAttributeName: "the 'count' path is only allowed for to-many relationships" ;
    end if ;
  end if ;
#--- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mObservableAttributeName:s ;
  end if ;
#--- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !observedObjectOCName
    !observableKeyPath
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @multiValuedBinding analyzeOutletBinding
  ??@entityMap unused inEntityMap
  ??@observableObjectMap inObservableObjectMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
  ?!@stringset ioImplementationFileInclusionSet
:
  @outletClassBindingOptionMap outletClassBindingOptionMap ;
  @easyBindingTypeAndFormatterList acceptableTypeFormatterList ;
  [inBindingMap searchKey !mBindingName ?acceptableTypeFormatterList ?outletClassBindingOptionMap] ;
#--- Find observable property
  @string generatedBindingName := mBindingName->string ;
  @uint idx := 1 ;
  foreach mMultiValuedBindingList do
    @string observedObjectOCName ;
    @observablePropertyMap observablePropertyMap ;
    if [inObservableObjectMap hasKey !mBoundObjectName->string] then
      @string includeFile ;
      [inObservableObjectMap searchKey
        ![@lstring new !mBoundObjectName->string !here]
        ?observedObjectOCName
        ?includeFile
        ?observablePropertyMap
       ] ;
       ioImplementationFileInclusionSet += !includeFile ;
    else
      error mBoundObjectName
        : "the '" . mBoundObjectName . "' object is not observable"
        : observedObjectOCName, observablePropertyMap
      ;
    end if ;
    @easyBindingType observablePropertyType ;
    [observablePropertyMap searchKey !mBoundPropertyName ?observablePropertyType ?2*] ;
    @string observableKeyPath := mBoundPropertyName->string ;
  #--- check model belongs to an acceptable type
    @bool found := false ;
    @formatterEnum requiredFormatter [noFormatter] ;
    foreach acceptableTypeFormatterList while not found do
      requiredFormatter := mRequiredFormatter ;
      found := mType == observablePropertyType ;
    end foreach ;
    if not found then
      @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
      foreach acceptableTypeFormatterList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mBoundPropertyName:s ;
    end if ;
  #--- Check options
    @2stringlist bindingOptionList [emptyList] ;
    if mNegate then
      bindingOptionList += !"NSValueTransformerName" !"NSNegateBooleanTransformerName" ;
    end if ;
    foreach mOutletBindingOptionList do
      @easyBindingTypeList acceptableTypeList ;
      [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
      @bool found := false ;
      foreach acceptableTypeList while not found do
        foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
          found := mType == optionValue_mType ;
        end foreach ;
      end foreach ;
      if not found then
        @string s := "the option value acceptable types are:" ;
        foreach acceptableTypeList while not found do
          s .= "\n  - '" . [mType ebTypeName] . "'" ;
        end foreach ;
        error mOptionName:s ;
      end if ;
      bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
    end foreach ;
    ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
      !generatedBindingName
      !requiredFormatter
      !observedObjectOCName
      !observableKeyPath
      !bindingOptionList
    ] ;
  #---
    idx ++ ;
    generatedBindingName := mBindingName->string . idx ;
  end foreach ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzePreferences
  ??@entityMap inEntityMap
  ??@preferencesDeclarationList inPreferencesList
  ??@outletClassMap inOutletClassMap
  !@preferencesMap outPreferencesMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outPreferencesMap := [@preferencesMap emptyMap] ;
  foreach inPreferencesList do
    @observablePropertyMap observableAttributeMap [emptyMap] ;
  #--- Analyze actions
    @actionMap actionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?actionMap insertKey !actionName->mValue] ;
    end for ;
  #--- Analyze attributes
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      const @lstring observationDependancyKey [new
        !"preferences/" . mPreferencesName->string . "/self." . mAttributeName
        !mAttributeName->location
      ] ;
      [!?observableAttributeMap insertKey
        !mAttributeName
        !mType
        ![@stringlist listWithValue![mAttributeName string]]
        !observationDependancyKey
      ] ;
      [!?ioTransientDependencyGraph addNode
        !observationDependancyKey
        !observationDependancyKey->string
      ] ;
    end foreach ;
  #--- Analyze transient properties
    @transientListForImplementation transientListForImplementation ;
    @stringset implementationFileInclusionSet [emptySet] ;
    analyzeTransientProperties
      !"preferences/" . mPreferencesName . "/self."
      !mTransientList
      ![@observableObjectMap emptyMap]
      !?observableAttributeMap
      !?implementationFileInclusionSet
      ?transientListForImplementation
      !?ioTransientDependencyGraph
    ;
  #--- Build observable object map
    @observableObjectMap observableObjectMap [emptyMap] ;
    [!?observableObjectMap insertKey
      !["self" nowhere]
      !"self"
      !"" # No file to include
      !observableAttributeMap
    ] ;
  #--- Analyze outlets
    @outletGenerationList outletGenerationList [emptyList] ;
    foreach mOutletDeclarationList do
      @outletClassBindingMap bindingMap ;
      @bool hasTableValueBinding ;
      [inOutletClassMap searchKey !mOutletType ?2* ?bindingMap ?hasTableValueBinding] ;
      @outletBindingListForGeneration outletBindingList [emptyList] ;
      foreach mOutletBindingList do
        [mBinding analyzeOutletBinding
          !inEntityMap
          !observableObjectMap
          !bindingMap
          ![@controllerMap emptyMap]
          !actionMap
          !hasTableValueBinding
          !?outletBindingList
          !?implementationFileInclusionSet
        ] ;
      end foreach ;
      outletGenerationList += ![mOutletType string] ![mOutletName string] !outletBindingList ;
    end foreach ;
  #---
    [!?implementationFileInclusionSet removeKey !""] ;
    [!?outPreferencesMap insertKey
      !mPreferencesName
      !attributeListForImplementation
      !transientListForImplementation
      !outletGenerationList
      !mActionDeclarationList
      !observableAttributeMap
      !implementationFileInclusionSet
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

reader @easyBindingType ebTypeIdentifier ??@string inClassOrEntityName -> @string outResult :
  switch selfcopy
  when boolType : outResult := "bool" ;
  when integer16Type : outResult := "integer16" ;
  when integer32Type : outResult := "integer32" ;
  when integer64Type : outResult := "integer64" ;
  when uintegerType : outResult := "unsignedInteger" ;
  when decimalType : outResult := "decimal" ;
  when floatType : outResult := "float" ;
  when doubleType : outResult := "double" ;
  when stringType : outResult := "NSString" ;
  when dataType : outResult := "NSData" ;
  when dateType : outResult := "NSDate" ;
  when fontType : outResult := "NSFont" ;
  when imageType : outResult := "NSImage" ;
  when colorType : outResult := "NSColor" ;
  when toManyEntitiesType : outResult := "toMany[" . inClassOrEntityName . "]" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

local routine checkBindingOptions
  ??@outletBindingOptionList inBindingOptionListAST
  ??@outletClassBindingOptionMap inAvailableBindingOptionMap
  !@2stringlist outBindingOptionListForGeneration
:
  outBindingOptionListForGeneration := [@2stringlist emptyList] ;
  foreach inBindingOptionListAST do
    @easyBindingTypeList acceptableTypeList ;
    [inAvailableBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    outBindingOptionListForGeneration += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@observablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
;

#----------------------------------------------------------------------------*

override method @multiValuedBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@observablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mBindingName: "a controller does not implement the $" . mBindingName . " binding" ;
end method ;

#----------------------------------------------------------------------------*

override method @tableValueBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@observablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mControllerName: "a controller does not implement $tableValue binding" ;
end method ;

#----------------------------------------------------------------------------*

override method @runBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@observablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mTargetName: "a controller does not implement $run action" ;
end method ;

#----------------------------------------------------------------------------*

override method @regularBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@observablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
:
  @string resultingObservedObjectName ;
  @string resultingObservedPropertyPath ;
  if mObservedObjectName->string == "root" then
    resultingObservedObjectName := "mRootObjectController" ;
    resultingObservedPropertyPath := "selection." . mObservableAttributeName ;
  else
    error mObservedObjectName
    : "observed object should be 'root'"
    : resultingObservedObjectName, resultingObservedPropertyPath
    ;
  end if ;
  @string boundTypeIdentifierString ;
  if [inAllObservablePropertyMap hasKey !mObservableAttributeName->string] then
    @easyBindingType t ;
    [inAllObservablePropertyMap searchKey !mObservableAttributeName ?t ?2*] ;
    boundTypeIdentifierString := [t ebTypeIdentifier !""] ;
  elsif [inAllRelationshipMap hasKey !mObservableAttributeName->string] then
    @bool isToMany ;
    @lstring destinationEntityName ;
    [inAllRelationshipMap searchKey !mObservableAttributeName ?isToMany ?destinationEntityName ?2*] ;
    if isToMany then
      boundTypeIdentifierString := "toMany[" . destinationEntityName . "]" ;
    else
      boundTypeIdentifierString := "toOne[" . destinationEntityName . "]" ;
    end if ;
  else
    error mObservableAttributeName
    :"unknown property"
    : boundTypeIdentifierString ;
  end if ;
  @easyBindingTypeAndFormatterList acceptableTypeList ;
  @outletClassBindingOptionMap availableBindingOptionMap ;
  [inControllerClassBindingMap searchKey !mBindingName ?acceptableTypeList ?availableBindingOptionMap] ;
  @bool found := false ;
  @string acceptableTypesString := "" ;
  foreach acceptableTypeList while not found do
     const @string acceptableType := [mType ebTypeIdentifier !inControlledClassOrEntityName->string] ;
     acceptableTypesString .= "\n-  '" . acceptableType . "'" ;
     found := boundTypeIdentifierString == acceptableType ;
  end foreach ;
  if not found then
    error mObservableAttributeName
    :"cannot bind: property type is '" . boundTypeIdentifierString . "', acceptable type(s):" . acceptableTypesString
    ;
  end if ;
  checkBindingOptions
    !mOutletBindingOptionList
    !availableBindingOptionMap
    ?@2stringlist bindingOptionListForGeneration
  ;
  ioBindingListForGeneration += ![@regularBindingForGeneration new
    !mBindingName->string
    ![@formatterEnum noFormatter]
    !resultingObservedObjectName
    !resultingObservedPropertyPath
    !bindingOptionListForGeneration
  ] ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzeDocuments
  ??@documentDeclarationList inDocumentDeclarationList
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@preferencesMap inPreferencesMap
  !@documentMap outDocumentMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outDocumentMap := [@documentMap emptyMap] ;
  foreach inDocumentDeclarationList do
    @string rootEntityImplementationClassName ;
    @observablePropertyMap rootObjectObservablePropertyMap ;
    @relationshipMap allRelationshipMap ;
    [inEntityMap searchKey
      !mRootEntityName
      ?*
      ?rootEntityImplementationClassName
      ?*
      ?rootObjectObservablePropertyMap
      ?8*
      ?allRelationshipMap
      ?2*
    ] ;
  #--- Build observable object map
    @observableObjectMap observableObjectMap [emptyMap] ;
    [!?observableObjectMap insertKey
      !["root" nowhere]
      !"mRootObject"
      !"" # No file to include
      !rootObjectObservablePropertyMap
    ] ;
    for pref in inPreferencesMap do
      [!?observableObjectMap insertKey
        !pref->lkey
        !"g_" . pref->lkey->string
        !pref->lkey->string
        !pref->mObservablePropertyMap
      ] ;
    end for ;
  #--- Analyze controllers
    @observablePropertyMap observablePropertyMap [emptyMap] ;
    @controllerMap controllerMap [emptyMap] ;
    foreach mControllerList do
      @outletClassBindingMap controllerClassBindingMap ;
      @actionMap controllerActionMap ;
      @observablePropertyMap controllerObservablePropertyMap ;
      [inControllerClassMap searchKey
        !mControllerClassName
        ?*
        ?controllerClassBindingMap
        ?controllerActionMap
        ?controllerObservablePropertyMap
      ] ;
      @observablePropertyMap prefixedControllerObservablePropertyMap [emptyMap] ;
      foreach controllerObservablePropertyMap do
        const @lstring observedKey [new
          !"document/" . mDocumentName . "/" . mControllerName . "." . mObservationDependancyKey
          !mObservationDependancyKey->location
        ] ;
        [!?prefixedControllerObservablePropertyMap insertKey
          !lkey
          !mType
          !mPropertyDependancyList
          !observedKey
        ] ;
        [!?ioTransientDependencyGraph addNode
          !observedKey
          !observedKey->string
        ] ;
      end foreach ;
      [!?observableObjectMap insertKey
        !mControllerName
        !mControllerName->string
        !"" # No file to include
        !prefixedControllerObservablePropertyMap
      ] ;
      [inEntityMap searchKey !mControlledClassOrEntityName ?15*] ;
      @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
      foreach mControllerBindingList do
        [mBinding analyzeControllerBinding
          !allRelationshipMap
          !controllerClassBindingMap
          !mControlledClassOrEntityName
          !observablePropertyMap
          !?bindingListForGeneration
        ] ;
      end foreach ;
      [!?controllerMap insertKey
        !mControllerName
        !mControllerClassName->string
        !mControlledClassOrEntityName->string
        !bindingListForGeneration
        !controllerActionMap
      ] ;
    end foreach ;
  #--- Analyze transient properties
    @transientListForImplementation transientListForImplementation ;
    @stringset implementationFileInclusionSet [emptySet] ;
    analyzeTransientProperties
      !"document/" . mDocumentName . "/self."
      !mTransientList
      !observableObjectMap
      !?observablePropertyMap
      !?implementationFileInclusionSet
      ?transientListForImplementation
      !?ioTransientDependencyGraph
    ;
  #--- Analyze actions
    @actionMap documentActionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?documentActionMap insertKey !actionName->mValue] ;
    end for ;
  #--- Analyze outlets
    [!?observableObjectMap insertKey
      !["self" nowhere]
      !"self"
      !"" # No file to include
      !observablePropertyMap
    ] ;
    @outletGenerationList outletGenerationList [emptyList] ;
    foreach mOutletDeclarationList do
      @outletClassBindingMap bindingMap ;
      @bool hasTableValueBinding ;
      [inOutletClassMap searchKey !mOutletType ?2* ?bindingMap ?hasTableValueBinding] ;
      @outletBindingListForGeneration outletBindingList [emptyList] ;
      foreach mOutletBindingList do
        [mBinding analyzeOutletBinding
          !inEntityMap
          !observableObjectMap
          !bindingMap
          !controllerMap
          !documentActionMap
          !hasTableValueBinding
          !?outletBindingList
          !?implementationFileInclusionSet
        ] ;
      end foreach ;
      outletGenerationList += ![mOutletType string] ![mOutletName string] !outletBindingList ;
    end foreach ;
  #---
    [!?implementationFileInclusionSet removeKey !""] ;
    [!?outDocumentMap insertKey
      !mDocumentName
      ![mRootEntityName string]
      !rootEntityImplementationClassName
      !outletGenerationList
      !controllerMap
      !mActionDeclarationList
      !transientListForImplementation
      !implementationFileInclusionSet
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine checkDefaultValueType
  ??@easyBindingTypeList inDefaultValueCorrespondingAcceptableTypes
  ??@easyBindingType inAttributeActualType
  ??@lstring inAttributeName
:
  @bool found := false ;
  foreach inDefaultValueCorrespondingAcceptableTypes while not found do
    found := inAttributeActualType == mType ;
  end foreach ;
  if not found then
    error inAttributeName: "the default value is invalue for this attribute" ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeClasses
  ??@classList inClassList
  !@classMap outClassMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
:
  outClassMap := [@classMap emptyMap] ;
  foreach inClassList do
    @observablePropertyMap observablePropertyMap ;
    @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
    if [mSuperClassName string] != "" then
      [outClassMap searchKey !mSuperClassName ?* ?observablePropertyMap ?propertyListForInitMethodHeader ?4*] ;
    else
      observablePropertyMap := [@observablePropertyMap emptyMap] ;
      propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
    end if ;
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      propertyListForInitMethodHeader += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      const @lstring observationDependencyKey [new
        !"class/" . mClassName . "/self." . mAttributeName
        !mAttributeName->location
      ] ;
      [!?observablePropertyMap insertKey
        !mAttributeName
        !mType
        ![@stringlist listWithValue![mAttributeName string]]
        !observationDependencyKey
      ] ;    
      [!?ioTransientDependencyGraph addNode
        !observationDependencyKey
        !observationDependencyKey->string
      ] ;
    end foreach ;
  #--- Analyze transient properties
    @transientListForImplementation transientListForImplementation ;
    @stringset implementationFileInclusionSet [emptySet] ;
    analyzeTransientProperties
      !"class/" . mClassName . "/self."
      !mTransientList
      ![@observableObjectMap emptyMap]
      !?observablePropertyMap
      !?implementationFileInclusionSet
      ?transientListForImplementation
      !?ioTransientDependencyGraph
    ;
  #---
    [!?implementationFileInclusionSet removeKey !""] ;
    [!?outClassMap insertKey
      !mClassName
      ![mSuperClassName string]
      !observablePropertyMap
      !propertyListForInitMethodHeader
      !inheritedAttributeListForImplementation
      !attributeListForImplementation
      !transientListForImplementation
      !implementationFileInclusionSet
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeOutletClasses
  ??@outletClassList inOutletClassList
  !@outletClassMap outOutletClassMap
:
  outOutletClassMap := [@outletClassMap emptyMap] ;
  foreach inOutletClassList do
  #---
    @outletClassBindingMap bindingMap [emptyMap] ;
    foreach mOutletClassBindingList do
      @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
      foreach mBindingOptionList do
        [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
#        foreach mAcceptableTypeList do
#        
#        
#        end foreach ;
      end foreach ;
      [!?bindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
    end foreach ;
  #---
    [!?outOutletClassMap insertKey
      !mOutletClassName
      !mGenerateCode
      !mSuperClassName->string
      !bindingMap
      !mHasTableValueBinding
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeControllerClasses
  ??@controllerClassList inControllerClassList
  !@controllerClassMap outControllerClassMap
:
  outControllerClassMap := [@controllerClassMap emptyMap] ;
  foreach inControllerClassList do
  #--- Analyze actions
    @actionMap actionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?actionMap insertKey !actionName->mValue] ;
    end for ;
  #---
    @outletClassBindingMap bindingMap [emptyMap] ;
    foreach mBindingList do
      @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
      foreach mBindingOptionList do
        [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
#        foreach mAcceptableTypeList do
#        
#        
#        end foreach ;
      end foreach ;
      [!?bindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
    end foreach ;
  #---
    @observablePropertyMap observablePropertyMap [emptyMap] ;
    for property in mControllerObservablePropertyList do
#      const @lstring observationDependencyKey [new
#        !"controller." . mOutletClassName . "." . property->mPropertyName
#        !property->mPropertyName->location
#      ] ;
      [!?observablePropertyMap insertKey
        !property->mPropertyName
        !property->mType
        ![@stringlist emptyList]
        !property->mPropertyName
      ] ;
    end for ;
  #---
    [!?outControllerClassMap insertKey
      !mOutletClassName
      !mGenerateCode
      !bindingMap
      !actionMap
      !observablePropertyMap
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

routine semanticAnalysis
  ??@ASTstruct inAST
  ?@string inSourceFilePath
  !@outletClassMap outOutletClassMap
  !@controllerClassMap outControllerClassMap
  !@classMap outClassMap
  !@entityMap outEntityMap
  !@preferencesMap outPreferencesMap
  !@documentMap outDocumentMap
  !@stringlist outSortedTransientOrderedList
  !@2stringlist outTransientDependencyArcList
:
  outSortedTransientOrderedList := [@stringlist emptyList] ;
  @transientDependencyGraph transientDependencyGraph [emptyGraph] ;
  analyzeOutletClasses !inAST->mOutletClassList ?outOutletClassMap ;
  analyzeControllerClasses !inAST->mControllerClassList ?outControllerClassMap ;
  analyzeClasses 
    !inAST->mClassList
    ?outClassMap
    !?transientDependencyGraph
  ;
  analyzeEntities
    !inAST->mEntityList
    ?outEntityMap
    !?transientDependencyGraph
  ;
  analyzePreferences
    !outEntityMap
    !inAST->mPreferencesList
    !outOutletClassMap
    ?outPreferencesMap
    !?transientDependencyGraph
  ;
  analyzeDocuments
    !inAST->mDocumentDeclarationList
    !outOutletClassMap
    !outControllerClassMap
    !outEntityMap
    !outPreferencesMap
    ?outDocumentMap
    !?transientDependencyGraph
  ;
#--- Output graphviz file ?
  if ([@uint errorCount] == 0) & [option easyBindings_options.outputTransientDependencyGraph value] then
    const @string s := [transientDependencyGraph graphviz] ;
    const @string path := inSourceFilePath . ".transientDependancyGraph.dot" ;
    [s writeToFileWhenDifferentContents !path ?*] ;
  end if ;
#--- Analyze transient dependencies
  outTransientDependencyArcList := [transientDependencyGraph arcs] ;
  if [@uint errorCount] == 0 then
    if [transientDependencyGraph undefinedNodeCount] > 0 then
      foreach [transientDependencyGraph undefinedNodeKeyList] do
        error inAST->mEndOfSourceFile : "the '" . mValue . "' property is not defined" ;
      end foreach ;
    else
      @stringlist unsortedTransientList ;
      [transientDependencyGraph topologicalSort
        ?outSortedTransientOrderedList
        ?*
        ?unsortedTransientList
        ?*
      ] ;
      if [unsortedTransientList length] > 0 then
        @string s := [[unsortedTransientList length] string] . " transient declarations are involved in circular dependancies:" ;
        foreach unsortedTransientList do
          s .= "\n-  " . mValue ;
        end foreach ;
        error inAST->mEndOfSourceFile : s ;
      else # all defined, no circularity
      end if ;
    end if ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*


end semantics ;
