semantics semanticAnalysis :
  import "easyBindings_options.gOption" ;
  import "abstractSyntaxTree.gSemantics" ;
  import "transient_analysis_generation.gSemantics" ;

#----------------------------------------------------------------------------*

reader @easyBindingType propertyAttributeString -> @string outResult :
  switch selfcopy
  when boolType, integer16Type, integer32Type, integer64Type,
       floatType, doubleType, decimalType,
       toManyEntitiesType : outResult := "" ;
  when stringType : outResult := "(copy)" ;
  when fontType, imageType, dataType : outResult := "" ;
  when colorType, dateType : outResult := "(assign)" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

reader @easyBindingType requiredCellTypeInTableColumnBinding -> @string outResult :
  switch selfcopy
  when boolType : outResult := "" ; # Empty string: not allowed
  when integer16Type : outResult := "NSTextFieldCell" ;
  when integer32Type : outResult := "NSTextFieldCell" ;
  when integer64Type : outResult := "NSTextFieldCell" ;
  when decimalType : outResult := "NSTextFieldCell" ;
  when floatType : outResult := "NSTextFieldCell" ;
  when doubleType : outResult := "NSTextFieldCell" ;
  when stringType : outResult := "NSTextFieldCell" ;
  when dataType : outResult := "" ;
  when dateType : outResult := "NSDateFieldCell" ;
  when fontType : outResult := "" ;
  when imageType : outResult := "" ;
  when colorType : outResult := "" ;
  when toManyEntitiesType : outResult := "" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

list @attributeListForImplementation {
  @easyBindingType mType ;
  @string mPropertyName ;
  @string mDefaultValueAsObjectiveCObject ;
  @string mDirectDefaultValue ;
}

#----------------------------------------------------------------------------*

map @classMap {
  @string mSuperClassName ;
  @classObservablePropertyMap mPropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  insert insertKey error message "the '%K' class is already declared" ;
  search searchKey error message "the '%K' class is not declared" ;
}

#----------------------------------------------------------------------------*

map @entityMap {
  @string mSuperEntityName ;
  @string mImplementationClassName ;
  @string mSuperImplementationClassName ;
  @classObservablePropertyMap mObservablePropertyMap ;
  @attributeListForImplementation mAttributeListForInitMethodHeader ;
  @attributeListForImplementation mInheritedAttributeListForImplementation ;
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @relationshipList mCurrentRelationshipList ;
  @relationshipList mAllRelationshipList ;
  @propertyMap mAllPropertyMap ;
  @relationshipMap mCurrentRelationshipMap ;
  @relationshipMap mAllRelationshipMap ;
  insert insertKey error message "the '%K' entity is already declared" ;
  search searchKey error message "the '%K' entity is not declared" ;
}

#----------------------------------------------------------------------------*

abstract class @abstractBindingForGeneration {
}

#----------------------------------------------------------------------------*

class @runBindingForGeneration extends @abstractBindingForGeneration {
  @string mTargetName ;
  @string mActionName ;
}

#----------------------------------------------------------------------------*

class @regularBindingForGeneration extends @abstractBindingForGeneration {
  @string mBindingName ;
  @formatterEnum mRequiredFormatter ;
  @string mObservedObjectName ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

list @columnBindingForTableValueBindingForGeneration {
  @string mColumnIdentifier ;
  @string mRequiredCellClass ;
  @string mObservableAttributeName ;
  @2stringlist mOutletBindingOptionList ;
}

#----------------------------------------------------------------------------*

class @tableValueBindingForGeneration extends @abstractBindingForGeneration {
  @string mControllerName ;
  @columnBindingForTableValueBindingForGeneration mColumnBindingForTableValueBindingForGeneration ;
}

#----------------------------------------------------------------------------*

list @outletBindingListForGeneration {
  @abstractBindingForGeneration mBinding ;
}

#----------------------------------------------------------------------------*

abstract reader @abstractBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
;

#----------------------------------------------------------------------------*

override reader @runBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "  " . inOutletName . ".target = " . mTargetName . " ;\n" ;
  outResult .= "  " . inOutletName . ".action = @selector (" . mActionName . ":) ;\n" ;  
end reader ;

#----------------------------------------------------------------------------*

override reader @tableValueBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "" ;
  for column in mColumnBindingForTableValueBindingForGeneration do
     outResult .=  "  if (nil == [" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"]) {\n"
     . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' NSTableView outlet has no formatter has no column with the " . column->mColumnIdentifier . " identifier\") ;\n"
     . "  }else{\n"
     . "    NSActionCell * cell = [" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"].dataCell ;\n"
     . "    if (! [cell isKindOfClass:[" . column->mRequiredCellClass . " class]]) {\n"
     . "      presentErrorWindow (__FILE__, __LINE__, @\"the dataCell is '" . column->mColumnIdentifier . "' column of the '" . inOutletName . "' should be an '" . column->mRequiredCellClass . " instance\") ;\n"
     . "    }\n"
     . "  }\n"
     . "  [[" . inOutletName . " tableColumnWithIdentifier:@\"" . column->mColumnIdentifier . "\"]\n"
     . "    bind:@\"value\"\n"
     . "    toObject:" . mControllerName . "\n"
     . "    withKeyPath:@\"arrangedObjects." . column->mObservableAttributeName . "\"\n"
     . "    options:" ;
     if [column->mOutletBindingOptionList length] == 0 then
       outResult .= "nil\n" ;
     else
       outResult .= "[NSDictionary dictionaryWithObjectsAndKeys:\n" ;
       foreach column->mOutletBindingOptionList do
         outResult .= "      " . mValue1 . ", @" . [mValue0 utf8Representation] . ",\n" ;
       end foreach ;
       outResult .= "      nil\n"
                    "    ]\n" ;
     end if ;
     outResult .= "  ] ;\n" ;
   end for ;
end reader ;

#----------------------------------------------------------------------------*

override reader @regularBindingForGeneration generateBinding
  ??@string inOutletName
  -> @string outResult
:
  outResult := "" ;
  switch mRequiredFormatter
  when noFormatter :
  when numberFormatter :
   outResult .=  "if ((nil != " . inOutletName . ") && (nil == " . inOutletName . ".formatter)) {\n"
   . "  presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has no formatter, it should have an NSNumberFormatter\") ;\n"
   . "  }else if ((nil != " . inOutletName . ") && ![" . inOutletName . ".formatter isKindOfClass:[NSNumberFormatter class]]) {\n"
   . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . " outlet has a formatter that is not kind of NSNumberFormatter class\") ;\n"
   . "  }\n" ;
  when dateFormatter :
    outResult .= "  if ((nil != " . inOutletName . ") && (nil == " . inOutletName . ".formatter)) {\n"
    . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has no formatter, it should have an NSDateFormatter\") ;\n"
    . "  }else if ((nil != " . inOutletName . ") && ![" . inOutletName . ".formatter isKindOfClass:[NSDateFormatter class]]) {\n"
    . "    presentErrorWindow (__FILE__, __LINE__, @\"the '" . inOutletName . "' outlet has a formatter that is not kind of NSDateFormatter class\") ;\n"
    . "  }\n" ;
  end switch ;
  outResult .= "  [" . inOutletName . "\n"
            . "    bind:@\"" . mBindingName . "\"\n"
            . "    toObject:" . mObservedObjectName . "\n"
            . "    withKeyPath:@\"" . mObservableAttributeName . "\"\n"
            . "    options:" ;
   if [mOutletBindingOptionList length] == 0 then
     outResult .= "nil\n" ;
   else
     outResult .= "[NSDictionary dictionaryWithObjectsAndKeys:\n" ;
     foreach mOutletBindingOptionList do
       outResult .= "      " . mValue1 . ", @" . [mValue0 utf8Representation] . ",\n" ;
     end foreach ;
     outResult .= "      nil\n"
                  "    ]\n" ;
   end if ;
   outResult .= "  ] ;\n" ;
end reader ;

#----------------------------------------------------------------------------*

list @outletGenerationList {
  @string mOutletType ;
  @string mOutletName ;
  @outletBindingListForGeneration mOutletBindingList ;
}

#----------------------------------------------------------------------------*

map @preferencesMap {
  @attributeListForImplementation mAttributeListForImplementation ;
  @transientListForImplementation mTransientListForImplementation ;
  @outletGenerationList mOutletDeclarationList ;
  @lstringlist mActionList ;
  @classObservablePropertyMap mObservablePropertyMap ;
  insert insertKey error message "the '%K' preference is already declared" ;
  search searchKey error message "the '%K' preference is not declared" ;
}

#----------------------------------------------------------------------------*

map @documentMap {
  @string mRootEntityName ;
  @string mRootEntityImplementationClassName ;
  @outletGenerationList mOutletDeclarationList ;
  @controllerMap mControllerMap ;
  @lstringlist mActionList ;
  @transientListForImplementation mTransientListForImplementation ;
  insert insertKey error message "the '%K' document is already declared" ;
  search searchKey error message "the '%K' document is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingOptionMap {
  @easyBindingTypeList mAcceptableTypeList ;
  insert insertKey error message "the '%K' binding option is already declared" ;
  search searchKey error message "the '%K' binding option is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassBindingMap {
  @easyBindingTypeAndFormatterList mAcceptableTypeList ;
  @outletClassBindingOptionMap mOutletClassBindingOptionMap ;
  insert insertKey error message "the '%K' binding is already declared" ;
  search searchKey error message "the '%K' binding is not declared" ;
}

#----------------------------------------------------------------------------*

map @outletClassMap {
  @bool mGenerateCode ;
  @string mSuperClassName ;
  @outletClassBindingMap mBindingMap ;
  @bool mHasTableValueBinding ;
  insert insertKey error message "the '%K' outlet class is already declared" ;
  search searchKey error message "the '%K' outlet class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerClassMap {
  @bool mGenerateCode ;
  @outletClassBindingMap mBindingMap ;
  @actionMap mActionMap ;
  @classObservablePropertyMap mObservablePropertyMap ;
  insert insertKey error message "the '%K' controller class is already declared" ;
  search searchKey error message "the '%K' controller class is not declared" ;
}

#----------------------------------------------------------------------------*

map @controllerMap {
  @string mControllerClassName ;
  @string mControlledClassOrEntityName ;
  @outletBindingListForGeneration mControllerBindingList ;
  @actionMap mActionMap ;
  insert insertKey error message "the '%K' controller is already declared" ;
  search searchKey error message "the '%K' controller is not declared" ;
}

#----------------------------------------------------------------------------*

map @relationshipMap {
  @bool mIsToMany ;
  @lstring mDestinationEntityName ;
  @lstring mInverseRelationshipName ;
  @deleteRuleEnum mDeleteRule ;
  insert insertKey error message "the '%K' relationship is already declared" ;
  search searchKey error message "the '%K' relationship is not declared" ;
}

#----------------------------------------------------------------------------*

map @propertyMap {
  insert insertKey error message "there is already a '%K' property (attribute, transient or relationship)" ;
}

#----------------------------------------------------------------------------*

map @actionMap {
  insert insertKey error message "there is already a '%K' action" ;
  search searchKey error message "the '%K' action is not defined" ;
}

#----------------------------------------------------------------------------*
#   ANALYZE ENTITIES                                                         *
#----------------------------------------------------------------------------*

local routine analyzeEntities
  ??@entityList inEntityList
  !@entityMap outEntityMap
:
  outEntityMap := [@entityMap emptyMap] ;
  foreach inEntityList do
    @classObservablePropertyMap classObservablePropertyMap ;
    @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
    @relationshipList allRelationshipList ;
    @string implementationSuperClassName ;
    @propertyMap allPropertyMap ;
    @relationshipMap allRelationshipMap ;
    if [mSuperEntityName string] != "" then
      [outEntityMap searchKey
        !mSuperEntityName
        ?*
        ?implementationSuperClassName
        ?*
        ?classObservablePropertyMap
        ?propertyListForInitMethodHeader
        ?4*
        ?allRelationshipList
        ?allPropertyMap
        ?*
        ?allRelationshipMap
      ] ;
    else
      classObservablePropertyMap := [@classObservablePropertyMap emptyMap] ;
      propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
      implementationSuperClassName := "" ;
      allRelationshipList := [@relationshipList emptyList] ;
      allPropertyMap := [@propertyMap emptyMap] ;
      allRelationshipMap := [@relationshipMap emptyMap] ;
    end if ;
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
  #--- Analyze attributes
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      [!?allPropertyMap insertKey !mAttributeName] ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      propertyListForInitMethodHeader += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      [!?classObservablePropertyMap insertKey !mAttributeName !mType ![@stringlist listWithValue![mAttributeName string]]] ;    
    end foreach ;
  #--- Analyze relationship (only check name is unique)
    @relationshipMap currentRelationshipMap [emptyMap] ;
    foreach mRelationshipList do
      [!?allRelationshipMap insertKey
        !mRelationshipName
        !mIsToMany
        !mDestinationEntityName
        !mInverseRelationshipName
        !mDeleteRule
      ] ;
      [!?currentRelationshipMap insertKey
        !mRelationshipName
        !mIsToMany
        !mDestinationEntityName
        !mInverseRelationshipName
        !mDeleteRule
      ] ;
      [!?allPropertyMap insertKey !mRelationshipName] ;
    end foreach ;
  #--- Analyze transient properties
    @transientListForImplementation transientListForImplementation ;
    analyzeTransientProperties
      !mTransientList
      ![@classObservableObjectMap emptyMap]
      !?classObservablePropertyMap
      ?transientListForImplementation
    ;
  #---
    [!?outEntityMap insertKey
      !mEntityName
      ![mSuperEntityName string]
      ![mImplementationClassName string]
      !implementationSuperClassName
      !classObservablePropertyMap
      !propertyListForInitMethodHeader
      !inheritedAttributeListForImplementation
      !attributeListForImplementation
      !transientListForImplementation
      !mRelationshipList
      !allRelationshipList . mRelationshipList
      !allPropertyMap
      !currentRelationshipMap
      !allRelationshipMap
    ] ;
  end foreach ;
#--- Check relationships
  foreach outEntityMap do
    foreach mCurrentRelationshipMap do
      @relationshipMap destinationEntityRelationshipMap ;
      [outEntityMap searchKey !mDestinationEntityName ?12* ?destinationEntityRelationshipMap] ;
      @lstring inverseOfInverseRelationshipName ;
      [destinationEntityRelationshipMap searchKey !mInverseRelationshipName ?2* ?inverseOfInverseRelationshipName ?*] ;
      if lkey->string != inverseOfInverseRelationshipName->string then
        error mInverseRelationshipName : "the inverse relationship does not name '" . lkey . "' relationship as inverse" ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeOutletBinding
  ??@entityMap inEntityMap
  ??@classObservableObjectMap inObservableObjectMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
;

#----------------------------------------------------------------------------*

override method @tableValueBinding analyzeOutletBinding
  ??@entityMap inEntityMap
  ??@classObservableObjectMap unused inObservableObjectMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap unused inActionMap
  ??@bool inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
:
  if not inHasTableValueBinding then
    error mControllerName: "this outlet does not support $tableValue binding" ;
  else
    @string controlledClassOrEntityName ;
    @outletBindingListForGeneration controllerBindingList ;
    [inControllerMap searchKey
      !mControllerName
      ?*
      ?controlledClassOrEntityName
      ?controllerBindingList
      ?*
    ] ;
    [inEntityMap searchKey
      ![@lstring new !controlledClassOrEntityName !here]
      ?3*
      ?@classObservablePropertyMap observablePropertyMap
      ?9*
    ] ;
    @columnBindingForTableValueBindingForGeneration columnBindingForTableValueBindingForGeneration [emptyList] ;
    for column in mTableValueColumnBinding do
      @easyBindingType type ;
      [observablePropertyMap searchKey
        !column->mBoundPropertyName
        ?type
        ?*
      ] ;
      const @string requiredCellTypeInTableColumnBinding := [type requiredCellTypeInTableColumnBinding] ;
      if requiredCellTypeInTableColumnBinding == "" then
        error column->mBoundPropertyName:"this property cannot be named in a $tableValue binding" ;
      elsif requiredCellTypeInTableColumnBinding != column->mCellTypeName->string then
        error column->mCellTypeName:"this property requires a " . requiredCellTypeInTableColumnBinding . " cell class" ;
      end if ;
      columnBindingForTableValueBindingForGeneration +=
        !column->mColumnName->string
        !requiredCellTypeInTableColumnBinding
        !column->mBoundPropertyName->string
        ![@2stringlist emptyList]
      ;
    end for ;
    ioOutletBindingListForGeneration += ![@tableValueBindingForGeneration new
      !mControllerName->string
      !columnBindingForTableValueBindingForGeneration
    ] ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @runBinding analyzeOutletBinding
  ??@entityMap unused inEntityMap
  ??@classObservableObjectMap unused inObservableObjectMap
  ??@outletClassBindingMap unused inBindingMap
  ??@controllerMap inControllerMap
  ??@actionMap inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
:
  if mTargetName->string == "self" then
    [inActionMap searchKey !mActionName] ;
  else
    @actionMap actionMap ;
    [inControllerMap searchKey !mTargetName ?3* ?actionMap] ;
    [actionMap searchKey !mActionName] ;
  end if ;
  ioOutletBindingListForGeneration += ![@runBindingForGeneration new
    !mTargetName->string
    !mActionName->string
  ] ;
end method ;

#----------------------------------------------------------------------------*

override method @regularBinding analyzeOutletBinding
  ??@entityMap unused inEntityMap
  ??@classObservableObjectMap inObservableObjectMap
  ??@outletClassBindingMap inBindingMap
  ??@controllerMap unused inControllerMap
  ??@actionMap unused inActionMap
  ??@bool unused inHasTableValueBinding
  ?!@outletBindingListForGeneration ioOutletBindingListForGeneration
:
  @outletClassBindingOptionMap outletClassBindingOptionMap ;
  @easyBindingTypeAndFormatterList acceptableTypeFormatterList ;
  [inBindingMap searchKey !mBindingName ?acceptableTypeFormatterList ?outletClassBindingOptionMap] ;
#--- Find preferences observable property
  @string observedObjectOCName ;
  @classObservablePropertyMap observablePropertyMap ;
  if [inObservableObjectMap hasKey !mObservedObjectName->string] then
    [inObservableObjectMap searchKey
      ![@lstring new !mObservedObjectName->string !here]
      ?observedObjectOCName
      ?observablePropertyMap
     ] ;
  else
    error mObservedObjectName
      : "the '" . mObservedObjectName . "' object is not observable"
      : observedObjectOCName, observablePropertyMap
    ;
  end if ;
  @easyBindingType observablePropertyType ;
  [observablePropertyMap searchKey !mObservableAttributeName ?observablePropertyType ?*] ;
#--- check model belongs to an acceptable type
  @bool found := false ;
  @formatterEnum requiredFormatter [noFormatter] ;
  foreach acceptableTypeFormatterList while not found do
    requiredFormatter := mRequiredFormatter ;
    found := mType == observablePropertyType ;
  end foreach ;
  if not found then
    @string s := "the bound property has '" . [observablePropertyType ebTypeName] . "' type, acceptable type(s):" ;
    foreach acceptableTypeFormatterList while not found do
      s .= "\n  - '" . [mType ebTypeName] . "'" ;
    end foreach ;
    error mObservableAttributeName:s ;
  end if ;
#--- Check options
  @2stringlist bindingOptionList [emptyList] ;
  foreach mOutletBindingOptionList do
    @easyBindingTypeList acceptableTypeList ;
    [outletClassBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    bindingOptionList += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
  ioOutletBindingListForGeneration += ![@regularBindingForGeneration new
    ![mBindingName string]
    !requiredFormatter
    !observedObjectOCName
    ![mObservableAttributeName string]
    !bindingOptionList
  ] ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzePreferences
  ??@entityMap inEntityMap
  ??@preferencesDeclarationList inPreferencesList
  ??@outletClassMap inOutletClassMap
  !@preferencesMap outPreferencesMap
:
  outPreferencesMap := [@preferencesMap emptyMap] ;
  foreach inPreferencesList do
    @classObservablePropertyMap observableAttributeMap [emptyMap] ;
  #--- Analyze actions
    @actionMap actionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?actionMap insertKey !actionName->mValue] ;
    end for ;
  #--- Analyze attributes
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      [!?observableAttributeMap insertKey !mAttributeName !mType ![@stringlist listWithValue![mAttributeName string]]] ;
    end foreach ;
  #--- Analyze transient properties
    @transientListForImplementation transientListForImplementation ;
    analyzeTransientProperties
      !mTransientList
      ![@classObservableObjectMap emptyMap]
      !?observableAttributeMap
      ?transientListForImplementation
    ;
  #--- Build observable object map
    @classObservableObjectMap observableObjectMap [emptyMap] ;
    [!?observableObjectMap insertKey
      !["self" nowhere]
      !"self"
      !observableAttributeMap
    ] ;
  #--- Analyze outlets
    @outletGenerationList outletGenerationList [emptyList] ;
    foreach mOutletDeclarationList do
      @outletClassBindingMap bindingMap ;
      @bool hasTableValueBinding ;
      [inOutletClassMap searchKey !mOutletType ?2* ?bindingMap ?hasTableValueBinding] ;
      @outletBindingListForGeneration outletBindingList [emptyList] ;
      foreach mOutletBindingList do
        [mBinding analyzeOutletBinding
          !inEntityMap
          !observableObjectMap
          !bindingMap
          ![@controllerMap emptyMap]
          !actionMap
          !hasTableValueBinding
          !?outletBindingList
        ] ;
      end foreach ;
      outletGenerationList += ![mOutletType string] ![mOutletName string] !outletBindingList ;
    end foreach ;
  #---
    [!?outPreferencesMap insertKey
      !mPreferencesName
      !attributeListForImplementation
      !transientListForImplementation
      !outletGenerationList
      !mActionDeclarationList
      !observableAttributeMap
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

reader @easyBindingType ebTypeIdentifier ??@string inClassOrEntityName -> @string outResult :
  switch selfcopy
  when boolType : outResult := "bool" ;
  when integer16Type : outResult := "integer16" ;
  when integer32Type : outResult := "integer32" ;
  when integer64Type : outResult := "integer64" ;
  when decimalType : outResult := "decimal" ;
  when floatType : outResult := "float" ;
  when doubleType : outResult := "double" ;
  when stringType : outResult := "NSString" ;
  when dataType : outResult := "NSData" ;
  when dateType : outResult := "NSDate" ;
  when fontType : outResult := "NSFont" ;
  when imageType : outResult := "NSImage" ;
  when colorType : outResult := "NSColor" ;
  when toManyEntitiesType : outResult := "toMany[" . inClassOrEntityName . "]" ;
  end switch ;
end reader ;

#----------------------------------------------------------------------------*

local routine checkBindingOptions
  ??@outletBindingOptionList inBindingOptionListAST
  ??@outletClassBindingOptionMap inAvailableBindingOptionMap
  !@2stringlist outBindingOptionListForGeneration
:
  outBindingOptionListForGeneration := [@2stringlist emptyList] ;
  foreach inBindingOptionListAST do
    @easyBindingTypeList acceptableTypeList ;
    [inAvailableBindingOptionMap searchKey !mOptionName ?acceptableTypeList] ;
    @bool found := false ;
    foreach acceptableTypeList while not found do
      foreach mOptionValuePossibleTypes prefixedby optionValue_ while not found do
        found := mType == optionValue_mType ;
      end foreach ;
    end foreach ;
    if not found then
      @string s := "the option value acceptable types are:" ;
      foreach acceptableTypeList while not found do
        s .= "\n  - '" . [mType ebTypeName] . "'" ;
      end foreach ;
      error mOptionName:s ;
    end if ;
    outBindingOptionListForGeneration += ![mOptionName string] !mOptionValueObjectiveCObject ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

abstract method @abstractBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@classObservablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
;

#----------------------------------------------------------------------------*

override method @tableValueBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@classObservablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mControllerName: "a controller does not implement $tableValue binding" ;
end method ;

#----------------------------------------------------------------------------*

override method @runBinding analyzeControllerBinding
  ??@relationshipMap unused inAllRelationshipMap
  ??@outletClassBindingMap unused inControllerClassBindingMap
  ??@lstring unused inControlledClassOrEntityName
  ??@classObservablePropertyMap unused inAllObservablePropertyMap
  ?!@outletBindingListForGeneration unused ioBindingListForGeneration
:
  error mTargetName: "a controller does not implement $run action" ;
end method ;

#----------------------------------------------------------------------------*

override method @regularBinding analyzeControllerBinding
  ??@relationshipMap inAllRelationshipMap
  ??@outletClassBindingMap inControllerClassBindingMap
  ??@lstring inControlledClassOrEntityName
  ??@classObservablePropertyMap inAllObservablePropertyMap
  ?!@outletBindingListForGeneration ioBindingListForGeneration
:
  @string resultingObservedObjectName ;
  @string resultingObservedPropertyPath ;
  if mObservedObjectName->string == "root" then
    resultingObservedObjectName := "mRootObjectController" ;
    resultingObservedPropertyPath := "selection." . mObservableAttributeName ;
  else
    error mObservedObjectName
    : "observed object should be 'root'"
    : resultingObservedObjectName, resultingObservedPropertyPath
    ;
  end if ;
  @string boundTypeIdentifierString ;
  if [inAllObservablePropertyMap hasKey !mObservableAttributeName->string] then
    @easyBindingType t ;
    [inAllObservablePropertyMap searchKey !mObservableAttributeName ?t ?*] ;
    boundTypeIdentifierString := [t ebTypeIdentifier !""] ;
  elsif [inAllRelationshipMap hasKey !mObservableAttributeName->string] then
    @bool isToMany ;
    @lstring destinationEntityName ;
    [inAllRelationshipMap searchKey !mObservableAttributeName ?isToMany ?destinationEntityName ?2*] ;
    if isToMany then
      boundTypeIdentifierString := "toMany[" . destinationEntityName . "]" ;
    else
      boundTypeIdentifierString := "toOne[" . destinationEntityName . "]" ;
    end if ;
  else
    error mObservableAttributeName
    :"unknown property"
    : boundTypeIdentifierString ;
  end if ;
  @easyBindingTypeAndFormatterList acceptableTypeList ;
  @outletClassBindingOptionMap availableBindingOptionMap ;
  [inControllerClassBindingMap searchKey !mBindingName ?acceptableTypeList ?availableBindingOptionMap] ;
  @bool found := false ;
  @string acceptableTypesString := "" ;
  foreach acceptableTypeList while not found do
     const @string acceptableType := [mType ebTypeIdentifier !inControlledClassOrEntityName->string] ;
     acceptableTypesString .= "\n-  '" . acceptableType . "'" ;
     found := boundTypeIdentifierString == acceptableType ;
  end foreach ;
  if not found then
    error mObservableAttributeName
    :"cannot bind: property type is '" . boundTypeIdentifierString . "', acceptable type(s):" . acceptableTypesString
    ;
  end if ;
  checkBindingOptions
    !mOutletBindingOptionList
    !availableBindingOptionMap
    ?@2stringlist bindingOptionListForGeneration
  ;
  ioBindingListForGeneration += ![@regularBindingForGeneration new
    !mBindingName->string
    ![@formatterEnum noFormatter]
    !resultingObservedObjectName
    !resultingObservedPropertyPath
    !bindingOptionListForGeneration
  ] ;
end method ;

#----------------------------------------------------------------------------*

local routine analyzeDocuments
  ??@documentDeclarationList inDocumentDeclarationList
  ??@outletClassMap inOutletClassMap
  ??@controllerClassMap inControllerClassMap
  ??@entityMap inEntityMap
  ??@preferencesMap inPreferencesMap
  !@documentMap outDocumentMap
:
  outDocumentMap := [@documentMap emptyMap] ;
  foreach inDocumentDeclarationList do
    @string rootEntityImplementationClassName ;
    @classObservablePropertyMap observablePropertyMap ;
    @relationshipMap allRelationshipMap ;
    [inEntityMap searchKey
      !mRootEntityName
      ?*
      ?rootEntityImplementationClassName
      ?*
      ?observablePropertyMap
      ?8*
      ?allRelationshipMap
    ] ;
  #--- Build observable object map
    @classObservableObjectMap observableObjectMap [emptyMap] ;
    [!?observableObjectMap insertKey
      !["root" nowhere]
      !"mRootObject"
      !observablePropertyMap
    ] ;
    for pref in inPreferencesMap do
      [!?observableObjectMap insertKey
        !pref->lkey
        !pref->lkey->string
        !pref->mObservablePropertyMap
      ] ;
    end for ;
  #--- Analyze controllers
    @controllerMap controllerMap [emptyMap] ;
    foreach mControllerList do
      @outletClassBindingMap controllerClassBindingMap ;
      @actionMap controllerActionMap ;
      @classObservablePropertyMap controllerObservablePropertyMap ;
      [inControllerClassMap searchKey
        !mControllerClassName
        ?*
        ?controllerClassBindingMap
        ?controllerActionMap
        ?controllerObservablePropertyMap
      ] ;
      [!?observableObjectMap insertKey
        !mControllerName
        !mControllerName->string
        !controllerObservablePropertyMap
      ] ;
      [inEntityMap searchKey !mControlledClassOrEntityName ?13*] ;
      @outletBindingListForGeneration bindingListForGeneration [emptyList] ;
      foreach mControllerBindingList do
        [mBinding analyzeControllerBinding
          !allRelationshipMap
          !controllerClassBindingMap
          !mControlledClassOrEntityName
          !observablePropertyMap
          !?bindingListForGeneration
        ] ;
      end foreach ;
      [!?controllerMap insertKey
        !mControllerName
        !mControllerClassName->string
        !mControlledClassOrEntityName->string
        !bindingListForGeneration
        !controllerActionMap
      ] ;
    end foreach ;
  #--- Analyze transient properties
    @transientListForImplementation transientListForImplementation ;
    analyzeTransientProperties
      !mTransientList
      !observableObjectMap
      !?observablePropertyMap
      ?transientListForImplementation
    ;
  #--- Analyze actions
    @actionMap documentActionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?documentActionMap insertKey !actionName->mValue] ;
    end for ;
  #--- Analyze outlets
    [!?observableObjectMap insertKey
      !["self" nowhere]
      !"self"
      !observablePropertyMap
    ] ;
    @outletGenerationList outletGenerationList [emptyList] ;
    foreach mOutletDeclarationList do
      @outletClassBindingMap bindingMap ;
      @bool hasTableValueBinding ;
      [inOutletClassMap searchKey !mOutletType ?2* ?bindingMap ?hasTableValueBinding] ;
      @outletBindingListForGeneration outletBindingList [emptyList] ;
      foreach mOutletBindingList do
        [mBinding analyzeOutletBinding
          !inEntityMap
          !observableObjectMap
          !bindingMap
          !controllerMap
          !documentActionMap
          !hasTableValueBinding
          !?outletBindingList
        ] ;
      end foreach ;
      outletGenerationList += ![mOutletType string] ![mOutletName string] !outletBindingList ;
    end foreach ;
  #---
    [!?outDocumentMap insertKey
      !mDocumentName
      ![mRootEntityName string]
      !rootEntityImplementationClassName
      !outletGenerationList
      !controllerMap
      !mActionDeclarationList
      !transientListForImplementation
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine checkDefaultValueType
  ??@easyBindingTypeList inDefaultValueCorrespondingAcceptableTypes
  ??@easyBindingType inAttributeActualType
  ??@lstring inAttributeName
:
  @bool found := false ;
  foreach inDefaultValueCorrespondingAcceptableTypes while not found do
    found := inAttributeActualType == mType ;
  end foreach ;
  if not found then
    error inAttributeName: "the default value is invalue for this attribute" ;
  end if ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeClasses
  ??@classList inClassList
  !@classMap outClassMap
:
  outClassMap := [@classMap emptyMap] ;
  foreach inClassList do
    @classObservablePropertyMap classObservablePropertyMap ;
    @attributeListForImplementation propertyListForInitMethodHeader [emptyList] ;
    if [mSuperClassName string] != "" then
      [outClassMap searchKey !mSuperClassName ?* ?classObservablePropertyMap ?propertyListForInitMethodHeader ?3*] ;
    else
      classObservablePropertyMap := [@classObservablePropertyMap emptyMap] ;
      propertyListForInitMethodHeader := [@attributeListForImplementation emptyList] ;
    end if ;
    @attributeListForImplementation attributeListForImplementation [emptyList] ;
    const @attributeListForImplementation inheritedAttributeListForImplementation := propertyListForInitMethodHeader ;
    foreach mAttributeList do
      checkDefaultValueType !mDefaultValueCorrespondingAcceptableTypes !mType !mAttributeName ;
      attributeListForImplementation += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      propertyListForInitMethodHeader += !mType ![mAttributeName string] !mDefaultValueObjectiveCObject !mDirectDefaultValue ;
      [!?classObservablePropertyMap insertKey !mAttributeName !mType ![@stringlist listWithValue![mAttributeName string]]] ;    
    end foreach ;
  #--- Analyze transient properties
    @transientListForImplementation transientListForImplementation ;
    analyzeTransientProperties
      !mTransientList
      ![@classObservableObjectMap emptyMap]
      !?classObservablePropertyMap
      ?transientListForImplementation
    ;
  #---
    [!?outClassMap insertKey
      !mClassName
      ![mSuperClassName string]
      !classObservablePropertyMap
      !propertyListForInitMethodHeader
      !inheritedAttributeListForImplementation
      !attributeListForImplementation
      !transientListForImplementation
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeOutletClasses
  ??@outletClassList inOutletClassList
  !@outletClassMap outOutletClassMap
:
  outOutletClassMap := [@outletClassMap emptyMap] ;
  foreach inOutletClassList do
  #---
    @outletClassBindingMap bindingMap [emptyMap] ;
    foreach mOutletClassBindingList do
      @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
      foreach mBindingOptionList do
        [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
#        foreach mAcceptableTypeList do
#        
#        
#        end foreach ;
      end foreach ;
      [!?bindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
    end foreach ;
  #---
    [!?outOutletClassMap insertKey
      !mOutletClassName
      !mGenerateCode
      !mSuperClassName->string
      !bindingMap
      !mHasTableValueBinding
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

local routine analyzeControllerClasses
  ??@controllerClassList inControllerClassList
  !@controllerClassMap outControllerClassMap
:
  outControllerClassMap := [@controllerClassMap emptyMap] ;
  foreach inControllerClassList do
  #--- Analyze actions
    @actionMap actionMap [emptyMap] ;
    for actionName in mActionDeclarationList do
      [!?actionMap insertKey !actionName->mValue] ;
    end for ;
  #---
    @outletClassBindingMap bindingMap [emptyMap] ;
    foreach mBindingList do
      @outletClassBindingOptionMap outletClassBindingOptionMap [emptyMap] ;
      foreach mBindingOptionList do
        [!?outletClassBindingOptionMap insertKey !mBindingOptionName !mAcceptableTypeList] ;
#        foreach mAcceptableTypeList do
#        
#        
#        end foreach ;
      end foreach ;
      [!?bindingMap insertKey !mBindingName !mAcceptableTypeFormatterList !outletClassBindingOptionMap] ;
    end foreach ;
  #---
    @classObservablePropertyMap observablePropertyMap [emptyMap] ;
    for property in mControllerObservablePropertyList do
      [!?observablePropertyMap insertKey !property->mPropertyName !property->mType ![@stringlist emptyList]] ;
    end for ;
  #---
    [!?outControllerClassMap insertKey
      !mOutletClassName
      !mGenerateCode
      !bindingMap
      !actionMap
      !observablePropertyMap
    ] ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

routine semanticAnalysis
  ??@ASTstruct inAST
  !@outletClassMap outOutletClassMap
  !@controllerClassMap outControllerClassMap
  !@classMap outClassMap
  !@entityMap outEntityMap
  !@preferencesMap outPreferencesMap
  !@documentMap outDocumentMap
:
  analyzeOutletClasses !inAST->mOutletClassList ?outOutletClassMap ;
  analyzeControllerClasses !inAST->mControllerClassList ?outControllerClassMap ;
  analyzeClasses !inAST->mClassList ?outClassMap ;
  analyzeEntities !inAST->mEntityList ?outEntityMap ;
  analyzePreferences !outEntityMap !inAST->mPreferencesList !outOutletClassMap ?outPreferencesMap ;
  analyzeDocuments !inAST->mDocumentDeclarationList !outOutletClassMap !outControllerClassMap !outEntityMap !outPreferencesMap ?outDocumentMap ;
end routine ;

#----------------------------------------------------------------------------*


end semantics ;
