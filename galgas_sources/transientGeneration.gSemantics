semantics transientGeneration :
  import "easyBindings_options.gOption" ;
  import "decoratedTypes.gSemantics" ;

#-----------------------------------------------------------------------------*
#   generateAttributeDeclarationInSwift                                       *
#-----------------------------------------------------------------------------*

reader @EXebType generateAttributeDeclarationInSwift
  ??@string unused inDeclarationKind # "entity, class, ...
  ??@string unused inKindName # Entity name, class name, ...
  ??@string inAttributeName
  ??@string inDirectSwiftDefaultValue
  ??generateUndoHandling:@bool inGenerateUndoHandling
  ->@string outResult
:
  outResult := "  //-------------------------------------------------------------------------------------------------------------------*\n" ;
  outResult += "  //    " + ["Attribute: " + inAttributeName stringByRightPadding !111 !' '] + "*\n" ;
  outResult += "  //-------------------------------------------------------------------------------------------------------------------*\n\n" ;
  outResult += "  var " + inAttributeName + "__explorer : NSTextField?\n" ;
  outResult += "  var " + inAttributeName + "_observers = NSMutableSet ()\n\n" ;

  switch mKind
  when enumType :
    outResult += "  var " + inAttributeName + " : " + [selfcopy swiftTypeName] + " = " + inDirectSwiftDefaultValue + "\n" ;
    outResult += "  var " + inAttributeName + "__as__number : NSNumber {\n"
                 "    get {\n"
                 "      return " + inAttributeName + ".toRaw ()\n"
                 "    }\n"
                 "    set {\n" ;
    if inGenerateUndoHandling then
      outResult += "      undoManager ().registerUndoWithTarget (self,\n"
                   "        selector:\"set" + [inAttributeName stringByCapitalizingFirstCharacter] + "__as__number:\",\n"
                   "        object:" + inAttributeName + "__as__number\n"
                   "      )\n" ;
    end if ;
    outResult += "      let v : Int? = newValue.integerValue\n"
                 "      " + inAttributeName + " = " + [selfcopy swiftTypeName] + ".fromRaw (v!)!\n"
                 "      if " + inAttributeName + "__explorer {\n"
                 "        " + inAttributeName + "__explorer!.stringValue = " + inAttributeName + ".string ()\n"
                 "      }\n" ;
  when integerType :
    outResult += "  var " + inAttributeName + "__as__number : NSNumber {\n"
                 "    get {\n"
                 "      return NSNumber (longLong:" + inAttributeName + ")\n"
                 "    }\n"
                 "    set {\n"
                 "      " + inAttributeName + " = newValue.longLongValue\n"
                 "    }\n"
                 "  }\n\n"
                 "  var " + inAttributeName + " : " + [selfcopy swiftTypeName] + " =  " + inDirectSwiftDefaultValue + " {\n" ;
    if inGenerateUndoHandling then
       outResult += "    willSet {\n"
                    "      undoManager ().registerUndoWithTarget (self,\n"
                    "        selector:\"set" + [inAttributeName stringByCapitalizingFirstCharacter] + "__as__number:\",\n"
                    "        object:" + inAttributeName + "__as__number\n"
                    "      )\n"
                    "    }\n" ;
    end if ;
    outResult += "    didSet {\n"
                 "      if " + inAttributeName + "__explorer {\n"
                 "        " + inAttributeName + "__explorer!.stringValue = NSString (format:\"%lld\", " + inAttributeName + ")\n"
                 "      }\n" ;
  when colorType, bezierPathType, boolType, classType, controllerClassType, dataType,
        dateType, documentType, doubleType, entityType, fontType, imageType, menuType,
        nibClassType, outletClassType, preferencesType, protocolType, stringType, structType, uintegerType :
    outResult += "  var " + inAttributeName + " : " + [selfcopy swiftTypeName] + " =  " + inDirectSwiftDefaultValue + " {\n" ;
    if inGenerateUndoHandling then
      outResult += "    willSet {\n"
                   "      undoManager ().registerUndoWithTarget (self,\n"
                   "        selector:\"set" + [inAttributeName stringByCapitalizingFirstCharacter] + ":\",\n"
                   "        object:" + [selfcopy valueForUndoManager !inAttributeName] + "\n"
                   "      )\n"
                   "    }\n" ;
    end if ;
    outResult += "    didSet {\n"
                 "      if " + inAttributeName + "__explorer {\n"
                 "        " + inAttributeName + "__explorer!.stringValue = " + [selfcopy valueAccessorForExplorerWindow !inAttributeName] + "\n"
                 "      }\n" ;
  end switch ;
  outResult += "    //--- Notify observers\n"
               "      for anyObject in " + inAttributeName + "_observers.allObjects {\n"
               "        let object = anyObject as PMTriggerProtocol\n"
               "        enterTriggerWithObject (object)\n"
               "      }\n"
               "    }\n"
               "  }\n\n"
               "  func addObserverOf_" + inAttributeName + " (inObserver : PMTriggerProtocol) {\n"
               "    " + inAttributeName + "_observers.addObject (inObserver)\n"
               "    enterTriggerWithObject (inObserver)\n"
               "  }\n\n"
               "  func removeObserverOf_" + inAttributeName + " (inObserver : PMTriggerProtocol) {\n"
               "    " + inAttributeName + "_observers.removeObject (inObserver)\n"
               "    enterTriggerWithObject (inObserver)\n"
               "  }\n" ;
end reader ;

#----------------------------------------------------------------------------*

#! generateSwiftFormalArgument

#----------------------------------------------------------------------------*

abstract reader @abstractTransientDependencyForImplementation generateSwiftFormalArgument
  ->@string outResult
;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromSelfForImplementation generateSwiftFormalArgument
  ->@string outResult
:
  if mNamesCountOption then
    outResult := mMasterAttributeName . "_count : Int" ;
  else
  outResult := mMasterAttributeName . " : " . [mMasterAttributeType swiftTypeName] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromControllerForImplementation generateSwiftFormalArgument
  ->@string outResult
:
  outResult := mMasterAttributeName . " : " . [mMasterAttributeType swiftTypeName] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromRootForImplementation generateSwiftFormalArgument
  ->@string outResult
:
  if mNamesCountOption then
    outResult := "in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] . "_count : Int" ;
  else
    outResult := mMasterAttributeName . " : " . [mMasterAttributeType swiftTypeName] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromPreferenceForImplementation generateSwiftFormalArgument
  ->@string outResult
:
  outResult := mMasterAttributeName . " : " . [mMasterAttributeType swiftTypeName] ;
end reader ;

#----------------------------------------------------------------------------*

#! generateFormalObjectiveCArgument

#----------------------------------------------------------------------------*

abstract reader @abstractTransientDependencyForImplementation generateFormalObjectiveCArgument
  ->@string outResult
;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromSelfForImplementation generateFormalObjectiveCArgument
  ->@string outResult
:
  if mNamesCountOption then
    outResult := "const NSUInteger in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] . "_count" ;
  else
    outResult := [mMasterAttributeType ocTypeName] . " in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromControllerForImplementation generateFormalObjectiveCArgument
  ->@string outResult
:
  outResult := [mMasterAttributeType ocTypeName] . " in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromRootForImplementation generateFormalObjectiveCArgument
  ->@string outResult
:
  if mNamesCountOption then
    outResult := "const NSUInteger in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] . "_count" ;
  else
    outResult := [mMasterAttributeType ocTypeName] . " in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromPreferenceForImplementation generateFormalObjectiveCArgument
  ->@string outResult
:
  outResult := [mMasterAttributeType ocTypeName] . " in" . [mMasterAttributeName stringByCapitalizingFirstCharacter] ;
end reader ;

#----------------------------------------------------------------------------*

#!generateObjectiveCMasterAttributeCall

#----------------------------------------------------------------------------*

abstract reader @abstractTransientDependencyForImplementation generateObjectiveCMasterAttributeCall
  ->@string outResult
;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromSelfForImplementation generateObjectiveCMasterAttributeCall
  ->@string outResult
:
  outResult := "self." . mMasterAttributeName ;
  if mNamesCountOption then
    outResult .= ".count" ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromRootForImplementation generateObjectiveCMasterAttributeCall
  ->@string outResult
:
  outResult := "self.rootObject." . mMasterAttributeName ;
  if mNamesCountOption then
    outResult .= ".count" ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromControllerForImplementation generateObjectiveCMasterAttributeCall
  ->@string outResult
:
  outResult := mControllerName . "." . mMasterAttributeName ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromPreferenceForImplementation generateObjectiveCMasterAttributeCall
  ->@string outResult
:
  outResult := "g_" . mPreferenceName . "." . mMasterAttributeName ;
end reader ;

#----------------------------------------------------------------------------*

function generateTransientFunctionDeclarations
  ??@string inKindName
  ??@transientListForImplementation inTransientListForImplementation
  ->@string outResult
:
  @stringset inclusionSet [emptySet] ;
  foreach inTransientListForImplementation do
    [mTransientType addInclusionInHeaderFile !?inclusionSet] ;
    foreach mDependencyList do
      [[mDependency mMasterAttributeType] addInclusionInHeaderFile !?inclusionSet] ;
    end foreach ;
  end foreach ;  
  outResult := "" ;
  foreach inclusionSet do
    outResult .= "#import \"" . key . ".h\"\n" ;
  end foreach ;
#---
  outResult .=
    "//-------------------------------------------------------------------------------------------------------------------*\n"
  . "//   T R A N S I E N T    P R O P E R T I E S                                 *\n"
  . "//-------------------------------------------------------------------------------------------------------------------*\n\n" ;

  foreach inTransientListForImplementation do
    outResult .= [mTransientType ocTypeName] . " compute_" . inKindName . "_" . mTransientName . " (\n" ;
    @bool first := true ;
    foreach mDependencyList do
      if first then
        first := false ;
      else
        outResult .= ",\n" ;
      end if ;
      outResult .= "    " . [mDependency generateFormalObjectiveCArgument] ;
    end foreach ;
    foreach mRootSignDependencyList do
      if first then
        first := false ;
      else
        outResult .= ",\n" ;
      end if ;
      outResult .= "    const NSInteger inSignature" ;
    end foreach ;
    outResult .= ") ;\n\n" ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

function generateTransientFunctionImplementation
  ??@string inKindName
  ??@EXebType inTransientType
  ??@string inTransientName
  ??@directDependancyList inDependencyList
  ??@stringlist inRootSignDependencyList
  ->@string outResult
:
  @stringset inclusionSet [emptySet] ;
  [inTransientType addInclusionInImplementationFile !?inclusionSet] ;
  foreach inDependencyList do
    [[mDependency mMasterAttributeType] addInclusionInImplementationFile !?inclusionSet] ;
  end foreach ;
  outResult := "" ;
  foreach inclusionSet do
    outResult .= "#import \"" . key . ".h\"\n" ;
  end foreach ;
#---
  outResult .= [inTransientType ocTypeName] . " compute_" . inKindName . "_" . inTransientName . " (\n" ;
  @bool first := true ;
  foreach inDependencyList do
    if first then
      first := false ;
    else
      outResult .= ",\n" ;
    end if ;
    outResult .= "    " . [mDependency generateFormalObjectiveCArgument] ;
  end foreach ;
  foreach inRootSignDependencyList do
    if first then
      first := false ;
    else
      outResult .= ",\n" ;
    end if ;
    outResult .= "    const NSInteger inSignature" ;
  end foreach ;
  outResult .= ") {\n" ;
end function ;

#----------------------------------------------------------------------------*

function generateTransientFunctionImplementationInSwift
  ??@string inKindName
  ??@EXebType inTransientType
  ??@string inTransientName
  ??@directDependancyList inDependencyList
  ??@stringlist inRootSignDependencyList
  ->@string outResult
:
  @stringset inclusionSet [emptySet] ;
  [inTransientType addInclusionInImplementationFile !?inclusionSet] ;
  foreach inDependencyList do
    [[mDependency mMasterAttributeType] addInclusionInImplementationFile !?inclusionSet] ;
  end foreach ;
#---
  outResult := "func compute_" . inKindName . "_" . inTransientName . " (\n" ;
  @bool first := true ;
  foreach inDependencyList do
    if first then
      first := false ;
    else
      outResult .= ",\n" ;
    end if ;
    outResult .= "    " . [mDependency generateSwiftFormalArgument] ;
  end foreach ;
  foreach inRootSignDependencyList do
    if first then
      first := false ;
    else
      outResult .= ",\n" ;
    end if ;
    outResult .= "    inSignature : Int" ;
  end foreach ;
  outResult .= ") -> " . [inTransientType swiftTypeName] . " {\n" ;
end function ;

#----------------------------------------------------------------------------*

function generateObjectiveCTransientCacheRoutine
  ??@string inKindName 
  ??@transientListForImplementation inTransientListForImplementation
  ->@string outResult
:
  outResult := "" ;
  foreach inTransientListForImplementation do
    outResult .=
    "//-------------------------------------------------------------------------------------------------------------------*\n"
    "// Cache routine of '" . mTransientName . "' transient     *\n"
    "//-------------------------------------------------------------------------------------------------------------------*\n\n"   
    "- (" . [mTransientType ocTypeName] . ") " . mTransientName . " {\n"
    "  if (! " . mTransientName . "__computed) {\n"
    "    " . mTransientName . "__cache = compute_" . inKindName . "_" . mTransientName . " (" ;
    @bool first := true ;
    foreach mDependencyList do
      if first then
        first := false ;
      else
        outResult .= ", " ;
      end if ;
      outResult .= [mDependency generateObjectiveCMasterAttributeCall] ;
    end foreach ;
    foreach mRootSignDependencyList do
      if first then
        first := false ;
      else
        outResult .= ", " ;
      end if ;
      outResult .= "self.rootObject.signature" ;
    end foreach ;
    outResult .= ") ;\n"
    "    " . mTransientName . "__computed = YES ;\n"
    "  }\n"
    "  return " . mTransientName . "__cache" ;
    if [mTransientType copyOnAssign] then outResult .= ".copy" ; end if ;
    outResult .= " ;\n"
    "}\n\n" ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

#!generateSwiftMasterAttributeCall

#----------------------------------------------------------------------------*

abstract reader @abstractTransientDependencyForImplementation generateSwiftMasterAttributeCall
  ->@string outResult
;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromSelfForImplementation generateSwiftMasterAttributeCall
  ->@string outResult
:
  outResult := mMasterAttributeName ;
  if mNamesCountOption then
    outResult .= ".count" ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromRootForImplementation generateSwiftMasterAttributeCall
  ->@string outResult
:
  outResult := "rootObject." . mMasterAttributeName ;
  if mNamesCountOption then
    outResult .= ".count" ;
  end if ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromControllerForImplementation generateSwiftMasterAttributeCall
  ->@string outResult
:
  outResult := mControllerName . "." . mMasterAttributeName ;
end reader ;

#----------------------------------------------------------------------------*

override reader @transientDependencyFromPreferenceForImplementation generateSwiftMasterAttributeCall
  ->@string outResult
:
  outResult := "(g_" . mPreferenceName . "?." . mMasterAttributeName . ")!" ;
end reader ;

#----------------------------------------------------------------------------*

function generateSwiftTransientCacheRoutine
  ??@string inKindName 
  ??@EXebType unused mTransientType
  ??@string mTransientName
  ??@directDependancyList mDependencyList
  ??@stringlist mRootSignDependencyList
  ->@string outResult
:
  outResult :=
  "    if " . mTransientName . "__cache == nil {\n"
  "      if TRACE_TRANSIENT_TRIGGER {\n"
  "        NSLog (\"Compute transient " . inKindName . "." . mTransientName . "\")\n"
  "      }\n"
  "      " . mTransientName . "__cache = compute_" . inKindName . "_" . mTransientName . " (" ;
  @bool first := true ;
  foreach mDependencyList do
    if first then
      first := false ;
    else
      outResult .= ", " ;
    end if ;
    outResult .= [mDependency generateSwiftMasterAttributeCall] ;
  end foreach ;
  foreach mRootSignDependencyList do
    if first then
      first := false ;
    else
      outResult .= ", " ;
    end if ;
    outResult .= "self.rootObject.signature" ;
  end foreach ;
  outResult += ") ;\n"
               "    }\n"
               "    return " . mTransientName . "__cache!\n" ;
end function ;

#----------------------------------------------------------------------------*

listmap @triggeredKeysForSelfObject (@stringlist) ;

#----------------------------------------------------------------------------*

listmap @triggeredKeysForOtherObjects (@2stringlist) ;

#----------------------------------------------------------------------------*
#!generateObjectiveCTransientTriggerFromSelfAttribute
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateObjectiveCTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateObjectiveCTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
:
  if [ioMasterAttributeSet hasKey !mMasterAttributeName] then
    ioMasterAttributeSet += !inTransientName ;
    ioRegisteredTransientSet += !inTransientName ;
    ioContinue := true ;
    ioResult .=
    "  //--- Trigger '" . inTransientName . " transient'\n"
    "    if (" . inTransientName . "__computed) {\n"
    "      " . inTransientName . "__computed = NO ;\n"
    "      [PMApplication\n"
    "        enterTriggerForObject:self\n"
    "        transientIndex:" . [inPrefix . "." . inClassName . "." . inTransientName identifierRepresentation] . "\n"
    "      ] ;\n"
    "    }\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateObjectiveCTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
:
  if [ioMasterAttributeSet hasKey !mMasterAttributeName] then
    ioMasterAttributeSet += !inTransientName ;
    ioRegisteredTransientSet += !inTransientName ;
    ioContinue := true ;
    ioResult .=
    "  //--- Trigger '" . inTransientName . " transient'\n"
    "    if (" . inTransientName . "__computed) {\n"
    "      " . inTransientName . "__computed = NO ;\n"
    "      [PMApplication\n"
    "        enterTriggerForObject:self\n"
    "        transientIndex:" . [inPrefix . "." . inClassName . "." . inTransientName identifierRepresentation] . "\n"
    "      ] ;\n"
    "    }\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateObjectiveCTransientTriggerFromSelfAttribute
  ??@string unused inPrefix # entity, class, preference
  ??@string unused inClassName
  ??@string unused inTransientName
  ?!@stringset unused ioMasterAttributeSet
  ?!@stringset unused ioRegisteredTransientSet
  ?!@bool unused ioContinue
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateObjectiveCTransientTriggerFromSelfAttribute
  ??@string unused inPrefix # entity, class, preference
  ??@string unused inClassName
  ??@string unused inTransientName
  ?!@stringset unused ioMasterAttributeSet
  ?!@stringset unused ioRegisteredTransientSet
  ?!@bool unused ioContinue
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

function generateObjectiveCTransientTriggering
  ??@string inPropertyName
  ??@string inClassName
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inPrefix # entity, class, preference
  ->@string outResult
:
  outResult := "" ;
#----
  @stringset masterSet [setWithString !inPropertyName] ;
  @stringset registeredTransientSet [emptySet] ;
  @bool looping := true ;
  loop [inTransientListForImplementation length] + 1 : while looping do
    looping := false ;
    foreach inTransientListForImplementation do
      foreach mDependencyList do
        if (not [registeredTransientSet hasKey !mTransientName]) then
          [mDependency generateObjectiveCTransientTriggerFromSelfAttribute
            !inPrefix
            !inClassName
            !mTransientName
            !?masterSet
            !?registeredTransientSet
            !?looping
            !?outResult
          ] ;
        end if ;
      end foreach ;
    end foreach ;
  end loop ;
end function ;

#----------------------------------------------------------------------------*
#!generateSwiftTransientTriggerFromSelfAttribute
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateSwiftTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateSwiftTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
:
  if [ioMasterAttributeSet hasKey !mMasterAttributeName] then
    ioMasterAttributeSet += !inTransientName ;
    ioRegisteredTransientSet += !inTransientName ;
    ioContinue := true ;
    ioResult .=
    "      //--- Trigger '" . inTransientName . " transient'\n"
    "        if " . inTransientName . "__cache != nil {\n"
    "          " . inTransientName . "__cache = nil\n"
    "          enterTriggerForObject_" . [inPrefix . "." . inClassName . "." . inTransientName identifierRepresentation] . " (self)\n"
    "        }\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateSwiftTransientTriggerFromSelfAttribute
  ??@string inPrefix # entity, class, preference
  ??@string inClassName
  ??@string inTransientName
  ?!@stringset ioMasterAttributeSet
  ?!@stringset ioRegisteredTransientSet
  ?!@bool ioContinue
  ?!@string ioResult
:
  if [ioMasterAttributeSet hasKey !mMasterAttributeName] then
    ioMasterAttributeSet += !inTransientName ;
    ioRegisteredTransientSet += !inTransientName ;
    ioContinue := true ;
    ioResult .=
    "      //--- Trigger '" . inTransientName . " transient'\n"
    "        if " . inTransientName . "__cache != nil {\n"
    "          " . inTransientName . "__cache = nil\n"
    "          enterTriggerForObject_" . [inPrefix . "." . inClassName . "." . inTransientName identifierRepresentation] . " (self)\n"
    "        }\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateSwiftTransientTriggerFromSelfAttribute
  ??@string unused inPrefix # entity, class, preference
  ??@string unused inClassName
  ??@string unused inTransientName
  ?!@stringset unused ioMasterAttributeSet
  ?!@stringset unused ioRegisteredTransientSet
  ?!@bool unused ioContinue
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateSwiftTransientTriggerFromSelfAttribute
  ??@string unused inPrefix # entity, class, preference
  ??@string unused inClassName
  ??@string unused inTransientName
  ?!@stringset unused ioMasterAttributeSet
  ?!@stringset unused ioRegisteredTransientSet
  ?!@bool unused ioContinue
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

function generateSwiftTransientTriggering
  ??@string inPropertyName
  ??@string inClassName
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inPrefix # entity, class, preference
  ->@string outResult
:
  outResult := "" ;
#----
  @stringset masterSet [setWithString !inPropertyName] ;
  @stringset registeredTransientSet [emptySet] ;
  @bool looping := true ;
  loop [inTransientListForImplementation length] + 1 : while looping do
    looping := false ;
    foreach inTransientListForImplementation do
      foreach mDependencyList do
        if (not [registeredTransientSet hasKey !mTransientName]) then
          [mDependency generateSwiftTransientTriggerFromSelfAttribute
            !inPrefix
            !inClassName
            !mTransientName
            !?masterSet
            !?registeredTransientSet
            !?looping
            !?outResult
          ] ;
        end if ;
      end foreach ;
    end foreach ;
  end loop ;
end function ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateAddOCObserverForTransient
  ??@string inLeadingSpaces
  ?!@string ioResult
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateAddOCObserverForTransient
  ??@string unused inLeadingSpaces
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateAddOCObserverForTransient
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  ioResult .= inLeadingSpaces .
  "  [" . mControllerName . "\n"
  "    addObserver:self\n"
  "    forKeyPath:@\"" . mMasterAttributeName . "\"\n"
  "    options:0\n"
  "    context:NULL\n"
  "  ] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateAddOCObserverForTransient
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  if not mMasterIsTransient then
    ioResult .= inLeadingSpaces . "  [g_" . mPreferenceName . " addObserverOf_" . mMasterAttributeName . ":self] ;\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateAddOCObserverForTransient
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  ioResult .= inLeadingSpaces . "  [self.rootObject addObserverOf_" . mMasterAttributeName . ":self] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

function generateAddOCObserverForTransients
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inLeadingSpaces
  ->@string outResult
:
  outResult := "" ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency generateAddOCObserverForTransient
        !inLeadingSpaces
        !?outResult
      ] ;
    end foreach ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*
#! handleSwiftObserverForTransient
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation handleSwiftObserverForTransient
  ??@string inOperationName
  ??@string inKind
  ??@string inKindName
  ??@string inTransientName
  ??@string inLeadingSpaces
  ?!@string ioResult
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation handleSwiftObserverForTransient
  ??@string inOperationName
  ??@string inKind
  ??@string inKindName
  ??@string inTransientName
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  ioResult += inLeadingSpaces . inOperationName + mMasterAttributeName + " (triggerObjectFor_" + [inKind + "." + inKindName + "." + inTransientName identifierRepresentation] + ")\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation handleSwiftObserverForTransient
  ??@string inOperationName
  ??@string inKind
  ??@string inKindName
  ??@string inTransientName
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  ioResult .= inLeadingSpaces . mControllerName . "." . inOperationName + mMasterAttributeName
            + " (triggerObjectFor_" + [inKind + "." + inKindName + "." + inTransientName identifierRepresentation] . ")\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation handleSwiftObserverForTransient
  ??@string inOperationName
  ??@string inKind
  ??@string inKindName
  ??@string inTransientName
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  if not mMasterIsTransient then
    ioResult .= inLeadingSpaces . "g_" . mPreferenceName . "?." . inOperationName . mMasterAttributeName
            + " (triggerObjectFor_" + [inKind + "." + inKindName + "." + inTransientName identifierRepresentation] . ")\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation handleSwiftObserverForTransient
  ??@string inOperationName
  ??@string inKind
  ??@string inKindName
  ??@string inTransientName
  ??@string inLeadingSpaces
  ?!@string ioResult
:
  ioResult += inLeadingSpaces . "rootObject." . inOperationName . mMasterAttributeName + " (triggerObjectFor_" + [inKind + "." + inKindName + "." + inTransientName identifierRepresentation] + ")\n" ;
end method ;

#----------------------------------------------------------------------------*

function generateAddSwiftObserverForTransients
  ??@string inKind
  ??@string inKindName
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inLeadingSpaces
  ->@string outResult
:
  outResult := "" ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency handleSwiftObserverForTransient
        !"addObserverOf_"
        !inKind
        !inKindName
        !mTransientName
        !inLeadingSpaces
        !?outResult
      ] ;
    end foreach ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

function generateRemoveSwiftObserverForTransients
  ??@string inKind
  ??@string inKindName
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inLeadingSpaces
  ->@string outResult
:
  outResult := "" ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency handleSwiftObserverForTransient
        !"removeObserverOf_"
        !inKind
        !inKindName
        !mTransientName
        !inLeadingSpaces
        !?outResult
      ] ;
    end foreach ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*
#! generateOCRemoveObserverForTransient
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateOCRemoveObserverForTransient
  ?!@string ioResult
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateOCRemoveObserverForTransient
  ?!@string unused ioResult
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateOCRemoveObserverForTransient
  ?!@string ioResult
:
  ioResult .=
  "  [" . mControllerName . "\n"
  "    removeObserver:self\n"
  "    forKeyPath:@\"" . mMasterAttributeName . "\"\n"
  "  ] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateOCRemoveObserverForTransient
  ?!@string ioResult
:
  if not mMasterIsTransient then
    ioResult .= "  [g_" . mPreferenceName . " removeObserverOf_" . mMasterAttributeName . ":self] ;\n" ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateOCRemoveObserverForTransient
  ?!@string ioResult
:
  ioResult .= "  [self.rootObject removeObserverOf_" . mMasterAttributeName . ":self] ;\n" ;
end method ;

#----------------------------------------------------------------------------*

function generateRemoveOCObserverForTransients
  ??@transientListForImplementation inTransientListForImplementation
  ->@string outResult
:
  outResult := "" ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency generateOCRemoveObserverForTransient
        !?outResult
      ] ;
    end foreach ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

listmap @observerListMap (@stringlist) ;

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyForImplementation generateObserverRoutineForTransient
  ??@string inTransientName
  ?!@observerListMap didChangeTriggeredRoutineListMap
  ?!@observerListMap ioObserveForKeyPathRoutineElementListMap
;

#----------------------------------------------------------------------------*

override method @transientDependencyFromSelfForImplementation generateObserverRoutineForTransient
  ??@string unused inTransientName
  ?!@observerListMap unused didChangeTriggeredRoutineListMap
  ?!@observerListMap unused ioObserveForKeyPathRoutineElementListMap
:
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromControllerForImplementation generateObserverRoutineForTransient
  ??@string inTransientName
  ?!@observerListMap unused didChangeTriggeredRoutineListMap
  ?!@observerListMap ioObserveForKeyPathRoutineElementListMap
:
  ioObserveForKeyPathRoutineElementListMap += !mControllerName . "." . mMasterAttributeName !inTransientName ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromPreferenceForImplementation generateObserverRoutineForTransient
  ??@string inTransientName
  ?!@observerListMap didChangeTriggeredRoutineListMap
  ?!@observerListMap unused ioObserveForKeyPathRoutineElementListMap
:
  if not mMasterIsTransient then
    didChangeTriggeredRoutineListMap += !["preference." . mPreferenceName . "." . mMasterAttributeName identifierRepresentation] !inTransientName ;
  end if ;
end method ;

#----------------------------------------------------------------------------*

override method @transientDependencyFromRootForImplementation generateObserverRoutineForTransient
  ??@string inTransientName
  ?!@observerListMap didChangeTriggeredRoutineListMap
  ?!@observerListMap unused ioObserveForKeyPathRoutineElementListMap
:
  didChangeTriggeredRoutineListMap += !mTriggerRoutineName !inTransientName ;
end method ;

#----------------------------------------------------------------------------*

function generateObjectiveCObserverRoutinesForTransient
  ??@string inKindName 
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inPrefix # entity, class, preference
  ->@string outResult
:
  outResult := "" ;
  @observerListMap didChangeTriggeredRoutineListMap [emptyMap] ;
  @observerListMap observeForKeyPathRoutineElementListMap [emptyMap] ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency generateObserverRoutineForTransient
        !mTransientName
        !?didChangeTriggeredRoutineListMap
        !?observeForKeyPathRoutineElementListMap
      ] ;
    end foreach ;
  end foreach ;
#------------------------ Generate xxx_xxx_didChange methods
  const @string fullPrefix := inPrefix . "." . inKindName . "." ;
  foreach didChangeTriggeredRoutineListMap do
    outResult .=
    "//-------------------------------------------------------------------------------------------------------------------*\n"
    "//  " . key . "_didChange   *\n"
    "//-------------------------------------------------------------------------------------------------------------------*\n\n"
    "- (void) " . key . "_didChange {\n" ;
    foreach mList do
    outResult .=
      "  //--- Trigger '" . mValue . " transient'\n"
      "  if (" . mValue . "__computed) {\n"
      "    " . mValue . "__computed = NO ;\n"
      "    [PMApplication\n"
      "      enterTriggerForObject:self\n"
      "      transientIndex:" . [fullPrefix . mValue identifierRepresentation] . "\n"
      "    ] ;\n"
      "  }\n" ;
    end foreach ;
    outResult .= "}\n\n" ;
  end foreach ;
#------------------------ Generate observeValueForKeyPath method
  foreach observeForKeyPathRoutineElementListMap
  before
    outResult .=
    "//-------------------------------------------------------------------------------------------------------------------*\n"
    "//  observeValueForKeyPath:ofObject:change:context:                           *\n"
    "//-------------------------------------------------------------------------------------------------------------------*\n\n"
    "- (void) observeValueForKeyPath: (NSString *) inKeyPath\n"
    "         ofObject: (id) inObject\n"
    "         change: (NSDictionary *) inChange\n"
    "         context: (void *) inContext {\n"
    " " ;
  do
    outResult .=
    " if ((inObject == " . [key stringByDeletingPathExtension] .") && [inKeyPath isEqualToString:@\"" . [key pathExtension] . "\"]) {\n" ;
    foreach mList do
      outResult .=
      "  //--- Trigger '" . mValue . " transient'\n"
      "    if (" . mValue . "__computed) {\n"
      "      " . mValue . "__computed = NO ;\n"
      "      [PMApplication\n"
      "        enterTriggerForObject:self\n"
      "        transientIndex:" . [fullPrefix . mValue identifierRepresentation] . "\n"
      "      ] ;\n"
      "    }\n" ;
    end foreach ;
    outResult .= "  }else" ;
  after
    outResult .=
    "{\n"
    "    [super\n"
    "     observeValueForKeyPath:inKeyPath\n"
    "     ofObject:inObject\n"
    "     change:inChange\n"
    "     context:inContext\n"
    "    ] ;\n"
    "  }\n"
    "}\n\n" ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

function generateSwiftObserverRoutinesForTransient
  ??@string inKindName 
  ??@transientListForImplementation inTransientListForImplementation
  ??@string inPrefix # entity, class, preference
  ->@string outResult
:
  outResult := "" ;
  @observerListMap didChangeTriggeredRoutineListMap [emptyMap] ;
  @observerListMap observeForKeyPathRoutineElementListMap [emptyMap] ;
  foreach inTransientListForImplementation do
    foreach mDependencyList do
      [mDependency generateObserverRoutineForTransient
        !mTransientName
        !?didChangeTriggeredRoutineListMap
        !?observeForKeyPathRoutineElementListMap
      ] ;
    end foreach ;
  end foreach ;
#------------------------ Generate xxx_xxx_didChange methods
  const @string fullPrefix := inPrefix . "." . inKindName . "." ;
  foreach didChangeTriggeredRoutineListMap do
    outResult .=
    "  //-------------------------------------------------------------------------------------------------------------------*\n"
    "  //    " . ["Transient: " . key stringByRightPadding !111 !' '] . "*\n"
    "  //-------------------------------------------------------------------------------------------------------------------*\n\n"
    "  func " . key . "_didChange () {\n" ;
    foreach mList do
    outResult .=
      "    //--- Trigger '" . mValue . " transient'\n"
      "    if " . mValue . "__cache != nil {\n"
      "      " . mValue . "__cache = nil ;\n"
      "      enterTriggerForObject_" . [fullPrefix . mValue identifierRepresentation] . " (self)\n"
      "    }\n" ;
    end foreach ;
    outResult .= "  }\n\n" ;
  end foreach ;
#------------------------ Generate observeValueForKeyPath method
  foreach observeForKeyPathRoutineElementListMap
  before
    outResult .=
    "  //-------------------------------------------------------------------------------------------------------------------*\n"
    "  //  observeValueForKeyPath:ofObject:change:context:                                                                  *\n"
    "  //-------------------------------------------------------------------------------------------------------------------*\n\n"
    "  override func observeValueForKeyPath (inKeyPath : String!,\n"
    "                                        ofObject inObject:AnyObject!,\n"
    "                                        change inChange:[NSObject : AnyObject]!,\n"
    "                                        context inContext:UnsafePointer <()>) {\n"
    " " ;
  do
    outResult .=
    " if (inObject as NSObject == " . [key stringByDeletingPathExtension] .") && (inKeyPath == \"" . [key pathExtension] . "\") {\n" ;
    foreach mList do
      outResult .=
      "  //--- Trigger '" . mValue . " transient'\n"
      "    if " . mValue . "__cache != nil {\n"
      "      " . mValue . "__cache = nil\n"
      "      enterTriggerForObject_" . [fullPrefix . mValue identifierRepresentation] . " (self)\n"
      "    }\n" ;
    end foreach ;
    outResult .= "  }else" ;
  after
    outResult .=
    "{\n"
    "     super.observeValueForKeyPath (inKeyPath,\n"
    "       ofObject:inObject,\n"
    "       change:inChange,\n"
    "       context:inContext\n"
    "     )\n"
    "    }\n"
    "  }\n\n" ;
  end foreach ;
end function ;

#----------------------------------------------------------------------------*

routine generateTransientTrigersAndApplication
  ??@2stringlist inTransientDependencyArcList
  ??@string unused inSourceDirectoryPath
  ??@stringlist inSortedTransientOrderedList
:
#--- Output dependency order definition file
  @string graphString := "" ;
  @stringset dependentSet [emptySet] ;
  foreach inTransientDependencyArcList do
    graphString .= "// " . mValue0 . " -> " . mValue1 . "\n" ;
    dependentSet += !mValue1 ;
  end foreach ;
  @string transientOrderedList := "" ;
  foreach > inSortedTransientOrderedList do
    transientOrderedList .= "// " . mValue . "\n" ;
  end foreach ;
  @string transientObjectiveCIndexString := "" ;
  @string transientSwiftIndexString := "" ;
  @string transientListAsString := "" ;
  var transientList := [@stringlist emptyList] ;
  @uint idx := 0 ;
  foreach > inSortedTransientOrderedList do
    if [dependentSet hasKey !mValue] then
      transientObjectiveCIndexString .= "#define " . [mValue identifierRepresentation] . " (" . idx . ")\n" ;
      transientSwiftIndexString .= "// " . idx . ": " . [mValue identifierRepresentation] . "\n" ;
      transientListAsString .= "      @" . [[mValue pathExtension] utf8Representation] . ", // " . mValue . "\n" ;
      transientList += !mValue ;
      idx ++ ;
    end if ;
  end foreach ;
end routine ;

#----------------------------------------------------------------------------*

end semantics ;
