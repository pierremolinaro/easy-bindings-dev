import Cocoa

//---------------------------------------------------------------------------------------------------------------------*

@objc(%!ENTITY_NAME%) class %!ENTITY_NAME% : PMManagedObject {

%for () in ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
  ![mType generateAttributeDeclarationInSwift !"entity" !ENTITY_NAME !mAttributeName !mDirectSwiftDefaultValue !generateUndoHandling:true]
end

for () in ENTITY_CURRENT_RELATIONSHIP_MAP do
  if mIsToMany then
%  //-------------------------------------------------------------------------------------------------------------------*
  //    %!["To many relationship: " + lkey stringByRightPadding !111 !' ']%*
  //-------------------------------------------------------------------------------------------------------------------*

  var %!lkey->string%_observers = NSMutableSet ()
  var %!lkey->string%__explorer : NSPopUpButton?
  var %!lkey->string% : NSMutableArray = NSMutableArray () { // Set of %![mRelationshipType key]% entities
    didSet {
      if (oldValue !== %!lkey->string%) {
      //--- Register old value in undo manager
        undoManager ().registerUndoWithTarget (self, selector:"set%![lkey stringByCapitalizingFirstCharacter]%", object:oldValue)
      //--- Update explorer
        if %!lkey->string%__explorer != nil {
          updateManagedObjectToManyRelationshipDisplayForKey ("%!lkey->string%", popUpButton:%!lkey->string%__explorer!)
        }
      //--- Removed object set
        var removedObjectSet = NSMutableSet ()
        removedObjectSet.addObjectsFromArray (oldValue)
        removedObjectSet.minusSet (NSSet (array:%!lkey->string%))
        for object : AnyObject in removedObjectSet {
          let managedObject = object as %![mRelationshipType key]%
          managedObject.%!mOppositeRelationshipName->string% = nil ;
%    if [SIGN_SET hasKey !lkey->string] then
      %      managedObject.removeSignatureObserver (self)\n%
    end
%        }
      //--- Added object set
        var addedObjectSet = NSMutableSet ()
        addedObjectSet.addObjectsFromArray (%!lkey->string%)
        addedObjectSet.minusSet (NSSet (array:oldValue))
        for object : AnyObject in addedObjectSet {
          let managedObject = object as %![mRelationshipType key]%
          managedObject.%!mOppositeRelationshipName->string% = self\n%
    if [SIGN_SET hasKey !lkey->string] then
      %      object.addSignatureObserver (self)\n%
    end
%        }
      //--- Notify observers object count did change
        for anyObject in %!lkey->string%_observers {
          let object = anyObject as PMTriggerProtocol
          enterTriggerWithObject (object)
        }
%    if [SIGN_SET hasKey !lkey->string] then
      %    //--- Trigger signature computing\n%
      %      triggerSignatureComputing ()\n%
    end
    %      }
    }
  }

  func insertObject (inObject : %![mRelationshipType key]%,
                     in%![lkey stringByCapitalizingFirstCharacter]%AtIndex: Int) {
    let idx : Int = %!lkey->string%.indexOfObject (inObject)
    if idx == NSNotFound {
      %!lkey->string%.insertObject (inObject, atIndex:inMNamesAtIndex)
        undoManager ().registerUndoWithTarget (self,
        selector:"removeObjectFrom%![lkey stringByCapitalizingFirstCharacter]%:",
        object:inObject
      )
      inObject.%!mOppositeRelationshipName->string% = self
    //--- Update explorer
      if %!lkey->string%__explorer != nil {
        updateManagedObjectToManyRelationshipDisplayForKey ("%!lkey->string%", popUpButton:%!lkey->string%__explorer!)
      }
    }else if idx != inMNamesAtIndex {
    }
  //--- Notify observers object count did change
    for anyObject in %!lkey->string%_observers {
      let object = anyObject as PMTriggerProtocol
      enterTriggerWithObject (object)
    }
  }

  func removeObjectFrom%![lkey stringByCapitalizingFirstCharacter]%AtIndex (inIndex : Int) {
    let removedObject = %!lkey->string%.objectAtIndex (inIndex) as %![mRelationshipType key]%
  //--- Perform removing
    %!lkey->string%.removeObjectAtIndex (inIndex)
  //--- Register all object in undo manager
    undoManager ().prepareWithInvocationTarget (self).insertObject (removedObject, in%![lkey stringByCapitalizingFirstCharacter]%AtIndex:inIndex)
  //--- Update explorer
    if %!lkey->string%__explorer != nil {
      updateManagedObjectToManyRelationshipDisplayForKey ("%!lkey->string%", popUpButton:%!lkey->string%__explorer!)
    }
  //--- Reset inverse relationship
    removedObject.%!mOppositeRelationshipName->string% = nil
  //--- Notify observers object count did change
    for anyObject in %!lkey->string%_observers {
      let object = anyObject as PMTriggerProtocol
      enterTriggerWithObject (object)
    }
  }

  func appendTo%![lkey stringByCapitalizingFirstCharacter]% (inObject : %![mRelationshipType key]%) {
    if !%!lkey->string%.containsObject (inObject) {
      insertObject (inObject, in%![lkey stringByCapitalizingFirstCharacter]%AtIndex:self.%!lkey->string%.count)
    }
  }

  func removeObjectFrom%![lkey stringByCapitalizingFirstCharacter]% (inObject : %![mRelationshipType key]%) {
    let idx = %!lkey->string%.indexOfObject (inObject)
    if NSNotFound != idx {
      removeObjectFrom%![lkey stringByCapitalizingFirstCharacter]%AtIndex (idx)
    }
  }
   
  func addObserverOf_%!lkey->string% (inObserver : PMTriggerProtocol) {
    %!lkey->string%_observers.addObject (inObserver)
    enterTriggerWithObject (inObserver)
  }

  func removeObserverOf_%!lkey->string% (inObserver : PMTriggerProtocol) {
    %!lkey->string%_observers.removeObject (inObserver)
    enterTriggerWithObject (inObserver)
  }
%
  end
end
for () in CURRENT_RELATIONSHIP_LIST do
  if not mIsToMany then
%  //-------------------------------------------------------------------------------------------------------------------*
  //    %!["To one relationship: " + mRelationshipName stringByRightPadding !111 !' ']%*
  //-------------------------------------------------------------------------------------------------------------------*

  var %!mRelationshipName->string%_observers = NSMutableSet ()
  var %!mRelationshipName->string%__explorer : NSButton?
  weak var %!mRelationshipName->string% : %!mDestinationEntityName->string%? = nil {
    didSet {
 //     if oldValue != %!mRelationshipName->string% {
      //--- Register old value in undo manager
        undoManager ().registerUndoWithTarget (self, selector:"set%![mRelationshipName stringByCapitalizingFirstCharacter]%:", object:oldValue)
      //--- Update explorer
        if %!mRelationshipName->string%__explorer != nil {
          updateManagedObjectToOneRelationshipDisplayForKey ("%!mRelationshipName->string%", button : %!mRelationshipName->string%__explorer!)
        }
%if [SIGN_SET hasKey !mRelationshipName->string] then
  %  //--- Remove signature observer from old object
       %!mRelationshipName->string%.removeSignatureObserver (self)\n%
end
%      //--- Set opposite relation ship
%    if mInverseRelationIsToMany then
%        oldValue?.removeObjectFrom%![mInverseRelationshipName stringByCapitalizingFirstCharacter]% (self)
        %!mRelationshipName->string%?.appendTo%![mInverseRelationshipName stringByCapitalizingFirstCharacter]% (self)
%    else
%        oldValue?.%!mInverseRelationshipName->string% = nil
        %!mRelationshipName->string%?.%!mInverseRelationshipName->string% = self
%    end
    if [SIGN_SET hasKey !mRelationshipName->string] then
%   //--- Add signature observer to new object
      %!mRelationshipName->string%.addSignatureObserver (self)
    //--- Trigger signature computing
      triggerSignatureComputing ()
%    end
%      }
//    }
  }
   
  func addObserverOf_%!mRelationshipName->string% (inObserver : AnyObject) {
    %!mRelationshipName->string%_observers.addObject (inObserver)
    NSApp.sendAction ("%!["entity." + ENTITY_NAME + "." + mRelationshipName identifierRepresentation]%_didChange", to:inObserver, from:self)
  }

  func removeObserverOf_%!mRelationshipName->string% (inObserver : AnyObject) {
    %!mRelationshipName->string%_observers.removeObject (inObserver)
    NSApp.sendAction ("%!["entity." + ENTITY_NAME + "." + mRelationshipName identifierRepresentation]%_didChange", to:inObserver, from:self)
  }
%
  end
end
%
  //-------------------------------------------------------------------------------------------------------------------*
  //    init                                                                                                           *
  //-------------------------------------------------------------------------------------------------------------------*

  init (entityManager : PMObjectManager) {
    super.init (entityManager:entityManager)
  //--- Register trigger objects
%
!generateAddSwiftObserverForTransients [!"entity" !ENTITY_NAME !TRANSIENT_LIST_FOR_IMPLEMENTATION !"    "]
%  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    deinit                                                                                                         *
  //-------------------------------------------------------------------------------------------------------------------*

  deinit {
  //--- remove trigger objects
%
!generateRemoveSwiftObserverForTransients [!"entity" !ENTITY_NAME !TRANSIENT_LIST_FOR_IMPLEMENTATION !"    "]
%  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    populateExplorerWindow                                                                                         *
  //-------------------------------------------------------------------------------------------------------------------*

  override func populateExplorerWindowWithRect (inout ioRect : NSRect, view : NSView) {
%for () in ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%    %!mAttributeName%__explorer = createEntryForAttributeNamed ("%!mAttributeName%", ioRect:&ioRect, view:view)\n%
%    if %!mAttributeName%__explorer {\n%
%      %!mAttributeName%__explorer!.stringValue = %![mType valueAccessorForExplorerWindow !mAttributeName]%\n%
%    }\n%
end
for () in CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%   %!mRelationshipName->string%__explorer = createEntryForToManyRelationshipNamed ("%!mRelationshipName->string%", ioRect: &ioRect, view: view)
   updateManagedObjectToManyRelationshipDisplayForKey ("%!mRelationshipName->string%", popUpButton:%!mRelationshipName->string%__explorer!)\n%
  else
%   %!mRelationshipName->string%__explorer = createEntryForToOneRelationshipNamed ("%!mRelationshipName->string%", ioRect: &ioRect, view: view)
   updateManagedObjectToOneRelationshipDisplayForKey ("%!mRelationshipName->string%",button:%!mRelationshipName->string%__explorer!)\n%
  end
end%  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    clearObjectExplorer                                                                                            *
  //-------------------------------------------------------------------------------------------------------------------*

  override func clearObjectExplorer () {
%for () in ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%    %!mAttributeName%__explorer = nil\n%
end
for () in CURRENT_RELATIONSHIP_LIST do
%    %!mRelationshipName->string%__explorer = nil\n%
end%    super.clearObjectExplorer ()
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    saveIntoDictionary                                                                                             *
  //-------------------------------------------------------------------------------------------------------------------*

  override func saveIntoDictionary (ioDictionary : NSMutableDictionary) {
    super.saveIntoDictionary (ioDictionary)
%for () in ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%    ioDictionary.setValue (%![mType dictionarySaverTransformerName !mAttributeName]%, forKey: "%!mAttributeName%")\n%
end
for () in CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%    storeEntityArrayInDictionary (%!mRelationshipName->string%, inRelationshipName:"%!mRelationshipName->string%", ioDictionary:ioDictionary) ;\n%
  else
%    storeEntityInDictionary (%!mRelationshipName->string%, inRelationshipName:"%!mRelationshipName->string%", ioDictionary:ioDictionary) ;\n%
  end
end
%  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    setUpWithDictionary                                                                                            *
  //-------------------------------------------------------------------------------------------------------------------*

  override func setUpWithDictionary (inDictionary : NSDictionary,
                                     managedObjectArray : NSArray) {
    super.setUpWithDictionary (inDictionary, managedObjectArray:managedObjectArray)
%for () in ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%    %!mAttributeName% = inDictionary.read%![mType swiftTypeName]% ("%!mAttributeName%")\n%
end
for () in CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%    %!mRelationshipName->string% = readEntityArrayFromDictionary ("%!mRelationshipName->string%", inDictionary:inDictionary, managedObjectArray:managedObjectArray)\n%
  elsif not mInverseRelationIsToMany then
%    %!mRelationshipName->string% = readEntityFromDictionary ("%!mRelationshipName->string%", inDictionary:inDictionary, managedObjectArray:managedObjectArray) as? %!mDestinationEntityName->string%\n%
  end
end
%  }

%
for () in TRANSIENT_LIST_FOR_IMPLEMENTATION do
%  //-------------------------------------------------------------------------------------------------------------------*
  //    %!["Transient: " + mTransientName stringByRightPadding !111 !' ']%*
  //-------------------------------------------------------------------------------------------------------------------*\n\n%
%  var %!mTransientName%_observers = NSMutableSet ()\n%
%  var %!mTransientName%__cache : %![mTransientType swiftTypeName]%?\n%
%  var %!mTransientName% : %![mTransientType swiftTypeName]% {\n%
!generateSwiftTransientCacheRoutine [!ENTITY_NAME !mTransientType !mTransientName !mDependencyList !mRootSignDependencyList]
%  }

  func %!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%_didChange () {
    self.willChangeValueForKey ("%!mTransientName%")
    self.didChangeValueForKey  ("%!mTransientName%")
    for anyObject in %!mTransientName%_observers {
      let object = anyObject as PMTriggerProtocol
      enterTriggerWithObject (object)
    }
  }

   func addObserverOf_%!mTransientName% (inObserver : PMTriggerProtocol) {
    %!mTransientName%_observers.addObject (inObserver)
    enterTriggerWithObject (inObserver)
  }
 
  func removeObserverOf_%!mTransientName% (inObserver : PMTriggerProtocol) {
    %!mTransientName%_observers.removeObject (inObserver)
    enterTriggerWithObject (inObserver)
  }

  var triggerObjectFor_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%__cache : PMTrigger_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%? = nil
  var triggerObjectFor_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]% : PMTrigger_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]% {
    if !triggerObjectFor_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%__cache {
      triggerObjectFor_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%__cache = PMTrigger_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]% (object:self)
    }
    return triggerObjectFor_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%__cache!
  }
 
%
end
%  //-------------------------------------------------------------------------------------------------------------------*
  //   accessibleObjects                                                                                               *
  //-------------------------------------------------------------------------------------------------------------------*

  override func accessibleObjects (inout objects : NSMutableArray) {
    super.accessibleObjects (&objects)
%for () in CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%    for object : AnyObject in %!mRelationshipName->string% {
      let managedObject = object as PMManagedObject
      objects.addObject (managedObject)
    }\n%
  else
%    if %!mRelationshipName->string% != nil {\n%
%      objects.addObject (%!mRelationshipName->string%!)\n%
%    }\n%
  end
end%  }

  //-------------------------------------------------------------------------------------------------------------------*

}

