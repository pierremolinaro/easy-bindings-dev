import Cocoa
//-----------------------------------------------------------------------------*

@objc(%!ENTITY_NAME%) class %!ENTITY_NAME% : PMManagedEntity {

%foreach ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%  //-----------------------------------------------------------------------------*
  //    %!["Attribute: " . mAttributeName stringByRightPadding !73 !' ']%*
  //-----------------------------------------------------------------------------*

  var %!mAttributeName%__explorer : NSTextField?
  var %!mAttributeName%_observers = NSMutableSet ()
%if mType->mKind == [@typeKind enumType] then
%  var %!mAttributeName% : %![mType swiftTypeName]% =  %!mDirectSwiftDefaultValue%
  var %!mAttributeName%__as__number : NSNumber {
    get {
      return %!mAttributeName%.toRaw ()
    }
    set {
      undoManager ().registerUndoWithTarget (self,
        selector:"set%![mAttributeName stringByCapitalizingFirstCharacter]%__as__number:",
        object:%!mAttributeName%__as__number
      )
      let v : Int? = newValue.integerValue ()
      %!mAttributeName% = %![mType swiftTypeName]%.fromRaw (v!)!
      %!mAttributeName%__explorer?.setStringValue (%!mAttributeName%.string ())
%
else
%  var %!mAttributeName% : %![mType swiftTypeName]% =  %!mDirectSwiftDefaultValue% {
    willSet {
      undoManager ().registerUndoWithTarget (self,
        selector:"set%![mAttributeName stringByCapitalizingFirstCharacter]%:",
        object:%![mType valueForUndoManager !mAttributeName]%
      )
    }
    didSet {
      %!mAttributeName%__explorer?.setStringValue (%![mType valueAccessorForExplorerWindow !mAttributeName]%)
%end
%    //--- Notify observers
       %!mAttributeName%_observers.makeObjectsPerformSelector ("%!["entity." . ENTITY_NAME . "." . mAttributeName identifierRepresentation]%_didChange")
% !generateSwiftTransientTriggering [!mAttributeName !ENTITY_NAME !TRANSIENT_LIST_FOR_IMPLEMENTATION !"entity"]
%    }
  }

  func addObserverOf_%!mAttributeName% (inObserver : AnyObject) {
    %!mAttributeName%_observers.addObject (inObserver)
    NSApp.sendAction ("%!["entity." . ENTITY_NAME . "." . mAttributeName identifierRepresentation]%_didChange", to:inObserver, from:self)
  }
  func removeObserverOf_%!mAttributeName% (inObserver : AnyObject) {
    %!mAttributeName%_observers.removeObject (inObserver)
    NSApp.sendAction ("%!["entity." . ENTITY_NAME . "." . mAttributeName identifierRepresentation]%_didChange", to:inObserver, from:self)
  }

%
end
foreach CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%  //-----------------------------------------------------------------------------*
  //    %!["To many relationship: " . mRelationshipName stringByRightPadding !73 !' ']%*
  //-----------------------------------------------------------------------------*
  var %!mRelationshipName->string%_observers = NSMutableSet ()
  var %!mRelationshipName->string% : NSMutableArray = NSMutableArray () { // Set of %!mDestinationEntityName->string% entities
    didSet {
      if (oldValue != %!mRelationshipName->string%) {
      //--- Register old value in undo manager
      //  undoManager ().prepareWithInvocationTarget (self, set%![mRelationshipName stringByCapitalizingFirstCharacter]%:%!mRelationshipName->string%)
      //--- Removed object set
        var removedObjectSet = NSMutableSet ()
        removedObjectSet.addObjectsFromArray (oldValue)
        removedObjectSet.minusSet (NSSet (array:%!mRelationshipName->string%))
        for object : AnyObject in removedObjectSet {
          let managedObject = object as %!mDestinationEntityName->string%
          managedObject.%!mInverseRelationshipName->string% = nil ;
%    if [SIGN_SET hasKey !mRelationshipName->string] then
      %      managedObject.removeSignatureObserver (self)\n%
    end
%        }
      //--- Added object set
        var addedObjectSet = NSMutableSet ()
        addedObjectSet.addObjectsFromArray (%!mRelationshipName->string%)
        addedObjectSet.minusSet (NSSet (array:oldValue))
        for object : AnyObject in addedObjectSet {
          let managedObject = object as %!mDestinationEntityName->string%
          managedObject.%!mInverseRelationshipName->string% = self\n%
    if [SIGN_SET hasKey !mRelationshipName->string] then
      %      object.addSignatureObserver (self)\n%
    end
%        }
      //--- Notify observers object count did change
        %!mRelationshipName->string%_observers.makeObjectsPerformSelector ("%!["entity." . ENTITY_NAME . "." . mRelationshipName identifierRepresentation]%_didChange")\n%
    if [SIGN_SET hasKey !mRelationshipName->string] then
      %    //--- Trigger signature computing\n%
      %      triggerSignatureComputing ()\n%
    end
    !generateSwiftTransientTriggering [!mRelationshipName->string !ENTITY_NAME !TRANSIENT_LIST_FOR_IMPLEMENTATION !"entity"]
    %      }
    }
  }

  func appendTo%![mRelationshipName stringByCapitalizingFirstCharacter]% (inObject : %!mDestinationEntityName->string%) {
    if !%!mRelationshipName->string%.containsObject (inObject) {
      insertObject (inObject, in%![mRelationshipName stringByCapitalizingFirstCharacter]%AtIndex:self.%!mRelationshipName->string%.count ())
    }
  }

  func insertObject (inObject : %!mDestinationEntityName->string%,
                     in%![mRelationshipName stringByCapitalizingFirstCharacter]%AtIndex: Int) {
    let idx : Int = %!mRelationshipName->string%.indexOfObject (inObject)
    if idx == NSNotFound {
      %!mRelationshipName->string%.insertObject (inObject, atIndex:inMNamesAtIndex)
        undoManager ().registerUndoWithTarget (self,
        selector:"removeObjectFrom%![mRelationshipName stringByCapitalizingFirstCharacter]%:",
        object:inObject
      )
      inObject.%!mInverseRelationshipName->string% = self
    }else if idx != inMNamesAtIndex {
    }
  //--- Notify observers object count did change
    %!mRelationshipName->string%_observers.makeObjectsPerformSelector ("%!["entity." . ENTITY_NAME . "." . mRelationshipName identifierRepresentation]%_didChange")
  }

  func removeObjectFrom%![mRelationshipName stringByCapitalizingFirstCharacter]% (inObject : %!mDestinationEntityName->string%) {
    let idx = %!mRelationshipName->string%.indexOfObject (inObject)
    if NSNotFound != idx {
      removeObjectFrom%![mRelationshipName stringByCapitalizingFirstCharacter]%AtIndex (idx)
    }
  }

  func removeObjectFrom%![mRelationshipName stringByCapitalizingFirstCharacter]%AtIndex (inIndex : Int) {
    let removedObject = %!mRelationshipName->string%.objectAtIndex (inIndex) as %!mDestinationEntityName->string%
  //--- Perform removing
    %!mRelationshipName->string%.removeObjectAtIndex (inIndex)
  //--- Register all object in undo manager
    //undoManager ().prepareWithInvocationTarget (self).insertObject (removedObject, in%![mRelationshipName stringByCapitalizingFirstCharacter]%AtIndex:inIndex)
  //--- Reset inverse relationship
    removedObject.%!mInverseRelationshipName->string% = nil
  //--- Notify observers object count did change
    %!mRelationshipName->string%_observers.makeObjectsPerformSelector ("%!["entity." . ENTITY_NAME . "." . mRelationshipName identifierRepresentation]%_didChange")
  }
   
  func addObserverOf_%!mRelationshipName->string% (inObserver : AnyObject) {
    %!mRelationshipName->string%_observers.addObject (inObserver)
    NSApp.sendAction ("%!["entity.". ENTITY_NAME . "." . mRelationshipName identifierRepresentation]%_didChange", to:inObserver, from:self)
  }

  func removeObserverOf_%!mRelationshipName->string% (inObserver : AnyObject) {
    %!mRelationshipName->string%_observers.removeObject (inObserver)
    NSApp.sendAction ("%!["entity.". ENTITY_NAME . "." . mRelationshipName identifierRepresentation]%_didChange", to:inObserver, from:self)
  }
%
  end
end
%

%foreach CURRENT_RELATIONSHIP_LIST do
  if not mIsToMany then
%  //-----------------------------------------------------------------------------*
  //    %!["To one relationship: " . mRelationshipName stringByRightPadding !73 !' ']%*
  //-----------------------------------------------------------------------------*
  var %!mRelationshipName->string%_observers = NSMutableSet ()
  var %!mRelationshipName->string% : %!mDestinationEntityName->string%? = nil {
    didSet {
      if oldValue != %!mRelationshipName->string% {
      //--- Register old value in undo manager
       // [[self.undoManager prepareWithInvocationTarget:self set%![mRelationshipName stringByCapitalizingFirstCharacter]%:currentObject]
%if [SIGN_SET hasKey !mRelationshipName->string] then
  %  //--- Remove signature observer from old object
       %!mRelationshipName->string%.removeSignatureObserver (self)\n%
end
%      //--- Set opposite relation ship
%    if mInverseRelationIsToMany then
%        oldValue?.removeObjectFrom%![mInverseRelationshipName stringByCapitalizingFirstCharacter]% (self)
        %!mRelationshipName->string%?.appendTo%![mInverseRelationshipName stringByCapitalizingFirstCharacter]% (self)
%    else
%        oldValue?.%!mInverseRelationshipName->string% = nil
        %!mRelationshipName->string%?.%!mInverseRelationshipName->string% = self
%    end
    if [SIGN_SET hasKey !mRelationshipName->string] then
%   //--- Add signature observer to new object
      %!mRelationshipName->string%.addSignatureObserver (self)
    //--- Trigger signature computing
      triggerSignatureComputing ()
%    end
    !generateSwiftTransientTriggering [!mRelationshipName->string !ENTITY_NAME !TRANSIENT_LIST_FOR_IMPLEMENTATION !"entity"]
%      }
    }
  }
   
  func addObserverOf_%!mRelationshipName->string% (inObserver : AnyObject) {
    %!mRelationshipName->string%_observers.addObject (inObserver)
    NSApp.sendAction ("%!["entity.". ENTITY_NAME . "." . mRelationshipName identifierRepresentation]%_didChange", to:inObserver, from:self)
  }

  func removeObserverOf_%!mRelationshipName->string% (inObserver : AnyObject) {
    %!mRelationshipName->string%_observers.removeObject (inObserver)
    NSApp.sendAction ("%!["entity.". ENTITY_NAME . "." . mRelationshipName identifierRepresentation]%_didChange", to:inObserver, from:self)
  }
%
  end
end
%

  //-----------------------------------------------------------------------------*
  //    init                                                                     *
  //-----------------------------------------------------------------------------*

  init (entityManager : PMEntityManager) {
    super.init (entityManager:entityManager)
  }

  //-----------------------------------------------------------------------------*
  //    populateExplorerWindow                                                   *
  //-----------------------------------------------------------------------------*

  override func populateExplorerWindowWithRect (inout ioRect : NSRect, view : NSView) {
%foreach ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%    %!mAttributeName%__explorer = createEntryForAttributeNamed ("%!mAttributeName%", ioRect:&ioRect, view:view)\n%
%    %!mAttributeName%__explorer?.setStringValue (%![mType valueAccessorForExplorerWindow !mAttributeName]%)\n%
end
%  }

  //-----------------------------------------------------------------------------*
  //    clearContextExplorer                                                     *
  //-----------------------------------------------------------------------------*

  override func clearContextExplorer () {
%foreach ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%    %!mAttributeName%__explorer = nil\n%
end
%    super.clearContextExplorer ()
  }

  //-----------------------------------------------------------------------------*
  //    saveIntoDictionary                                                       *
  //-----------------------------------------------------------------------------*

  override func saveIntoDictionary (ioDictionary : NSMutableDictionary) {
    super.saveIntoDictionary (ioDictionary)
%foreach ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%    ioDictionary.setValue (%![mType dictionarySaverTransformerName !mAttributeName]%, forKey: "%!mAttributeName%")\n%
end
%  }

  //---------------------------------------------------------------------------*
  //    setUpWithDictionary                                                    *
  //---------------------------------------------------------------------------*

  override func setUpWithDictionary (inDictionary : NSDictionary,
                                     managedObjectArray : PMManagedEntity []) {
    super.setUpWithDictionary (inDictionary, managedObjectArray:managedObjectArray)
%foreach ATTRIBUTE_LIST_FOR_IMPLEMENTATION do
%    %!mAttributeName% = inDictionary.read%![mType swiftTypeName]% ("%!mAttributeName%")\n%
end
%  }

%
foreach TRANSIENT_LIST_FOR_IMPLEMENTATION do
%  //-----------------------------------------------------------------------------*
  //    %!["Transient: " . mTransientName stringByRightPadding !73 !' ']%*
  //-----------------------------------------------------------------------------*\n\n%
%  var %!mTransientName%__cache : %![mTransientType swiftTypeName]%?\n%
%  var %!mTransientName% : %![mTransientType swiftTypeName]% {\n%
!generateSwiftTransientCacheRoutine [!ENTITY_NAME !mTransientType !mTransientName !mDependencyList !mRootSignDependencyList]
%  }\n\n%
end
%
}

