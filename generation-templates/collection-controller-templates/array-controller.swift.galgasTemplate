import Cocoa

//—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

private let displayDebugMessage = false

//—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
//    %!["ArrayController_" + OBJECT_TYPE_NAME + "_" + RELATIONSHIP_NAME stringByRightPadding !113 !' ']%*
//—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

class ArrayController_%!OBJECT_TYPE_NAME%_%!RELATIONSHIP_NAME% : AbstractArrayController, PMTransientPropertyProtocol {
  private let mAllowsEmptySelection = false
  private let mAllowsMultipleSelection = true

  private var mModel : %!OBJECT_TYPE_NAME%?

  private var sortedArray = ArrayOf_%!ELEMENT_TYPE_NAME% ()

  private var mTableViewController : Controller_PMTableView_controller?
 
  //-------------------------------------------------------------------------------------------------------------------*
  //    init                                                                                                           *
  //-------------------------------------------------------------------------------------------------------------------*

  override init () {
    super.init ()
  //--- Sort Descriptors
%
for () in BOUND_COLUMNS do
  %    mSortDescriptors.append (NSSortDescriptor (key:"%!mObservablePropertyName%_keyCodingValue", ascending:true))\n%
end
%
  //--- 'canRemove' transient function 
    canRemove.computeFunction = { self.selectedObjectSet ().count > 0 }
  //--- 'sortedArray' transient function 
    sortedArray.computeFunction = {
      let sortedObjectArray : Array<%!ELEMENT_TYPE_NAME%>
      if let model = self.mModel {
        var currentObjectArrayAsMutableArray = NSMutableArray (array:model.%!RELATIONSHIP_NAME%.props)
        currentObjectArrayAsMutableArray.sortUsingDescriptors (self.mSortDescriptors)
        sortedObjectArray = currentObjectArrayAsMutableArray.copy () as! Array<%!ELEMENT_TYPE_NAME%>
      }else{
        sortedObjectArray = Array<%!ELEMENT_TYPE_NAME%> ()
      }
      return sortedObjectArray
    }
 }

   //-------------------------------------------------------------------------------------------------------------------*
  //    bind_modelAndView                                                                                              *
  //-------------------------------------------------------------------------------------------------------------------*

  func bind_modelAndView (object:%!OBJECT_TYPE_NAME%, tableView:PMTableView, file:String, line:Int) {
    mModel = object
    mTableViewController = Controller_PMTableView_controller (object:self, outlet:tableView, file:file, line:line)
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    unbind_modelAndView                                                                                            *
  //-------------------------------------------------------------------------------------------------------------------*

  func unbind_modelAndView () {
    canRemove.computeFunction = nil
    sortedArray.computeFunction = nil
    mTableViewController?.unregister ()
    mTableViewController = nil
    mInternalSelectedObjectSet = Set ()
%for () in BOUND_COLUMNS do
  %    mModel?.%!RELATIONSHIP_NAME%.removeObserverOf_%!mObservablePropertyName% (event, inTrigger:false)\n%
end
%  }
  
  //-------------------------------------------------------------------------------------------------------------------*
  //    Sort descriptors                                                                                               *
  //-------------------------------------------------------------------------------------------------------------------*
  
  private var mSortDescriptors = [AnyObject] () {
    didSet {
      noteModelDidChange () // Force sorting
      postEvents () // Notify outlets display should be done
    }
  }

  //-------------------------------------------------------------------------------------------------------------------*
  
  override func setSortDescriptors (sortDescriptors : [AnyObject]) {
    mSortDescriptors = sortDescriptors
  }
  
  //-------------------------------------------------------------------------------------------------------------------*
  //    Selected object set                                                                                            *
  //-------------------------------------------------------------------------------------------------------------------*

  var mSelectedObjectSetShouldBeComputed = true

  var mInternalSelectedObjectSet = Set <%!ELEMENT_TYPE_NAME%> ()

  //-------------------------------------------------------------------------------------------------------------------*

  func selectedObjectSet () -> Set <%!ELEMENT_TYPE_NAME%> {
    if mSelectedObjectSetShouldBeComputed {
      mSelectedObjectSetShouldBeComputed = false
      var newInternalSelectedObjectSet = mInternalSelectedObjectSet
      newInternalSelectedObjectSet.intersectInPlace (sortedArray.props)
      mInternalSelectedObjectSet = newInternalSelectedObjectSet
      if (mInternalSelectedObjectSet.count == 0) && (sortedArray.props.count > 0) {
        mInternalSelectedObjectSet.insert (sortedArray.props [0])
      }
    }
    return mInternalSelectedObjectSet
  }

  //-------------------------------------------------------------------------------------------------------------------*
  
  func setSelectedObjectSet (objectSet : Set <%!ELEMENT_TYPE_NAME%>) {
    mInternalSelectedObjectSet = objectSet
    mSelectedObjectSetShouldBeComputed = true
    canRemove.noteModelDidChange ()
  }

  //-------------------------------------------------------------------------------------------------------------------*

  override func selectedObjectIndexSet () -> NSIndexSet {
  //--- Dictionary of object indexes
    var objectDictionary = [%!ELEMENT_TYPE_NAME% : Int] ()
    for (index, object) in enumerate (sortedArray.props) {
      objectDictionary [object] = index
    }
    var indexSet = NSMutableIndexSet ()
    for object in selectedObjectSet () {
      if let index = objectDictionary [object] {
        indexSet.addIndex (index)
      }
    }
    return indexSet
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    Model observing event                                                                                          *
  //-------------------------------------------------------------------------------------------------------------------*

  private var eventModelChange_cache : PMTransientEvent? = nil
  var event : PMTransientEvent {
    get {
      if eventModelChange_cache == nil {
        eventModelChange_cache = PMTransientEvent (self)
      }
      return eventModelChange_cache!
    }
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    Object array dictionary                                                                                        *
  //-------------------------------------------------------------------------------------------------------------------*

  private var mSortedObjectArrayDictionary = [%!ELEMENT_TYPE_NAME% : Int] ()
  private var mSortedObjectArrayDictionaryShouldBeComputed = true
  
  var sortedObjectArrayDictionary : [%!ELEMENT_TYPE_NAME% : Int] {
    get {
      if mSortedObjectArrayDictionaryShouldBeComputed {
        mSortedObjectArrayDictionaryShouldBeComputed = false
        mSortedObjectArrayDictionary = [:]
        for (idx, object) in enumerate (sortedArray.props) {
          mSortedObjectArrayDictionary [object] = idx
        }
      }
      return mSortedObjectArrayDictionary
    }
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    Observing model change                                                                                         *
  //-------------------------------------------------------------------------------------------------------------------*
  
  func noteModelDidChange () {
    if displayDebugMessage {
      NSLog ("\%@", __FUNCTION__)
    }
    sortedArray.noteModelDidChange ()
    canRemove.noteModelDidChange ()
    mSortedObjectArrayDictionaryShouldBeComputed = true
    mSelectedObjectSetShouldBeComputed = true
  //--- Notify tableView outlets model did change
    postEvents ()
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    Configure table view                                                                                           *
  //-------------------------------------------------------------------------------------------------------------------*

  override func configureTableView (inTableView : PMTableView, file : String, line : Int) {
    inTableView.allowsEmptySelection = mAllowsEmptySelection
    inTableView.allowsMultipleSelection = mAllowsMultipleSelection
%for () in BOUND_COLUMNS do
%    if let anyObject: AnyObject = inTableView.makeViewWithIdentifier ("%!mColumnName%", owner:self) {
      if let unwrappedTableCellView = anyObject as? NSTableCellView {
        if !(unwrappedTableCellView.textField is %!mColumnOutletTypeName%) {
          presentErrorWindow (file, line, "\"%!mColumnName%\" column view is not an instance of %!mColumnOutletTypeName%")
        }
      }else{
        presentErrorWindow (file, line, "\"%!mColumnName%\" column cell view is not an instance of NSTableCellView")
      }
    }else{
      presentErrorWindow (file, line, "\"%!mColumnName%\" column view unknown")
    }
%end
%    inTableView.setDataSource (self)
    inTableView.setDelegate (self)
%for () in BOUND_COLUMNS do
%    if let col_%!mObservablePropertyName% : NSTableColumn = inTableView.tableColumnWithIdentifier ("%!mColumnName%") {
      col_%!mObservablePropertyName%.sortDescriptorPrototype = NSSortDescriptor (key:"%!mObservablePropertyName%_keyCodingValue", ascending:true)
    }
%end
%    let columns = inTableView.tableColumns as NSArray
    if columns.count > 0 {
      let firstColumn = columns [0] as! NSTableColumn
      if let sdp = firstColumn.sortDescriptorPrototype {
        inTableView.sortDescriptors = NSArray (object:sdp) as! [AnyObject]
      }
    }
%for () in BOUND_COLUMNS do
  %    mModel?.%!RELATIONSHIP_NAME%.addObserverOf_%!mObservablePropertyName% (event, inTrigger:true)\n%
end
%  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    T A B L E V I E W    D E L E G A T E : tableViewSelectionDidChange:                                            *
  //-------------------------------------------------------------------------------------------------------------------*

  func tableViewSelectionDidChange (notication : NSNotification) {
    if displayDebugMessage {
      appendToTransientEventLog (String (format:"    \%@\\n", __FUNCTION__))
    }
    let tableView : AnyObject? = notication.object
    if let tableView = notication.object as? NSTableView, model = mModel {
      var newSelectedObjectSet = Set <%!ELEMENT_TYPE_NAME%> ()
      for index in tableView.selectedRowIndexes {
        newSelectedObjectSet.insert (sortedArray.props.objectAtIndex (index, file: __FILE__, line: __LINE__))
      }
      setSelectedObjectSet (newSelectedObjectSet)
    }
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    T A B L E V I E W    D E L E G A T E : tableView:sortDescriptorsDidChange:                                     *
  //-------------------------------------------------------------------------------------------------------------------*

  func tableView (aTableView: NSTableView,
                  sortDescriptorsDidChange oldDescriptors: [AnyObject]) {
    if displayDebugMessage {
      NSLog ("\%@", __FUNCTION__)
    }
    mSortDescriptors = aTableView.sortDescriptors
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    T A B L E V I E W    D A T A S O U R C E                                                                       *
  //-------------------------------------------------------------------------------------------------------------------*
  // http://thegreyblog.blogspot.fr/2014/06/nscontroltexteditingdelegate-methods.html

  func numberOfRowsInTableView (NSTableView) -> Int {
    if displayDebugMessage {
      appendToTransientEventLog (String (format:"    \%@ (\%ld objects)\\n", __FUNCTION__, sortedArray.props.count))
    }
    return sortedArray.props.count
  }

  //-------------------------------------------------------------------------------------------------------------------*

  func tableView (tableView : NSTableView,
                  viewForTableColumn : NSTableColumn?,
                  row : Int) -> NSView {
    if displayDebugMessage {
//      NSLog ("\%@, row \%d, column \%@", __FUNCTION__, row, viewForTableColumn!.identifier)
    }
    let columnIdentifier = viewForTableColumn!.identifier
    var result : NSTableCellView = tableView.makeViewWithIdentifier (columnIdentifier, owner:self) as! NSTableCellView
    result.textField?.tag = row
    let object = sortedArray.props.objectAtIndex (row, file:__FILE__, line:__LINE__)
   %
for () in BOUND_COLUMNS
do
% if columnIdentifier == "%!mColumnName%" {\n%
  ![[FILE_WRAPPER textFileContentsAtPath !"/cell-" + [mPropertyType key] + "-" + mColumnOutletTypeName + ".txt"] stringByReplacingStringByString !"$MODEL$" !mObservablePropertyName]
%    }%
between %else%
end
%
    return result
  }

 %
for () in BOUND_COLUMNS do
% //-------------------------------------------------------------------------------------------------------------------*

  func set_%!mObservablePropertyName%_Action (sender : %!mColumnOutletTypeName%) {
    let row = sender.tag
    let object = sortedArray.props.objectAtIndex (row, file:__FILE__, line:__LINE__)
    let validationResult = object.%!mObservablePropertyName%.validate (%![mPropertyType transformerForTableViewAction !"sender"]%)
    switch validationResult {
    case PMValidationResult.ok :
      object.%!mObservablePropertyName%.setProp (%![mPropertyType transformerForTableViewAction !"sender"]%)
    case PMValidationResult.rejectWithBeep :
      NSBeep ()
    case PMValidationResult.rejectWithAlert (let informativeText) :
      if let window = sender.window {
        let alert = NSAlert ()
        alert.messageText = String (format:"The value “%![mPropertyType formatterStringForFormatPrinting]%” is invalid.", %![mPropertyType transformerForTableViewAction !"sender"]%)
        alert.informativeText = informativeText
        alert.addButtonWithTitle ("Ok")
        alert.addButtonWithTitle ("Discard Change")
        alert.beginSheetModalForWindow (window, completionHandler:{(response : NSModalResponse) in
          if response == NSAlertSecondButtonReturn { // Discard Change
         //   object.%!mObservablePropertyName%.removeObserver(self.eventModelChange, inTrigger:false)
            object.%!mObservablePropertyName%.setProp (%![mPropertyType transformerForTableViewAction !"sender"]%)
         //   object.%!mObservablePropertyName%.addObserver (self.eventModelChange, inTrigger:false)
          }
        })
      }
    }
  }

%
end
%  //-------------------------------------------------------------------------------------------------------------------*
  //    add                                                                                                            *
  //-------------------------------------------------------------------------------------------------------------------*

   func add (inSender : NSButton?) {
    if displayDebugMessage {
      appendToTransientEventLog (String (format:"    \%@\\n", __FUNCTION__))
    }
    if let object = mModel, undoManager = object.undoManager () {
      var newObject : %!ELEMENT_TYPE_NAME% = %!ELEMENT_TYPE_NAME% (undoManager:undoManager)
      var array = object.%!RELATIONSHIP_NAME%.props
      array.append (newObject)
    //--- New object is the selection
      var newSelectedObjectSet = Set <%!ELEMENT_TYPE_NAME%> ()
      newSelectedObjectSet.insert (newObject)
      setSelectedObjectSet (newSelectedObjectSet)
      object.%!RELATIONSHIP_NAME%.props = array
    }
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    remove                                                                                                         *
  //-------------------------------------------------------------------------------------------------------------------*

  func remove (inSender : NSButton?) {
    if let model = mModel where selectedObjectSet ().count > 0 {
    //------------- Find the object to be selected after selected object removing
    //--- Dictionary of object sorted indexes
      var sortedObjectDictionary = [%!ELEMENT_TYPE_NAME% : Int] ()
      for (index, object) in enumerate (sortedArray.props) {
        sortedObjectDictionary [object] = index
      }
      var indexArrayOfSelectedObjects = [Int] ()
      for object in selectedObjectSet () {
        let index = sortedObjectDictionary [object]
        if let idx = index {
          indexArrayOfSelectedObjects.append (idx)
        }
      }
    //--- Sort
      indexArrayOfSelectedObjects.sort { $0 < $1 }
    //--- Find the first index of a non selected object
      var newSelectionIndex = indexArrayOfSelectedObjects [0] + 1
      for index in indexArrayOfSelectedObjects {
        if newSelectionIndex < index {
          break
        }else{
          newSelectionIndex = index + 1
        }
      }
      var newSelectedObject : %!ELEMENT_TYPE_NAME%? = nil
      if (newSelectionIndex >= 0) && (newSelectionIndex < sortedArray.props.count) {
        newSelectedObject = sortedArray.props [newSelectionIndex]
      }
    //----------------------------------------- Remove selected object
    //--- Dictionary of object absolute indexes
      var objectDictionary = [%!ELEMENT_TYPE_NAME% : Int] ()
      for (index, object) in enumerate (model.%!RELATIONSHIP_NAME%.props) {
        objectDictionary [object] = index
      }
    //--- Build selected objects index array
      var selectedObjectIndexArray = [Int] ()
      for object in selectedObjectSet () {
        let index = objectDictionary [object]
        if let idx = index {
          selectedObjectIndexArray.append (idx)
        }
      }
    //--- Sort in reverse order
      selectedObjectIndexArray.sort { $1 < $0 }
    //--- Remove objects, in reverse of order of their index
      var newObjectArray = model.%!RELATIONSHIP_NAME%.props
      for index in selectedObjectIndexArray {
        newObjectArray.removeAtIndex (index)
      }
    //----------------------------------------- Set new selection
      var newSelectionSet = Set <%!ELEMENT_TYPE_NAME%> ()
      if let object = newSelectedObject {
        newSelectionSet.insert (object)
      }
      setSelectedObjectSet (newSelectionSet)
    //----------------------------------------- Set new object array
      model.%!RELATIONSHIP_NAME%.props = newObjectArray
    }
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //  Transient: canRemove                                                                                             *
  //-------------------------------------------------------------------------------------------------------------------*

  var canRemove = PMTransientProperty_Bool ()
}

//---------------------------------------------------------------------------------------------------------------------*
