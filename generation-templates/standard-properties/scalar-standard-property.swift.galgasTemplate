//----------------------------------------------------------------------------------------------------------------------
//   Scalar property %!TYPE%
//----------------------------------------------------------------------------------------------------------------------

typealias EBReadOnlyProperty_%!TYPE%    = EBGenericReadOnlyProperty <%!TYPE%>
typealias EBTransientProperty_%!TYPE%   = EBGenericTransientProperty <%!TYPE%>
%if not TRANSIENT then
%typealias EBReadWriteProperty_%!TYPE%   = EBGenericReadWriteProperty <%!TYPE%>
typealias EBPropertyProxy_%!TYPE%       = EBGenericPropertyProxy <%!TYPE%>
typealias EBComputedProperty_%!TYPE%    = EBGenericComputedProperty <%!TYPE%>
typealias EBStoredProperty_%!TYPE%      = EBGenericStoredProperty <%!TYPE%>
typealias EBPreferencesProperty_%!TYPE% = EBGenericPreferenceProperty <%!TYPE%>

//----------------------------------------------------------------------------------------------------------------------

func compare_%!TYPE%_values (_ left : %!TYPE%, _ inAscending : Bool, _ right : %!TYPE%) -> ComparisonResult {
%if COMPARISON_METHOD != "" then
  %  let order = left.%!COMPARISON_METHOD% (right)\n%
  %  switch order {\n%
  %  case .orderedAscending :\n%
  %    return inAscending ? .orderedAscending : .orderedDescending\n%
  %  case .orderedSame :\n%
  %    return .orderedSame\n%
  %  case .orderedDescending :\n%
  %    return inAscending ? .orderedDescending : .orderedAscending\n%
  %  }\n%
else
  %  if left < right {\n%
  %    return inAscending ? .orderedAscending : .orderedDescending\n%
  %  }else if left > right {\n%
  %    return inAscending ? .orderedDescending : .orderedAscending\n%
  %  }else{\n%
  %    return .orderedSame\n%
  %  }\n%
end
%}

//----------------------------------------------------------------------------------------------------------------------

func compare_%!TYPE%_properties (_ left : EBReadOnlyProperty_%!TYPE%, _ right : EBReadOnlyProperty_%!TYPE%) -> ComparisonResult {
  switch left.selection {
  case .empty :
    switch right.selection {
    case .empty :
      return .orderedSame
    default:
      return .orderedAscending
    }
  case .multiple :
    switch right.selection {
    case .empty :
      return .orderedDescending
    case .multiple :
      return .orderedSame
   case .single (_) :
      return .orderedAscending
   }
 case .single (let currentValue) :
    switch right.selection {
    case .empty, .multiple :
      return .orderedDescending
    case .single (let otherValue) :
%
if COMPARISON_METHOD != "" then
  %      return currentValue.%!COMPARISON_METHOD% (otherValue)\n%
else
  %      if currentValue < otherValue {\n%
  %        return .orderedAscending\n%
  %      }else if currentValue > otherValue {\n%
  %        return .orderedDescending\n%
  %      }else{\n%
  %        return .orderedSame\n%
  %      }\n%
end
%    }
  }
}
%end
%
