//----------------------------------------------------------------------------------------------------------------------
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//----------------------------------------------------------------------------------------------------------------------

import Cocoa

//----------------------------------------------------------------------------------------------------------------------

let ENTITY_KEY = "--entity"

//----------------------------------------------------------------------------------------------------------------------

fileprivate let kEntityDictionary : [String : EBManagedObject.Type] = [
%
for () in ENTITY_LIST
do
  %  "%!mEntityName%" : %!mEntityName%.self%
  for () in mObsoleteEntityNames do
    %,\n  "%![mValue string]%" : %!mEntityName%.self%
  end
between
  %,\n%
end
%
]

//----------------------------------------------------------------------------------------------------------------------
//  newInstanceOfEntityNamed
//----------------------------------------------------------------------------------------------------------------------

func newInstanceOfEntityNamed (_ ebUndoManager : EBUndoManager?,
                               _ inEntityTypeName : String) -> EBManagedObject? {
  if let T = kEntityDictionary [inEntityTypeName] {
    return T.init (ebUndoManager)
  }else{
    return nil
  }
}

//----------------------------------------------------------------------------------------------------------------------
//   makeManagedObjectFromDictionary
//----------------------------------------------------------------------------------------------------------------------

func makeManagedObjectFromDictionary (_ inUndoManager : EBUndoManager?,
                                      _ inDictionary : NSDictionary) -> EBManagedObject? {
  let entityName = inDictionary.value (forKey: ENTITY_KEY) as! String
  if let object = newInstanceOfEntityNamed (inUndoManager, entityName) {
    object.setUpAtomicPropertiesWithDictionary (inDictionary) 
    return object
  }else{
    return nil
  }
}

//----------------------------------------------------------------------------------------------------------------------
//     loadEasyBindingFile
//----------------------------------------------------------------------------------------------------------------------

func loadEasyBindingFile (_ inUndoManager : EBUndoManager?, from data: Data) throws
     -> (UInt8, [String : Any], EBManagedObject?, EBManagedDocumentFileFormat) {
//---- Define input data scanner
  var dataScanner = EBDataScanner (data:data)
//--- Check Signature
  if dataScanner.testString (string: PM_BINARY_FORMAT_SIGNATURE) {
    return try loadEasyBindingBinaryFile (inUndoManager, from: &dataScanner)
  }else if dataScanner.testString (string: PM_TEXTUAL_FORMAT_SIGNATURE) {
    return try loadEasyBindingTextFile (inUndoManager, from: &dataScanner)
  }else{
    let dictionary = [
      "Cannot Open Document" : NSLocalizedDescriptionKey,
      "The file has an invalid format" : NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
}

//----------------------------------------------------------------------------------------------------------------------

class ParallelObjectSetupContext {
  let mOperationQueue = OperationQueue ()
  var mToOneSetUpOperationList = [() -> Void] ()
  var mToManySetUpOperationList = [() -> Void] ()
  let mMutex = DispatchSemaphore (value: 1)
}

//----------------------------------------------------------------------------------------------------------------------

func loadEasyBindingTextFile (_ inUndoManager : EBUndoManager?,
        from ioDataScanner: inout EBDataScanner) throws -> (UInt8, [String : Any], EBManagedObject?, EBManagedDocumentFileFormat) {
  var startLoadFile = Date ()
//--- Check header ends with line feed
  ioDataScanner.acceptRequired (byte: ASCII.lineFeed.rawValue)
//--- Read Status
  let metadataStatus = UInt8 (ioDataScanner.parseBase62EncodedInt ())
 // Swift.print ("metadataStatus \(metadataStatus)")
//--- Read metadata dictionary
  let metadataDictionary : [String : Any] = try ioDataScanner.parseJSON ()
 // Swift.print ("metadataDictionary \(metadataDictionary)")
//--- Read classes
  var classDefinition = [(String, [String])] ()
  while ioDataScanner.testAccept (byte: ASCII.dollar.rawValue) {
    let className = try ioDataScanner.parseString ()
    // Swift.print ("CLASS NAME: '\(className)', class index \(classDefinition.count)")
    var readPropertyNames = true
    var propertyNameArray = [String] ()
    while readPropertyNames, ioDataScanner.ok () {
      if ioDataScanner.test (byte: ASCII.dollar.rawValue) {
        readPropertyNames = false
      }else if ioDataScanner.test (byte: ASCII.at.rawValue) {
        readPropertyNames = false
      }else{
        let propertyName = try ioDataScanner.parseString ()
        propertyNameArray.append (propertyName)
//        Swift.print ("  PROPERTY NAME: '\(propertyName)'")
      }
    }
    classDefinition.append ((className, propertyNameArray))
  }
  Swift.print ("Read classes \(Date ().timeIntervalSince (startLoadFile) * 1000.0) ms")
  startLoadFile = Date ()
//--- Read objects
//  let readIndex = ioDataScanner.mReadIndex
  var objectArray = [EBManagedObject] ()
  var propertyValueArray = [[String : NSRange]] ()
  while !ioDataScanner.eof (), ioDataScanner.testAccept (byte: ASCII.at.rawValue) {
    let classIndex = ioDataScanner.parseBase62EncodedInt ()
    // Swift.print ("CLASS INDEX: '\(classIndex)'")
    let managedObject = newInstanceOfEntityNamed (inUndoManager, classDefinition [classIndex].0)!
    objectArray.append (managedObject)
    var readPropertyValues = true
    var valueDictionary = [String : NSRange] ()
    var propertyIndex = 0
    while readPropertyValues, ioDataScanner.ok () {
      if ioDataScanner.test (byte: ASCII.at.rawValue) {
        readPropertyValues = false
      }else if ioDataScanner.eof () {
        readPropertyValues = false
      }else{
        let propertyRange = ioDataScanner.getLineRange ()
        valueDictionary [classDefinition [classIndex].1 [propertyIndex]] = propertyRange
        propertyIndex += 1
        // Swift.print ("  PROPERTY VALUE: '\(propertyValue)'")
      }
    }
    propertyValueArray.append (valueDictionary)
  }
  Swift.print ("Read objects \(Date ().timeIntervalSince (startLoadFile) * 1000.0) ms")
  startLoadFile = Date ()
//--- Setup objects
  startLoadFile = Date ()
  var idx = 0
  let parallelObjectSetupContext = ParallelObjectSetupContext ()
  for managedObject in objectArray {
    let valueDictionary = propertyValueArray [idx]
    idx += 1
    managedObject.setUpWithTextDictionary (valueDictionary, objectArray, ioDataScanner.data, parallelObjectSetupContext)
  }
  parallelObjectSetupContext.mOperationQueue.waitUntilAllOperationsAreFinished ()
  Swift.print ("prepare objects \(Date ().timeIntervalSince (startLoadFile) * 1000.0) ms")
  for setupOperation in parallelObjectSetupContext.mToOneSetUpOperationList{
    setupOperation ()
  }
  Swift.print ("setup toOne \(Date ().timeIntervalSince (startLoadFile) * 1000.0) ms")
  for setupOperation in parallelObjectSetupContext.mToManySetUpOperationList {
    setupOperation ()
  }
  Swift.print ("setup objects \(Date ().timeIntervalSince (startLoadFile) * 1000.0) ms")
//--- Scanner error ?
  if !ioDataScanner.ok () {
    let dictionary = [
      "Cannot Open Document" : NSLocalizedDescriptionKey,
      "The file has an invalid format" : NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
//--- Analyze read data
  var rootObject : EBManagedObject? = nil
  if objectArray.count > 0 {
    rootObject = objectArray [0]
  }
//---
  if rootObject == nil {
    let dictionary = [
      "Cannot Open Document" :  NSLocalizedDescriptionKey,
      "Root object cannot be read" :  NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
//---
  return (metadataStatus, metadataDictionary, rootObject, .textual)
}

//----------------------------------------------------------------------------------------------------------------------

func loadEasyBindingBinaryFile (_ inUndoManager : EBUndoManager?,
                                from ioDataScanner: inout EBDataScanner) throws
                -> (UInt8, [String : Any], EBManagedObject?, EBManagedDocumentFileFormat) {
//--- Read Status
  let metadataStatus = ioDataScanner.parseByte ()
//--- if ok, check byte is 1
  ioDataScanner.acceptRequired (byte: 1)
//--- Read metadata dictionary
  let dictionaryData = ioDataScanner.parseAutosizedData ()
  let metadataDictionary = try PropertyListSerialization.propertyList (from: dictionaryData as Data,
    options:[],
    format:nil
  ) as! [String : Any]
//--- Read data
  let dataFormat = ioDataScanner.parseByte ()
  let fileData = ioDataScanner.parseAutosizedData ()
//--- if ok, check final byte (0)
  ioDataScanner.acceptRequired (byte: 0)
//--- Scanner error ?
  if !ioDataScanner.ok () {
    let dictionary = [
      "Cannot Open Document" : NSLocalizedDescriptionKey,
      "The file has an invalid format" : NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
//--- Analyze read data
  var rootObject : EBManagedObject? = nil
  if dataFormat == 0x06 {
    rootObject = try readManagedObjectsFromBinaryData (inUndoManager, inData: fileData)
  }else{
    try raiseInvalidDataFormatError (dataFormat: dataFormat)
  }
//---
  if rootObject == nil {
    let dictionary = [
      "Cannot Open Document" :  NSLocalizedDescriptionKey,
      "Root object cannot be read" :  NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
//---
  return (metadataStatus, metadataDictionary, rootObject, .binary)
}

//----------------------------------------------------------------------------------------------------------------------

fileprivate func readManagedObjectsFromBinaryData (_ inUndoManager : EBUndoManager?, inData : Data) throws -> EBManagedObject? {
  var resultRootObject : EBManagedObject? = nil
  if let dictionaryArray = try PropertyListSerialization.propertyList (from: inData as Data, options: [], format: nil) as? [NSDictionary] {
    let creationStart = Date ()
    var objectArray = [EBManagedObject] ()
    for d in dictionaryArray {
      let className = d.object (forKey: ENTITY_KEY) as! String
      if let object = newInstanceOfEntityNamed (inUndoManager, className) {
        objectArray.append (object)
      }else{
        let dictionary = [
          "Cannot Open Document" :  NSLocalizedDescriptionKey,
          "Root object cannot be read" :  NSLocalizedRecoverySuggestionErrorKey
        ]
        throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo:dictionary)
      }
    }
    if LOG_OPERATION_DURATION {
      Swift.print ("  Object Creation \(Int (Date ().timeIntervalSince (creationStart) * 1000.0)) ms")
    }
    let setupStart = Date ()
    var idx = 0
    for d in dictionaryArray {
      let object = objectArray [idx]
      object.setUpWithDictionary (d, managedObjectArray: &objectArray)
      idx += 1
    }
    resultRootObject = objectArray [0] //--- Set root object
    if LOG_OPERATION_DURATION {
      Swift.print ("  Object Setup \(Int (Date ().timeIntervalSince (setupStart) * 1000.0)) ms")
    }
  }
  return resultRootObject
}

//----------------------------------------------------------------------------------------------------------------------

fileprivate func raiseInvalidDataFormatError (dataFormat : UInt8) throws {
  let dictionary = [
    "Cannot Open Document" :  NSLocalizedDescriptionKey,
    "Unkown data format: \(dataFormat)" :  NSLocalizedRecoverySuggestionErrorKey
  ]
  throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
}

//----------------------------------------------------------------------------------------------------------------------
//     loadEasyRootObjectDictionary
//----------------------------------------------------------------------------------------------------------------------

func loadEasyRootObjectDictionary (from data: Data) throws -> (UInt8, [String : Any], [String : Any]?) {
//---- Define input data scanner
  var dataScanner = EBDataScanner (data: data)
//--- Check Signature
  for c in PM_BINARY_FORMAT_SIGNATURE.utf8 {
    dataScanner.acceptRequired (byte: c)
  }
//--- Read Status
  let metadataStatus = dataScanner.parseByte ()
//--- if ok, check byte is 1
  dataScanner.acceptRequired (byte: 1)
//--- Read metadata dictionary
  let dictionaryData = dataScanner.parseAutosizedData ()
  let metadataDictionary = try PropertyListSerialization.propertyList (from: dictionaryData,
    options:[],
    format:nil
  ) as! [String : Any]
//--- Read data
  let dataFormat = dataScanner.parseByte ()
  let fileData = dataScanner.parseAutosizedData ()
//--- if ok, check final byte (0)
  dataScanner.acceptRequired (byte: 0)
//--- Scanner error ?
  if !dataScanner.ok () {
    let dictionary = [
      "Cannot Open Document" : NSLocalizedDescriptionKey,
      "The file has an invalid format" : NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
//--- Analyze read data
  var rootObjectDictionary : [String : Any]? = nil
  if dataFormat == 0x06 {
    if let dictionaryArray = try PropertyListSerialization.propertyList (from: fileData, options: [], format: nil) as? [[String : Any]] {
      rootObjectDictionary = dictionaryArray [0]
    }
  }else{
    try raiseInvalidDataFormatError (dataFormat: dataFormat)
  }
//---
  if rootObjectDictionary == nil {
    let dictionary = [
      "Cannot Open Document" : NSLocalizedDescriptionKey,
      "Root object cannot be read" : NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
//---
  return (metadataStatus, metadataDictionary, rootObjectDictionary)
}

//----------------------------------------------------------------------------------------------------------------------
