//----------------------------------------------------------------------------------------------------------------------
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//----------------------------------------------------------------------------------------------------------------------

import Cocoa

//----------------------------------------------------------------------------------------------------------------------

extension EBGraphicView {

  //····················································································································

  final override func mouseDown (with inEvent : NSEvent) {
    if let viewController = self.viewController {
      NSCursor.arrow.set ()
      let unalignedMouseDownLocation = self.convert (inEvent.locationInWindow, from:nil)
      let canariUnalignedMouseDownLocation = unalignedMouseDownLocation.canariPoint
      let modifierFlags = inEvent.modifierFlags
      let modifierFlagsContainsControl = modifierFlags.contains (.control)
      let modifierFlagsContainsShift = modifierFlags.contains (.shift)
      let modifierFlagsContainsOption = modifierFlags.contains (.option)
      let (possibleObjectIndex, possibleKnobIndex) = self.indexOfFrontObject (at: unalignedMouseDownLocation)
      switch (modifierFlagsContainsControl, modifierFlagsContainsShift, modifierFlagsContainsOption) {
      case (true, false, false) : // Ctrl Key On, no shift -> Contextual click
        if let theMenu = self.mPopulateContextualMenuClosure? (canariUnalignedMouseDownLocation) {
          NSMenu.popUpContextMenu (theMenu, with: inEvent, for: self)
        }
      case (false, true, false) : // Shift Key
        self.guideFor (possibleObjectIndex: possibleObjectIndex)
        self.mMouseDownBehaviour = ShiftMouseDownBehaviour (unalignedMouseDownLocation, possibleObjectIndex, viewController)
      case (_, _, true) : // Option Key On
        if let pbType = self.pasteboardType {
          self.ebStartDragging (with: inEvent, dragType: pbType)
        }else{
          self.mMouseDownBehaviour = OptionMouseDownBehaviour (unalignedMouseDownLocation, self, viewController)
        }
      case (false, false, false) : // No Modifier Key
        self.guideFor (possibleObjectIndex: possibleObjectIndex)
        if let objectIndex = possibleObjectIndex {
          self.mMouseDownBehaviour = MouseDownOnObjectBehaviour (
            unalignedMouseDownLocation,
            objectIndex: objectIndex,
            possibleKnobIndex: possibleKnobIndex,
            self,
            viewController
          )
        }else{
          self.mMouseDownBehaviour = MouseDownOutsideAnyObjectBehaviour (unalignedMouseDownLocation, viewController)
        }
      default :
        super.mouseDown (with: inEvent)
      }
    }
  }

  //····················································································································

  final override func mouseDragged (with inEvent : NSEvent) {
    super.mouseDragged (with: inEvent)
    let unalignedLocationInView = self.convert (inEvent.locationInWindow, from: nil)
    let locationOnGridInView = unalignedLocationInView.aligned (onGrid: canariUnitToCocoa (self.mouseGridInCanariUnit))
    self.updateXYplacards (locationOnGridInView)

    self.mMouseDownBehaviour.onMouseDraggedOrModifierFlagsChanged (unalignedLocationInView, inEvent.modifierFlags, self)
  }

    //····················································································································

    final override func mouseUp (with inEvent : NSEvent) {
      super.mouseUp (with: inEvent)
      let unalignedLocationInView = self.convert (inEvent.locationInWindow, from: nil)
      self.mSelectionRectangle = nil
      self.mGuideBezierPath = nil
      self.mMouseDownBehaviour.onMouseUp (unalignedLocationInView, self)
      self.mMouseDownBehaviour = DefaultBehaviourOnMouseDown ()
    //--- Set cursor
      self.setCursor (forLocationInView: unalignedLocationInView)
    //--- Update frame and bounds
      self.updateViewFrameAndBounds ()
    }

  //····················································································································

  final func drag (possibleKnob inPossibleKnobIndex : Int?,
                   objectIndex : Int,
                   _ inProposedTranslation: CanariPoint,
                   _ inLastMouseDraggedLocation : CanariPoint) {
    let objects = self.viewController?.graphicObjectArray ?? []
    if let knobIndex = inPossibleKnobIndex { // Mode knob
      let p = objects [objectIndex].canMove (knob: knobIndex, xBy: inProposedTranslation.x, yBy: inProposedTranslation.y)
      if (p.x != 0) || (p.y != 0) {
        let mouseDraggedLocation = CanariPoint (
          x: p.x + inLastMouseDraggedLocation.x,
          y: p.y + inLastMouseDraggedLocation.y
        )
        objects [objectIndex].move (
          knob: knobIndex,
          xBy: p.x,
          yBy: p.y,
          newX: mouseDraggedLocation.x,
          newY: mouseDraggedLocation.y
        )
      }
    }else{ // Move selected objects
      self.dragSelection (inProposedTranslation, inLastMouseDraggedLocation)
    }
  }

  //····················································································································

  final fileprivate func dragSelection (_ proposedTranslation: CanariPoint, _ lastMouseDraggedLocation : CanariPoint) {
    var dx = proposedTranslation.x
    var dy = proposedTranslation.y
    for object in self.viewController?.selectedGraphicObjectSet ?? [] {
      let p = object.acceptedTranslation (xBy: dx, yBy: dy)
      dx = p.x
      dy = p.y
    }
    if (dx != 0) || (dy != 0) {
      let userSet = OCObjectSet ()
      for object in self.viewController?.selectedGraphicObjectSet ?? [] {
        object.translate (xBy: dx, yBy: dy, userSet: userSet)
      }
    }
  }

  //····················································································································

  final internal func indexOfFrontObject (at inLocation : NSPoint) -> (Int?, Int?){
    var possibleObjectIndex : Int? = nil
    var possibleKnobIndex : Int? = nil
    let selectedObjects = self.selectionShapes
    var idx = selectedObjects.count
    while (idx > 0) && (possibleObjectIndex == nil) {
      idx -= 1
      possibleKnobIndex = selectedObjects [idx].knobIndex (at: inLocation)
      if possibleKnobIndex != nil {
        possibleObjectIndex = idx
      }
    }
    idx = selectedObjects.count
    while (idx > 0) && (possibleObjectIndex == nil) {
      idx -= 1
      if selectedObjects [idx].contains (point: inLocation) {
        possibleObjectIndex = idx
      }
    }
    let objects = self.objectDisplayArray
    idx = objects.count
    while (idx > 0) && (possibleObjectIndex == nil) {
      idx -= 1
      if objects [idx].contains (point: inLocation) {
        possibleObjectIndex = idx
      }
    }
    return (possibleObjectIndex, possibleKnobIndex)
  }

  //····················································································································

  final internal func knobIndex (ofSelectedObjectIndex inObjectIndex : Int, at inLocation : NSPoint) -> Int? {
    let selectedObjects = self.selectionShapes
    if inObjectIndex < selectedObjects.count {
      return selectedObjects [inObjectIndex].knobIndex (at: inLocation)
    }else{
      return nil
    }
  }

  //····················································································································

  final internal func indexesOfObjects (intersecting inRect : NSRect) -> Set <Int> {
    var result = Set <Int> ()
    var idx = 0
    for object in self.objectDisplayArray {
      if object.intersects (rect: inRect) {
        result.insert (idx)
      }
      idx += 1
    }
    return result
  }

  //····················································································································

  final override func flagsChanged (with inEvent : NSEvent) {
    let unalignedLocationInView = self.convert (inEvent.locationInWindow, from: nil)
    self.mMouseMovedOrFlagsChangedCallback? (unalignedLocationInView)
    self.mMouseDownBehaviour.onMouseDraggedOrModifierFlagsChanged (unalignedLocationInView, NSEvent.modifierFlags, self)
    super.flagsChanged (with: inEvent)
  }

  //····················································································································

  final func setCursor (forLocationInView inLocation : NSPoint) {
    let (possibleObjectIndex, possibleKnobIndex) = self.indexOfFrontObject (at: inLocation)
    if let objectIndex = possibleObjectIndex,
       let knobIndex = possibleKnobIndex,
       let object = self.viewController?.graphicObjectArray [objectIndex],
       let newCursor = object.cursorForKnob (knob: knobIndex) {
         newCursor.set ()
    }else{
      NSCursor.arrow.set ()
    }
  }

  //····················································································································

}

//----------------------------------------------------------------------------------------------------------------------
