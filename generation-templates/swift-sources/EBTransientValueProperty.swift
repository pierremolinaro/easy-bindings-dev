//----------------------------------------------------------------------------------------------------------------------
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//----------------------------------------------------------------------------------------------------------------------

import Cocoa

//----------------------------------------------------------------------------------------------------------------------
//   EBTransientValueProperty <T>
//----------------------------------------------------------------------------------------------------------------------

class EBTransientValueProperty <T> : EBReadOnlyValueProperty <T> where T : Equatable {

  //····················································································································

  private var mValueCache : EBSelection <T>? = nil
  var mReadModelFunction : Optional<() -> EBSelection <T> > = nil

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      if let valueCache = self.mValueCache {
        self.mValueExplorer?.stringValue = "\(valueCache)"
      }else{
        self.mValueExplorer?.stringValue = "nil"
      }
    }
  }

  //····················································································································

  private var mMutex = DispatchSemaphore (value: 1)

  override var prop : EBSelection <T> {
    self.mMutex.wait ()
    if self.mValueCache == nil {
      self.mValueCache = self.mReadModelFunction? ()
      if self.mValueCache == nil {
        self.mValueCache = .empty
      }
      self.mValueExplorer?.stringValue = "\(self.mValueCache!)"
    }
    self.mMutex.signal ()
    return self.mValueCache!
  }

  //····················································································································

  override func postEvent () {
    if self.mValueCache != nil {
      self.mValueCache = nil
      self.mValueExplorer?.stringValue = "nil"
      if logEvents () {
        appendMessageString ("Transient \(explorerIndexString (self.ebObjectIndex)) propagation\n")
      }
      super.postEvent ()
    }else if logEvents () {
      appendMessageString ("Transient \(explorerIndexString (self.ebObjectIndex)) nil\n")
    }
  }

  //····················································································································

  override func computePropertyAsynchronously (_ inOperationQueue : OperationQueue) {
   inOperationQueue.addOperation { _ = self.prop }
  }

  //····················································································································

  func configure <T1, T2, T3> (_ in1 : EBReadOnlyValueProperty <T1>,
                               _ in2 : EBReadOnlyValueProperty <T2>,
                               _ in3 : EBReadOnlyValueProperty <T3>,
                               _ computationCallBack : @escaping (_ in1 : T1, _ in2 : T2, _ in3 : T3) -> T) {
    in1.addEBObserver (self)
    in2.addEBObserver (self)
    in3.addEBObserver (self)
    self.mReadModelFunction = { [weak in1, weak in2, weak in3] in
      if let uwIn1 = in1, let uwIn2 = in2, let uwIn3 = in3 {
        switch (uwIn1.prop, uwIn2.prop, uwIn3.prop) {
        case (.single (let v1), .single (let v2), .single (let v3)) :
          let v = computationCallBack (v1, v2, v3)
          return .single (v)
        default:
          return .empty
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

}

//----------------------------------------------------------------------------------------------------------------------
