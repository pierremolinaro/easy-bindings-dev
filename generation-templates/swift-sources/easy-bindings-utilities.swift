//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  EBSignatureObserverProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc protocol EBSignatureObserverProtocol {
  func clearSignatureCache ()
  func signature () -> UInt32
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBWeakObserverSetElement
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate struct EBWeakObserverSetElement {

  //····················································································································

  private weak var mObserver : EBEvent? = nil // SOULD BE WEAK

  //····················································································································

  fileprivate var observer : EBEvent? { return self.mObserver }

  //····················································································································

  init (observer : EBEvent) {
    mObserver = observer
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBWeakEventSet
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct EBWeakEventSet {

  //····················································································································

  fileprivate var mDictionary = [Int : EBWeakObserverSetElement] ()

  //····················································································································

  mutating func insert (_ inObserver : EBEvent) {
    let address : Int = inObserver.ebObjectIndex
    self.mDictionary [address] = EBWeakObserverSetElement (observer:inObserver)
  }

  //····················································································································

  mutating func remove (_ inObserver : EBEvent) {
    let address : Int = inObserver.ebObjectIndex
    self.mDictionary [address] = nil
  }

  //····················································································································

  mutating func apply (_ inFunction : (_ : EBEvent) -> Void) {
    for (key, entry) in self.mDictionary {
      if let observer = entry.observer {
        inFunction (observer)
      }else{
        self.mDictionary [key] = nil
      }
    }
  }

  //····················································································································

  var count : Int {
    var n = 0
    for (_, entry) in self.mDictionary {
      if entry.observer != nil {
        n += 1
      }
    }
    return n
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBModelNotifierEvent
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBModelNotifierEvent : EBEvent {

  //····················································································································
  //   Properties
  //····················································································································

  private let mClient : ReadOnlyAbstractGenericRelationshipProperty
  private let mRemoveSortObserversCallback : (EBModelNotifierEvent) -> Void

  //····················································································································
  //   Properties
  //····················································································································

  init (_ inClient : ReadOnlyAbstractGenericRelationshipProperty,
        addSortObserversCallback inAddSortObserversCallback : (EBModelNotifierEvent) -> Void,
        removeSortObserversCallback inRemoveSortObserversCallback : @escaping (EBModelNotifierEvent) -> Void) {
    mClient = inClient
    mRemoveSortObserversCallback = inRemoveSortObserversCallback
    super.init ()
    inAddSortObserversCallback (self)
  }

  //····················································································································

  func removeSortObservers () {
    self.mRemoveSortObserversCallback (self)
  }

  //····················································································································

  override func postEvent () {
    super.postEvent ()
    self.mClient.notifyModelDidChange ()
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBAbstractProperty (abstract class)
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBAbstractProperty : EBEvent {

  private final var mObservers = EBWeakEventSet ()

  //····················································································································

  final func addEBObserver (_ inObserver : EBEvent) {
    self.mObservers.insert (inObserver)
    self.updateObserverExplorer ()
    inObserver.postEvent ()
  }

  //····················································································································

  final func addEBObserversFrom (_ inObserverSet : inout EBWeakEventSet) {
    inObserverSet.apply { (_ observer : EBEvent) in
      self.mObservers.insert (observer)
      observer.postEvent ()
    }
    self.updateObserverExplorer ()
  }

  //····················································································································

  final func removeEBObserver (_ inObserver : EBEvent) {
    self.mObservers.remove (inObserver)
    self.updateObserverExplorer ()
  }

  //····················································································································

  final func removeEBObserversFrom (_ inObserverSet : inout EBWeakEventSet) {
    inObserverSet.apply {(_ observer : EBEvent) in
      self.mObservers.remove (observer)
    }
    self.updateObserverExplorer ()
  }

  //····················································································································

  override func postEvent () {
    self.mObservers.apply ( {(_ observer : EBEvent) in observer.postEvent () })
  }

  //····················································································································

  final var mObserverExplorer : NSPopUpButton? {
    didSet {
      self.updateObserverExplorer ()
    }
  }

  //····················································································································

  final func updateObserverExplorer () {
    if let observerExplorer = self.mObserverExplorer {
      observerExplorer.removeAllItems ()
      let observerCount = self.mObservers.count
      observerExplorer.addItem (withTitle: String (observerCount))
      observerExplorer.isEnabled = observerCount > 0
      self.mObservers.apply ( {(_ observer : EBEvent) in
        let stringValue = explorerIndexString (observer.ebObjectIndex) + " — " + observer.className
        observerExplorer.addItem (withTitle: stringValue)
      })
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBObserver
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBObserver : EBAbstractProperty {
  private var mPostEventFunction : Optional < () -> Void > = nil

  //····················································································································

  func setPostEventFunction (_ function : Optional < () -> Void >) {
    self.mPostEventFunction = function
  }

  //····················································································································

  override func postEvent() {
    self.mPostEventFunction? ()
    super.postEvent ()
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   presentErrorWindow
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func presentErrorWindow (_ file : String,
                         _ line : Int,
                         _ errorMessage : String) {
  if Thread.isMainThread {
    presentErrorWindowInMainThread (file, line, errorMessage)
  }else{
    DispatchQueue.main.async { presentErrorWindowInMainThread (file, line, errorMessage) }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate var gErrorWindows : [NSWindow] = []
fileprivate var gOrigin = NSPoint (x: 20.0, y: 20.0)

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate func presentErrorWindowInMainThread (_ file : String,
                                                 _ line : Int,
                                                 _ errorMessage : String) {
  var message = "File: \(file)\n"
  message += "Line: \(line)\n"
  message += "Message: \(errorMessage)\n"
  let r = NSRect (origin: gOrigin, size: NSSize (width: 300.0, height: 200.0))
  gOrigin.x += 20.0
  gOrigin.y += 20.0
  let window = NSWindow (
    contentRect: r,
    styleMask: [.titled, .closable],
    backing: .buffered,
    defer: true
  )
  window.title = "Outlet Error"
  let contentView : NSView = window.contentView!
  let tfRect = NSInsetRect (contentView.bounds, 10.0, 10.0)
  let tf = NSTextField (frame: tfRect)
  tf.isEditable = false
  tf.isSelectable = true
  tf.font = .boldSystemFont (ofSize: 0.0)
  tf.textColor = .red
  tf.stringValue = message
  contentView.addSubview (tf)
  window.makeKeyAndOrderFront (nil)
  gErrorWindows.append (window)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   checkOutletConnection
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func checkOutletConnection (_ inOutlet : NSObject?,
                            _ inOutletName : String,
                            _ inOutletType : NSObject.Type,
                            _ inFile : String,
                            _ inLine : Int) {
  if let outlet : NSObject = inOutlet {
    if !(outlet.isKind (of: inOutletType.self)) {
      presentErrorWindow (inFile, inLine, "the '\(inOutletName)' outlet is not an instance of '\(inOutletType.self)'")
    }
  }else{
    presentErrorWindow (inFile, inLine, "the '\(inOutletName)' outlet is nil")
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBValidationResult
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum EBValidationResult <T> {
  case ok (T /* validated value */)
  case rejectWithBeep
  case rejectWithAlert (String /* informativeText */)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBUserClassNameProtocol protocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc protocol EBUserClassNameProtocol {
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBTableCellView
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBTableCellView : NSTableCellView, EBUserClassNameProtocol {
  final var mUnbindFunction : Optional < () -> Void > = nil

  //····················································································································

  required init? (coder : NSCoder) {
    super.init (coder: coder)
    noteObjectAllocation (self)
  }

  //····················································································································

  override init (frame : NSRect) {
    super.init (frame: frame)
    noteObjectAllocation (self)
  }

  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································

  override func removeFromSuperview () {
    super.removeFromSuperview ()
    if Thread.isMainThread {
      self.mUnbindFunction? ()
    }else{
      DispatchQueue.main.async { self.mUnbindFunction? () }
    }
  }

  //····················································································································

  override func removeFromSuperviewWithoutNeedingDisplay () {
    super.removeFromSuperviewWithoutNeedingDisplay ()
    if Thread.isMainThread {
      self.mUnbindFunction? ()
    }else{
      DispatchQueue.main.async { self.mUnbindFunction? () }
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBObject class
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private var gEasyBindingsObjectIndex = 0

//······················································································································

class EBObject : NSObject, EBUserClassNameProtocol {
  let ebObjectIndex : Int

  //····················································································································

  override init () {
    ebObjectIndex = gEasyBindingsObjectIndex
    gEasyBindingsObjectIndex += 1
    super.init ()
    noteObjectAllocation (self)
  }

  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBSimpleController
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBSimpleController : EBOutletEvent {

  //····················································································································

  private let mPrivateObservedObjects : [EBAbstractProperty]

  //····················································································································

  init (observedObjects : [EBAbstractProperty], callBack: @escaping () -> Void) {
    mPrivateObservedObjects = observedObjects
    super.init ()
    self.mEventCallBack = callBack
    for object in observedObjects {
      object.addEBObserver (self)
    }
  }

  //····················································································································

  override func unregister () {
    super.unregister ()
    for object in self.mPrivateObservedObjects {
      object.removeEBObserver (self)
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    createEntryForAttributeNamed
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

let EXPLORER_ROW_HEIGHT : CGFloat = 20.0
private let FIRST_COLUMN_WIDTH  : CGFloat = 60.0
private let SECOND_COLUMN_WIDTH : CGFloat = 400.0
private let THIRD_COLUMN_WIDTH  : CGFloat = 300.0

let EXPLORER_ROW_WIDTH : CGFloat = FIRST_COLUMN_WIDTH + SECOND_COLUMN_WIDTH + THIRD_COLUMN_WIDTH

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func titleColumn (_ y : CGFloat) -> NSRect {
  return NSRect (x: 0.0, y: y, width: EXPLORER_ROW_WIDTH, height: EXPLORER_ROW_HEIGHT)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func firstColumn (_ y : CGFloat) -> NSRect {
  return NSRect (x: 0.0, y: y, width: FIRST_COLUMN_WIDTH, height: EXPLORER_ROW_HEIGHT)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func secondColumn (_ y : CGFloat) -> NSRect {
  return NSRect (x: FIRST_COLUMN_WIDTH, y: y, width: SECOND_COLUMN_WIDTH, height: EXPLORER_ROW_HEIGHT)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func thirdColumn (_ y : CGFloat) -> NSRect {
  return NSRect (x: FIRST_COLUMN_WIDTH + SECOND_COLUMN_WIDTH, y: y, width: THIRD_COLUMN_WIDTH, height: EXPLORER_ROW_HEIGHT)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private let explorerLetters = ["A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L",
                               "M", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

func explorerIndexString (_ idx : Int) -> String {
  var result = String (idx % 10)
  var n = idx / 10
  result += "\(n % 10)"
  n /= 10
  result += explorerLetters [n % explorerLetters.count]
  n /= explorerLetters.count
  result += explorerLetters [n % explorerLetters.count]
  n /= explorerLetters.count
  result += explorerLetters [n % explorerLetters.count]
  n /= explorerLetters.count
  if n > 0 {
    result += "\(n)"
  }
  return result
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func createEntryForPropertyNamed (_ attributeName : String,
                                  idx : Int,
                                  y ioY : inout CGFloat,
                                  view : NSView,
                                  observerExplorer ioObserverExplorer : inout NSPopUpButton?,
                                  valueExplorer ioValueExplorer : inout NSTextField?) {
  let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
//--- Explorer popup button
  let observerExplorer = NSPopUpButton (frame: firstColumn (ioY), pullsDown: true)
  ioObserverExplorer = observerExplorer
  observerExplorer.font = font
  view.addSubview (observerExplorer)
//--- Property textfield
  let tf = NSTextField (frame: secondColumn (ioY))
  tf.isEnabled = true
  tf.isEditable = false
  tf.stringValue = explorerIndexString (idx) + " — " + attributeName
  tf.font = font
  view.addSubview (tf)
//--- Value textfield
  let valueExplorer = NSTextField (frame: thirdColumn (ioY))
  ioValueExplorer = valueExplorer
  valueExplorer.isEnabled = true
  valueExplorer.isEditable = false
  valueExplorer.font = font
  view.addSubview (valueExplorer)
//--- Update rect origin
  ioY += EXPLORER_ROW_HEIGHT
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func createEntryForTitle (_ title : String,
                          y ioY : inout CGFloat,
                          view : NSView) {
  let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
//--- Title textfield
  let tf = NSTextField (frame:titleColumn (ioY))
  tf.isEnabled = true
  tf.isEditable = false
  tf.stringValue = title
  tf.font = font
  tf.backgroundColor = NSColor.lightGray
  tf.drawsBackground = true
  tf.isBordered = false
  view.addSubview (tf)
//--- Update rect origin
  ioY += EXPLORER_ROW_HEIGHT
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    createEntryForObjectNamed
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func createEntryForObjectNamed (_ name : String,
                                object : EBObject,
                                y ioY : inout CGFloat,
                                view : NSView) {
  let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
//--- Property textfield
  let tf = NSTextField (frame:secondColumn (ioY))
  tf.isEnabled = true
  tf.isEditable = false
  tf.stringValue = name
  tf.font = font
  view.addSubview (tf)
//--- Value textfield
  let vtf = NSTextField (frame:thirdColumn (ioY))
  vtf.isEnabled = true
  vtf.isEditable = false
  vtf.stringValue = explorerIndexString (object.ebObjectIndex) + " — " + String (describing: type(of: object))
  vtf.font = font
  view.addSubview (vtf)
//--- Update rect origin
  ioY += EXPLORER_ROW_HEIGHT
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    createEntryForToOneRelationshipNamed
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func createEntryForToOneRelationshipNamed (_ relationshipName : String,
                                           idx : Int,
                                           y ioY : inout CGFloat,
                                           view : NSView,
                                           valueExplorer ioValueExplorer : inout NSButton?) {
  let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
  let tf = NSTextField (frame: secondColumn (ioY))
  tf.isEnabled = true
  tf.isEditable = false
  tf.stringValue = explorerIndexString (idx) + " — " + relationshipName
  tf.font = font
  view.addSubview (tf)
  let valueExplorer = NSButton (frame: thirdColumn (ioY))
  ioValueExplorer = valueExplorer
  valueExplorer.font = font
  view.addSubview (valueExplorer)
  ioY += EXPLORER_ROW_HEIGHT
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    createEntryForToManyRelationshipNamed
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func createEntryForToManyRelationshipNamed (_ relationshipName : String,
                                            idx : Int,
                                            y ioY : inout CGFloat,
                                            view : NSView,
                                            valueExplorer ioValueExplorer : inout NSPopUpButton?) {
  let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
  let tf = NSTextField (frame:secondColumn (ioY))
  tf.isEnabled = true
  tf.isEditable = false
  tf.stringValue = explorerIndexString (idx) + " — " + relationshipName
  tf.font = font
  view.addSubview (tf)
  let valueExplorer = NSPopUpButton (frame: thirdColumn (ioY), pullsDown: true)
  ioValueExplorer = valueExplorer
  valueExplorer.font = font
  view.addSubview (valueExplorer)
  ioY += EXPLORER_ROW_HEIGHT
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    defaultValidationFunction
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func defaultValidationFunction <T> (_ currentValue : T, proposedValue : T) -> EBValidationResult <T> {
  return EBValidationResult.ok (proposedValue)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   PropertyKind
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum PropertyKind { case empty ; case single ; case multiple }

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBSelection
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum EBSelection <T> : Equatable where T : Equatable {

  //····················································································································

  case empty
  case multiple
  case single (T)

  //····················································································································

  static func == (lhs : EBSelection <T>, rhs : EBSelection <T>) -> Bool {
    switch (lhs, rhs) {
    case (.empty, .empty) :
      return true
    case (.multiple, .multiple) :
      return true
    case (.single (let left), .single (let right)) :
      return left == right
    default :
      return false
    }
  }

  //····················································································································

  func kind () -> PropertyKind {
    switch self {
    case .empty : return .empty
    case .multiple : return .multiple
    case .single : return .single
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func &= (left : inout PropertyKind, right : PropertyKind) {
  switch left {
  case .empty : break
  case .multiple :
    if right == .empty {
      left = .empty
    }
  case .single :
    switch right {
    case .empty :
      left = .empty
    case .multiple :
      left = .multiple
    case .single :
      break
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate func compareIntProperties (left : EBSelection <Int>,
                                       right : EBSelection <Int>,
                                       function : (Int, Int) -> Bool) -> EBSelection <Bool> {
  switch left {
  case .empty :
    return .empty
  case .multiple :
    switch right {
    case .empty :
      return .empty
    case .multiple, .single :
      return .multiple
    }
  case .single (let vg) :
    switch right {
    case .empty :
      return .empty
    case .multiple :
      return .multiple
    case .single (let vd) :
      return .single (function (vg, vd))
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func > (left : EBSelection <Int>, right : EBSelection <Int>) -> EBSelection <Bool> {
  return compareIntProperties (left: left, right: right) {$0 > $1}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func >= (left : EBSelection <Int>, right : EBSelection <Int>) -> EBSelection <Bool> {
  return compareIntProperties (left: left, right: right) {$0 >= $1}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func < (left : EBSelection <Int>, right : EBSelection <Int>) -> EBSelection <Bool> {
  return compareIntProperties (left: left, right: right) {$0 < $1}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func <= (left : EBSelection <Int>, right : EBSelection<Int>) -> EBSelection <Bool> {
  return compareIntProperties (left: left, right: right) {$0 <= $1}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func == (left : EBSelection <Int>, right : EBSelection <Int>) -> EBSelection <Bool> {
  return compareIntProperties (left: left, right: right) {$0 == $1}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func != (left : EBSelection <Int>, right : EBSelection <Int>) -> EBSelection <Bool> {
  return compareIntProperties (left: left, right: right) {$0 != $1}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate func combineBoolProperties (left : EBSelection <Bool>,
                                        right : EBSelection <Bool>,
                                        function : (Bool, Bool) -> Bool) -> EBSelection <Bool> {
  switch left {
  case .empty :
    return .empty
  case .multiple :
    switch right {
    case .empty :
      return .empty
    case .multiple, .single :
      return .multiple
    }
  case .single (let vg) :
    switch right {
    case .empty :
      return .empty
    case .multiple :
      return .multiple
    case .single (let vd) :
      return .single (function (vg, vd))
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func && (left : EBSelection <Bool>, right : EBSelection <Bool>) -> EBSelection <Bool> {
  return combineBoolProperties (left: left, right: right, function: {$0 && $1})
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func || (left : EBSelection <Bool>, right : EBSelection <Bool>) -> EBSelection <Bool> {
  return combineBoolProperties (left: left, right: right, function: {$0 || $1})
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func ^ (left : EBSelection <Bool>, right : EBSelection <Bool>) -> EBSelection <Bool> {
  return combineBoolProperties (left: left, right: right, function: {$0 != $1})
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

prefix func ! (operand : EBSelection <Bool>) -> EBSelection <Bool> {
  switch operand {
  case .empty :
    return .empty
  case .multiple :
    return .multiple
  case .single (let v) :
    return .single (!v)
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    ReadOnlyAbstractGenericRelationshipProperty
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadOnlyAbstractGenericRelationshipProperty : EBAbstractProperty {

  //····················································································································
  //  Data clients
  //····················································································································

  private var mClients = Set <ReadOnlyAbstractGenericRelationshipProperty> ()

  //····················································································································

  final internal func attachClient (_ inClient : ReadOnlyAbstractGenericRelationshipProperty) {
    self.mClients.insert (inClient)
    inClient.notifyModelDidChange ()
  }

  //····················································································································

  final internal func detachClient (_ inClient : ReadOnlyAbstractGenericRelationshipProperty) {
    self.mClients.remove (inClient)
  }

  //····················································································································

  internal func notifyModelDidChange () {
    for client in self.mClients {
      client.notifyModelDidChange ()
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    ReadOnlyAbstractObjectProperty
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadOnlyAbstractObjectProperty <T : Hashable> : ReadOnlyAbstractGenericRelationshipProperty {

  //····················································································································
  // Abstract methods
  //····················································································································

  var prop : EBSelection < T? > { get { return .empty } }  // Abstract method

  //····················································································································

  var propval : T? { return nil } // Abstract method

  //····················································································································
  //  Internal value
  //····················································································································

  internal var mInternalValue : T? = nil {
    didSet {
      if self.mInternalValue != oldValue {
        if (self.mInternalValue == nil) != (oldValue == nil) {
          self.none_property.postEvent ()
        }
        self.postEvent ()
        self.notifyModelDidChangeFrom (oldValue: oldValue)
        self.notifyModelDidChange ()
      }
    }
  }

  //····················································································································

  internal func notifyModelDidChangeFrom (oldValue inOldValue : T?) {
  }

  //····················································································································
  //  none property
  //····················································································································

  final var none_property = EBTransientProperty_Bool ()

  final var none_property_selection : EBSelection <Bool> { return self.none_property.prop }

  //····················································································································
  //  init
  //····················································································································

  override init () {
    super.init ()
    self.none_property.mReadModelFunction = { [weak self] in
      if let me = self {
        switch me.prop {
        case .empty :
          return .single (false)
        case .multiple :
          return .multiple
        case .single :
          return .single (true)
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    ReadOnlyAbstractArrayProperty
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadOnlyAbstractArrayProperty <T : Hashable> : ReadOnlyAbstractGenericRelationshipProperty {

  //····················································································································
  // Abstract methods
  //····················································································································

  var prop : EBSelection < [T] > { get { return .empty } }  // Abstract method

  //····················································································································

  var propval : [T] { return [] } // Abstract method

  //····················································································································

  final var propset : Set <T> { return self.mInternalSetValue }

  //····················································································································
  //  Internal value
  //····················································································································

  var internalSetValue : Set <T> { return self.mInternalSetValue }

  private var mInternalSetValue = Set <T> () // Requires T to be hashable

  internal var mInternalArrayValue = [T] () {
    didSet {
      if self.mInternalArrayValue != oldValue {
        if self.mInternalArrayValue.count != oldValue.count {
          self.count_property.postEvent ()
        }
        self.postEvent ()
        self.notifyModelDidChangeFrom (oldValue: oldValue)
        self.notifyModelDidChange ()
        let newSet = Set (self.mInternalArrayValue)
        if self.mInternalSetValue != newSet {
          let oldSet = self.mInternalSetValue
          self.mInternalSetValue = newSet
          let removedSet = oldSet.subtracting (newSet)
          let addedSet = newSet.subtracting (oldSet)
          self.updateObservers (removedSet: removedSet, addedSet: addedSet)
        }
      }
    }
  }

  //····················································································································

  internal func notifyModelDidChangeFrom (oldValue inOldValue : [T]) {
  }

  //····················································································································

  internal func updateObservers (removedSet inRemovedSet : Set <T>, addedSet inAddedSet : Set <T>) {
  }

  //····················································································································
  //  count property
  //····················································································································

  final var count_property = EBTransientProperty_Int ()

  final var count_property_selection : EBSelection <Int> { return self.count_property.prop }

  //····················································································································
  //  init
  //····················································································································

  override init () {
    super.init ()
    self.count_property.mReadModelFunction = { [weak self] in
      if let me = self {
        switch me.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          return .single (v.count)
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Data extension: comparable
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension Data : Comparable {

  //····················································································································

  static public func < (_ left : Data, _ right : Data) -> Bool {
    var result = left.count < right.count
    if left.count == right.count {
      var idx = 0
      while (idx < right.count) && !result {
        result = left [idx] < right [idx]
        idx += 1
      }
    }
    return result
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   Protocol ValuePropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol ValuePropertyProtocol : Equatable {
  func ebHashValue () -> UInt32
  func convertToNSObject () -> NSObject
  static func convertFromNSObject (object : NSObject) -> Self
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBReadOnlyValueProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBReadOnlyValueProperty <T> : EBAbstractProperty where T : Equatable {

  //····················································································································

  var prop : EBSelection <T> { return .empty } // Abstract method

  //····················································································································
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBReadWriteValueProperty <T> (abstract class)
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBReadWriteValueProperty <T> : EBReadOnlyValueProperty <T> where T : Equatable {

  //····················································································································

  func setProp (_ value : T) { } // Abstract method

  //····················································································································

  func validateAndSetProp (_ candidateValue : T, windowForSheet inWindow:NSWindow?) -> Bool {
    return false
  } // Abstract method

  //····················································································································
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBPropertyValueProxy <T : ValuePropertyProtocol>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class EBPropertyValueProxy <T : ValuePropertyProtocol> : EBReadWriteValueProperty <T> {

  //····················································································································

  var mReadModelFunction : Optional < () -> EBSelection <T> > = nil
  var mWriteModelFunction : Optional < (T) -> Void > = nil
  var mValidateAndWriteModelFunction : Optional < (T, NSWindow?) -> Bool > = nil
  private var mCachedValue : EBSelection <T>? = nil

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      self.updateValueExplorer (possibleValue: self.mCachedValue)
    }
  }

  //····················································································································

  private func updateValueExplorer (possibleValue : EBSelection <T>?) {
    if let value = possibleValue {
      switch value {
      case .empty :
        self.mValueExplorer?.stringValue = "—"
      case .multiple :
        self.mValueExplorer?.stringValue = "—"
      case .single (let value) :
        self.mValueExplorer?.stringValue = "\(value)"
      }
    }else{
      self.mValueExplorer?.stringValue = "nil"
    }
  }

  //····················································································································

  override func postEvent () {
    if self.mCachedValue != nil {
      self.mCachedValue = nil
      if logEvents () {
        appendMessageString ("Proxy \(explorerIndexString (self.ebObjectIndex)) propagation\\n")
      }
      super.postEvent ()
    }else if logEvents () {
      appendMessageString ("Proxy \(explorerIndexString (self.ebObjectIndex)) nil\\n")
    }
  }

  //····················································································································

  override var prop : EBSelection <T> {
    if let unReadModelFunction = self.mReadModelFunction, self.mCachedValue == nil {
      self.mCachedValue = unReadModelFunction ()
      self.updateValueExplorer (possibleValue: self.mCachedValue)
    }
    if self.mCachedValue == nil {
      self.mCachedValue = .empty
    }
    return self.mCachedValue!
  }

  //····················································································································

  override func setProp (_ value : T) {
    self.mWriteModelFunction? (value)
  }

  //····················································································································

  override func validateAndSetProp (_ candidateValue : T,
                                    windowForSheet inWindow : NSWindow?) -> Bool {
    var result = false
    if let unwValidateAndWriteModelFunction = self.mValidateAndWriteModelFunction {
      result = unwValidateAndWriteModelFunction (candidateValue, inWindow)
    }
    return result
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBStoredValueProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBStoredValueProperty <T : ValuePropertyProtocol> : EBReadWriteValueProperty <T> {

  //····················································································································

  weak var ebUndoManager : UndoManager?  // SOULD BE WEAK
  var mSetterDelegate : Optional < (_ inValue : T) -> Void >

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      self.mValueExplorer?.stringValue = "\(mValue)"
    }
  }

  //····················································································································

  init (defaultValue inValue : T) {
    mValue = inValue
    mSetterDelegate = nil
    super.init ()
  }

 //····················································································································

  init (defaultValue inValue : T, setterDelegate inSetterDelegate : @escaping (_ inValue : T) -> Void) {
    mValue = inValue
    mSetterDelegate = inSetterDelegate
    super.init ()
  }

  //····················································································································

  private var mValue : T {
    didSet {
      if self.mValue != oldValue {
        self.mSetterDelegate? (mValue)
        self.mValueExplorer?.stringValue = "\(mValue)"
        self.ebUndoManager?.registerUndo (withTarget: self, selector: #selector(performUndo(_:)), object: oldValue.convertToNSObject ())
        if logEvents () {
          appendMessageString ("Property \(explorerIndexString (self.ebObjectIndex)) did change value to \(mValue)\\n")
        }
        self.postEvent ()
        self.clearSignatureCache ()
      }
    }
  }

  //····················································································································

  @objc func performUndo (_ oldValue : NSNumber) {
    self.mValue = T.convertFromNSObject (object: oldValue)
  }

  //····················································································································

  override var prop : EBSelection<T> { return .single (mValue) }

  //····················································································································

  var propval : T { return self.mValue }

  //····················································································································

  override func setProp (_ value : T) { self.mValue = value }

  //····················································································································

  var validationFunction : (T, T) -> EBValidationResult <T> = defaultValidationFunction

   //····················································································································

  override func validateAndSetProp (_ candidateValue : T,
                                    windowForSheet inWindow:NSWindow?) -> Bool {
    var result = true
    let validationResult = validationFunction (propval, candidateValue)
    switch validationResult {
    case EBValidationResult.ok (let validatedValue) :
      setProp (validatedValue)
    case EBValidationResult.rejectWithBeep :
      result = false
      __NSBeep ()
    case EBValidationResult.rejectWithAlert (let informativeText) :
      result = false
      let alert = NSAlert ()
      alert.messageText = "The value " + String (describing: candidateValue) + " is invalid."
      alert.informativeText = informativeText
      alert.addButton (withTitle: "Ok")
      alert.addButton (withTitle: "Discard Change")
      if let window = inWindow {
        alert.beginSheetModal (for: window) { (response : NSApplication.ModalResponse) in
          if response == .alertSecondButtonReturn { // Discard Change
            self.postEvent ()
          }
        }
      }else{
        alert.runModal ()
      }
    }
    return result
  }

  //····················································································································

  func storeIn (dictionary : NSMutableDictionary, forKey inKey : String) {
    dictionary.setValue (self.mValue.convertToNSObject (), forKey: inKey)
  }

  //····················································································································

  func readFrom (dictionary : NSDictionary, forKey inKey : String) {
    let possibleValue = dictionary.object (forKey: inKey)
    if let value = possibleValue as? NSObject {
      self.setProp (T.convertFromNSObject (object: value))
    }
  }

  //····················································································································
  //    SIGNATURE
  //····················································································································

  final private weak var mSignatureObserver : EBSignatureObserverProtocol? = nil // SOULD BE WEAK
  final private var mSignatureCache : UInt32? = nil

  //····················································································································

  final func setSignatureObserver (observer : EBSignatureObserverProtocol?) {
    self.mSignatureObserver = observer
  }

  //····················································································································

  final private func clearSignatureCache () {
    if self.mSignatureCache != nil {
      self.mSignatureCache = nil
      self.mSignatureObserver?.clearSignatureCache ()
    }
  }

  //····················································································································

  final func signature () -> UInt32 {
    let computedSignature : UInt32
    if let s = self.mSignatureCache {
      computedSignature = s
    }else{
      computedSignature = self.propval.ebHashValue ()
      self.mSignatureCache = computedSignature
    }
    return computedSignature
  }

  //····················································································································
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBPreferencesValueProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class EBPreferencesValueProperty <T : ValuePropertyProtocol> : EBStoredValueProperty <T> {

  //····················································································································

  private var mPreferenceKey : String

  //····················································································································

  init (defaultValue inValue : T, prefKey inPreferenceKey : String) {
    mPreferenceKey = inPreferenceKey
    super.init (defaultValue: inValue)
  //--- Read from preferences
    let possibleValue = UserDefaults.standard.object (forKey: inPreferenceKey)
    if let value = possibleValue as? NSObject {
      setProp (T.convertFromNSObject (object: value))
    }
  }

  //····················································································································

  override func postEvent () {
    UserDefaults.standard.set (self.propval.convertToNSObject (), forKey: self.mPreferenceKey)
    super.postEvent ()
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBTransientValueProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBTransientValueProperty <T> : EBReadOnlyValueProperty <T> where T : Equatable {

  //····················································································································

  private var mValueCache : EBSelection <T>? = nil
  var mReadModelFunction : Optional<() -> EBSelection <T> > = nil

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      if let valueCache = self.mValueCache {
        self.mValueExplorer?.stringValue = "\(valueCache)"
      }else{
        self.mValueExplorer?.stringValue = "nil"
      }
    }
  }

  //····················································································································

  override var prop : EBSelection <T> {
    if self.mValueCache == nil {
      if let unwrappedComputeFunction = self.mReadModelFunction {
        self.mValueCache = unwrappedComputeFunction ()
      }
      if self.mValueCache == nil {
        self.mValueCache = .empty
      }
      self.mValueExplorer?.stringValue = "\(self.mValueCache!)"
    }
    return self.mValueCache!
  }

  //····················································································································

  override func postEvent () {
    if self.mValueCache != nil {
      self.mValueCache = nil
      self.mValueExplorer?.stringValue = "nil"
      if logEvents () {
        appendMessageString ("Transient \(explorerIndexString (self.ebObjectIndex)) propagation\\n")
      }
      super.postEvent ()
    }else if logEvents () {
      appendMessageString ("Transient \(explorerIndexString (self.ebObjectIndex)) nil\\n")
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol EBEnumProtocol {
  var rawValue : Int { get }
  static func buildfromRawValue (rawValue : Int) -> Self?
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol EnumPropertyProtocol : ValuePropertyProtocol, EBEnumProtocol {
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBAbstractEnumProperty : EBAbstractProperty {
  func rawValue () -> Int? { return nil } // Abstract method
  func setFrom (rawValue : Int) {}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBReadOnlyEnumProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBReadOnlyEnumProperty <T : EBEnumProtocol> : EBAbstractEnumProperty where T : Equatable {

  var prop : EBSelection <T> { return .empty } // Abstract method

  //····················································································································

  override func rawValue () -> Int? {
    switch self.prop {
    case .empty, .multiple :
      return nil
    case .single (let v) :
      return v.rawValue
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBReadWriteEnumProperty <T> (abstract class)
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBReadWriteEnumProperty <T : EBEnumProtocol> : EBReadOnlyEnumProperty <T> where T : Equatable {

  //····················································································································

  func setProp (_ value : T) { } // Abstract method

  //····················································································································

  func validateAndSetProp (_ candidateValue : T, windowForSheet inWindow:NSWindow?) -> Bool {
    return false
  } // Abstract method

  //····················································································································

  override func setFrom (rawValue : Int) {
    if let v = T.buildfromRawValue (rawValue: rawValue) {
      self.setProp (v)
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBPropertyEnumProxy <T : ValuePropertyProtocol>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class EBPropertyEnumProxy <T : EnumPropertyProtocol> : EBReadWriteEnumProperty <T> {

  //····················································································································

  var mReadModelFunction : Optional < () -> EBSelection <T> > = nil
  var mWriteModelFunction : Optional < (T) -> Void > = nil
  var mValidateAndWriteModelFunction : Optional < (T, NSWindow?) -> Bool > = nil
  private var mCachedValue : EBSelection <T>? = nil

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      self.updateValueExplorer (possibleValue: self.mCachedValue)
    }
  }

  //····················································································································

  private func updateValueExplorer (possibleValue : EBSelection <T>?) {
    if let value = possibleValue {
      switch value {
      case .empty :
        self.mValueExplorer?.stringValue = "—"
      case .multiple :
        self.mValueExplorer?.stringValue = "—"
      case .single (let value) :
        self.mValueExplorer?.stringValue = "\(value)"
      }
    }else{
      self.mValueExplorer?.stringValue = "nil"
    }
  }

  //····················································································································

  override func postEvent () {
    if self.mCachedValue != nil {
      self.mCachedValue = nil
      if logEvents () {
        appendMessageString ("Proxy \(explorerIndexString (self.ebObjectIndex)) propagation\\n")
      }
      super.postEvent ()
    }else if logEvents () {
      appendMessageString ("Proxy \(explorerIndexString (self.ebObjectIndex)) nil\\n")
    }
  }

  //····················································································································

  override var prop : EBSelection <T> {
    if let unReadModelFunction = self.mReadModelFunction, self.mCachedValue == nil {
      self.mCachedValue = unReadModelFunction ()
      self.updateValueExplorer (possibleValue: self.mCachedValue)
    }
    if self.mCachedValue == nil {
      self.mCachedValue = .empty
    }
    return self.mCachedValue!
  }

  //····················································································································

  override func setProp (_ value : T) {
    if let unWriteModelFunction = self.mWriteModelFunction {
      unWriteModelFunction (value)
    }
  }

  //····················································································································

  override func validateAndSetProp (_ candidateValue : T,
                                    windowForSheet inWindow:NSWindow?) -> Bool {
    var result = false
    if let unwValidateAndWriteModelFunction = self.mValidateAndWriteModelFunction {
      result = unwValidateAndWriteModelFunction (candidateValue, inWindow)
    }
    return result
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBStoredEnumProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class EBStoredEnumProperty <T : EnumPropertyProtocol> : EBReadWriteEnumProperty <T> {

  //····················································································································

  weak var ebUndoManager : UndoManager? // SOULD BE WEAK
  fileprivate var mPreferenceKey : String?
  var mSetterDelegate : ((_ inValue : T) -> Void)?

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      self.mValueExplorer?.stringValue = "\(mValue)"
    }
  }

  //····················································································································

  init (defaultValue inValue : T) {
    mValue = inValue
    mPreferenceKey = nil
    mSetterDelegate = nil
    super.init ()
  }

  //····················································································································

  init (defaultValue inValue : T, prefKey inPreferenceKey : String) {
    mValue = inValue
    mPreferenceKey = inPreferenceKey
    mSetterDelegate = nil
    super.init ()
  //--- Read from preferences
    let possibleValue = UserDefaults.standard.object (forKey: inPreferenceKey)
    if let value = possibleValue as? NSObject {
      setProp (T.convertFromNSObject (object: value))
    }
  }

 //····················································································································

  init (defaultValue inValue : T, setterDelegate inSetterDelegate : @escaping (_ inValue : T) -> Void) {
    mValue = inValue
    mPreferenceKey = nil
    mSetterDelegate = inSetterDelegate
    super.init ()
  }

  //····················································································································

  private var mValue : T {
    didSet {
      if self.mValue != oldValue {
        self.mSetterDelegate? (self.mValue)
        if let prefKey = self.mPreferenceKey {
          UserDefaults.standard.set (mValue.convertToNSObject (), forKey:prefKey)
        }
        self.mValueExplorer?.stringValue = "\(mValue)"
        self.ebUndoManager?.registerUndo (withTarget:self, selector:#selector(performUndo(_:)), object: oldValue.convertToNSObject ())
        if logEvents () {
          appendMessageString ("Property \(explorerIndexString (self.ebObjectIndex)) did change value to \(mValue)\\n")
        }
        postEvent ()
        clearSignatureCache ()
      }
    }
  }

  //····················································································································

  @objc func performUndo (_ oldValue : NSNumber) {
    self.mValue = T.convertFromNSObject (object: oldValue)
  }

  //····················································································································

  override var prop : EBSelection<T> { return .single (mValue) }

  //····················································································································

  var propval : T { return self.mValue }

  //····················································································································

  override func setProp (_ value : T) { self.mValue = value }

  //····················································································································

  var validationFunction : (T, T) -> EBValidationResult <T> = defaultValidationFunction

  //····················································································································

  override func validateAndSetProp (_ candidateValue : T,
                                    windowForSheet inWindow:NSWindow?) -> Bool {
    var result = true
    let validationResult = validationFunction (propval, candidateValue)
    switch validationResult {
    case .ok (let validatedValue) :
      setProp (validatedValue)
    case .rejectWithBeep :
      result = false
      __NSBeep ()
    case .rejectWithAlert (let informativeText) :
      result = false
      let alert = NSAlert ()
      alert.messageText = "The value " + String (describing: candidateValue) + " is invalid."
      alert.informativeText = informativeText
      alert.addButton (withTitle: "Ok")
      alert.addButton (withTitle: "Discard Change")
      if let window = inWindow {
        alert.beginSheetModal (for:window) { (response : NSApplication.ModalResponse) in
          if response == .alertSecondButtonReturn { // Discard Change
            self.postEvent ()
          }
        }
      }else{
        alert.runModal ()
      }
    }
    return result
  }

  //····················································································································

  func storeIn (dictionary : NSMutableDictionary, forKey inKey : String) {
    dictionary.setValue (mValue.convertToNSObject (), forKey:inKey)
  }

  //····················································································································

  func readFrom (dictionary : NSDictionary, forKey inKey : String) {
    let possibleValue = dictionary.object (forKey:inKey)
    if let value = possibleValue as? NSObject {
      self.setProp (T.convertFromNSObject (object: value))
    }
  }

  //····················································································································
  //    SIGNATURE
  //····················································································································

  final private weak var mSignatureObserver : EBSignatureObserverProtocol? = nil // SOULD BE WEAK
  final private var mSignatureCache : UInt32? = nil

  //····················································································································

  final func setSignatureObserver (observer : EBSignatureObserverProtocol?) {
    self.mSignatureObserver = observer
  }

  //····················································································································

  final private func clearSignatureCache () {
    if self.mSignatureCache != nil {
      self.mSignatureCache = nil
      self.mSignatureObserver?.clearSignatureCache ()
    }
  }

  //····················································································································

  final func signature () -> UInt32 {
    let computedSignature : UInt32
    if let s = self.mSignatureCache {
      computedSignature = s
    }else{
      computedSignature = propval.ebHashValue ()
      self.mSignatureCache = computedSignature
    }
    return computedSignature
  }

  //····················································································································
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBTransientEnumProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBTransientEnumProperty <T : EBEnumProtocol> : EBReadOnlyEnumProperty <T> where T : Equatable {

  //····················································································································

  private var mValueCache : EBSelection <T>? = nil
  var mReadModelFunction : Optional<() -> EBSelection <T> > = nil

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      if let valueCache = self.mValueCache {
        self.mValueExplorer?.stringValue = "\(valueCache)"
      }else{
        self.mValueExplorer?.stringValue = "nil"
      }
    }
  }

  //····················································································································

  override var prop : EBSelection <T> {
    if self.mValueCache == nil {
      if let unwrappedComputeFunction = self.mReadModelFunction {
        self.mValueCache = unwrappedComputeFunction ()
      }
      if self.mValueCache == nil {
        self.mValueCache = .empty
      }
      self.mValueExplorer?.stringValue = "\(self.mValueCache!)"
    }
    return self.mValueCache!
  }

  //····················································································································

  override func postEvent () {
    if self.mValueCache != nil {
      self.mValueCache = nil
      self.mValueExplorer?.stringValue = "nil"
      if logEvents () {
        appendMessageString ("Transient \(explorerIndexString (self.ebObjectIndex)) propagation\\n")
      }
      super.postEvent ()
    }else if logEvents () {
      appendMessageString ("Transient \(explorerIndexString (self.ebObjectIndex)) nil\\n")
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension String : ValuePropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension String : ValuePropertyProtocol {

  //····················································································································

  func ebHashValue () -> UInt32 {
    let possibleData = self.data (using: String.Encoding.utf8)
    if let data = possibleData {
      return data.ebHashValue ()
    }else{
      return 0
    }
  }

  //····················································································································

  func convertToNSObject () -> NSObject {
    return self as NSObject
  }

  //····················································································································

  static func convertFromNSObject (object : NSObject) -> String {
    return object as! String
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension UInt32 : ValuePropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension UInt32 : ValuePropertyProtocol {

  //····················································································································

  func ebHashValue () -> UInt32 {
    return self
  }

  //····················································································································

  func convertToNSObject () -> NSObject {
    return NSNumber (value: self)
  }

  //····················································································································

  static func convertFromNSObject (object : NSObject) -> UInt32 {
    let number = object as! NSNumber
    return number.uint32Value
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension Int : ValuePropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension Int : ValuePropertyProtocol {

  //····················································································································

  func ebHashValue () -> UInt32 {
    var value = self.bigEndian
    let array = withUnsafeBytes (of: &value) { Array($0) }
    return array.ebHashValue ()
  }

  //····················································································································

  func convertToNSObject () -> NSObject {
    return NSNumber (value: self)
  }

  //····················································································································

  static func convertFromNSObject (object : NSObject) -> Int {
    let number = object as! NSNumber
    return number.intValue
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension Double : ValuePropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension Double : ValuePropertyProtocol {

  //····················································································································

  func ebHashValue () -> UInt32 {
    var value = self.bitPattern.bigEndian
    let array = withUnsafeBytes (of: &value) { Array($0) }
    return array.ebHashValue ()
  }

  //····················································································································

  func convertToNSObject () -> NSObject {
    return NSNumber (value: self)
  }

  //····················································································································

  static func convertFromNSObject (object : NSObject) -> Double {
    let number = object as! NSNumber
    return number.doubleValue
  }

  //····················································································································
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension Bool : ValuePropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension Bool : ValuePropertyProtocol {

  //····················································································································

  func ebHashValue () -> UInt32 {
    var crc : UInt32 = 0
    crc.accumulateUInt8 (self ? 1 : 0)
    return crc
  }

  //····················································································································

  func convertToNSObject () -> NSObject {
    return NSNumber (value: self)
  }

  //····················································································································

  static func convertFromNSObject (object : NSObject) -> Bool {
    let number = object as! NSNumber
    return number.boolValue
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

public func < (left:Bool, right:Bool) -> Bool {
  return !left && right
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

public func > (left:Bool, right:Bool) -> Bool {
  return left && !right
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension NSColor : ClassPropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension NSColor : ClassPropertyProtocol {

  //····················································································································

  final func ebHashValue () -> UInt32 {
    let s = self.archiveToString ()
    return s.ebHashValue ()
  }

  //····················································································································

  func archiveToString () -> String {
    let rgbColor = self.usingColorSpaceName (.calibratedRGB)!
    let red = rgbColor.redComponent
    let green = rgbColor.greenComponent
    let blue = rgbColor.blueComponent
    let alpha = rgbColor.alphaComponent
    let s = "\(red) \(green) \(blue) \(alpha)"
    return s
//    Swift.print ("Color : \(s)")
//    let data = NSMutableData ()
//    let archiver = NSKeyedArchiver (forWritingWith: data)
//    archiver.encode (self, forKey: NSKeyedArchiveRootObjectKey)
//    archiver.finishEncoding ()
//    return data as Data
  }

  //····················································································································

  static func unarchiveFromData (data : Data) -> NSObject? {
    return NSKeyedUnarchiver.unarchiveObject (with: data) as? NSColor
  }

  //····················································································································

  static func unarchiveFromString (string : String) -> NSObject? {
    let scanner = Scanner (string: string)
    var red = 0.0
    _ = scanner.scanDouble (&red)
    var green = 0.0
    _ = scanner.scanDouble (&green)
    var blue = 0.0
    _ = scanner.scanDouble (&blue)
    var alpha = 0.0
    _ = scanner.scanDouble (&alpha)
    return NSColor (calibratedRed: CGFloat (red), green: CGFloat (green), blue: CGFloat (blue), alpha: CGFloat (alpha))
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension Date : ValuePropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension Date : ValuePropertyProtocol {

  //····················································································································

  func ebHashValue () -> UInt32 {
    let data = NSMutableData ()
    let archiver = NSKeyedArchiver (forWritingWith: data)
    archiver.encode (self, forKey: NSKeyedArchiveRootObjectKey)
    archiver.finishEncoding ()
    return (data as Data).ebHashValue ()
  }

  //····················································································································

  func convertToNSObject () -> NSObject {
    return self as NSObject
//    let data = NSMutableData ()
//    let archiver = NSKeyedArchiver (forWritingWith: data)
//    archiver.encode (self, forKey: NSKeyedArchiveRootObjectKey)
//    archiver.finishEncoding ()
//    return data as NSObject
  }

  //····················································································································

  static func convertFromNSObject (object : NSObject) -> Date {
    return (object as? Date) ?? Date ()
 //   return NSKeyedUnarchiver.unarchiveObject (with: object as! Data) as! Date  }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension NSFont : ClassPropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension NSFont : ClassPropertyProtocol {

  //····················································································································

  final func ebHashValue () -> UInt32 {
    let s = self.archiveToString ()
    return s.ebHashValue ()
  }

  //····················································································································

  func archiveToString () -> String {
    let s = "\(self.fontName):\(self.pointSize)"
    // Swift.print ("Font '\(s)'")
    return s
  }

  //····················································································································

  static func unarchiveFromData (data : Data) -> NSObject? {
    return NSKeyedUnarchiver.unarchiveObject (with: data) as? NSFont
  }

  //····················································································································

  static func unarchiveFromString (string : String) -> NSObject? {
    let components = string.components (separatedBy: ":")
    if components.count == 2, let fontSize = Double (components [1]) {
      let fontName = components [0]
      return NSFont (name: fontName, size: CGFloat (CGFloat (fontSize)))
    }else{
      return nil
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension Data : ValuePropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension Data : ValuePropertyProtocol {

  //····················································································································

  func ebHashValue () -> UInt32 {
    var crc : UInt32 = 0
    for i in 0 ..< self.count {
      crc.accumulateUInt8 (self [i])
    }
    return crc
  }

  //····················································································································

  func convertToNSObject () -> NSObject {
    return self as NSObject
  }

  //····················································································································

  static func convertFromNSObject (object : NSObject) -> Data {
    return object as! Data
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    extension NSBezierPath : ClassPropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension NSBezierPath : ClassPropertyProtocol {

  //····················································································································

  final func ebHashValue () -> UInt32 {
    let s = self.archiveToString ()
    return s.ebHashValue ()
  }

  //····················································································································

  func archiveToString () -> String {
    var result = ""
    var idx = 0
    var points = [NSPoint] (repeating: .zero, count: 3)
    while idx < self.elementCount {
      let type = self.element (at: idx, associatedPoints: &points)
      idx += 1
      switch type {
      case .moveTo:
        result += ":\(points[0].x) \(points[0].y)"
      case .lineTo:
        result += ";\(points[0].x) \(points[0].y)"
      case .curveTo:
        result += "@\(points[0].x) \(points[0].y) \(points[1].x) \(points[1].y) \(points[2].x) \(points[2].y)"
      case .closePath:
        result += "#"
      @unknown default :
        ()
      }
    }
    result += "*\(self.windingRule.rawValue) \(self.lineCapStyle.rawValue) \(self.lineJoinStyle.rawValue)"
    result += " \(self.lineWidth) \(self.flatness) \(self.miterLimit)"
    return result
  }

  //····················································································································

  static func unarchiveFromData (data : Data) -> NSObject? {
    return NSKeyedUnarchiver.unarchiveObject (with: data) as? NSBezierPath
  }

  //····················································································································

  static func unarchiveFromString (string : String) -> NSObject? {
    let bp = NSBezierPath ()
    let scanner = Scanner (string: string)
    var ok = true
    var loop = true
    while ok && loop {
      if scanner.scanString (":", into: nil) {
        var x = 0.0
        ok = scanner.scanDouble (&x)
        var y = 0.0
        if ok {
          ok = scanner.scanDouble (&y)
        }
        if ok {
          bp.move (to: NSPoint (x: CGFloat (x), y: CGFloat (y)))
        }
      }else if scanner.scanString (";", into: nil) {
        var x = 0.0
        ok = scanner.scanDouble (&x)
        var y = 0.0
        if ok {
          ok = scanner.scanDouble (&y)
        }
        if ok {
          bp.line (to: NSPoint (x: CGFloat (x), y: CGFloat (y)))
        }
      }else if scanner.scanString ("@", into: nil) {
        var x0 = 0.0
        ok = scanner.scanDouble (&x0)
        var y0 = 0.0
        if ok {
          ok = scanner.scanDouble (&y0)
        }
        var x1 = 0.0
        if ok {
          ok = scanner.scanDouble (&x1)
        }
        var y1 = 0.0
        if ok {
          ok = scanner.scanDouble (&y1)
        }
        var x2 = 0.0
        if ok {
          ok = scanner.scanDouble (&x2)
        }
        var y2 = 0.0
        if ok {
          ok = scanner.scanDouble (&y2)
        }
        if ok {
          bp.curve (
            to: NSPoint (x: CGFloat (x2), y: CGFloat (y2)),
            controlPoint1: NSPoint (x: CGFloat (x0), y: CGFloat (y0)),
            controlPoint2: NSPoint (x: CGFloat (x1), y: CGFloat (y1))
          )
        }
      }else if scanner.scanString ("#", into: nil) {
        bp.close ()
      }else if scanner.scanString ("*", into: nil) {
        loop = false
      }
    }
    if ok {
      var windingRuleRawValue = 0
      ok = scanner.scanInt (&windingRuleRawValue)
      if ok, let windingRule = NSBezierPath.WindingRule (rawValue: UInt (windingRuleRawValue)) {
        bp.windingRule = windingRule
      }else{
        ok = false
      }
    }
    if ok {
      var lineCapStyleRawValue = 0
      ok = scanner.scanInt (&lineCapStyleRawValue)
      if ok, let lineCapStyle = NSBezierPath.LineCapStyle (rawValue: UInt (lineCapStyleRawValue)) {
        bp.lineCapStyle = lineCapStyle
      }else{
        ok = false
      }
    }
    if ok {
      var lineJoinStyleRawValue = 0
      ok = scanner.scanInt (&lineJoinStyleRawValue)
      if ok, let lineJoinStyle = NSBezierPath.LineJoinStyle (rawValue: UInt (lineJoinStyleRawValue)) {
        bp.lineJoinStyle = lineJoinStyle
      }else{
        ok = false
      }
    }
    if ok {
      var lineWidth = 0.0
      ok = scanner.scanDouble (&lineWidth)
      if ok {
        bp.lineWidth = CGFloat (lineWidth)
      }
    }
    if ok {
      var flatness = 0.0
      ok = scanner.scanDouble (&flatness)
      if ok {
        bp.flatness = CGFloat (flatness)
      }
    }
    if ok {
      var miterLimit = 0.0
      ok = scanner.scanDouble (&miterLimit)
      if ok {
        bp.miterLimit = CGFloat (miterLimit)
      }
    }
    // print ("ok: \(ok)")
    return bp
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    BezierPathArray
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct BezierPathArray : Hashable, Comparable, ValuePropertyProtocol {

  //····················································································································

  private var mPathes = [EBBezierPath] ()

  //····················································································································

  var array : [EBBezierPath] { return self.mPathes }

  //····················································································································

  mutating func append (_ inBP : EBBezierPath) {
    if !inBP.isEmpty {
      self.mPathes.append (inBP)
    }
  }

  //····················································································································

  mutating func append (_ inBezierPathArray : [EBBezierPath]) {
    for bp in inBezierPathArray {
      if !bp.isEmpty {
        self.mPathes.append (bp)
      }
    }
  }

   //····················································································································

  mutating func append (_ inBezierPathArray : BezierPathArray) {
    self.mPathes += inBezierPathArray.mPathes
  }

 //····················································································································

  var bounds : NSRect {
    var r = NSRect.null
    for path in self.mPathes {
      r = r.union (path.bounds)
    }
    return r
  }

  //····················································································································

  public static func == (lhs: BezierPathArray, rhs: BezierPathArray) -> Bool {
    var equal = lhs.mPathes.count == rhs.mPathes.count
    if equal {
      var idx = 0
      while idx < lhs.mPathes.count {
        if lhs.mPathes [idx] != rhs.mPathes [idx] {
          equal = false
          idx = lhs.mPathes.count // For exiting loop
        }
        idx += 1
      }
    }
    return equal
  }

  //····················································································································

  public static func < (lhs: BezierPathArray, rhs: BezierPathArray) -> Bool {
    var inferior = lhs.mPathes.count < rhs.mPathes.count
    if lhs.mPathes.count == rhs.mPathes.count {
      let leftData = NSMutableData ()
      let leftArchiver = NSKeyedArchiver (forWritingWith: leftData)
      leftArchiver.encode (self, forKey: NSKeyedArchiveRootObjectKey)
      leftArchiver.finishEncoding ()
      // let leftData  = NSKeyedArchiver.archivedData (withRootObject: lhs.mPathes)
      let rightData = NSMutableData ()
      let rightArchiver = NSKeyedArchiver (forWritingWith: rightData)
      rightArchiver.encode (self, forKey: NSKeyedArchiveRootObjectKey)
      rightArchiver.finishEncoding ()
      // let rightData = NSKeyedArchiver.archivedData (withRootObject: rhs.mPathes)
      inferior = (leftData as Data) < (rightData as Data)
    }
    return inferior
  }

  //····················································································································

  func ebHashValue () -> UInt32 {
    let data = NSMutableData ()
    let archiver = NSKeyedArchiver (forWritingWith: data)
    archiver.encode (self, forKey: NSKeyedArchiveRootObjectKey)
    archiver.finishEncoding ()
    return (data as Data).ebHashValue ()
  }

  //····················································································································

  func convertToNSObject () -> NSObject {
    let data = NSMutableData ()
    let archiver = NSKeyedArchiver (forWritingWith: data)
    var array = [NSBezierPath] ()
    for p in self.mPathes {
      array.append (p.nsBezierPath)
    }
    archiver.encode (array, forKey: NSKeyedArchiveRootObjectKey)
    archiver.finishEncoding ()
    return data
  }

  //····················································································································

  static func convertFromNSObject (object : NSObject) -> BezierPathArray {
    let array = NSKeyedUnarchiver.unarchiveObject (with: object as! Data) as! [NSBezierPath]
    var result = BezierPathArray ()
    for bp in array {
      result.append (EBBezierPath (bp))
    }
    return result
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   Protocol ClassPropertyProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol ClassPropertyProtocol : class, Equatable {
  func ebHashValue () -> UInt32
  func archiveToString () -> String
  static func unarchiveFromData (data : Data) -> NSObject?
  static func unarchiveFromString (string : String) -> NSObject?
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBReadOnlyClassProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBReadOnlyClassProperty <T> : EBAbstractProperty where T : Equatable {

  var prop : EBSelection <T> { return .empty } // Abstract method

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBReadWriteClassProperty <T> (abstract class)
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBReadWriteClassProperty <T> : EBReadOnlyClassProperty <T> where T : Equatable {
  func setProp (_ value : T) { } // Abstract method
  func validateAndSetProp (_ candidateValue : T, windowForSheet inWindow:NSWindow?) -> Bool {
    return false
  } // Abstract method
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBPropertyClassProxy <T : ClassPropertyProtocol>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class EBPropertyClassProxy <T : ClassPropertyProtocol> : EBReadWriteClassProperty <T> {

  //····················································································································

  var mReadModelFunction : Optional < () -> EBSelection <T> > = nil
  var mWriteModelFunction : Optional < (T) -> Void > = nil
  var mValidateAndWriteModelFunction : Optional < (T, NSWindow?) -> Bool > = nil
  private var mCachedValue : EBSelection <T>? = nil

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      self.updateValueExplorer (possibleValue: self.mCachedValue)
    }
  }

  //····················································································································

  private func updateValueExplorer (possibleValue : EBSelection <T>?) {
    if let value = possibleValue {
      switch value {
      case .empty :
        self.mValueExplorer?.stringValue = "—"
      case .multiple :
        self.mValueExplorer?.stringValue = "—"
      case .single (let value) :
        self.mValueExplorer?.stringValue = "\(value)"
      }
    }else{
      self.mValueExplorer?.stringValue = "nil"
    }
  }

  //····················································································································

  override func postEvent () {
    if self.mCachedValue != nil {
      self.mCachedValue = nil
      if logEvents () {
        appendMessageString ("Proxy \(explorerIndexString (self.ebObjectIndex)) propagation\\n")
      }
      super.postEvent ()
    }else if logEvents () {
      appendMessageString ("Proxy \(explorerIndexString (self.ebObjectIndex)) nil\\n")
    }
  }

  //····················································································································

  override var prop : EBSelection <T> {
    if let unReadModelFunction = self.mReadModelFunction, self.mCachedValue == nil {
      self.mCachedValue = unReadModelFunction ()
      self.updateValueExplorer (possibleValue: self.mCachedValue)
    }
    if self.mCachedValue == nil {
      self.mCachedValue = .empty
    }
    return self.mCachedValue!
  }

  //····················································································································

  override func setProp (_ value : T) {
    if let unWriteModelFunction = self.mWriteModelFunction {
      unWriteModelFunction (value)
    }
  }

  //····················································································································

  override func validateAndSetProp (_ candidateValue : T,
                                    windowForSheet inWindow:NSWindow?) -> Bool {
    var result = false
    if let unwValidateAndWriteModelFunction = self.mValidateAndWriteModelFunction {
      result = unwValidateAndWriteModelFunction (candidateValue, inWindow)
    }
    return result
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBStoredClassProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBStoredClassProperty <T : ClassPropertyProtocol> : EBReadWriteClassProperty <T> {
  weak var ebUndoManager : UndoManager? // SOULD BE WEAK
  var mSetterDelegate : ((_ inValue : T) -> Void)?

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      self.mValueExplorer?.stringValue = "\(mValue)"
    }
  }

  //····················································································································

  init (defaultValue inValue : T) {
    mValue = inValue
    mSetterDelegate = nil
    super.init ()
  }

   //····················································································································

  init (defaultValue inValue : T, setterDelegate inSetterDelegate : @escaping (_ inValue : T) -> Void) {
    mValue = inValue
    mSetterDelegate = inSetterDelegate
    super.init ()
  }

  //····················································································································

  private var mValue : T {
    didSet {
      if self.mValue != oldValue {
        self.mSetterDelegate? (self.mValue)
        self.mValueExplorer?.stringValue = "\(mValue)"
        self.ebUndoManager?.registerUndo (withTarget: self, selector: #selector (performUndo(_:)), object: oldValue)
        if logEvents () {
          appendMessageString ("Property \(explorerIndexString (self.ebObjectIndex)) did change value to \(mValue)\\n")
        }
        self.postEvent ()
        self.clearSignatureCache ()
      }
    }
  }

  //····················································································································

  @objc func performUndo (_ oldValue : NSObject) {
    self.mValue = oldValue as! T
  }

  //····················································································································

  override var prop : EBSelection<T> { return .single (mValue) }

  var propval : T { return self.mValue }

  override func setProp (_ value : T) { self.mValue = value }

  //····················································································································

  var validationFunction : (T, T) -> EBValidationResult <T> = defaultValidationFunction

  override func validateAndSetProp (_ candidateValue : T,
                                    windowForSheet inWindow : NSWindow?) -> Bool {
    var result = true
    let validationResult = validationFunction (propval, candidateValue)
    switch validationResult {
    case .ok (let validatedValue) :
      setProp (validatedValue)
    case .rejectWithBeep :
      result = false
      __NSBeep ()
    case .rejectWithAlert (let informativeText) :
      result = false
      let alert = NSAlert ()
      alert.messageText = "The value " + String (describing: candidateValue) + " is invalid."
      alert.informativeText = informativeText
      alert.addButton (withTitle: "Ok")
      alert.addButton (withTitle: "Discard Change")
      if let window = inWindow {
        alert.beginSheetModal (for:window) { (response : NSApplication.ModalResponse) in
          if response == .alertSecondButtonReturn { // Discard Change
            self.postEvent ()
          }
        }
      }else{
        alert.runModal ()
      }
    }
    return result
  }

  //····················································································································

  func storeIn (dictionary : NSMutableDictionary, forKey inKey : String) {
    dictionary.setValue (self.mValue.archiveToString (), forKey: inKey)
  }

  //····················································································································

  func readFrom (dictionary : NSDictionary, forKey inKey : String) {
    let possibleValue = dictionary.object (forKey: inKey)
    if let value = possibleValue as? Data, let unarchivedValue = T.unarchiveFromData (data: value) as? T {
      self.setProp (unarchivedValue)
    }else if let value = possibleValue as? String, let unarchivedValue = T.unarchiveFromString (string: value) as? T {
      self.setProp (unarchivedValue)
    }
  }

  //····················································································································
  //    SIGNATURE
  //····················································································································

  final private weak var mSignatureObserver : EBSignatureObserverProtocol? = nil // SOULD BE WEAK
  final private var mSignatureCache : UInt32? = nil

  //····················································································································

  final func setSignatureObserver (observer : EBSignatureObserverProtocol?) {
    self.mSignatureObserver = observer
  }

  //····················································································································

  final private func clearSignatureCache () {
    if self.mSignatureCache != nil {
      self.mSignatureCache = nil
      self.mSignatureObserver?.clearSignatureCache ()
    }
  }

  //····················································································································

  final func signature () -> UInt32 {
    let computedSignature : UInt32
    if let s = self.mSignatureCache {
      computedSignature = s
    }else{
      computedSignature = propval.ebHashValue ()
      self.mSignatureCache = computedSignature
    }
    return computedSignature
  }

  //····················································································································
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBPreferencesClassProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBPreferencesClassProperty <T : ClassPropertyProtocol> : EBStoredClassProperty <T> {

 //····················································································································

  private var mPreferenceKey : String

 //····················································································································

  init (defaultValue inValue : T, prefKey inPreferenceKey : String) {
    mPreferenceKey = inPreferenceKey
    super.init (defaultValue: inValue)
  //--- Read value from preferences
    let possibleValue = UserDefaults.standard.object (forKey: inPreferenceKey)
    if let value = possibleValue as? Data, let unarchivedValue = T.unarchiveFromData (data: value) as? T {
      self.setProp (unarchivedValue)
    }else if let value = possibleValue as? String, let unarchivedValue = T.unarchiveFromString (string: value) as? T {
      self.setProp (unarchivedValue)
    }
  }

  //····················································································································

  override func postEvent () {
    UserDefaults.standard.set (self.propval.archiveToString (), forKey: self.mPreferenceKey)
    super.postEvent ()
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBTransientClassProperty <T>
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBTransientClassProperty <T> : EBReadOnlyClassProperty <T> where T : Equatable {
  private var mValueCache : EBSelection <T>? = nil
  var mReadModelFunction : Optional<() -> EBSelection <T> > = nil

  //····················································································································

  var mValueExplorer : NSTextField? {
    didSet {
      if let valueCache = self.mValueCache {
        self.mValueExplorer?.stringValue = "\(valueCache)"
      }else{
        self.mValueExplorer?.stringValue = "nil"
      }
    }
  }

  //····················································································································

  override var prop : EBSelection <T> {
    if self.mValueCache == nil {
      if let unwrappedComputeFunction = self.mReadModelFunction {
        self.mValueCache = unwrappedComputeFunction ()
      }
      if self.mValueCache == nil {
        self.mValueCache = .empty
      }
      self.mValueExplorer?.stringValue = "\(mValueCache!)"
    }
    return self.mValueCache!
  }

  //····················································································································

  override func postEvent () {
    if self.mValueCache != nil {
      self.mValueCache = nil
      self.mValueExplorer?.stringValue = "nil"
      if logEvents () {
        let className = String (describing:type(of: self))
        appendMessageString ("Transient \(className) \(explorerIndexString (self.ebObjectIndex)) propagation\\n")
      }
      super.postEvent ()
    }else if logEvents () {
      let className = String (describing:type(of: self))
      appendMessageString ("Transient \(className) \(explorerIndexString (self.ebObjectIndex)) nil\\n")
    }
  }

  //····················································································································

}
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
