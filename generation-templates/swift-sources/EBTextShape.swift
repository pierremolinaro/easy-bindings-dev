//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBTextShape alignments
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum EBTextHorizontalAlignment {
  case left
  case center
  case right
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum EBTextVerticalAlignment {
  case above
  case center
  case below
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBTextShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBTextShape : EBShape {
//  private let mString : String
//  private let mOrigin : CGPoint
//  private let mTextAttributes : [NSAttributedString.Key : Any]
//  private let mSize : NSSize
  private let mFilledBezierPath : NSBezierPath
  private let mForeColor : NSColor
  private var mCachedBoundingBox : NSRect? = nil

  //····················································································································
  //  Init
  //····················································································································

  init (_ inString: String,
        _ inOrigin : CGPoint,
        _ inTextAttributes : [NSAttributedString.Key : Any],
        _ inHorizontalAlignment : EBTextHorizontalAlignment,
        _ inVerticalAlignment : EBTextVerticalAlignment) {
//    mString = "" // inString
//    mTextAttributes = inTextAttributes
//    mSize = inString.size (withAttributes: mTextAttributes)
    let size = inString.size (withAttributes: inTextAttributes)
    var p = inOrigin
    switch inHorizontalAlignment {
    case .left :
      ()
    case .center :
      p.x -= size.width / 2.0
    case .right :
      p.x -= size.width
    }
    switch inVerticalAlignment {
    case .above :
      ()
    case .center :
      p.y -= size.height / 2.0
    case .below :
      p.y -= size.height
    }
//    mOrigin = p
  //--- Bezier path
    mFilledBezierPath = inString.bezierPath (at: p, withAttributes: inTextAttributes)
  //--- Color
    if let c = inTextAttributes [NSAttributedString.Key.foregroundColor] as? NSColor {
      mForeColor = c
    }else{
      mForeColor = NSColor.black
    }
    super.init ()
//    self.append (EBFilledBezierPathShape ([bp], color))
  }

  //····················································································································

  private init (_ inBezierPath : NSBezierPath, _ inColor : NSColor) {
    mFilledBezierPath = inBezierPath
    mForeColor = inColor
    super.init ()
  }

  //····················································································································
  //  transformedBy
  //····················································································································

  override func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBShape {
    let result = EBTextShape (inAffineTransform.transform (self.mFilledBezierPath), self.mForeColor)
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    super.draw (inDirtyRect)
    self.mForeColor.setFill ()
    self.mFilledBezierPath.fill ()
 //   mString.draw (at: mOrigin, withAttributes: mTextAttributes)
  }

  //····················································································································
  // boundingBox
  //····················································································································

  override var boundingBox : NSRect {
    if let cbb = mCachedBoundingBox {
      return cbb
    }else{
      var r = super.boundingBox
//      let rText = NSRect (origin: mOrigin, size: mSize)
      r = r.union (self.mFilledBezierPath.bounds)
      self.mCachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  //   Contains point
  //····················································································································

  override func contains (point inPoint : NSPoint) -> Bool {
    var result = super.contains (point: inPoint)
    if !result {
//      let rText = NSRect (origin: mOrigin, size: mSize)
      result = self.mFilledBezierPath.bounds.contains (inPoint)
    }
    return result
  }

  //····················································································································
  //   intersects
  //····················································································································

  override func intersects (rect inRect : NSRect) -> Bool {
    var result = super.intersects (rect: inRect)
    if !result {
//      let rText = NSRect (origin: mOrigin, size: mSize)
      result = self.mFilledBezierPath.bounds.intersects (inRect)
    }
    return result
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  override public var hashValue : Int {
    var h = super.hashValue
    h.rotateLeft ()
    h ^= self.mFilledBezierPath.hashValue
    h.rotateLeft ()
    h ^= self.mForeColor.hashValue
//    h.rotateLeft ()
//    h ^= mOrigin.y.hashValue
    return h
  }

  //····················································································································
  //   isEqualTo
  //····················································································································

  override func isEqualTo (_ inOperand : EBShape) -> Bool {
    var equal = false
    if let operand = inOperand as? EBTextShape {
      equal = self.mFilledBezierPath == operand.mFilledBezierPath
      if equal {
        equal = self.mForeColor == operand.mForeColor
      }
    }
    return equal
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension String {

  //····················································································································

  func bezierPath (at inOrigin : NSPoint,
                   withAttributes inTextAttributes : [NSAttributedString.Key : Any]) -> NSBezierPath {
  //--- Font
    let font : NSFont
    if let f = inTextAttributes [NSAttributedString.Key.font] as? NSFont {
      font = f
    }else{
      font = NSFont ()
    }
  //--- Build text infrastructure
    let textStore = NSTextStorage (string: self, attributes: inTextAttributes)
    let textContainer = NSTextContainer ()
    let myLayout = NSLayoutManager ()
    myLayout.addTextContainer (textContainer)
    textStore.addLayoutManager (myLayout)
  //--- Get CCGlyph array
    let glyphRange : NSRange = myLayout.glyphRange (for: textContainer)
    var cgGlyphArray = [CGGlyph] (repeating: CGGlyph (), count:glyphRange.length)
    _ = myLayout.getGlyphs (in: glyphRange, glyphs: &cgGlyphArray, properties: nil, characterIndexes: nil, bidiLevels: nil)
  //--- Transform in NSGlyph array
    var nsGlyphArray = [NSGlyph] ()
    for cgGlyph in cgGlyphArray {
      nsGlyphArray.append (NSGlyph (cgGlyph))
    }

 //   let s = self.size (withAttributes: inTextAttributes)
//    NSLog ("as \(font.ascender), de \(font.descender), le \(font.leading), xh \(font.xHeight), cp \(font.capHeight), ps \(font.pointSize)")
//    NSLog ("\(font.boundingRectForFont)")
//    NSLog ("\(myLayout.usedRect(for: textContainer))")
  //--- Enter in Bezier path
    let bezier = NSBezierPath ()
    bezier.move (to: NSPoint (x: inOrigin.x, y: inOrigin.y - 2.0 * font.descender))
    bezier.appendGlyphs (&nsGlyphArray, count: glyphRange.length, in: font)
//    NSLog ("bounds \(bezier.bounds)")
    return bezier
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
