//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBTextShape alignments
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum EBTextHorizontalAlignment {
  case onTheRight
  case center
  case onTheLeft
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum EBTextVerticalAlignment {
  case above
  case center
  case below
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBTextShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBTextShape : EBShape {
  private let mFilledBezierPath : NSBezierPath
  private let mForeColor : NSColor
  private let mBackColor : NSColor?

  //····················································································································
  //  Init
  //····················································································································

  init (_ inString: String,
        _ inOrigin : CGPoint,
        _ inTextAttributes : [NSAttributedString.Key : Any],
        _ inHorizontalAlignment : EBTextHorizontalAlignment,
        _ inVerticalAlignment : EBTextVerticalAlignment) {
  //--- Forecolor
    if let c = inTextAttributes [NSAttributedString.Key.foregroundColor] as? NSColor {
      mForeColor = c
    }else{
      mForeColor = .black
    }
  //--- Back Color
    if let c = inTextAttributes [NSAttributedString.Key.backgroundColor] as? NSColor {
      mBackColor = c
    }else{
      mBackColor = nil
    }
  //--- Transform text into filled bezier path
    if inString == "" {
      mFilledBezierPath = NSBezierPath ()
    }else{
      let filledBezierPath = inString.bezierPath (at: inOrigin, withAttributes: inTextAttributes)
      let width = filledBezierPath.bounds.width
      let height = filledBezierPath.bounds.height
      var deltaX : CGFloat = inOrigin.x - filledBezierPath.bounds.origin.x
      switch inHorizontalAlignment {
      case .onTheRight :
        ()
      case .center :
        deltaX -= width / 2.0
      case .onTheLeft :
        deltaX -= width
      }
      var deltaY : CGFloat = inOrigin.y - filledBezierPath.bounds.origin.y
      switch inVerticalAlignment {
      case .above :
        ()
      case .center :
        deltaY -= height / 2.0
      case .below :
        deltaY -= height
      }
      let af = NSAffineTransform ()
      af.translateX (by: deltaX, yBy: deltaY)
      mFilledBezierPath = af.transform (filledBezierPath)
    }
    super.init ()
  }

  //····················································································································

  private init (_ inBezierPath : NSBezierPath, _ inForeColor : NSColor, _ inBackColor : NSColor?) {
    mFilledBezierPath = inBezierPath
    mForeColor = inForeColor
    mBackColor = inBackColor
    super.init ()
  }

  //····················································································································
  //  transformedBy
  //····················································································································

  override func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBTextShape {
    let result = EBTextShape (inAffineTransform.transform (self.mFilledBezierPath), self.mForeColor, self.mBackColor)
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inView : NSView, _ inDirtyRect: NSRect) {
    super.draw (inView, inDirtyRect)
    if inView.needsToDraw (self.mFilledBezierPath.bounds) {
      if let backColor = self.mBackColor {
        backColor.setFill ()
        NSBezierPath.fill (self.mFilledBezierPath.bounds)
      }
      self.mForeColor.setFill ()
      self.mFilledBezierPath.fill ()
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  override internal func internalBoundingBox () -> NSRect {
    return self.mFilledBezierPath.isEmpty ? .null : self.mFilledBezierPath.bounds
  }

  //····················································································································
  //   Contains point
  //····················································································································

  override func contains (point inPoint : NSPoint) -> Bool {
    var result = super.contains (point: inPoint)
    if !result {
      result = self.mFilledBezierPath.bounds.contains (inPoint)
    }
    return result
  }

  //····················································································································
  //   intersects
  //····················································································································

  override func intersects (rect inRect : NSRect) -> Bool {
    var result = super.intersects (rect: inRect)
    if !result {
      result = self.mFilledBezierPath.bounds.intersects (inRect)
    }
    return result
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  override func hash (into hasher: inout Hasher) {
    super.hash (into: &hasher)
    self.mFilledBezierPath.hash (into: &hasher)
    self.mForeColor.hash (into: &hasher)
    self.mBackColor.hash (into: &hasher)
  }

  //····················································································································
  //   isEqualToShape
  //····················································································································

  override func isEqualToShape (_ inOperand : EBShape) -> Bool {
    var equal = false
    if let operand = inOperand as? EBTextShape {
      equal = self.mFilledBezierPath == operand.mFilledBezierPath
      if equal {
        equal = self.mForeColor == operand.mForeColor
      }
      if equal {
        equal = self.mBackColor == operand.mBackColor
      }
      if equal {
        equal = super.isEqualToShape (operand)
      }
    }
    return equal
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
