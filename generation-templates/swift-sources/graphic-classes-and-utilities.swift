//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  EBGraphicManagedObject
//  dynamic before func is required in order to make functions overriden in extensions
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBGraphicManagedObject : EBManagedObject {

  //····················································································································

  var selectionLayer_property = EBTransientProperty_CALayer ()

  //····················································································································

  dynamic func acceptedTranslation (by inValue: CGPoint) -> CGPoint {
    return inValue
  }

  //····················································································································

  dynamic func acceptToTranslate (xBy inDx: CGFloat, yBy inDy: CGFloat) -> Bool {
    return false
  }

  //····················································································································

  dynamic func translate (xBy inDx: CGFloat, yBy inDy: CGFloat) {
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    StrokeOrFill
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum StrokeOrFill : Int {
  case stroke
  case fill
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShapes
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBShapes : Hashable, EBUserClassNameProtocol {

  //····················································································································
  //  Properties
  //····················································································································

  private var paths : [([NSBezierPath], NSColor, StrokeOrFill)]
  private var cachedBoundingBox : NSRect?

  //····················································································································
  //  init
  //····················································································································

  init () {
    paths = []
    cachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································

  init (_ inPaths : [([NSBezierPath], NSColor, StrokeOrFill)]) {
    paths = inPaths
    cachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································

  init (_ inBezierPaths : [NSBezierPath], _ inColor : NSColor, _ inOperation : StrokeOrFill) {
    paths = []
    cachedBoundingBox = nil
    noteObjectAllocation (self)
    self.paths.append ((inBezierPaths, inColor, inOperation))
  }

  //····················································································································
  //  deinit
  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  append
  //····················································································································

  func append (_ inBezierPaths : [NSBezierPath], _ inColor : NSColor, _ inOperation : StrokeOrFill) {
    self.paths.append ((inBezierPaths, inColor, inOperation))
    self.cachedBoundingBox = nil
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  func draw (_ dirtyRect: NSRect) {
    for (paths, color, operation) in self.paths {
      switch operation {
      case .stroke :
        color.setStroke ()
        for bp in paths {
          bp.stroke ()
        }
      case .fill :
        color.setFill ()
        for bp in paths {
          bp.fill ()
        }
      }
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  var boundingBox : NSRect {
    if let cbb = cachedBoundingBox {
      return cbb
    }else{
      var r = NSZeroRect
      for (bps, _, operation) in self.paths {
        switch operation {
        case .fill :
          for bp in bps {
            r = r.union (bp.bounds)
          }
        case .stroke :
          for bp in bps {
            let lineWidth = max (bp.lineWidth, 1.0)
            r = r.union (bp.bounds.insetBy (dx: -lineWidth, dy: -lineWidth))
          }
        }
      }
      self.cachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  //   intersects
  //····················································································································

  func intersects (_ inRect : NSRect) -> Bool {
    return self.boundingBox.intersects (inRect)
  }

  //····················································································································
  /// Returns a Boolean value indicating whether two values are equal.
  ///
  /// Equality is the inverse of inequality. For any values `a` and `b`,
  /// `a == b` implies that `a != b` is `false`.
  ///
  /// - Parameters:
  ///   - lhs: A value to compare.
  ///   - rhs: Another value to compare.
  //····················································································································

  public static func == (lhs: EBShapes, rhs: EBShapes) -> Bool {
    var equal = lhs.paths.count == rhs.paths.count
    if equal {
      var idx = 0
      while idx < lhs.paths.count {
        equal = (lhs.paths [idx].0.count == rhs.paths [idx].0.count) && (lhs.paths [idx].1 == rhs.paths [idx].1) && (lhs.paths [idx].2 == rhs.paths [idx].2)
        if equal {
          var idy = 0
          while idy < lhs.paths [idx].0.count {
            equal = lhs.paths [idx].0 [idy] == rhs.paths [idx].0 [idy]
            if !equal {
              break
            }
            idy += 1
          }
        }
        if !equal {
          break
        }
        idx += 1
      }
    }
    return equal
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  public var hashValue : Int {
    var h = 0
    for (bps, color, op) in self.paths {
      h ^= color.hashValue ^ op.rawValue.hashValue
      for pb in bps {
        h ^= pb.hashValue
      }
    }
    return h
  }


  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   Build PDF image
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func buildPDFimage (frame inFrame: CGRect,
                    shapes inShapes: EBShapes,
                    backgroundColor inBackColor : NSColor? = nil) -> Data {
  let view = EBOffscreenView (frame: inFrame)
  view.setBackColor (inBackColor)
  view.setPaths (inShapes)
  return view.dataWithPDF (inside: inFrame)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBOffscreenView
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate final class EBOffscreenView : NSView, EBUserClassNameProtocol {

  private var mShapes = EBShapes ()
  private var mBackColor : NSColor? = nil

  //····················································································································

  override init (frame frameRect: NSRect) {
    super.init (frame: frameRect)
    noteObjectAllocation (self)
  }

  //····················································································································

  required init? (coder: NSCoder) {
    super.init (coder: coder)
    noteObjectAllocation (self)
  }

  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  Set paths
  //····················································································································

  func setPaths (_ inShapes : EBShapes) {
    self.mShapes = inShapes
  }

  //····················································································································
  //  Set back color
  //····················································································································

  func setBackColor (_ inColor : NSColor?) {
    self.mBackColor = inColor
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ dirtyRect: NSRect) {
    if let backColor = mBackColor {
      backColor.setFill ()
      NSRectFill (dirtyRect)
    }
  //--- Bezier paths
    self.mShapes.draw (dirtyRect)
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShapeLayer
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct EBShapeLayer : Hashable {

  //····················································································································
  //   Properties
  //····················································································································

  private let mShapes : EBShapes
  private let mTransform : NSAffineTransform
  var userIndex = -1
  var userSecondaryIndex = -1

  //····················································································································
  //   Init
  //····················································································································

  init (_ inShapes : EBShapes, transform inTransform : NSAffineTransform = NSAffineTransform ()) {
    mShapes = inShapes
    mTransform = inTransform
  }

  //····················································································································
  // Equatable protocol
  //····················································································································

  public static func == (lhs: EBShapeLayer, rhs: EBShapeLayer) -> Bool {
    return (lhs.userIndex == rhs.userIndex)
      && (lhs.userSecondaryIndex == rhs.userSecondaryIndex)
      && (lhs.mShapes == rhs.mShapes)
      && (lhs.mTransform == rhs.mTransform)
  }

  //····················································································································
  // Hashable protocol
  //····················································································································

  public var hashValue: Int {
    var h = self.userIndex
    h ^= self.userSecondaryIndex
    h ^= self.mTransform.hashValue
    h ^= self.mShapes.hashValue
    return h
  }

  //····················································································································
  // boundingBox
  //····················································································································

  var boundingBox : NSRect {
    let r = self.mShapes.boundingBox
    let bottomLeft = self.mTransform.transform (r.origin)
    let bottomRight = self.mTransform.transform (NSPoint (x:r.maxX, y:r.minY))
    let topRight = self.mTransform.transform (NSPoint (x:r.maxX, y:r.maxY))
    let topLeft = self.mTransform.transform (NSPoint (x:r.minX, y:r.maxY))
    let minX = min (bottomRight.x, bottomLeft.x, topRight.x, topLeft.x)
    let maxX = max (bottomRight.x, bottomLeft.x, topRight.x, topLeft.x)
    let minY = min (bottomRight.y, bottomLeft.y, topRight.y, topLeft.y)
    let maxY = max (bottomRight.y, bottomLeft.y, topRight.y, topLeft.y)
    return NSRect (x: minX, y: minY, width: maxX - minX, height: maxY - minY)
  }
  
  //····················································································································
  // draw
  //····················································································································

  func draw (_ inDirtyRect: NSRect) {
    if self.boundingBox.intersects (inDirtyRect) {
      self.mTransform.concat ()
      self.mShapes.draw (inDirtyRect)
      let at = self.mTransform.copy () as! NSAffineTransform
      at.invert ()
      at.concat ()
    }
  }

  //····················································································································

  func sameDisplay (as inObject : EBShapeLayer) -> Bool {
    return (self.mTransform == inObject.mTransform) && (self.mShapes == inObject.mShapes)
  }

  //····················································································································
  //   intersects
  //····················································································································

  func intersects (_ inRect : NSRect) -> Bool {
    return self.boundingBox.intersects (inRect)
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShapeLayerArray
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct EBShapeLayerArray : Hashable {

  //····················································································································
  //   Properties
  //····················································································································

  let objects : [EBShapeLayer]

  //····················································································································
  //   Init
  //····················································································································

  init (_ inObjects : [EBShapeLayer]) {
    objects = inObjects
  }

  //····················································································································
  // Equatable protocol
  //····················································································································

  public static func == (lhs: EBShapeLayerArray, rhs: EBShapeLayerArray) -> Bool {
    if lhs.objects.count != rhs.objects.count {
      return false
    }else{
      var idx = 0
      while idx < lhs.objects.count {
        if lhs.objects [idx] != rhs.objects [idx] {
          return false
        }
        idx += 1
      }
      return true
    }
  }

  //····················································································································
  // Hashable protocol
  //····················································································································

  public var hashValue: Int {
    var h = 0
    for object in objects {
      h ^= object.hashValue
    }
    return h
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————






















//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EXTENSION CALayer: findLayer (at inPoint : CGPoint) -> CALayer?
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension CALayer {

  //····················································································································

  func findLayer (at inPoint : CGPoint) -> CALayer? {
    if self.isOpaque && self.frame.contains (inPoint) {
      return self
    }else{
      for layer in (self.sublayers ?? []).reversed () {
        let possibleResult = layer.findLayer (at: inPoint)
        if let result = possibleResult {
          if (result.name == nil) && (self.name != nil) {
            return self
          }else{
            return result
          }
        }
      }
      return nil
    }
  }

  //····················································································································
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension CAShapeLayer {

  //····················································································································

  override func findLayer (at inPoint : CGPoint) -> CALayer? {
    var r = super.findLayer (at: inPoint)
  //--- Test in filled path
    if let path = self.path, r == nil, self.fillColor != nil, path.contains (inPoint) {
      r = self
    }
  //--- Test in stroke path
    if let path = self.path, r == nil, self.strokeColor != nil, self.lineWidth > 0.0 {
      let possibleStrokePath = CGPath (
        __byStroking: path,
        transform:nil,
        lineWidth: self.lineWidth,
        lineCap: .round,
        lineJoin: .round,
        miterLimit: self.miterLimit
      )
      if let strokePath = possibleStrokePath, strokePath.contains (inPoint) {
        r = self
      }
    }
  //---
    return r
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EXTENSION CALayer: findIndexesOfObjects (intersecting inRect : CGRect)
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension CALayer {

  //····················································································································

  func findIndexesOfObjects (intersecting inRect : CGRect) -> Set <Int> {
     var result = Set <Int> ()
     if let name = self.name, let idx = Int (name) {
       var intersect = self.intersects (inRect)
       if !intersect {
         for layer in self.sublayers ?? [] {
           if layer.intersects (inRect) {
             intersect = true
             break
           }
         }
       }
       if intersect {
         result.insert (idx)
       }
     }else{
       for layer in self.sublayers ?? [] {
         let r = layer.findIndexesOfObjects (intersecting: inRect)
         result.formUnion (r)
       }
     }
     return result
  }

  //····················································································································

  func intersects (_ inRect : CGRect) -> Bool {
    return self.isOpaque && self.frame.intersects (inRect)
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension CAShapeLayer {

  //····················································································································

  override func intersects (_ inRect : CGRect) -> Bool {
    if let boundingBox = self.path?.boundingBox {
      return inRect.intersects (boundingBox)
    }else{
      return super.intersects (inRect)
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

