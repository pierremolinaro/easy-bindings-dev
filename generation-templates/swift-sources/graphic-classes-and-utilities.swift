//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  EBGraphicManagedObject
//  dynamic before func is required in order to make functions overriden in extensions
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBGraphicManagedObject : EBManagedObject {

  //····················································································································

  var selectionLayer_property = EBTransientProperty_EBShape ()

  //····················································································································

  @objc dynamic func acceptedTranslation (by inValue: CGPoint) -> CGPoint {
    return inValue
  }

  //····················································································································

  @objc dynamic func acceptToTranslate (xBy inDx: CGFloat, yBy inDy: CGFloat) -> Bool {
    return false
  }

  //····················································································································

  @objc dynamic func translate (xBy inDx: CGFloat, yBy inDy: CGFloat) {
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBShape : Hashable, EBUserClassNameProtocol {

  //····················································································································
  //  Properties
  //····················································································································

  private var shapes : [EBShape]
  private var cachedBoundingBox : NSRect?

  //····················································································································
  //  init
  //····················································································································

  init () {
    shapes = []
    cachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································

  init (shape inShape : EBShape) {
    shapes = [inShape]
    cachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································

  init (shapes inShapes : [EBShape]) {
    shapes = inShapes
    cachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································
  //  deinit
  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  append
  //····················································································································

  func append (shape inShape : EBShape) {
    self.shapes.append (inShape)
    self.cachedBoundingBox = nil
  }

  //····················································································································
  //  +=
  //····················································································································

  func append (shapes inShapes : [EBShape]) {
    self.shapes += inShapes
    self.cachedBoundingBox = nil
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  func draw (_ inDirtyRect: NSRect) {
    for shape in self.shapes {
      shape.draw (inDirtyRect)
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  var boundingBox : NSRect {
    if let cbb = cachedBoundingBox {
      return cbb
    }else{
      var r = NSZeroRect
      for shape in self.shapes {
        r = r.union (shape.boundingBox)
      }
      self.cachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  //   intersects
  //····················································································································

  func intersects (_ inRect : NSRect) -> Bool {
    return self.boundingBox.intersects (inRect)
  }

  //····················································································································
  /// Returns a Boolean value indicating whether two values are equal.
  ///
  /// Equality is the inverse of inequality. For any values `a` and `b`,
  /// `a == b` implies that `a != b` is `false`.
  ///
  /// - Parameters:
  ///   - lhs: A value to compare.
  ///   - rhs: Another value to compare.
  //····················································································································

  public static func == (lhs: EBShape, rhs: EBShape) -> Bool {
    var equal = lhs.shapes.count == rhs.shapes.count
    if equal {
      var idx = 0
      while idx < lhs.shapes.count {
        equal = lhs.shapes [idx] == rhs.shapes [idx]
        if !equal {
          break
        }
        idx += 1
      }
    }
    return equal
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  public var hashValue : Int {
    var h = 0
    for shape in self.shapes {
      h ^= shape.hashValue
    }
    return h
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBStrokeBezierPathShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBStrokeBezierPathShape : EBShape {
  private var paths : [NSBezierPath]
  private let color : NSColor
  private var cachedBoundingBox : NSRect?

  //····················································································································
  //  Init
  //····················································································································

  init (_ inPaths: [NSBezierPath], _ inColor: NSColor) {
    paths = inPaths
    color = inColor
    super.init ()
  }

  //····················································································································
  //  append
  //····················································································································

  func append (path inBezierPath : NSBezierPath) {
    self.paths.append (inBezierPath)
    self.cachedBoundingBox = nil
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    self.color.setStroke ()
    for bp in self.paths {
      bp.stroke ()
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  override var boundingBox : NSRect {
    if let cbb = cachedBoundingBox {
      return cbb
    }else{
      var r = super.boundingBox
      for bp in self.paths {
        let lineWidth = max (bp.lineWidth, 1.0)
        r = r.union (bp.bounds.insetBy (dx: -lineWidth, dy: -lineWidth))
      }
      self.cachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  /// Returns a Boolean value indicating whether two values are equal.
  ///
  /// Equality is the inverse of inequality. For any values `a` and `b`,
  /// `a == b` implies that `a != b` is `false`.
  ///
  /// - Parameters:
  ///   - lhs: A value to compare.
  ///   - rhs: Another value to compare.
  //····················································································································

  public static func == (lhs: EBStrokeBezierPathShape, rhs: EBStrokeBezierPathShape) -> Bool {
    var equal = true // lhs super.== rhs
    if equal {
      equal = lhs.paths.count == rhs.paths.count
    }
    if equal {
      var idx = 0
      while idx < lhs.paths.count {
        equal = lhs.paths [idx] == rhs.paths [idx]
        if !equal {
          break
        }
        idx += 1
      }
    }
    return equal
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  override public var hashValue : Int {
    var h = super.hashValue
    h ^= color.hashValue
    for path in self.paths {
      h ^= path.hashValue
    }
    return h
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBFilledBezierPathShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBFilledBezierPathShape : EBShape {
  private var paths : [NSBezierPath]
  private let color : NSColor
  private var cachedBoundingBox : NSRect?

  //····················································································································
  //  Init
  //····················································································································

  init (_ inPaths: [NSBezierPath], _ inColor: NSColor) {
    paths = inPaths
    color = inColor
    super.init ()
  }

  //····················································································································
  //  append
  //····················································································································

  func append (_ inBezierPath : NSBezierPath) {
    self.paths.append (inBezierPath)
    self.cachedBoundingBox = nil
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    self.color.setFill ()
    for bp in self.paths {
      bp.fill ()
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  override var boundingBox : NSRect {
    if let cbb = cachedBoundingBox {
      return cbb
    }else{
      var r = super.boundingBox
      for bp in self.paths {
        r = r.union (bp.bounds)
      }
      self.cachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  override public var hashValue : Int {
    var h = super.hashValue
    h ^= color.hashValue
    for path in self.paths {
      h ^= path.hashValue
    }
    return h
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   Build PDF image
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func buildPDFimage (frame inFrame: CGRect,
                    shapes inShapes: EBShape,
                    backgroundColor inBackColor : NSColor? = nil) -> Data {
  let view = EBOffscreenView (frame: inFrame)
  view.setBackColor (inBackColor)
  view.setPaths (inShapes)
  return view.dataWithPDF (inside: inFrame)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBOffscreenView
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate final class EBOffscreenView : NSView, EBUserClassNameProtocol {

  private var mShapes = EBShape ()
  private var mBackColor : NSColor? = nil

  //····················································································································

  override init (frame frameRect: NSRect) {
    super.init (frame: frameRect)
    noteObjectAllocation (self)
  }

  //····················································································································

  required init? (coder: NSCoder) {
    super.init (coder: coder)
    noteObjectAllocation (self)
  }

  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  Set paths
  //····················································································································

  func setPaths (_ inShapes : EBShape) {
    self.mShapes = inShapes
  }

  //····················································································································
  //  Set back color
  //····················································································································

  func setBackColor (_ inColor : NSColor?) {
    self.mBackColor = inColor
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    if let backColor = mBackColor {
      backColor.setFill ()
      #if swift(>=4)
        __NSRectFill (inDirtyRect)
      #else
        NSRectFill (inDirtyRect)
      #endif
    }
  //--- Bezier paths
    self.mShapes.draw (inDirtyRect)
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShapeLayer
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct EBShapeLayer : Hashable {

  //····················································································································
  //   Properties
  //····················································································································

  private let mShapes : EBShape
  private let mTransform : NSAffineTransform
  var userIndex = -1
  var userSecondaryIndex = -1

  //····················································································································
  //   Init
  //····················································································································

  init () {
    mShapes = EBShape ()
    mTransform = NSAffineTransform ()
  }

  //····················································································································

  init (_ inShapes: EBShape, transform inTransform: NSAffineTransform = NSAffineTransform ()) {
    mShapes = inShapes
    mTransform = inTransform
  }

  //····················································································································
  // Equatable protocol
  //····················································································································

  public static func == (lhs: EBShapeLayer, rhs: EBShapeLayer) -> Bool {
    return (lhs.userIndex == rhs.userIndex)
      && (lhs.userSecondaryIndex == rhs.userSecondaryIndex)
      && (lhs.mShapes == rhs.mShapes)
      && (lhs.mTransform == rhs.mTransform)
  }

  //····················································································································
  // Hashable protocol
  //····················································································································

  public var hashValue: Int {
    var h = self.userIndex
    h ^= self.userSecondaryIndex
    h ^= self.mTransform.hashValue
    h ^= self.mShapes.hashValue
    return h
  }

  //····················································································································
  // boundingBox
  //····················································································································

  var boundingBox : NSRect {
    let r = self.mShapes.boundingBox
    let bottomLeft = self.mTransform.transform (r.origin)
    let bottomRight = self.mTransform.transform (NSPoint (x:r.maxX, y:r.minY))
    let topRight = self.mTransform.transform (NSPoint (x:r.maxX, y:r.maxY))
    let topLeft = self.mTransform.transform (NSPoint (x:r.minX, y:r.maxY))
    let minX = min (bottomRight.x, bottomLeft.x, topRight.x, topLeft.x)
    let maxX = max (bottomRight.x, bottomLeft.x, topRight.x, topLeft.x)
    let minY = min (bottomRight.y, bottomLeft.y, topRight.y, topLeft.y)
    let maxY = max (bottomRight.y, bottomLeft.y, topRight.y, topLeft.y)
    return NSRect (x: minX, y: minY, width: maxX - minX, height: maxY - minY)
  }
  
  //····················································································································
  // draw
  //····················································································································

  func draw (_ inDirtyRect: NSRect) {
    if self.boundingBox.intersects (inDirtyRect) {
      self.mTransform.concat ()
      self.mShapes.draw (inDirtyRect)
      let at = self.mTransform.copy () as! NSAffineTransform
      at.invert ()
      at.concat ()
    }
  }

  //····················································································································

  func sameDisplay (as inObject : EBShapeLayer) -> Bool {
    return (self.mTransform == inObject.mTransform) && (self.mShapes == inObject.mShapes)
  }

  //····················································································································
  //   intersects rectangle
  //····················································································································

  func intersects (_ inRect : NSRect) -> Bool {
    return self.boundingBox.intersects (inRect)
  }

  //····················································································································
  //   Contains point
  //····················································································································

  func contains (_ inPoint : NSPoint) -> Bool {
    return self.boundingBox.contains (inPoint)
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShapeLayerArray
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct EBShapeLayerArray : Hashable {

  //····················································································································
  //   Properties
  //····················································································································

  let objects : [EBShapeLayer]

  //····················································································································
  //   Init
  //····················································································································

  init (_ inObjects : [EBShapeLayer]) {
    objects = inObjects
  }

  //····················································································································
  // Equatable protocol
  //····················································································································

  public static func == (lhs: EBShapeLayerArray, rhs: EBShapeLayerArray) -> Bool {
    if lhs.objects.count != rhs.objects.count {
      return false
    }else{
      var idx = 0
      while idx < lhs.objects.count {
        if lhs.objects [idx] != rhs.objects [idx] {
          return false
        }
        idx += 1
      }
      return true
    }
  }

  //····················································································································
  // Hashable protocol
  //····················································································································

  public var hashValue: Int {
    var h = 0
    for object in objects {
      h ^= object.hashValue
    }
    return h
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
