//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension Int {
  mutating func rotateLeft () {
    let b0 = self >> 31
    let bl = self << 1
    self = b0 | bl
  }

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  EBGraphicManagedObject
//  dynamic before func is required in order to make functions overriden in extensions
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBGraphicManagedObject : EBManagedObject {

  //····················································································································

  var selectionDisplay_property = EBTransientProperty_EBShape ()

  //····················································································································

  @objc dynamic func acceptedTranslation (by inValue: CGPoint) -> CGPoint {
    return inValue
  }

  //····················································································································

  @objc dynamic func acceptToTranslate (xBy inDx: CGFloat, yBy inDy: CGFloat) -> Bool {
    return false
  }

  //····················································································································

  @objc dynamic func translate (xBy inDx: CGFloat, yBy inDy: CGFloat) {
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBShape : Hashable, EBUserClassNameProtocol {

  //····················································································································
  //  Properties
  //····················································································································

  private var mShapes : [EBShape]
  private var mCachedBoundingBox : NSRect?
  var userIndex = -1
  var userSecondaryIndex = -1

  //····················································································································
  //  init
  //····················································································································

  init () {
    mShapes = []
    mCachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································

  init (shape inShape : EBShape) {
    mShapes = [inShape]
    mCachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································

  init (shapes inShapes : [EBShape]) {
    mShapes = inShapes
    mCachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································
  //  deinit
  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  append
  //····················································································································

  func append (shape inShape : EBShape) {
    self.mShapes.append (inShape)
    self.mCachedBoundingBox = nil
  }

  //····················································································································

  func append (shapes inShapes : [EBShape]) {
    self.mShapes += inShapes
    self.mCachedBoundingBox = nil
  }

  //····················································································································
  //  Transformed shape using NSAffineTransform object
  //····················································································································

  func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBShape {
    let result = EBShape ()
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································

  fileprivate final func internalTransform (_ result : EBShape, by inAffineTransform : NSAffineTransform) {
    for shape in self.mShapes {
      result.append (shape: shape.transformedBy (inAffineTransform))
    }
    result.userIndex = self.userIndex
    result.userSecondaryIndex = self.userSecondaryIndex
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  func draw (_ inDirtyRect: NSRect) {
    for shape in self.mShapes {
      shape.draw (inDirtyRect)
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  var boundingBox : NSRect {
    if let cbb = mCachedBoundingBox {
      return cbb
    }else{
      var r = NSZeroRect
      for shape in self.mShapes {
        r = r.union (shape.boundingBox)
      }
      self.mCachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  //   intersects
  //····················································································································

  func intersects (_ inRect : NSRect) -> Bool {
    return self.boundingBox.intersects (inRect)
  }

  //····················································································································
  //   Contains point §§§ TEMPORARY §§§
  //····················································································································

  func contains (_ inPoint : NSPoint) -> Bool {
    return self.boundingBox.contains (inPoint)
  }

  //····················································································································

  func sameDisplay (as inObject : EBShape) -> Bool {
    var equal = true // lhs super.== rhs
    if equal {
      equal = self.mShapes.count == inObject.mShapes.count
    }
    if equal {
      var idx = 0
      while idx < self.mShapes.count {
        equal = self.mShapes [idx] == inObject.mShapes [idx]
        if !equal {
          break
        }
        idx += 1
      }
    }
    return equal
  }

  //····················································································································
  /// Returns a Boolean value indicating whether two values are equal.
  ///
  /// Equality is the inverse of inequality. For any values `a` and `b`,
  /// `a == b` implies that `a != b` is `false`.
  ///
  /// - Parameters:
  ///   - lhs: A value to compare.
  ///   - rhs: Another value to compare.
  //····················································································································

  public static func == (lhs: EBShape, rhs: EBShape) -> Bool {
    var equal = lhs.mShapes.count == rhs.mShapes.count
    if equal {
      var idx = 0
      while idx < lhs.mShapes.count {
        equal = lhs.mShapes [idx] == rhs.mShapes [idx]
        if !equal {
          break
        }
        idx += 1
      }
    }
    return equal
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  public var hashValue : Int {
    var h = 0
    for shape in self.mShapes {
      h.rotateLeft ()
      h ^= shape.hashValue
    }
    return h
  }

  //····················································································································
  //   Indexes of objects intersection rectangle
  //····················································································································

  func indexes (intersecting inRect : CGRect) -> Set <Int> {
    var result = Set <Int> ()
    for object in self.mShapes.reversed () {
      if (object.userIndex >= 0) && object.intersects (inRect) {
        result.insert (object.userIndex)
      }
    }
    return result
  }

  //····················································································································
  // index of object containing point (-1 if none)
  //····················································································································

  func indexOfObject (containing inPoint : NSPoint) -> Int {
    var result = -1
    var idx = self.mShapes.count - 1
    while (idx >= 0) && (result < 0) {
      let object = self.mShapes [idx]
      if (object.userIndex >= 0) && object.contains (inPoint) {
        result = object.userIndex
      }
      idx -= 1
    }
    return result
  }

  //····················································································································

  func computeInvalidRect (_ inObjects : EBShape) -> NSRect {
    var invalidRect = NSZeroRect
    let commonCount = min (self.mShapes.count, inObjects.mShapes.count)
    var idx = 0
    while idx < commonCount {
      let currentObjet = self.mShapes [idx]
      let newObject = inObjects.mShapes [idx]
      if !newObject.sameDisplay(as: currentObjet) {
        invalidRect = invalidRect.union (currentObjet.boundingBox)
        invalidRect = invalidRect.union (newObject.boundingBox)
      }
      idx += 1
    }
  //--- Enter in invalid rect removed objects
    while idx < self.mShapes.count {
      invalidRect = invalidRect.union (self.mShapes [idx].boundingBox)
      idx += 1
    }
  //--- Enter in invalid rect new objects
    idx = commonCount
    while idx < inObjects.mShapes.count {
      invalidRect = invalidRect.union (inObjects.mShapes [idx].boundingBox)
      idx += 1
    }
    return invalidRect
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBStrokeBezierPathShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBStrokeBezierPathShape : EBShape {
  private var mPaths : [NSBezierPath]
  private let mColor : NSColor
  private var mCachedBoundingBox : NSRect?

  //····················································································································
  //  Init
  //····················································································································

  init (_ inPaths: [NSBezierPath], _ inColor: NSColor) {
    mPaths = inPaths
    mColor = inColor
    super.init ()
  }

  //····················································································································
  //  append
  //····················································································································

  func append (path inBezierPath : NSBezierPath) {
    self.mPaths.append (inBezierPath)
    self.mCachedBoundingBox = nil
  }

  //····················································································································
  //  transformedBy
  //····················································································································

  override func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBShape {
    var paths = [NSBezierPath] ()
    for path in self.mPaths {
      let bp = inAffineTransform.transform (path)
      paths.append (bp)
    }
    let result = EBStrokeBezierPathShape (paths, self.mColor)
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    self.mColor.setStroke ()
    for bp in self.mPaths {
      bp.stroke ()
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  override var boundingBox : NSRect {
    if let cbb = mCachedBoundingBox {
      return cbb
    }else{
      var r = super.boundingBox
      for bp in self.mPaths {
        let lineWidth = max (bp.lineWidth, 1.0)
        r = r.union (bp.bounds.insetBy (dx: -lineWidth, dy: -lineWidth))
      }
      self.mCachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  /// Returns a Boolean value indicating whether two values are equal.
  ///
  /// Equality is the inverse of inequality. For any values `a` and `b`,
  /// `a == b` implies that `a != b` is `false`.
  ///
  /// - Parameters:
  ///   - lhs: A value to compare.
  ///   - rhs: Another value to compare.
  //····················································································································

  public static func == (lhs: EBStrokeBezierPathShape, rhs: EBStrokeBezierPathShape) -> Bool {
    var equal = true // lhs super.== rhs
    if equal {
      equal = lhs.mPaths.count == rhs.mPaths.count
    }
    if equal {
      var idx = 0
      while idx < lhs.mPaths.count {
        equal = lhs.mPaths [idx] == rhs.mPaths [idx]
        if !equal {
          break
        }
        idx += 1
      }
    }
    return equal
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  override public var hashValue : Int {
    var h = super.hashValue
    h.rotateLeft ()
    h ^= mColor.hashValue
    for path in self.mPaths {
      h.rotateLeft ()
      h ^= path.hashValue
    }
    return h
  }

  //····················································································································
  //   Indexes of objects intersection rectangle
  //····················································································································

  override func indexes (intersecting inRect : CGRect) -> Set <Int> {
    var result = super.indexes (intersecting: inRect)
    if self.userIndex >= 0 {
      for bp in self.mPaths.reversed () {
        if bp.bounds.intersects (inRect) { // §§§§ A AMÉLIORER
          result.insert (self.userIndex)
        }
      }
    }
    return result
  }

  //····················································································································
  // index of object containing point (-1 if none)
  //····················································································································

  override func indexOfObject (containing inPoint : NSPoint) -> Int {
    var result = -1
    if self.userIndex >= 0 {
      for bp in self.mPaths.reversed () {
        if bp.bounds.contains (inPoint) { // §§§§ A AMÉLIORER
          result = self.userIndex
          break
        }
      }
    }
    if result < 0 {
      result = super.indexOfObject (containing: inPoint)
    }
    return result
  }

  //····················································································································

//  override func computeInvalidRect (_ inObjects : EBShape) -> NSRect {
//    var invalidRect = super.computeInvalidRect (inObjects)
//    return invalidRect
//  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBFilledBezierPathShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBFilledBezierPathShape : EBShape {
  private var mPaths : [NSBezierPath]
  private let mColor : NSColor
  private var mCachedBoundingBox : NSRect?

  //····················································································································
  //  Init
  //····················································································································

  init (_ inPaths: [NSBezierPath], _ inColor: NSColor) {
    mPaths = inPaths
    mColor = inColor
    super.init ()
  }

  //····················································································································
  //  append
  //····················································································································

  func append (_ inBezierPath : NSBezierPath) {
    self.mPaths.append (inBezierPath)
    self.mCachedBoundingBox = nil
  }

  //····················································································································
  //  transformedBy
  //····················································································································

  override func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBShape {
    var paths = [NSBezierPath] ()
    for path in self.mPaths {
      let bp = inAffineTransform.transform (path)
      paths.append (bp)
    }
    let result = EBFilledBezierPathShape (paths, self.mColor)
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    self.mColor.setFill ()
    for bp in self.mPaths {
      bp.fill ()
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  override var boundingBox : NSRect {
    if let cbb = mCachedBoundingBox {
      return cbb
    }else{
      var r = super.boundingBox
      for bp in self.mPaths {
        r = r.union (bp.bounds)
      }
      self.mCachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  override public var hashValue : Int {
    var h = super.hashValue
    h.rotateLeft ()
    h ^= mColor.hashValue
    for path in self.mPaths {
      h.rotateLeft ()
      h ^= path.hashValue
    }
    return h
  }

  //····················································································································
  //   Indexes of objects intersection rectangle
  //····················································································································

  override func indexes (intersecting inRect : CGRect) -> Set <Int> {
    var result = super.indexes (intersecting: inRect)
    if self.userIndex >= 0 {
      for bp in self.mPaths.reversed () {
        if bp.bounds.intersects (inRect) { // §§§§ A AMÉLIORER
          result.insert (self.userIndex)
        }
      }
    }
    return result
  }

  //····················································································································
  // index of object containing point (-1 if none)
  //····················································································································

  override func indexOfObject (containing inPoint : NSPoint) -> Int {
    var result = -1
    if self.userIndex >= 0 {
      for bp in self.mPaths.reversed () {
        if bp.bounds.contains (inPoint) { // §§§§ A AMÉLIORER
          result = self.userIndex
          break
        }
      }
    }
    if result < 0 {
      result = super.indexOfObject (containing: inPoint)
    }
    return result
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   Build PDF image
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func buildPDFimage (frame inFrame: CGRect,
                    shapes inShapes: EBShape,
                    backgroundColor inBackColor : NSColor? = nil) -> Data {
  let view = EBOffscreenView (frame: inFrame)
  view.setBackColor (inBackColor)
  view.setPaths (inShapes)
  return view.dataWithPDF (inside: inFrame)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBOffscreenView
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate final class EBOffscreenView : NSView, EBUserClassNameProtocol {

  private var mShape = EBShape ()
  private var mBackColor : NSColor? = nil

  //····················································································································

  override init (frame frameRect: NSRect) {
    super.init (frame: frameRect)
    noteObjectAllocation (self)
  }

  //····················································································································

  required init? (coder: NSCoder) {
    super.init (coder: coder)
    noteObjectAllocation (self)
  }

  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  Set paths
  //····················································································································

  func setPaths (_ inShapes : EBShape) {
    self.mShape = inShapes
  }

  //····················································································································
  //  Set back color
  //····················································································································

  func setBackColor (_ inColor : NSColor?) {
    self.mBackColor = inColor
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    if let backColor = mBackColor {
      backColor.setFill ()
      #if swift(>=4)
        __NSRectFill (inDirtyRect)
      #else
        NSRectFill (inDirtyRect)
      #endif
    }
  //--- Bezier paths
    self.mShape.draw (inDirtyRect)
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
