//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  Extension CGPath
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension CGPath {

  //····················································································································
  // https://stackoverflow.com/questions/45967240/convert-cgpathref-to-nsbezierpath

  public var bezierPath : NSBezierPath {
    var path = NSBezierPath ()
    self.apply (info: &path, function: CGPathCallback)
    return path
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private func CGPathCallback (_ info: UnsafeMutableRawPointer?, _ element : UnsafePointer<CGPathElement>) {
  if let bezierPath : NSBezierPath = info?.load (as: NSBezierPath.self) {// (__bridge NSBezierPath *)info;
 // CGPoint *points = element->points;
    let points = element.pointee.points
    switch element.pointee.type {
    case .moveToPoint:
      bezierPath.move (to: points [0])
    case .addLineToPoint:
      bezierPath.line (to: points [0])
    case .addQuadCurveToPoint:
        let qp0 = bezierPath.currentPoint
        let qp1 = points [0]
        let qp2 = points [1]
      //  NSPoint qp0 = bezierPath.currentPoint, qp1 = points[0], qp2 = points[1], cp1, cp2;
        let m : CGFloat = 2.0 / 3.0
        let cp1 = NSPoint (x: qp0.x + ((qp1.x - qp0.x) * m), y: qp0.y + ((qp1.y - qp0.y) * m))
//        cp1.x = (qp0.x + ((qp1.x - qp0.x) * m));
//        cp1.y = (qp0.y + ((qp1.y - qp0.y) * m));
        let cp2 = NSPoint (x: qp2.x + ((qp1.x - qp2.x) * m), y: qp2.y + ((qp1.y - qp2.y) * m))
//        cp2.x = (qp2.x + ((qp1.x - qp2.x) * m));
//        cp2.y = (qp2.y + ((qp1.y - qp2.y) * m));
        bezierPath.curve (to: qp2, controlPoint1: cp1, controlPoint2: cp2)
    case .addCurveToPoint:
      bezierPath.curve (to:points[2], controlPoint1: points[0], controlPoint2: points[1])
    case .closeSubpath:
      bezierPath.close ()
    @unknown default:
      ()
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension CGPoint : Hashable {

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  public func hash (into hasher: inout Hasher) {
    self.x.hash (into: &hasher)
    self.y.hash (into: &hasher)
  }

  //····················································································································}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
