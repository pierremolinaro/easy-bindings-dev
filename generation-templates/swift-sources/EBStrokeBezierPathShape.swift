//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBStrokeBezierPathShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBStrokeBezierPathShape : EBShape {
  private let mFilledPaths : [NSBezierPath]
  private let mColor : NSColor
  private let mClipBezierPath : NSBezierPath?

  //····················································································································
  //  Init
  //····················································································································

  init (_ inPaths : [NSBezierPath], _ inColor : NSColor, _ inClipBezierPath : NSBezierPath? = nil) {
    var filledPaths = [NSBezierPath] ()
    for path in inPaths {
      if !path.isEmpty {
        let cgPath = path.pathByStroking
        filledPaths.append (cgPath.bezierPath)
      }
    }
    mFilledPaths = filledPaths
    mColor = inColor
    mClipBezierPath = inClipBezierPath
    super.init ()
  }

  //····················································································································

  private init (transformedPaths inFilledPaths : [NSBezierPath], _ inColor : NSColor, _ inClipBezierPath : NSBezierPath?) {
    mFilledPaths = inFilledPaths
    mColor = inColor
    mClipBezierPath = inClipBezierPath
    super.init ()
  }

  //····················································································································
  //  transformedBy
  //····················································································································

  override func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBStrokeBezierPathShape {
    var filledPaths = [NSBezierPath] ()
    for path in self.mFilledPaths {
      let bp = inAffineTransform.transform (path)
      filledPaths.append (bp)
    }
    let clipPath : NSBezierPath?
    if let path = self.mClipBezierPath {
      clipPath = inAffineTransform.transform (path)
    }else{
      clipPath = nil
    }
    let result = EBStrokeBezierPathShape (transformedPaths: filledPaths, self.mColor, clipPath)
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inView : NSView, _ inDirtyRect: NSRect) {
    super.draw (inView, inDirtyRect)
    self.mColor.setFill ()
    if let clipBezierPath = self.mClipBezierPath {
      NSGraphicsContext.saveGraphicsState ()
      clipBezierPath.addClip ()
    }
    for bp in self.mFilledPaths {
      if !bp.isEmpty && inView.needsToDraw (bp.bounds) {
        bp.fill ()
      }
    }
    if self.mClipBezierPath != nil {
      NSGraphicsContext.restoreGraphicsState ()
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  override internal func internalBoundingBox () -> NSRect {
    var r = NSRect.null
    for bp in self.mFilledPaths {
      if !bp.isEmpty {
        r = r.union (bp.bounds)
      }
    }
    if let path = self.mClipBezierPath {
      r = r.intersection (path.bounds)
    }
    return r
  }

  //····················································································································
  //   Contains point
  //····················································································································

  override func contains (point inPoint : NSPoint) -> Bool {
    var result = super.contains (point: inPoint)
    var idx = 0
    while (idx < self.mFilledPaths.count) && !result {
      result = self.mFilledPaths [idx].contains (inPoint)
      idx += 1
    }
    return result
  }

  //····················································································································
  //   intersects
  //····················································································································

  override func intersects (rect inRect : NSRect) -> Bool {
    var result = super.intersects (rect: inRect)
    var idx = 0
    while (idx < self.mFilledPaths.count) && !result {
      result = inRect.intersectsFilledBezierPath (self.mFilledPaths [idx])
      idx += 1
    }
    return result
  }

  //····················································································································
  //   isEqualToShape
  //····················································································································

  override func isEqualToShape (_ inOperand : EBShape) -> Bool {
    var equal = false
    if let operand = inOperand as? EBStrokeBezierPathShape {
      equal = self.mFilledPaths.count == operand.mFilledPaths.count
      if equal {
        equal = self.mColor == operand.mColor
      }
      if equal {
        equal = self.mClipBezierPath == operand.mClipBezierPath
      }
      if equal {
        equal = super.isEqualToShape (operand)
      }
      var idx = 0
      while (idx < self.mFilledPaths.count) && equal {
        equal = self.mFilledPaths [idx] == operand.mFilledPaths [idx]
        idx += 1
      }
    }
    return equal
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  override func hash (into hasher: inout Hasher) {
    super.hash (into: &hasher)
    self.mColor.hash (into: &hasher)
    self.mClipBezierPath?.hash (into: &hasher)
    for path in self.mFilledPaths {
      path.hash (into: &hasher)
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
