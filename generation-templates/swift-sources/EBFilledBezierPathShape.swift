//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// EBFilledBezierPathShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBFilledBezierPathShape : EBShape {
  private var mFilledPaths : [NSBezierPath]
  private let mColor : NSColor
  private var mCachedBoundingBox : NSRect?

  //····················································································································
  //  Init
  //····················································································································

  init (_ inPaths: [NSBezierPath], _ inColor: NSColor) {
    mFilledPaths = inPaths
    mColor = inColor
    super.init ()
  }

  //····················································································································
  //  append
  //····················································································································

  func append (_ inBezierPath : NSBezierPath) {
    self.mFilledPaths.append (inBezierPath)
    self.mCachedBoundingBox = nil
  }

  //····················································································································
  //  transformedBy
  //····················································································································

  override func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBShape {
    var paths = [NSBezierPath] ()
    for path in self.mFilledPaths {
      let bp = inAffineTransform.transform (path)
      paths.append (bp)
    }
    let result = EBFilledBezierPathShape (paths, self.mColor)
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    super.draw (inDirtyRect)
    self.mColor.setFill ()
    for bp in self.mFilledPaths {
      bp.fill ()
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  override var boundingBox : NSRect {
    if let cbb = mCachedBoundingBox {
      return cbb
    }else{
      var r = super.boundingBox
      for bp in self.mFilledPaths {
        r = r.union (bp.bounds)
      }
      self.mCachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  //   Contains point
  //····················································································································

  override func contains (point inPoint : NSPoint) -> Bool {
    var result = super.contains (point: inPoint)
    var idx = 0
    while (idx < self.mFilledPaths.count) && !result {
      result = self.mFilledPaths [idx].contains (inPoint)
      idx += 1
    }
    return result
  }

  //····················································································································
  //   intersects
  //····················································································································
// https://stackoverflow.com/questions/15578017/how-to-determine-if-nsbezierpaths-intersect-in-cocoa
// http://robnapier.net/clipping-cgrect-cgpath

  override func intersects (rect inRect : NSRect) -> Bool {
    var result = super.intersects (rect: inRect)
    var idx = 0
    while (idx < self.mFilledPaths.count) && !result {
      if self.mFilledPaths [idx].bounds.intersects (inRect) {
        // result = pathIntersectRect (self.mFilledPaths [idx], inRect)
        result = true
      }
      idx += 1
    }
    return result
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  override public var hashValue : Int {
    var h = super.hashValue
    h.rotateLeft ()
    h ^= mColor.hashValue
    for path in self.mFilledPaths {
      h.rotateLeft ()
      h ^= path.hashValue
    }
    return h
  }

  //····················································································································
  //   isEqualTo
  //····················································································································

  override func isEqualTo (_ inOperand : EBShape) -> Bool {
    var equal = false
    if let operand = inOperand as? EBFilledBezierPathShape {
      equal = self.mFilledPaths.count == operand.mFilledPaths.count
      if equal {
        equal = super.isEqualTo (inOperand)
      }
      var idx = 0
      while (idx < self.mFilledPaths.count) && equal {
        equal = self.mFilledPaths [idx] == operand.mFilledPaths [idx]
        idx += 1
      }
    }
    return equal
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

// MFBezierPathCollider.m

fileprivate func create16BitsGrayContextOfSize (_ inRect : NSRect) -> CGContext? {
  let w = Int (inRect.size.width)
  let h = Int (inRect.size.height)
  let nComps : Int = 1
  let bits   : Int = 16
  let bitsPerPix  = bits * nComps
  let bytesPerRow = bitsPerPix * w
  let cs = CGColorSpaceCreateDeviceGray ()
  let context = CGContext (data: nil, width: w, height: h, bitsPerComponent: bits, bytesPerRow: bytesPerRow, space: cs, bitmapInfo: 0)
  context?.translateBy (x: -inRect.origin.x, y: -inRect.origin.y)
  context?.setFillColorSpace (cs)
  context?.setStrokeColorSpace (cs)
  return context
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate func drawPath (_ inPath : CGPath, withClip inClip : CGRect, context inContext : CGContext) {
    inContext.saveGState ()
    inContext.clear (inClip)
    let clippedColor : [CGFloat] = [1.0, 1.0 , 1.0, 1.0] // Full white
    inContext.setFillColor (clippedColor)
    inContext.addPath (inPath)
    inContext.clip ()
    inContext.addRect (inClip)
    inContext.fillPath ()
    inContext.restoreGState ()
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func pathIntersectRect (_ testPath : NSBezierPath, _ inRect : NSRect) -> Bool {
  var intersect = false
  if inRect.intersects (testPath.bounds) {
    var r = inRect
    r.origin.x *= 10.0
    r.origin.y *= 10.0
    r.size.width *= 10.0
    r.size.height *= 10.0
    if let computeContext = create16BitsGrayContextOfSize (r) {
      drawPath (testPath.cgPathScaledBy (10.0), withClip: r, context: computeContext)
      let clippedPathsImage : CGImage = computeContext.makeImage ()!
      let onePixSquare = CGRect (x: 0, y: 0, width: 1, height: 1)
      let testContext = create16BitsGrayContextOfSize (onePixSquare)!
      testContext.clear (onePixSquare)
      testContext.draw (clippedPathsImage, in: onePixSquare)
      let data : UnsafeMutableRawPointer? = testContext.data
      let value = data?.load (as: Int32.self) ?? 0
      intersect = value != 0
    }
  }
  return intersect
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension NSBezierPath {

  //····················································································································

  public func cgPathScaledBy (_ inFactor : CGFloat) -> CGPath {
    let path = CGMutablePath ()
    var points = [CGPoint] (repeating: .zero, count: 3)
    for idx in 0 ..< self.elementCount {
      let type = self.element (at: idx, associatedPoints: &points)
      switch type {
      case .moveTo:
        var p = points [0]
        p.x *= inFactor
        p.y *= inFactor
        path.move (to: p)
      case .lineTo:
        var p = points [0]
        p.x *= inFactor
        p.y *= inFactor
        path.addLine (to: p)
      case .curveTo:
        var p0 = points [0]
        p0.x *= inFactor
        p0.y *= inFactor
        var p1 = points [1]
        p1.x *= inFactor
        p1.y *= inFactor
        var p2 = points [2]
        p2.x *= inFactor
        p2.y *= inFactor
        path.addCurve (to: p2, control1: p0, control2: p1)
      case .closePath:
        path.closeSubpath ()
      }
    }
    return path
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
