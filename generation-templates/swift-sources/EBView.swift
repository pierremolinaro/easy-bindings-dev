//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBViewControllerProtocol
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol EBViewControllerProtocol : class {

  var objectCount : Int { get }
  var objectArray : [EBGraphicManagedObject] { get }

  var undoManager : EBUndoManager? { get }

//--- Selection operations

  var selectedGraphicObjectSet : Set <EBGraphicManagedObject> { get }

  var selectedIndexesSet : Set <Int> { get }

  func deleteSelectionAndRemoveDeletedObjectsFromManagedObjectContext ()

  func selectAllObjects ()

  var canBringForward : Bool { get }
  func bringForward ()

  var canBringToFront : Bool { get }
  func bringToFront ()

  var canSendBackward : Bool { get }
  func sendBackward ()

  var canSendToBack : Bool { get }
  func sendToBack ()

  func setSelection (objectsWithIndexes inIndexes : [Int])

  func addToSelection (objectsWithIndex inIndexes : [Int])

  func removeFromSelection (objectWithIndex inIndex : Int)

  func clearSelection ()
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBView
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc(EBView) class EBView : NSView, EBUserClassNameProtocol {

  //····················································································································

  required init? (coder: NSCoder) {
    super.init (coder:coder)
    noteObjectAllocation (self)
  }

  //····················································································································

  override init (frame:NSRect) {
    super.init (frame:frame)
    noteObjectAllocation (self)
  }
  
  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  Properties
  //····················································································································

   private weak var mViewController : EBViewControllerProtocol? = nil // SOULD BE WEAK

  //····················································································································
  //    set controller
  //····················································································································

  func set (controller inController : EBViewControllerProtocol?) {
    mViewController = inController
  }

  //····················································································································
  //    Selection Rectangle Layer
  //····················································································································

  var selectionRectangleLayer : EBShape? = nil {
    didSet {
      if let oldSelectionRectangleLayer = oldValue {
        self.setNeedsDisplay (oldSelectionRectangleLayer.boundingBox)
      }
      if let newSelectionRectangleLayer = selectionRectangleLayer {
        self.setNeedsDisplay (newSelectionRectangleLayer.boundingBox)
      }
    }
  }

  //····················································································································
  //    $underObjectsDisplay binding
  //····················································································································

  private var mUnderObjectsDisplayController : EBReadOnlyController_EBShape?

  func bind_underObjectsDisplay (_ model : EBReadOnlyProperty_EBShape, file : String, line : Int) {
    self.mUnderObjectsDisplayController = EBReadOnlyController_EBShape (
      model: model,
      callBack: { [weak self] in self?.updateUnderObjectsDisplay (from: model) }
    )
  }

  func unbind_underObjectsDisplay () {
    mUnderObjectsDisplayController?.unregister ()
    mUnderObjectsDisplayController = nil
  }

  //····················································································································

  private func updateUnderObjectsDisplay (from model : EBReadOnlyProperty_EBShape) {
    switch model.prop {
    case .empty, .multiple :
      self.setUnderObjectsDisplay (EBShape ())
    case .single (let v) :
      self.setUnderObjectsDisplay (v)
    }
  }


  //····················································································································

  private var mUnderObjectsDisplay = EBShape ()

  //····················································································································

  func setUnderObjectsDisplay (_ inDisplay : EBShape) {
    if self.mUnderObjectsDisplay != inDisplay {
      self.setNeedsDisplay (self.mUnderObjectsDisplay.boundingBox)
      self.setNeedsDisplay (inDisplay.boundingBox)
    }
    self.mUnderObjectsDisplay = inDisplay
  }

  //····················································································································
  //    $overObjectsDisplay binding
  //····················································································································

  private var mOverObjectsDisplayController : EBReadOnlyController_EBShape?

  func bind_overObjectsDisplay (_ model : EBReadOnlyProperty_EBShape, file:String, line:Int) {
    self.mOverObjectsDisplayController = EBReadOnlyController_EBShape (
      model: model,
      callBack: { [weak self] in self?.updateOverObjectsDisplay (from: model) }
    )
  }

  func unbind_overObjectsDisplay () {
    mOverObjectsDisplayController?.unregister ()
    mOverObjectsDisplayController = nil
  }

  //····················································································································

  private func updateOverObjectsDisplay (from model : EBReadOnlyProperty_EBShape) {
    switch model.prop {
    case .empty, .multiple :
      self.setOverObjectsDisplay (EBShape ())
    case .single (let v) :
      self.setOverObjectsDisplay (v)
    }
  }


  //····················································································································

  private var mOverObjectsDisplay = EBShape ()

  //····················································································································

  func setOverObjectsDisplay (_ inDisplay : EBShape) {
    if self.mOverObjectsDisplay != inDisplay {
      self.setNeedsDisplay (self.mOverObjectsDisplay.boundingBox)
      self.setNeedsDisplay (inDisplay.boundingBox)
    }
    self.mOverObjectsDisplay = inDisplay
  }

  //····················································································································
  //  Draw Dirty rect
  //····················································································································

  func drawUnderObjects (_ inDirtyRect: NSRect) {
    self.mUnderObjectsDisplay.draw (inDirtyRect)
  }

  //····················································································································

  func drawOverObjects (_ inDirtyRect: NSRect) {
    self.mOverObjectsDisplay.draw (inDirtyRect)
    self.selectionRectangleLayer?.draw (inDirtyRect)
    for shape in self.mSelectionShapes {
      shape.draw (inDirtyRect)
    }
  }

  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    if let backColor = self.mBackColor {
      backColor.setFill ()
      __NSRectFill (inDirtyRect)
    }
    self.drawUnderObjects (inDirtyRect)
    for object in self.mObjectDisplayArray {
      object.draw (inDirtyRect)
    }
    self.drawOverObjects (inDirtyRect)
  }

  //····················································································································
  //    Arrow Key Magnitude
  //····················································································································


  private var arrowKeyMagnitude : CGFloat = 10.0
  private var mArrowKeyMagnitudeController : EBReadOnlyController_CGFloat? = nil

  func bind_arrowKeyMagnitude (_ model : EBReadOnlyProperty_CGFloat, file : String, line : Int) {
    self.mArrowKeyMagnitudeController = EBReadOnlyController_CGFloat (
      model: model,
      callBack: { [weak self] in self?.updateShiftArrowKeyMagnitude (from: model) }
    )
  }

  func unbind_arrowKeyMagnitude () {
    self.mArrowKeyMagnitudeController?.unregister ()
    self.mArrowKeyMagnitudeController = nil
  }

  //····················································································································

  func set (arrowKeyMagnitude : CGFloat) {
    self.arrowKeyMagnitude = arrowKeyMagnitude
  }

  //····················································································································

  private func updateArrowKeyMagnitude (from model : EBReadOnlyProperty_CGFloat) {
    switch model.prop {
    case .empty :
      break
    case .single (let v) :
      self.set (arrowKeyMagnitude:v)
    case .multiple :
      break
    }
  }

  //····················································································································
  //    Shift Arrow Key Magnitude
  //····················································································································

  private var shiftArrowKeyMagnitude : CGFloat = 10.0
  private var mShiftArrowKeyMagnitudeController : EBReadOnlyController_CGFloat? = nil

  func bind_shiftArrowKeyMagnitude (_ model : EBReadOnlyProperty_CGFloat, file:String, line:Int) {
    self.mShiftArrowKeyMagnitudeController = EBReadOnlyController_CGFloat (
      model: model,
      callBack: { [weak self] in self?.updateShiftArrowKeyMagnitude (from: model) }
    )
  }

  func unbind_shiftArrowKeyMagnitude () {
    mShiftArrowKeyMagnitudeController?.unregister ()
    mShiftArrowKeyMagnitudeController = nil
  }

  //····················································································································

  private func updateShiftArrowKeyMagnitude (from model : EBReadOnlyProperty_CGFloat) {
    switch model.prop {
    case .empty :
      break
    case .single (let v) :
      self.set (shiftArrowKeyMagnitude: v)
    case .multiple :
      break
    }
  }

 //····················································································································

  func set (shiftArrowKeyMagnitude : CGFloat) {
    self.shiftArrowKeyMagnitude = shiftArrowKeyMagnitude
  }

  //····················································································································
  //    Back color
  //····················································································································

  private var mBackColor : NSColor? = nil
  private var mBackColorController : EBReadOnlyController_NSColor? = nil

  func bind_backColor (_ model : EBReadOnlyProperty_NSColor, file:String, line:Int) {
    self.mBackColorController = EBReadOnlyController_NSColor (
      model: model,
      callBack: { [weak self] in self?.updateBackColor (from: model) }
    )
  }

  func unbind_backColor () {
    mBackColorController?.unregister ()
    mBackColorController = nil
  }

  //····················································································································

  private func updateBackColor (from model : EBReadOnlyProperty_NSColor) {
    switch model.prop {
    case .empty :
      break
    case .single (let v) :
      self.set (backColor: v)
    case .multiple :
      break
    }
  }

 //····················································································································

  func set (backColor : NSColor) {
    self.mBackColor = backColor
    self.needsDisplay = true
  }

  //····················································································································
  // Object display array
  //····················································································································

  private var mObjectDisplayArray = [EBShape] ()

  //····················································································································

  func updateObjectDisplay (_ inObjectDisplayArray : [EBShape]) {
  //--- Find invalid rectangle
    var invalidRect = NSRect.null
    let minCount = min (self.mObjectDisplayArray.count, inObjectDisplayArray.count)
    var idx = 0
    while idx < minCount {
      if inObjectDisplayArray [idx] != self.mObjectDisplayArray [idx] {
        invalidRect = invalidRect.union (inObjectDisplayArray [idx].boundingBox)
        invalidRect = invalidRect.union (self.mObjectDisplayArray [idx].boundingBox)
      }
      idx += 1
    }
    while idx < self.mObjectDisplayArray.count {
      invalidRect = invalidRect.union (self.mObjectDisplayArray [idx].boundingBox)
      idx += 1
    }
    while idx < inObjectDisplayArray.count {
      invalidRect = invalidRect.union (inObjectDisplayArray [idx].boundingBox)
      idx += 1
    }
  //--- Store new object array and tell view to display
    self.mObjectDisplayArray = inObjectDisplayArray
    self.setNeedsDisplay (invalidRect)
  }

  //····················································································································

  func objectBoundingBox () -> NSRect {
    var r = NSRect.null
    for shape in mObjectDisplayArray {
      r = r.union (shape.boundingBox)
    }
    return r
  }

  //····················································································································
  // Mouse Events
  //····················································································································

   private func indexOfFrontmostObject (at inLocation : NSPoint) -> (Int?, Int?) {
    var possibleObjectIndex : Int? = nil
    var possibleKnobIndex : Int? = nil
    var idx = self.mSelectionShapes.count
    while (idx > 0) && (possibleObjectIndex == nil) {
      idx -= 1
      possibleKnobIndex = self.mSelectionShapes [idx].knobIndex (at: inLocation)
      if possibleKnobIndex != nil {
        possibleObjectIndex = idx
      }
    }
    idx = self.mObjectDisplayArray.count
    while (idx > 0) && (possibleObjectIndex == nil) {
      idx -= 1
      if self.mObjectDisplayArray [idx].contains (point: inLocation) {
        possibleObjectIndex = idx
      }
    }
    //Swift.print ("possibleObjectIndex \(possibleObjectIndex), possibleKnobIndex \(possibleKnobIndex)")
    return (possibleObjectIndex, possibleKnobIndex)
  }

  //····················································································································

  private func indexesOfObjects (intersecting inRect : NSRect) -> Set <Int> {
    var result = Set <Int> ()
    var idx = 0
    for object in self.mObjectDisplayArray {
      if object.intersects (rect: inRect) {
        result.insert (idx)
      }
      idx += 1
    }
    return result
  }

  //····················································································································

  private var mLastMouseDraggedLocation : NSPoint? = nil
  private var mSelectionRectangleOrigin : NSPoint? = nil
  private var mPossibleKnob : (Int, Int)? = nil // Object index, knob index
  private var mPerformEndUndoGroupingOnMouseUp = false
  var mDraggingObjectsIsAlignedOnArrowKeyMagnitude = false

  //····················································································································

  override func mouseDown (with inEvent: NSEvent) {
    super.mouseDown (with: inEvent)
    let mouseDownLocation = self.convert (inEvent.locationInWindow, from:nil)
    mLastMouseDraggedLocation = mouseDownLocation
    if let viewController = self.mViewController {
    //--- Find index of object under mouse down
      let (possibleObjectIndex, possibleKnobIndex) = self.indexOfFrontmostObject (at: mouseDownLocation)
      let controlKey = inEvent.modifierFlags.contains (.control)
      if !controlKey {
        let shiftKey = inEvent.modifierFlags.contains (.shift)
        let commandKey = inEvent.modifierFlags.contains (.command)
        if shiftKey { // Shift key extends selection
          if let objectIndex = possibleObjectIndex {
            viewController.addToSelection (objectsWithIndex: [objectIndex])
          }
        }else if commandKey { // Command key toggles selection of object under click
          if let objectIndex = possibleObjectIndex {
            if viewController.selectedIndexesSet.contains (objectIndex) {
              viewController.removeFromSelection (objectWithIndex: objectIndex)
            }else{
              viewController.addToSelection (objectsWithIndex: [objectIndex])
            }
          }
        }else if let objectIndex = possibleObjectIndex {
          if let knobIndex = possibleKnobIndex {
            mPossibleKnob = (objectIndex, knobIndex)
          }
          if !viewController.selectedIndexesSet.contains (objectIndex) {
            viewController.setSelection (objectsWithIndexes: [objectIndex])
          }
        }else{ // Click outside an object : clear selection
          viewController.clearSelection ()
          mSelectionRectangleOrigin = mLastMouseDraggedLocation
        }
      }
    }
  }

  //····················································································································

  override func mouseDragged (with inEvent : NSEvent) {
    super.mouseDragged (with: inEvent)
    let mouseDraggedLocation = self.convert (inEvent.locationInWindow, from:nil)
    if let selectionRectangleOrigin = mSelectionRectangleOrigin {
      self.handleSelectionRectangle (from: selectionRectangleOrigin, to: mouseDraggedLocation)
    }else if let lastMouseDraggedLocation = mLastMouseDraggedLocation {
      var proposedTranslation = CGPoint (
        x: mouseDraggedLocation.x - lastMouseDraggedLocation.x,
        y:mouseDraggedLocation.y - lastMouseDraggedLocation.y
      )
      if mDraggingObjectsIsAlignedOnArrowKeyMagnitude {
        let stepX = proposedTranslation.x / self.arrowKeyMagnitude
        proposedTranslation.x = stepX.rounded (.towardZero) * self.arrowKeyMagnitude ;
        let stepY = proposedTranslation.y / self.arrowKeyMagnitude
        proposedTranslation.y = stepY.rounded (.towardZero) * self.arrowKeyMagnitude ;
      }
      if let (objectIndex, knobIndex) = self.mPossibleKnob {
        self.drag (knob: knobIndex, objectIndex: objectIndex,proposedTranslation, lastMouseDraggedLocation)
      }else{
        self.dragSelection (proposedTranslation, lastMouseDraggedLocation)
      }
    }
  }

  //····················································································································

  fileprivate func handleSelectionRectangle (from inSelectionRectangleOrigin : NSPoint,
                                             to inMouseDraggedLocation : NSPoint) {
    let xMin = min (inSelectionRectangleOrigin.x, inMouseDraggedLocation.x)
    let yMin = min (inSelectionRectangleOrigin.y, inMouseDraggedLocation.y)
    let xMax = max (inSelectionRectangleOrigin.x, inMouseDraggedLocation.x)
    let yMax = max (inSelectionRectangleOrigin.y, inMouseDraggedLocation.y)
    let r = NSRect (x:xMin, y:yMin, width:xMax-xMin, height:yMax-yMin)
    var shapes = [EBShape] ()
    let bp = NSBezierPath (rect: r)
    bp.lineWidth = 0.0
    shapes.append (EBFilledBezierPathShape ([bp], NSColor.lightGray.withAlphaComponent (0.2)))
    shapes.append (EBStrokeBezierPathShape ([bp], NSColor.lightGray))
    self.selectionRectangleLayer = EBShape (shapes: shapes)
    let indexSet = self.indexesOfObjects (intersecting:r)
    self.mViewController?.setSelection (objectsWithIndexes: Array (indexSet))
  }

  //····················································································································

  fileprivate func drag (knob knobIndex : Int,
                         objectIndex : Int,
                         _ inProposedTranslation: CGPoint,
                         _ inLastMouseDraggedLocation : CGPoint) {
    let objects = self.mViewController?.objectArray ?? []
    if objects [objectIndex].canMove (knob: knobIndex, by: inProposedTranslation) {
      if !self.mPerformEndUndoGroupingOnMouseUp {
        self.mPerformEndUndoGroupingOnMouseUp = true
        mViewController?.undoManager?.beginUndoGrouping ()
      }
      objects [objectIndex].move (knob: knobIndex, by: inProposedTranslation)
      let mouseDraggedLocation = CGPoint (
        x: inProposedTranslation.x + inLastMouseDraggedLocation.x,
        y: inProposedTranslation.y + inLastMouseDraggedLocation.y
      )
      mLastMouseDraggedLocation = mouseDraggedLocation
    }
  }

  //····················································································································

  fileprivate func dragSelection (_ proposedTranslation: CGPoint, _ lastMouseDraggedLocation : CGPoint) {
    var translation = proposedTranslation
    for object in self.mViewController?.selectedGraphicObjectSet ?? [] {
      let p = object.acceptedTranslation (by: translation)
      translation = p
    }
    if (translation.x != 0.0) || (translation.y != 0.0) {
      if !self.mPerformEndUndoGroupingOnMouseUp {
        self.mPerformEndUndoGroupingOnMouseUp = true
        mViewController?.undoManager?.beginUndoGrouping ()
      }
      for object in mViewController?.selectedGraphicObjectSet ?? [] {
        object.translate (xBy: translation.x, yBy:translation.y)
      }
      let mouseDraggedLocation = CGPoint (x: translation.x + lastMouseDraggedLocation.x, y: translation.y + lastMouseDraggedLocation.y)
      mLastMouseDraggedLocation = mouseDraggedLocation
    }
  }

  //····················································································································

  override func mouseUp (with inEvent : NSEvent) {
    super.mouseUp (with: inEvent)
    if self.mPerformEndUndoGroupingOnMouseUp {
      self.mPerformEndUndoGroupingOnMouseUp = false
      mViewController?.undoManager?.endUndoGrouping ()
    }
    self.mLastMouseDraggedLocation = nil
    self.mSelectionRectangleOrigin = nil
    self.selectionRectangleLayer = nil
    self.mPossibleKnob = nil
  }


  //····················································································································
  // key Events
  //····················································································································

  override func keyDown (with inEvent: NSEvent) {
    let amount : CGFloat = inEvent.modifierFlags.contains (.shift)
      ? self.shiftArrowKeyMagnitude
      : self.arrowKeyMagnitude
    ;
    for character in (inEvent.characters ?? "").unicodeScalars {
      switch (Int (character.value)) {
      case NSEvent.SpecialKey.upArrow.rawValue :
        _ = wantsToTranslateSelection (byX: 0.0, byY:amount)
      case NSEvent.SpecialKey.downArrow.rawValue :
        _ = wantsToTranslateSelection (byX: 0.0, byY:-amount)
      case NSEvent.SpecialKey.leftArrow.rawValue :
        _ = wantsToTranslateSelection (byX: -amount, byY:0.0)
      case NSEvent.SpecialKey.rightArrow.rawValue :
        _ = wantsToTranslateSelection (byX: amount, byY:0.0)
      case 0x7F, NSEvent.SpecialKey.deleteForward.rawValue :
        deleteSelection ()
      default :
        break
      }
    }
  }

  //····················································································································

  private func deleteSelection () {
    mViewController?.deleteSelectionAndRemoveDeletedObjectsFromManagedObjectContext ()
  }

  //····················································································································

  private func wantsToTranslateSelection (byX inDx: CGFloat, byY inDy: CGFloat) -> Bool {
    var accepted = true
    for object in mViewController?.selectedGraphicObjectSet ?? [] {
      if !object.acceptToTranslate (xBy: inDx, yBy:inDy) {
        accepted = false
        break
      }
    }
    if accepted {
      for object in mViewController?.selectedGraphicObjectSet ?? [] {
        object.translate (xBy: inDx, yBy:inDy)
      }
    }
    return accepted
  }

  //····················································································································
  //   Menu actions
  // MARK: -
  //····················································································································

  @objc func validateMenuItem (_ inMenuItem : NSMenuItem) -> Bool {
    let validate : Bool
    let action = inMenuItem.action
    if action == #selector (EBView.selectAll(_:)) {
      validate = (mViewController?.objectCount ?? 0) > 0
    }else if action == #selector (EBView.bringToFront(_:)) {
      validate = mViewController?.canBringToFront ?? false
    }else if action == #selector (EBView.bringForward(_:)) {
      validate = mViewController?.canBringForward ?? false
    }else if action == #selector (EBView.sendToBack(_:)) {
      validate = mViewController?.canSendToBack ?? false
    }else if action == #selector (EBView.sendBackward(_:)) {
      validate = mViewController?.canSendBackward ?? false
    }else{
      validate = false
    }
    return validate
  }

  //····················································································································

  override func selectAll (_ : Any?) {
    mViewController?.selectAllObjects ()
  }

  //····················································································································

  @objc func bringForward () {
    mViewController?.bringForward ()
  }

  //····················································································································

  @objc func bringToFront (_ : Any?) {
    mViewController?.bringToFront ()
  }

  //····················································································································

  @objc func bringForward (_ : Any?) {
    mViewController?.bringForward ()
  }

  //····················································································································

  @objc func sendToBack (_ : Any?) {
    mViewController?.sendToBack ()
  }

  //····················································································································

  @objc func sendBackward (_ : Any?) {
    mViewController?.sendBackward ()
  }

  //····················································································································
  //    Selection Layer
  //····················································································································

  private var mSelectionShapes = [EBShape] ()

  //····················································································································

  func updateSelectionShape (_ inShapes : [EBShape]) {
    for shape in self.mSelectionShapes {
      self.setNeedsDisplay (shape.boundingBox)
    }
    for shape in inShapes {
      self.setNeedsDisplay (shape.boundingBox)
    }
    self.mSelectionShapes = inShapes
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
