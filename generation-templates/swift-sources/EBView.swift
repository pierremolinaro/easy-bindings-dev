//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBView
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc(EBView) class EBView : NSView, EBUserClassNameProtocol, EBViewScaleProvider {

  //····················································································································
  // MARK: -
  //····················································································································

  required init? (coder: NSCoder) {
    super.init (coder:coder)
    noteObjectAllocation (self)
  }

  //····················································································································

  override init (frame:NSRect) {
    super.init (frame:frame)
    noteObjectAllocation (self)
  }
  
  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································

  override var isFlipped : Bool { return false }

  //····················································································································

  override var isOpaque: Bool { return true }

  //····················································································································
  // MARK: -
  //····················································································································

   private weak var mViewController : EBViewControllerProtocol? = nil // SOULD BE WEAK

  //····················································································································

   var viewController : EBViewControllerProtocol? { return self.mViewController }

  //····················································································································

  func set (controller inController : EBViewControllerProtocol?) {
    self.mViewController = inController
  }

  //····················································································································
  // MARK: -
  //····················································································································

  internal var selectionRectangleLayer : EBShape? = nil {
    didSet {
      if let oldSelectionRectangleLayer = oldValue {
        self.setNeedsDisplay (oldSelectionRectangleLayer.boundingBox)
      }
      if let newSelectionRectangleLayer = self.selectionRectangleLayer {
        self.setNeedsDisplay (newSelectionRectangleLayer.boundingBox)
      }
    }
  }

  //····················································································································
  // MARK: -
  //····················································································································

  final var mUnderObjectsDisplay = EBShape () {
    didSet {
      if self.mUnderObjectsDisplay != oldValue {
        self.updateViewFrameAndBounds ()
        self.setNeedsDisplay (oldValue.boundingBox)
        self.setNeedsDisplay (self.mUnderObjectsDisplay.boundingBox)
      }
    }
  }

  //····················································································································

  final internal var mUnderObjectsDisplayController : EBReadOnlyController_EBShape?

  //····················································································································
  // MARK: -
  //····················································································································

  final var mOverObjectsDisplay = EBShape () {
    didSet {
      if self.mOverObjectsDisplay != oldValue {
        self.updateViewFrameAndBounds ()
        self.setNeedsDisplay (oldValue.boundingBox)
        self.setNeedsDisplay (self.mOverObjectsDisplay.boundingBox)
      }
    }
  }

  //····················································································································

  internal var mOverObjectsDisplayController : EBReadOnlyController_EBShape?

  //····················································································································
  // MARK: -
  //····················································································································

  internal var mGuideBezierPath : NSBezierPath? = nil {
    willSet {
      self.invalidateGuideBezierPath ()
    }
    didSet {
      self.invalidateGuideBezierPath ()
    }
  }

  //····················································································································
  // MARK: -
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    self.mBackColor.setFill ()
    NSBezierPath.fill (inDirtyRect)
    self.drawGrid (inDirtyRect)
    self.mUnderObjectsDisplay.draw (inDirtyRect)
    for object in self.mObjectDisplayArray {
      object.draw (inDirtyRect)
    }
    self.mOverObjectsDisplay.draw (inDirtyRect)
    self.selectionRectangleLayer?.draw (inDirtyRect)
    for shape in self.mSelectionShapes {
      shape.draw (inDirtyRect)
    }
    self.drawGuideBezierPath (inDirtyRect)
    self.drawIssue (inDirtyRect)
    self.selectionRectangleLayer?.draw (inDirtyRect)
  }

  //····················································································································

  fileprivate func drawGrid (_ inDirtyRect: NSRect) {
    let r = inDirtyRect
    let gridDisplayStep = self.mGridStep * CGFloat (self.mGridStepFactor)
    let startX = (r.origin.x / gridDisplayStep).rounded (.down) * gridDisplayStep
    let endX = r.maxX
    let startY = (r.origin.y / gridDisplayStep).rounded (.down) * gridDisplayStep
    let endY = r.maxY
    let displayOffset = 0.5 / self.actualScale
    switch self.mGridStyle {
    case .noGrid :
      ()
    case .cross :
      let bp = NSBezierPath ()
      bp.lineWidth = 0.0
      bp.lineCapStyle = .round
      var x = startX
      while x <= endX {
        var y = startY
        while y <= endY {
          bp.move (to: NSPoint (x: x - 0.5 + displayOffset, y: y + displayOffset))
          bp.line (to: NSPoint (x: x + 0.5 + displayOffset, y: y + displayOffset))
          bp.move (to: NSPoint (x: x + displayOffset,       y: y + 0.5 + displayOffset))
          bp.line (to: NSPoint (x: x + displayOffset,       y: y - 0.5 + displayOffset))
          y += gridDisplayStep
        }
        x += gridDisplayStep
      }
      self.mGridCrossColor.setStroke ()
      bp.stroke ()
    case .line :
      let bp = NSBezierPath ()
      bp.lineWidth = 0.0
      bp.lineCapStyle = .round
      var x = startX
      while x <= r.maxX {
        let p1 = NSPoint (x: x + displayOffset, y: startY + displayOffset)
        let p2 = NSPoint (x: x + displayOffset, y: endY + displayOffset)
        bp.move (to: p1)
        bp.line (to: p2)
        x += gridDisplayStep
      }
      var y = startY
      while y <= endY {
        bp.move (to: NSPoint (x: startX + displayOffset, y: y + displayOffset))
        bp.line (to: NSPoint (x: endX   + displayOffset, y: y + displayOffset))
        y += gridDisplayStep
      }
      self.mGridLineColor.setStroke ()
      bp.stroke ()
    }
  }

  //····················································································································
  // MARK: -
  //····················································································································

  private var mArrowKeyMagnitude : Int = milsToCanariUnit (25)

  //····················································································································

  var arrowKeyMagnitude : Int { return self.mArrowKeyMagnitude }

  //····················································································································

  func set (arrowKeyMagnitude : Int) {
    self.mArrowKeyMagnitude = arrowKeyMagnitude
  }

  //····················································································································

  internal var mArrowKeyMagnitudeController : EBReadOnlyController_Int? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  private var mShiftArrowKeyMagnitude : Int = milsToCanariUnit (100)

  //····················································································································

  var shiftArrowKeyMagnitude : Int { return self.mShiftArrowKeyMagnitude }

 //····················································································································

  func set (shiftArrowKeyMagnitude : Int) {
    self.mShiftArrowKeyMagnitude = shiftArrowKeyMagnitude
  }

 //····················································································································

  internal var mShiftArrowKeyMagnitudeController : EBReadOnlyController_Int? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  final var mBackColor : NSColor = NSColor.white {
    didSet {
      self.needsDisplay = true
    }
  }

  //····················································································································

  internal var mBackColorController : EBReadOnlyController_NSColor? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  private var mObjectDisplayArray = [EBShape] ()

  //····················································································································

  var objectDisplayArray : [EBShape] { return mObjectDisplayArray }

  //····················································································································

  func updateObjectDisplay (_ inObjectDisplayArray : [EBShape]) {
  //--- Find invalid rectangle
    let minCount = min (self.mObjectDisplayArray.count, inObjectDisplayArray.count)
    var idx = 0
    while idx < minCount {
      if inObjectDisplayArray [idx] != self.mObjectDisplayArray [idx] {
        self.setNeedsDisplay (inObjectDisplayArray [idx].boundingBox)
        self.setNeedsDisplay (self.mObjectDisplayArray [idx].boundingBox)
      }
      idx += 1
    }
    while idx < self.mObjectDisplayArray.count {
      self.setNeedsDisplay (self.mObjectDisplayArray [idx].boundingBox)
      idx += 1
    }
    while idx < inObjectDisplayArray.count {
      self.setNeedsDisplay (inObjectDisplayArray [idx].boundingBox)
      idx += 1
    }
  //--- Store new object array and tell view to display
    self.mObjectDisplayArray = inObjectDisplayArray
    self.updateViewFrameAndBounds ()
  }

  //····················································································································

  var objectsAndIssueBoundingBox : NSRect {
    var r = NSRect.null
    for shape in self.mObjectDisplayArray {
      r = r.union (shape.boundingBox)
    }
    r = r.union (self.issueBoundingBox)
    r = r.union (self.mUnderObjectsDisplay.boundingBox)
    r = r.union (self.mOverObjectsDisplay.boundingBox)
    r = r.union (self.selectionShapeBoundingBox)
    return r
  }

  //····················································································································
  // MARK: -
  //····················································································································

  internal var mLastMouseDraggedLocation : CanariPoint? = nil
  internal var mSelectionRectangleOrigin : NSPoint? = nil
  internal var mPossibleKnob : (Int, Int)? = nil // Object index, knob index
  internal var mPerformEndUndoGroupingOnMouseUp = false
  var mDraggingObjectsIsAlignedOnArrowKeyMagnitude = false

  //····················································································································
  // MARK: -
  //····················································································································

  private var mPasteboardType : NSPasteboard.PasteboardType? = nil

  //····················································································································

  var pasteboardType : NSPasteboard.PasteboardType? { return self.mPasteboardType }

  //····················································································································

  func register (pasteboardType inPasteboardType : NSPasteboard.PasteboardType?) {
    self.mPasteboardType = inPasteboardType
  }

  //····················································································································
  //   MARK: -
  //   Selection Layer
  //····················································································································

  private var mSelectionShapes = [EBShape] ()

  //····················································································································

  var selectionShapes : [EBShape] { return self.mSelectionShapes }

  //····················································································································

  var selectionShapeBoundingBox : NSRect {
    var r = NSRect.null
    for shape in self.mSelectionShapes {
      r = r.union (shape.boundingBox)
    }
    return r
  }

  //····················································································································

  func updateSelectionShape (_ inShapes : [EBShape]) {
    self.setNeedsDisplay (self.selectionShapeBoundingBox)
    self.mSelectionShapes = inShapes
    self.setNeedsDisplay (self.selectionShapeBoundingBox)
    self.updateViewFrameAndBounds ()
  }

  //····················································································································
  //  MARK: -
  //····················································································································

  internal func updateViewFrameAndBounds () {
    let s = self.actualScale
    var newBounds = NSRect () // For including point (0, 0)
    newBounds = newBounds.union (self.objectsAndIssueBoundingBox)
//    if let clipView = self.superview as? NSClipView {
////      let r = self.convert (clipView.documentVisibleRect, from: clipView)
//      let r = clipView.documentVisibleRect
//      newBounds = newBounds.union (r)
//    }
    let currentBounds = self.bounds
    if currentBounds != newBounds {
      self.frame.size = newBounds.size
      self.bounds = newBounds
      self.needsDisplay = true
      self.applyZoom (Int (s * 100.0))
    }
  }

  //····················································································································
  //  MARK: -
  //····················································································································

  internal var mZoomPopUpButton : NSPopUpButton? = nil
  internal var mXPlacard : NSTextField? = nil
  internal var mYPlacard : NSTextField? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  internal var mXPlacardUnit = 2286 // mils

  //····················································································································

  func set (XPlacardUnit inUnit : Int) {
     self.mXPlacardUnit = inUnit
  }

  //····················································································································

  internal var mXPlacardUnitController : EBReadOnlyController_Int? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  internal var mYPlacardUnit = 2286 // mils

  //····················································································································

  func set (YPlacardUnit inUnit : Int) {
     self.mYPlacardUnit = inUnit
  }

  //····················································································································

  internal var mYPlacardUnitController : EBReadOnlyController_Int? = nil

  //····················································································································
  //  MARK: -
  //····················································································································

  override func viewWillMove (toSuperview inSuperview : NSView?) {
     super.viewWillMove (toSuperview: inSuperview)
  //--- Remove from superview ?
    if nil == inSuperview {
      self.removePlacards ()
    }
  }

  //····················································································································
  // MARK: -
  //····················································································································

 // private var mIsFirstResponder = false

  //····················································································································

  override var acceptsFirstResponder : Bool { return true }

  //····················································································································

  override func becomeFirstResponder () -> Bool {
//    self.mIsFirstResponder = true
//    self.needsDisplay = true
    return true
  }

  //····················································································································

  override func resignFirstResponder () -> Bool {
//    self.mIsFirstResponder = false
//    self.needsDisplay = true
    return true
  }

  //····················································································································
  //  Focus ring (https://developer.apple.com/library/content/qa/qa1785/_index.html)
  //····················································································································

  override var focusRingMaskBounds : NSRect { return self.bounds }

  //····················································································································

  override func drawFocusRingMask () {
    NSBezierPath.fill (self.bounds)
  }

  //····················································································································
  // MARK: -
  //····················································································································

  internal var mIssueBezierPath : NSBezierPath? = nil
  internal var mIssueKind : CanariIssueKind = .error // Any value, not used if mIssueBezierPath is nil

  //····················································································································
  // MARK: -
  //····················································································································

  internal var mZoomController : Controller_CanariViewWithZoomAndFlip_zoom?

  //····················································································································
  // MARK: -
  //····················································································································

  final private var mHorizontalFlip = false
  final private var mVerticalFlip = false

  //····················································································································

  final func set (horizontalFlip inFlip : Bool) {
    self.flip (horizontal: inFlip, vertical: self.mVerticalFlip)
  }

  //····················································································································

  final var horizontalFlip : Bool {
    return self.mHorizontalFlip
  }

  //····················································································································

  final func setVerticalFlip (_ inFlip : Bool) {
    self.flip (horizontal: self.mHorizontalFlip, vertical: inFlip)
  }

  //····················································································································

  final var verticalFlip : Bool {
    return self.mVerticalFlip
  }

  //····················································································································

  fileprivate func flip (horizontal inHorizontalFlip : Bool, vertical inVerticalFlip : Bool) {
     if let clipView = self.superview as? NSClipView {
       let toggleHorizontalFlip : CGFloat = (inHorizontalFlip != self.mHorizontalFlip) ? -1.0 : 1.0
       let toggleVerticalFlip   : CGFloat = (inVerticalFlip   != self.mVerticalFlip)   ? -1.0 : 1.0
       clipView.scaleUnitSquare (to: NSSize (width: toggleHorizontalFlip, height: toggleVerticalFlip))
       self.mHorizontalFlip = inHorizontalFlip
       self.mVerticalFlip = inVerticalFlip
     }
  }

  //····················································································································

  final internal var mHorizontalFlipController : EBReadOnlyController_Bool? = nil

  //····················································································································

  final internal var mVerticalFlipController : EBReadOnlyController_Bool? = nil

  //····················································································································
  // Grid Style
  // MARK: -
  //····················································································································

  final var mGridStyle : GridStyle = .noGrid {
    didSet {
      if self.mGridStyle != oldValue {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································

  final internal var mGridStyleController : EBReadOnlyController_GridStyle? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  final var mGridStep : CGFloat = milsToCocoaUnit (25.0) {
    didSet {
      if (self.mGridStep != oldValue) && (self.mGridStyle != .noGrid)  {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································
  // MARK: -
  //····················································································································

  final var mGridStepFactor : Int = 4 {
    didSet {
      if (self.mGridStepFactor != oldValue) && (self.mGridStyle != .noGrid)  {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································

  final internal var mGridStepFactorController : EBReadOnlyController_Int? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  final var mGridLineColor : NSColor = .black {
    didSet {
      if (self.mGridLineColor != oldValue) && (self.mGridStyle == .line)  {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································

  final internal var mGridLineColorController : EBReadOnlyController_NSColor? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  var mGridCrossColor : NSColor = .black {
    didSet {
      if (self.mGridCrossColor != oldValue) && (self.mGridStyle == .cross)  {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································

  internal var mGridCrossColorController : EBReadOnlyController_NSColor? = nil

  //····················································································································
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

