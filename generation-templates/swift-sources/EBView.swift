//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBView
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc(EBView) class EBView : NSView, EBUserClassNameProtocol, EBViewScaleProvider, NSDraggingSource {

  //····················································································································

  required init? (coder: NSCoder) {
    super.init (coder:coder)
    noteObjectAllocation (self)
  }

  //····················································································································

  override init (frame:NSRect) {
    super.init (frame:frame)
    noteObjectAllocation (self)
  }
  
  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································

  override var isFlipped : Bool { return false }

  //····················································································································
  // MARK: -
  //  View Controller
  //····················································································································

   private weak var mViewController : EBViewControllerProtocol? = nil // SOULD BE WEAK

  //····················································································································

   var viewController : EBViewControllerProtocol? { return self.mViewController }

  //····················································································································

  func set (controller inController : EBViewControllerProtocol?) {
    self.mViewController = inController
  }

  //····················································································································
  //    Selection Rectangle Layer
  //····················································································································

  var selectionRectangleLayer : EBShape? = nil {
    didSet {
      if let oldSelectionRectangleLayer = oldValue {
        self.setNeedsDisplay (oldSelectionRectangleLayer.boundingBox)
      }
      if let newSelectionRectangleLayer = selectionRectangleLayer {
        self.setNeedsDisplay (newSelectionRectangleLayer.boundingBox)
      }
    }
  }

  //····················································································································
  //    $underObjectsDisplay binding
  //····················································································································

  private var mUnderObjectsDisplayController : EBReadOnlyController_EBShape?

  func bind_underObjectsDisplay (_ model : EBReadOnlyProperty_EBShape, file : String, line : Int) {
    self.mUnderObjectsDisplayController = EBReadOnlyController_EBShape (
      model: model,
      callBack: { [weak self] in self?.updateUnderObjectsDisplay (from: model) }
    )
  }

  func unbind_underObjectsDisplay () {
    mUnderObjectsDisplayController?.unregister ()
    mUnderObjectsDisplayController = nil
  }

  //····················································································································

  private func updateUnderObjectsDisplay (from model : EBReadOnlyProperty_EBShape) {
    switch model.prop {
    case .empty, .multiple :
      self.mUnderObjectsDisplay = EBShape ()
    case .single (let v) :
      self.mUnderObjectsDisplay = v
    }
  }


  //····················································································································

  private var mUnderObjectsDisplay = EBShape ()

  //····················································································································
  //    $overObjectsDisplay binding
  //····················································································································

  private var mOverObjectsDisplayController : EBReadOnlyController_EBShape?

  //····················································································································

  func bind_overObjectsDisplay (_ model : EBReadOnlyProperty_EBShape, file:String, line:Int) {
    self.mOverObjectsDisplayController = EBReadOnlyController_EBShape (
      model: model,
      callBack: { [weak self] in self?.updateOverObjectsDisplay (from: model) }
    )
  }

  //····················································································································

  func unbind_overObjectsDisplay () {
    mOverObjectsDisplayController?.unregister ()
    mOverObjectsDisplayController = nil
  }

  //····················································································································

  private func updateOverObjectsDisplay (from model : EBReadOnlyProperty_EBShape) {
    switch model.prop {
    case .empty, .multiple :
      self.mOverObjectsDisplay = EBShape ()
    case .single (let v) :
      self.mOverObjectsDisplay =  v
    }
  }


  //····················································································································

  private var mOverObjectsDisplay = EBShape ()

  //····················································································································
  //  Draw Dirty rect
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    if let backColor = self.mBackColor {
      backColor.setFill ()
      NSBezierPath.fill (inDirtyRect)
    }
    self.drawGrid (inDirtyRect)
    self.mUnderObjectsDisplay.draw (inDirtyRect)
    for object in self.mObjectDisplayArray {
      object.draw (inDirtyRect)
    }
    self.mOverObjectsDisplay.draw (inDirtyRect)
    self.selectionRectangleLayer?.draw (inDirtyRect)
    for shape in self.mSelectionShapes {
      shape.draw (inDirtyRect)
    }
    self.drawIssue (inDirtyRect)
    if !self.mIsFirstResponder {
      NSColor.white.withAlphaComponent (0.1).setFill ()
      NSBezierPath.fill (inDirtyRect)
    }
  }

  //····················································································································
  //    Arrow Key Magnitude
  //····················································································································

  private var arrowKeyMagnitude : CGFloat = 10.0

  //····················································································································

  func set (arrowKeyMagnitude : CGFloat) {
    self.arrowKeyMagnitude = arrowKeyMagnitude
  }

  //····················································································································

  internal var mArrowKeyMagnitudeController : EBReadOnlyController_CGFloat? = nil

  //····················································································································
  //    Shift Arrow Key Magnitude
  //····················································································································

  private var shiftArrowKeyMagnitude : CGFloat = 10.0

 //····················································································································

  func set (shiftArrowKeyMagnitude : CGFloat) {
    self.shiftArrowKeyMagnitude = shiftArrowKeyMagnitude
  }

 //····················································································································

  internal var mShiftArrowKeyMagnitudeController : EBReadOnlyController_CGFloat? = nil

  //····················································································································
  //    Back color
  //····················································································································

  private var mBackColor : NSColor? = nil

 //····················································································································

  func set (backColor : NSColor) {
    self.mBackColor = backColor
    self.needsDisplay = true
  }

  //····················································································································

  internal var mBackColorController : EBReadOnlyController_NSColor? = nil

  //····················································································································
  // Object display array
  //····················································································································

  private var mObjectDisplayArray = [EBShape] ()

  //····················································································································

  func updateObjectDisplay (_ inObjectDisplayArray : [EBShape]) {
  //--- Find invalid rectangle
    var invalidRect = NSRect.null
    let minCount = min (self.mObjectDisplayArray.count, inObjectDisplayArray.count)
    var idx = 0
    while idx < minCount {
      if inObjectDisplayArray [idx] != self.mObjectDisplayArray [idx] {
        invalidRect = invalidRect.union (inObjectDisplayArray [idx].boundingBox)
        invalidRect = invalidRect.union (self.mObjectDisplayArray [idx].boundingBox)
      }
      idx += 1
    }
    while idx < self.mObjectDisplayArray.count {
      invalidRect = invalidRect.union (self.mObjectDisplayArray [idx].boundingBox)
      idx += 1
    }
    while idx < inObjectDisplayArray.count {
      invalidRect = invalidRect.union (inObjectDisplayArray [idx].boundingBox)
      idx += 1
    }
  //--- Store new object array and tell view to display
    self.mObjectDisplayArray = inObjectDisplayArray
    self.setNeedsDisplay (invalidRect)
    self.updateViewFrameAndBounds ()
  }

  //····················································································································

  func objectBoundingBox () -> NSRect {
    var r = NSRect.null
    for shape in mObjectDisplayArray {
      r = r.union (shape.boundingBox)
    }
    if let issueBezierPath = self.mIssueBezierPath, !issueBezierPath.isEmpty {
      let e = -issueBezierPath.lineWidth / 2.0
      r = r.union (issueBezierPath.bounds.insetBy (dx: e, dy: e))
    }
    return r
  }

  //····················································································································
  // Mouse Events
  //····················································································································

   private func indexOfFrontmostObject (at inLocation : NSPoint) -> (Int?, Int?) {
    var possibleObjectIndex : Int? = nil
    var possibleKnobIndex : Int? = nil
    var idx = self.mSelectionShapes.count
    while (idx > 0) && (possibleObjectIndex == nil) {
      idx -= 1
      possibleKnobIndex = self.mSelectionShapes [idx].knobIndex (at: inLocation)
      if possibleKnobIndex != nil {
        possibleObjectIndex = idx
      }
    }
    idx = self.mObjectDisplayArray.count
    while (idx > 0) && (possibleObjectIndex == nil) {
      idx -= 1
      if self.mObjectDisplayArray [idx].contains (point: inLocation) {
        possibleObjectIndex = idx
      }
    }
    //Swift.print ("possibleObjectIndex \(possibleObjectIndex), possibleKnobIndex \(possibleKnobIndex)")
    return (possibleObjectIndex, possibleKnobIndex)
  }

  //····················································································································

  private func indexesOfObjects (intersecting inRect : NSRect) -> Set <Int> {
    var result = Set <Int> ()
    var idx = 0
    for object in self.mObjectDisplayArray {
      if object.intersects (rect: inRect) {
        result.insert (idx)
      }
      idx += 1
    }
    return result
  }

  //····················································································································

  private var mLastMouseDraggedLocation : NSPoint? = nil
  private var mSelectionRectangleOrigin : NSPoint? = nil
  private var mPossibleKnob : (Int, Int)? = nil // Object index, knob index
  private var mPerformEndUndoGroupingOnMouseUp = false
  var mDraggingObjectsIsAlignedOnArrowKeyMagnitude = false

  //····················································································································

  override func mouseDragged (with inEvent : NSEvent) {
    super.mouseDragged (with: inEvent)
    self.updateXYplacards (inEvent.locationInWindow)
    let mouseDraggedLocation = self.convert (inEvent.locationInWindow, from:nil)
    if let selectionRectangleOrigin = mSelectionRectangleOrigin {
      self.handleSelectionRectangle (from: selectionRectangleOrigin, to: mouseDraggedLocation)
    }else if let lastMouseDraggedLocation = mLastMouseDraggedLocation {
      var proposedTranslation = CGPoint (
        x: mouseDraggedLocation.x - lastMouseDraggedLocation.x,
        y:mouseDraggedLocation.y - lastMouseDraggedLocation.y
      )
      if mDraggingObjectsIsAlignedOnArrowKeyMagnitude {
        let stepX = proposedTranslation.x / self.arrowKeyMagnitude
        proposedTranslation.x = stepX.rounded (.towardZero) * self.arrowKeyMagnitude ;
        let stepY = proposedTranslation.y / self.arrowKeyMagnitude
        proposedTranslation.y = stepY.rounded (.towardZero) * self.arrowKeyMagnitude ;
      }
      if let (objectIndex, knobIndex) = self.mPossibleKnob {
        self.drag (knob: knobIndex, objectIndex: objectIndex,proposedTranslation, lastMouseDraggedLocation)
      }else{
        self.dragSelection (proposedTranslation, lastMouseDraggedLocation)
      }
    }
  }

  //····················································································································

  fileprivate func handleSelectionRectangle (from inSelectionRectangleOrigin : NSPoint,
                                             to inMouseDraggedLocation : NSPoint) {
    let xMin = min (inSelectionRectangleOrigin.x, inMouseDraggedLocation.x)
    let yMin = min (inSelectionRectangleOrigin.y, inMouseDraggedLocation.y)
    let xMax = max (inSelectionRectangleOrigin.x, inMouseDraggedLocation.x)
    let yMax = max (inSelectionRectangleOrigin.y, inMouseDraggedLocation.y)
    let r = NSRect (x:xMin, y:yMin, width:xMax-xMin, height:yMax-yMin)
    var shapes = [EBShape] ()
    let bp = NSBezierPath (rect: r)
    bp.lineWidth = 0.0
    shapes.append (EBFilledBezierPathShape ([bp], NSColor.lightGray.withAlphaComponent (0.2)))
    shapes.append (EBStrokeBezierPathShape ([bp], NSColor.lightGray))
    self.selectionRectangleLayer = EBShape (shapes: shapes)
    let indexSet = self.indexesOfObjects (intersecting:r)
    self.mViewController?.setSelection (objectsWithIndexes: Array (indexSet))
  }

  //····················································································································

  fileprivate func drag (knob knobIndex : Int,
                         objectIndex : Int,
                         _ inProposedTranslation: CGPoint,
                         _ inLastMouseDraggedLocation : CGPoint) {
    let objects = self.mViewController?.objectArray ?? []
    if objects [objectIndex].canMove (knob: knobIndex, by: inProposedTranslation) {
      if !self.mPerformEndUndoGroupingOnMouseUp {
        self.mPerformEndUndoGroupingOnMouseUp = true
        mViewController?.undoManager?.beginUndoGrouping ()
      }
      objects [objectIndex].move (knob: knobIndex, by: inProposedTranslation)
      let mouseDraggedLocation = CGPoint (
        x: inProposedTranslation.x + inLastMouseDraggedLocation.x,
        y: inProposedTranslation.y + inLastMouseDraggedLocation.y
      )
      mLastMouseDraggedLocation = mouseDraggedLocation
    }
  }

  //····················································································································

  fileprivate func dragSelection (_ proposedTranslation: CGPoint, _ lastMouseDraggedLocation : CGPoint) {
    var translation = proposedTranslation
    for object in self.mViewController?.selectedGraphicObjectSet ?? [] {
      let p = object.acceptedTranslation (by: translation)
      translation = p
    }
    if (translation.x != 0.0) || (translation.y != 0.0) {
      if !self.mPerformEndUndoGroupingOnMouseUp {
        self.mPerformEndUndoGroupingOnMouseUp = true
        mViewController?.undoManager?.beginUndoGrouping ()
      }
      for object in mViewController?.selectedGraphicObjectSet ?? [] {
        object.translate (xBy: translation.x, yBy:translation.y)
      }
      let mouseDraggedLocation = CGPoint (x: translation.x + lastMouseDraggedLocation.x, y: translation.y + lastMouseDraggedLocation.y)
      mLastMouseDraggedLocation = mouseDraggedLocation
    }
  }

  //····················································································································

  override func mouseUp (with inEvent : NSEvent) {
    super.mouseUp (with: inEvent)
    if self.mPerformEndUndoGroupingOnMouseUp {
      self.mPerformEndUndoGroupingOnMouseUp = false
      mViewController?.undoManager?.endUndoGrouping ()
    }
    self.mLastMouseDraggedLocation = nil
    self.mSelectionRectangleOrigin = nil
    self.selectionRectangleLayer = nil
    self.mPossibleKnob = nil
  }

  //····················································································································
  // key Events
  //····················································································································

  override func keyDown (with inEvent: NSEvent) {
    let amount : CGFloat = inEvent.modifierFlags.contains (.shift)
      ? self.shiftArrowKeyMagnitude
      : self.arrowKeyMagnitude
    ;
    for character in (inEvent.characters ?? "").unicodeScalars {
      switch (character) {
      case NSEvent.SpecialKey.upArrow.unicodeScalar :
        _ = wantsToTranslateSelection (byX: 0.0, byY:amount)
      case NSEvent.SpecialKey.downArrow.unicodeScalar :
        _ = wantsToTranslateSelection (byX: 0.0, byY:-amount)
      case NSEvent.SpecialKey.leftArrow.unicodeScalar :
        _ = wantsToTranslateSelection (byX: -amount, byY:0.0)
      case NSEvent.SpecialKey.rightArrow.unicodeScalar :
        _ = wantsToTranslateSelection (byX: amount, byY:0.0)
      case NSEvent.SpecialKey.deleteForward.unicodeScalar, NSEvent.SpecialKey.delete.unicodeScalar :
        self.deleteSelection ()
      default :
        break
      }
    }
  }

  //····················································································································

  private func wantsToTranslateSelection (byX inDx: CGFloat, byY inDy: CGFloat) -> Bool {
    var accepted = true
    for object in mViewController?.selectedGraphicObjectSet ?? [] {
      if !object.acceptToTranslate (xBy: inDx, yBy:inDy) {
        accepted = false
        break
      }
    }
    if accepted {
      for object in mViewController?.selectedGraphicObjectSet ?? [] {
        object.translate (xBy: inDx, yBy:inDy)
      }
    }
    return accepted
  }

  //····················································································································
  // Paste board type
  // MARK: -
  //····················································································································

  private var mPasteboardType : NSPasteboard.PasteboardType? = nil

  //····················································································································

  func register (pasteboardType inPasteboardType : NSPasteboard.PasteboardType?) {
    self.mPasteboardType = inPasteboardType
  }

  //····················································································································

  var pasteboardType : NSPasteboard.PasteboardType? { return self.mPasteboardType }

  //····················································································································
  // Menu actions
  // MARK: -
  //····················································································································

  @objc func validateMenuItem (_ inMenuItem : NSMenuItem) -> Bool {
    let validate : Bool
    let action = inMenuItem.action
    if action == #selector (EBView.selectAll(_:)) {
      validate = (self.mViewController?.objectCount ?? 0) > 0
    }else if action == #selector (EBView.cut(_:)) {
      validate = self.mViewController?.canCut (self.mPasteboardType) ?? false
    }else if action == #selector (EBView.copy(_:)) {
      validate = self.mViewController?.canCopy (self.mPasteboardType) ?? false
    }else if action == #selector (EBView.paste(_:)) {
      validate = self.mViewController?.canPaste (self.mPasteboardType) ?? false
    }else if action == #selector (EBView.delete(_:)) {
      validate = self.mViewController?.canDelete () ?? false
    }else if action == #selector (EBView.bringToFront(_:)) {
      validate = self.mViewController?.canBringToFront ?? false
    }else if action == #selector (EBView.bringForward(_:)) {
      validate = self.mViewController?.canBringForward ?? false
    }else if action == #selector (EBView.sendToBack(_:)) {
      validate = self.mViewController?.canSendToBack ?? false
    }else if action == #selector (EBView.sendBackward(_:)) {
      validate = self.mViewController?.canSendBackward ?? false
    }else if action == #selector (EBView.snapToGrid(_:)) {
      validate = self.mViewController?.canSnapToGrid (cocoaToCanariUnit (self.arrowKeyMagnitude)) ?? false
    }else if action == #selector (EBView.flipHorizontally(_:)) {
      validate = self.mViewController?.canFlipHorizontally ?? false
    }else if action == #selector (EBView.flipVertically(_:)) {
      validate = self.mViewController?.canFlipVertically ?? false
    }else if action == #selector (EBView.rotate90Clockwise(_:)) {
      validate = self.mViewController?.canRotate90Clockwise ?? false
    }else if action == #selector (EBView.rotate90CounterClockwise(_:)) {
      validate = self.mViewController?.canRotate90CounterClockwise ?? false
    }else{
      validate = false
    }
    return validate
  }

  //····················································································································

  @objc func cut (_ : Any?) {
    let translation = NSPoint (x: self.shiftArrowKeyMagnitude, y: self.shiftArrowKeyMagnitude)
    self.mViewController?.cutSelectedObjectsIntoPasteboard (self.mPasteboardType, pasteOffset: translation)
  }

  //····················································································································

  @objc func copy (_ : Any?) {
    let translation = NSPoint (x: self.shiftArrowKeyMagnitude, y: self.shiftArrowKeyMagnitude)
    self.mViewController?.copySelectedObjectsIntoPasteboard (self.mPasteboardType, pasteOffset: translation)
  }

  //····················································································································

  @objc func paste (_ : Any?) {
    self.mViewController?.pasteFromPasteboard (self.mPasteboardType)
  }

  //····················································································································

  @objc func delete (_ : Any?) {
    self.deleteSelection ()
  }

  //····················································································································

  private func deleteSelection () {
    mViewController?.deleteSelectedObjects ()
  }

  //····················································································································

  override func selectAll (_ : Any?) {
    self.mViewController?.selectAllObjects ()
  }

  //····················································································································

  @objc func bringForward () {
    mViewController?.bringForward ()
  }

  //····················································································································

  @objc func bringToFront (_ : Any?) {
    mViewController?.bringToFront ()
  }

  //····················································································································

  @objc func bringForward (_ : Any?) {
    mViewController?.bringForward ()
  }

  //····················································································································

  @objc func sendToBack (_ : Any?) {
    mViewController?.sendToBack ()
  }

  //····················································································································

  @objc func sendBackward (_ : Any?) {
    mViewController?.sendBackward ()
  }

  //····················································································································

  @objc func snapToGrid (_ : Any?) {
    mViewController?.snapToGrid (cocoaToCanariUnit (self.arrowKeyMagnitude))
  }

  //····················································································································

  @objc func flipHorizontally (_ : Any?) {
    mViewController?.flipHorizontally ()
  }

  //····················································································································

  @objc func flipVertically (_ : Any?) {
    mViewController?.flipVertically ()
  }

  //····················································································································

  @objc func rotate90Clockwise (_ : Any?) {
    mViewController?.rotate90Clockwise ()
  }

  //····················································································································

  @objc func rotate90CounterClockwise (_ : Any?) {
    mViewController?.rotate90CounterClockwise ()
  }

  //····················································································································
  //   MARK: -
  //   Selection Layer
  //····················································································································

  private var mSelectionShapes = [EBShape] ()

  //····················································································································

  func updateSelectionShape (_ inShapes : [EBShape]) {
    for shape in self.mSelectionShapes {
      self.setNeedsDisplay (shape.boundingBox)
    }
    for shape in inShapes {
      self.setNeedsDisplay (shape.boundingBox)
    }
    self.mSelectionShapes = inShapes
  }

  //····················································································································

  func updateViewFrameAndBounds () {
    scaleToZoom (self.mZoom, self.mHorizontalFlip, self.mVerticalFlip)
  }

  //····················································································································

  override func viewDidMoveToSuperview () {
    super.viewDidMoveToSuperview ()
    if let scrollView = self.enclosingScrollView as? CanariScrollViewWithPlacard {
      self.installZoomPopUpButton (scrollView)
      self.installXYplacards (scrollView)
    }
  }

  //····················································································································
  //  scaleToZoom
  //  MARK: -
  //····················································································································

  internal var mZoom = 100

  //····················································································································

  internal func scaleToZoom (_ inZoom : Int,  // 0 -> fit to window
                             _ inHorizontalFlip : Bool,
                             _ inVerticalFlip : Bool) {
    if let clipView = self.superview as? NSClipView {
      var newRect = self.objectBoundingBox ()
      if let issueBezierPath = self.mIssueBezierPath, !issueBezierPath.isEmpty {
        newRect = newRect.union (issueBezierPath.bounds)
      }
      if let minimumBounds = self.mMinimumRect {
        newRect = newRect.union (minimumBounds)
      }
      if (inZoom != 0) || newRect.isNull {
        let r = clipView.convert (clipView.documentVisibleRect, from: self)
        newRect = newRect.union (r)
      }
      if self.bounds != newRect {
        self.frame.size = newRect.size
        self.bounds = newRect
      }
      let currentUnitSquareSize : NSSize = clipView.convert (NSSize (width: 1.0, height: 1.0), from:nil)
      let currentScale = 1.0 / currentUnitSquareSize.width
      let toggleHorizontalFlip : CGFloat = (inHorizontalFlip != self.mHorizontalFlip) ? -1.0 : 1.0 ;
      let toggleVerticalFlip   : CGFloat = (inVerticalFlip != self.mVerticalFlip) ? -1.0 : 1.0 ;
      if 0 == inZoom { // Fit to window
        let clipViewSize = clipView.frame.size
        let currentSize = self.frame.size
        let sx = clipViewSize.width / currentSize.width
        let sy = clipViewSize.height / currentSize.height
        let scale = fmin (sx, sy) / currentScale
        clipView.scaleUnitSquare(to: NSSize (width: toggleHorizontalFlip * scale, height: toggleVerticalFlip * scale))
      }else{
        let scale = CGFloat (inZoom) / (100.0 * currentScale)
        clipView.scaleUnitSquare(to: NSSize (width: toggleHorizontalFlip * scale, height: toggleVerticalFlip * scale))
      }
      let zoomTitle = "\(Int ((self.actualScale () * 100.0).rounded (.toNearestOrEven))) %"
      self.mZoomPopUpButton?.menu?.item (at:0)?.title = (0 == inZoom) ? ("(\(zoomTitle))") : zoomTitle
      self.setNeedsDisplay (self.frame)
    }
  }

  //····················································································································

  func actualScale () -> CGFloat {
    var result : CGFloat = 1.0
    if let clipView = self.superview as? NSClipView {
      let currentScale : NSSize = clipView.convert (NSSize (width: 1.0, height: 1.0), from:nil)
      result = 1.0 / currentScale.width
    }
    return result
  }

  //····················································································································
  //  Managing zoom popup button
  //  MARK: -
  //····················································································································

  fileprivate var mZoomPopUpButton : NSPopUpButton? = nil

  //····················································································································

  fileprivate func addPopupButtonItemForZoom (_ inZoom : Int) {
    if let zoomPopUpButton = self.mZoomPopUpButton {
      zoomPopUpButton.menu?.addItem (withTitle: ("\(inZoom) %"), action:#selector (EBView.setZoomFromPopUpButton(_:)), keyEquivalent: "")
      zoomPopUpButton.lastItem?.target = self
      zoomPopUpButton.lastItem?.tag = inZoom
    }
  }

  //····················································································································

  @objc func setZoomFromPopUpButton (_ inSender : NSMenuItem) {
    scaleToZoom (inSender.tag, self.mHorizontalFlip, self.mVerticalFlip)
    self.mZoom = inSender.tag
    self.mZoomController?.updateModel (self)
  }

  //····················································································································

  private func installZoomPopUpButton (_ inScrollView : CanariScrollViewWithPlacard) {
    if self.mZoomPopUpButton == nil {
      let r = NSRect (x: 0.0, y: 0.0, width: 70.0, height: 20.0)
      let zoomPopUpButton = NSPopUpButton (frame:r, pullsDown:true)
      self.mZoomPopUpButton = zoomPopUpButton
      zoomPopUpButton.font = NSFont.systemFont (ofSize:NSFont.smallSystemFontSize)
      zoomPopUpButton.autoenablesItems = false
      zoomPopUpButton.bezelStyle = .shadowlessSquare
      if let popUpButtonCell = zoomPopUpButton.cell as? NSPopUpButtonCell {
        popUpButtonCell.arrowPosition = .arrowAtBottom
      }
      zoomPopUpButton.isBordered = false
      zoomPopUpButton.menu?.addItem (
        withTitle:"\(Int (self.actualScale () * 100.0)) %",
        action:nil,
        keyEquivalent:""
      )
      self.addPopupButtonItemForZoom (50)
      self.addPopupButtonItemForZoom (100)
      self.addPopupButtonItemForZoom (150)
      self.addPopupButtonItemForZoom (200)
      self.addPopupButtonItemForZoom (250)
      self.addPopupButtonItemForZoom (400)
      self.addPopupButtonItemForZoom (500)
      self.addPopupButtonItemForZoom (600)
      self.addPopupButtonItemForZoom (800)
      self.addPopupButtonItemForZoom (1000)
      self.addPopupButtonItemForZoom (1200)
      self.addPopupButtonItemForZoom (1500)
      self.addPopupButtonItemForZoom (1700)
      self.addPopupButtonItemForZoom (2000)
      zoomPopUpButton.menu?.addItem (withTitle:"Fit to Window", action:#selector (EBView.setZoomFromPopUpButton(_:)), keyEquivalent:"")
      zoomPopUpButton.lastItem?.target = self
      zoomPopUpButton.lastItem?.tag = 0
      inScrollView.addPlacard (zoomPopUpButton)
    }
  }

  //····················································································································
  //  Managing mouse location
  //  MARK: -
  //····················································································································

  private var mXPlacard : NSTextField? = nil
  private var mYPlacard : NSTextField? = nil

  //····················································································································

  private func installXYplacards (_ inScrollView : CanariScrollViewWithPlacard) {
    if self.mXPlacard == nil {
      let r = NSRect (x: 0.0, y: 0.0, width: 90.0, height: 20.0)
      let xPlacard = NSTextField (frame: r)
      self.mXPlacard = xPlacard
      xPlacard.font = NSFont.systemFont (ofSize: NSFont.smallSystemFontSize)
      xPlacard.isBordered = false
      inScrollView.addPlacard (xPlacard)
    }
    if self.mYPlacard == nil {
      let r = NSRect (x: 0.0, y: 0.0, width: 90.0, height: 20.0)
      let yPlacard = NSTextField (frame: r)
      self.mYPlacard = yPlacard
      yPlacard.font = NSFont.systemFont (ofSize: NSFont.smallSystemFontSize)
      yPlacard.isBordered = false
      inScrollView.addPlacard (yPlacard)
    }
  }

  //····················································································································

  private func updateXYplacards (_ inLocationInWindow : NSPoint) {
    let p = self.convert (inLocationInWindow, from: nil)
    let x = stringFrom (valueInCocoaUnit: p.x, displayUnit: self.mXPlacardUnit)
    let y = stringFrom (valueInCocoaUnit: p.y, displayUnit: self.mYPlacardUnit)
    self.mXPlacard?.stringValue = "X = " + x
    self.mYPlacard?.stringValue = "Y = " + y
  }

  //····················································································································

  private func clearXYplacards () {
    self.mXPlacard?.stringValue = ""
    self.mYPlacard?.stringValue = ""
  }

  //····················································································································
  //  Mouse moved and tracking area
  //  MARK: -
  //····················································································································

  fileprivate var mTrackingArea : NSTrackingArea? = nil

  //····················································································································

  override func updateTrackingAreas () { // This is required for receiving mouse moved and mouseExited events
  //---
    self.updateViewFrameAndBounds ()
  //--- Remove tracking area
    if let trackingArea = self.mTrackingArea {
      self.removeTrackingArea (trackingArea)
    }
  //--- Add Updated tracking area
    let trackingArea = NSTrackingArea (
      rect: self.bounds,
      options: [.mouseEnteredAndExited, .mouseMoved, .activeInKeyWindow],
      owner: self,
      userInfo: nil
    )
    self.addTrackingArea (trackingArea)
    self.mTrackingArea = trackingArea
  //---
    super.updateTrackingAreas ()
  }

  //····················································································································

  override func mouseMoved (with inEvent : NSEvent) {
    super.mouseMoved (with: inEvent)
    self.updateXYplacards (inEvent.locationInWindow)
  }

  //····················································································································

  override func mouseExited (with inEvent : NSEvent) {
    super.mouseExited (with: inEvent)
    self.clearXYplacards ()
  }

  //····················································································································
  // X placard unit binding
  // MARK: -
  //····················································································································

  private var mXPlacardUnit = 2286 // mils

  //····················································································································

  func set (XPlacardUnit inUnit : Int) {
     self.mXPlacardUnit = inUnit
  }

  //····················································································································

  internal var mXPlacardUnitController : EBReadOnlyController_Int? = nil

  //····················································································································
  // Y placard unit binding
  // MARK: -
  //····················································································································

  private var mYPlacardUnit = 2286 // mils

  //····················································································································

  func set (YPlacardUnit inUnit : Int) {
     self.mYPlacardUnit = inUnit
  }

  //····················································································································

  internal var mYPlacardUnitController : EBReadOnlyController_Int? = nil

  //····················································································································
  //  Super view has been resized
  //  MARK: -
  //····················································································································

  override func viewWillMove (toSuperview inSuperview : NSView?) {
     super.viewWillMove (toSuperview: inSuperview)
  //--- Remove from superview ?
    if nil == inSuperview, let scrollView = self.enclosingScrollView as? CanariScrollViewWithPlacard {
     scrollView.removePlacard (self.mZoomPopUpButton)
     scrollView.removePlacard (self.mXPlacard)
     self.mXPlacard = nil ;
     scrollView.removePlacard (self.mYPlacard)
     self.mYPlacard = nil ;
    }
  }

  //····················································································································
  //  Responder chain
  // MARK: -
  //····················································································································

  private var mIsFirstResponder = false

  //····················································································································

  override var acceptsFirstResponder : Bool { return true }

  //····················································································································

  override func becomeFirstResponder () -> Bool {
    self.mIsFirstResponder = true
    self.needsDisplay = true
    return true
  }

  //····················································································································

  override func resignFirstResponder () -> Bool {
    self.mIsFirstResponder = false
    self.needsDisplay = true
    return true
  }

  //····················································································································
  //  Focus ring (https://developer.apple.com/library/content/qa/qa1785/_index.html)
  //····················································································································

  override var focusRingMaskBounds : NSRect { return self.bounds }

  //····················································································································

  override func drawFocusRingMask () {
    NSBezierPath.fill (self.bounds)
  }

  //····················································································································
  // MARK: -
  //····················································································································

  private var mIssueBezierPath : NSBezierPath? = nil
  private var mIssueKind : CanariIssueKind = .error // Any value, not used if mIssueBezierPath is nil

  //····················································································································

  func setIssue (_ inBezierPath : NSBezierPath?, _ issueKind : CanariIssueKind) {
    if self.mIssueBezierPath != inBezierPath {
      self.mIssueBezierPath = inBezierPath
      self.mIssueKind = issueKind
      self.updateViewFrameAndBounds ()
    }
  }

  //····················································································································

  private func drawIssue (_ inDirtyRect : NSRect) {
    if let issueBezierPath = self.mIssueBezierPath, !issueBezierPath.isEmpty {
      switch self.mIssueKind {
      case .error :
        NSColor.red.withAlphaComponent (0.15).setFill ()
        issueBezierPath.fill ()
        NSColor.red.setStroke ()
        issueBezierPath.stroke ()
      case .warning :
        NSColor.orange.withAlphaComponent (0.15).setFill ()
        issueBezierPath.fill ()
        NSColor.orange.setStroke ()
        issueBezierPath.stroke ()
      }
    }
  }

  //····················································································································
  //    draw Grid
  // MARK: -
  //····················································································································

  fileprivate func drawGrid (_ inDirtyRect: NSRect) {
    let r = inDirtyRect // self.bounds
    let gridDisplayStep = self.mGridStep * CGFloat (self.mGridStepFactor)
    let startX = (r.origin.x / gridDisplayStep).rounded (.down) * gridDisplayStep
    let endX = r.maxX
    let startY = (r.origin.y / gridDisplayStep).rounded (.down) * gridDisplayStep
    let endY = r.maxY
    let displayOffset = 0.5 / self.actualScale ()
    switch self.mGridStyle {
    case .noGrid :
      ()
    case .cross :
      let bp = NSBezierPath ()
      bp.lineWidth = 0.0
      bp.lineCapStyle = .round
      var x = startX
      while x <= endX {
        var y = startY
        while y <= endY {
          bp.move (to: NSPoint (x: x - 0.5 + displayOffset, y: y + displayOffset))
          bp.line (to: NSPoint (x: x + 0.5 + displayOffset, y: y + displayOffset))
          bp.move (to: NSPoint (x: x + displayOffset,       y: y + 0.5 + displayOffset))
          bp.line (to: NSPoint (x: x + displayOffset,       y: y - 0.5 + displayOffset))
          y += gridDisplayStep
        }
        x += gridDisplayStep
      }
      self.mGridCrossColor.setStroke ()
      bp.stroke ()
    case .line :
      let bp = NSBezierPath ()
      bp.lineWidth = 0.0
      bp.lineCapStyle = .round
      var x = startX
      while x <= r.maxX {
        let p1 = NSPoint (x: x + displayOffset, y: startY + displayOffset)
        let p2 = NSPoint (x: x + displayOffset, y: endY + displayOffset)
        bp.move (to: p1)
        bp.line (to: p2)
        x += gridDisplayStep
      }
      var y = startY
      while y <= endY {
        bp.move (to: NSPoint (x: startX + displayOffset, y: y + displayOffset))
        bp.line (to: NSPoint (x: endX   + displayOffset, y: y + displayOffset))
        y += gridDisplayStep
      }
      self.mGridLineColor.setStroke ()
      bp.stroke ()
    }
  }

  //····················································································································
  // MARK: -
  //····················································································································

  private var mCanariRectController : EBReadOnlyController_CanariRect? = nil

  //····················································································································

  func bind_canariRect (_ model : EBReadOnlyProperty_CanariRect, file : String, line : Int) {
   self.mCanariRectController = EBReadOnlyController_CanariRect (
      model: model,
      callBack: { [weak self] in self?.updateRect (from: model) }
    )
  }

  //····················································································································

  func unbind_canariRect () {
    self.mCanariRectController?.unregister ()
    self.mCanariRectController = nil
  }

  //····················································································································

  private func updateRect (from model : EBReadOnlyProperty_CanariRect) {
    var rect = CanariRect ()
    switch model.prop {
    case .empty :
      ()
    case .single (let v) :
      rect = v
    case .multiple :
      ()
    }
    self.setMinimumRect (rect)
  }

  //····················································································································

  fileprivate var mMinimumRect : NSRect? = nil

  private func setMinimumRect (_ inCanariRect : CanariRect) {
    let emptyModel = (inCanariRect.size.width <= 0) || (inCanariRect.size.height <= 0)
    if emptyModel {
      self.mMinimumRect = nil
    }else{
      self.mMinimumRect = inCanariRect.cocoaRect ()
    }
    self.updateViewFrameAndBounds ()
  }

  //····················································································································
  // MARK: -
  //····················································································································

  internal var mZoomController : Controller_CanariViewWithZoomAndFlip_zoom?

  //····················································································································

  func setZoom (_ inZoom : Int, activateZoomPopUpButton inActivate : Bool) {
    scaleToZoom (inZoom, self.mHorizontalFlip, self.mVerticalFlip)
    self.mZoom = inZoom
    self.mZoomPopUpButton?.isEnabled = inActivate
  }

  //····················································································································
  // MARK: -
  //····················································································································

  private var mHorizontalFlip = false

  //····················································································································

  final func set (horizontalFlip inFlip : Bool) {
    scaleToZoom (self.mZoom, inFlip, self.mVerticalFlip)
    self.mHorizontalFlip = inFlip
  }

  //····················································································································

  final var horizontalFlip : Bool {
    return self.mHorizontalFlip
  }

  //····················································································································

  internal var mHorizontalFlipController : EBReadOnlyController_Bool? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  final private var mVerticalFlip = false

  //····················································································································

  final func setVerticalFlip (_ inFlip : Bool) {
    scaleToZoom (self.mZoom, self.mHorizontalFlip, inFlip)
    self.mVerticalFlip = inFlip
  }

  //····················································································································

  final var verticalFlip : Bool {
    return self.mVerticalFlip
  }

  //····················································································································

  final internal var mVerticalFlipController : EBReadOnlyController_Bool? = nil

  //····················································································································
  // Grid Style
  // MARK: -
  //····················································································································

  final var mGridStyle : GridStyle = .noGrid {
    didSet {
      if self.mGridStyle != oldValue {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································

  final internal var mGridStyleController : EBReadOnlyController_GridStyle? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  final var mGridStep : CGFloat = milsToCocoaUnit (25.0) {
    didSet {
      if (self.mGridStep != oldValue) && (self.mGridStyle != .noGrid)  {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································
  // MARK: -
  //····················································································································

  final var mGridStepFactor : Int = 4 {
    didSet {
      if (self.mGridStepFactor != oldValue) && (self.mGridStyle != .noGrid)  {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································

  final internal var mGridStepFactorController : EBReadOnlyController_Int? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  final var mGridLineColor : NSColor = .black {
    didSet {
      if (self.mGridLineColor != oldValue) && (self.mGridStyle == .line)  {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································

  final internal var mGridLineColorController : EBReadOnlyController_NSColor? = nil

  //····················································································································
  // MARK: -
  //····················································································································

  var mGridCrossColor : NSColor = .black {
    didSet {
      if (self.mGridCrossColor != oldValue) && (self.mGridStyle == .cross)  {
        self.needsDisplay = true
      }
    }
  }

  //····················································································································

  internal var mGridCrossColorController : EBReadOnlyController_NSColor? = nil

  //····················································································································
  // MARK: -
  // Required by NSDraggingSource protocol
  //····················································································································

  func draggingSession (_ session: NSDraggingSession,
                        sourceOperationMaskFor context: NSDraggingContext) -> NSDragOperation {
    return .generic
  }

  //····················································································································

   override func mouseDown (with inEvent : NSEvent) {
    let selectedObjectSet = self.viewController?.selectedGraphicObjectSet ?? Set ()
    let isStartDraggingSourceEvent = inEvent.modifierFlags.contains (.option)
    let mouseDownLocation = self.convert (inEvent.locationInWindow, from:nil)
    mLastMouseDraggedLocation = mouseDownLocation
    if let viewController = self.mViewController {
    //--- Find index of object under mouse down
      let (possibleObjectIndex, possibleKnobIndex) = self.indexOfFrontmostObject (at: mouseDownLocation)
      let controlKey = inEvent.modifierFlags.contains (.control)
      if !controlKey {
        let shiftKey = inEvent.modifierFlags.contains (.shift)
        let commandKey = inEvent.modifierFlags.contains (.command)
        if shiftKey { // Shift key extends selection
          if let objectIndex = possibleObjectIndex {
            viewController.addToSelection (objectsWithIndex: [objectIndex])
          }
        }else if commandKey { // Command key toggles selection of object under click
          if let objectIndex = possibleObjectIndex {
            if viewController.selectedIndexesSet.contains (objectIndex) {
              viewController.removeFromSelection (objectWithIndex: objectIndex)
            }else{
              viewController.addToSelection (objectsWithIndex: [objectIndex])
            }
          }
        }else if let objectIndex = possibleObjectIndex {
          if let knobIndex = possibleKnobIndex {
            mPossibleKnob = (objectIndex, knobIndex)
          }
          if !viewController.selectedIndexesSet.contains (objectIndex) {
            viewController.setSelection (objectsWithIndexes: [objectIndex])
          }
        }else{ // Click outside an object : clear selection
          viewController.clearSelection ()
          mSelectionRectangleOrigin = mLastMouseDraggedLocation
        }
      }
    }else if selectedObjectSet.count > 0, let pbType = self.pasteboardType, isStartDraggingSourceEvent {
   //--- Build dragging item
      let pasteboardItem = NSPasteboardItem ()
      let draggingItem = NSDraggingItem (pasteboardWriter: pasteboardItem)
    //--- Buils image ans data
      let objectArray = self.viewController?.objectArray ?? []
      let displayShape = EBShape ()
      var objectDictionaryArray = [NSDictionary] ()
      for object in objectArray {
        if selectedObjectSet.contains (object), let objectShape = object.objectDisplay {
          displayShape.append (objectShape)
          let d = NSMutableDictionary ()
          object.saveIntoDictionary (d)
          objectDictionaryArray.append (d)
        }
      }
    //--- Transform image by scaling and translating
      let mouseDownLocation = self.convert (inEvent.locationInWindow, from:nil).aligned (onGrid: SYMBOL_GRID_IN_COCOA_UNIT)
      let transform = NSAffineTransform ()
      transform.scale (by: self.actualScale ())
      transform.translateX (by: -displayShape.boundingBox.origin.x, yBy: -displayShape.boundingBox.origin.y)
      let finalShape = displayShape.transformedBy (transform)
    //--- Build image
      let rect = finalShape.boundingBox
      let imagePDFData = buildPDFimage (frame: rect, shape: finalShape)
      let image = NSImage (data: imagePDFData)
    //--- Move image rect origin to mouse click location
      Swift.print ("\(mouseDownLocation) | \(displayShape.boundingBox)")
      var p = mouseDownLocation
  //    var p = displayShape.boundingBox.origin //
//      p.x -= displayShape.boundingBox.origin.x
//      p.y -= displayShape.boundingBox.origin.y
      p.x -= displayShape.boundingBox.size.width  / 2.0
      p.y -= displayShape.boundingBox.size.height / 2.0
      let draggingFrame = NSRect (origin: p, size: rect.size)
    //--- Associated data
      let dataDictionary : NSDictionary = [
        "OBJECTS" : objectDictionaryArray,
        "START" : NSStringFromPoint (mouseDownLocation)
      ]
      pasteboardItem.setPropertyList (dataDictionary, forType: pbType)
    //--- Set dragged image
      draggingItem.setDraggingFrame (draggingFrame, contents: image)
    //--- Begin
      self.beginDraggingSession (with: [draggingItem], event: inEvent, source: self)
    }else{
      super.mouseDown (with: inEvent)
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
