//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBShape : Hashable, EBUserClassNameProtocol {

  //····················································································································
  //  Properties
  //····················································································································

  private var mShapes : [EBShape]
  private var mCachedBoundingBox : NSRect?

  //····················································································································
  //  init
  //····················································································································

  init () {
    mShapes = []
    mCachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································

  init (shape inShape : EBShape) {
    mShapes = [inShape]
    mCachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································

  init (shapes inShapes : [EBShape]) {
    mShapes = inShapes
    mCachedBoundingBox = nil
    noteObjectAllocation (self)
  }

  //····················································································································
  //  deinit
  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  append
  //····················································································································

  func append (_ inShape : EBShape) {
    self.mShapes.append (inShape)
    self.mCachedBoundingBox = nil
  }

  //····················································································································

  func append (shapes inShapes : [EBShape]) {
    self.mShapes += inShapes
    self.mCachedBoundingBox = nil
  }

  //····················································································································
  //  Transformed shape using NSAffineTransform object
  //····················································································································

  func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBShape {
    let result = EBShape ()
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································

  final func internalTransform (_ result : EBShape, by inAffineTransform : NSAffineTransform) {
    for shape in self.mShapes {
      result.append (shape.transformedBy (inAffineTransform))
    }
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  func draw (_ inDirtyRect: NSRect) {
    for shape in self.mShapes {
      shape.draw (inDirtyRect)
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  var boundingBox : NSRect {
    if let cbb = mCachedBoundingBox {
      return cbb
    }else{
      var r = NSRect.null
      for shape in self.mShapes {
        r = r.union (shape.boundingBox)
      }
      self.mCachedBoundingBox = r
      return r
    }
  }

  //····················································································································
  //   intersects
  //····················································································································

  func intersects (rect inRect : NSRect) -> Bool {
    var result = false
    var idx = 0
    while (idx < self.mShapes.count) && !result {
      let shape = self.mShapes [idx]
      idx += 1
      result = shape.intersects (rect: inRect)
    }
    return result
  }

  //····················································································································
  //   Contains point
  //····················································································································

  func contains (point inPoint : NSPoint) -> Bool {
    for shape in self.mShapes {
      if shape.contains (point: inPoint) {
        return true
      }
    }
    return false
  }

  //····················································································································
  //   Knob Index
  //····················································································································

  func knobIndex (at inPoint : NSPoint) -> Int? {
    for shape in self.mShapes.reversed () {
      if let idx = shape.knobIndex (at: inPoint) {
        return idx
      }
    }
    return nil
  }

  //····················································································································
  /// Returns a Boolean value indicating whether two values are equal.
  ///
  /// Equality is the inverse of inequality. For any values `a` and `b`,
  /// `a == b` implies that `a != b` is `false`.
  ///
  /// - Parameters:
  ///   - lhs: A value to compare.
  ///   - rhs: Another value to compare.
  //····················································································································

  public static func == (lhs: EBShape, rhs: EBShape) -> Bool {
    return (lhs === rhs) || lhs.isEqualTo (rhs)
  }

  //····················································································································

  func isEqualTo (_ inOperand : EBShape) -> Bool {
    var equal = self.mShapes.count == inOperand.mShapes.count
    var idx = 0
    while (idx < self.mShapes.count) && equal {
      equal = self.mShapes [idx] == inOperand.mShapes [idx]
      idx += 1
    }
    return equal
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  public var hashValue : Int {
    var h = 0
    for shape in self.mShapes {
      h.rotateLeft ()
      h ^= shape.hashValue
    }
    return h
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
