//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct EBShape : Hashable {

  //····················································································································
  //  Properties
  //····················································································································

  private var mElements = [EBShapeElement] ()
  private var mCachedBoundingBox : NSRect? = nil
  private var mToolTips = [EBToolTip] ()

  //····················································································································
  //  init
  //····················································································································

  init () {
  }

  //····················································································································

  init (filled inFilledPaths : [EBBezierPath],
        _ inColor : NSColor?,
        _ inKnobIndex : Int? = nil,
        clip inClipBezierPath : EBBezierPath? = nil) {
    self.addFilledBezierPathes (inFilledPaths, inColor, inKnobIndex, clip: inClipBezierPath)
  }

  //····················································································································

  init (stroke inStrokePaths : [EBBezierPath],
        _ inColor : NSColor?,
        _ inKnobIndex : Int? = nil,
        clip inClipBezierPath : EBBezierPath? = nil) {
    self.addStrokeBezierPathes (inStrokePaths, inColor, inKnobIndex, clip: inClipBezierPath)
  }

  //····················································································································

  init (text inString: String,
        _ inOrigin : CGPoint,
        _ inTextAttributes : [NSAttributedString.Key : Any],
        _ inHorizontalAlignment : EBTextHorizontalAlignment,
        _ inVerticalAlignment : EBTextVerticalAlignment) {
    self.addText (inString, inOrigin, inTextAttributes, inHorizontalAlignment, inVerticalAlignment)
  }


  //····················································································································

  init (textKnob inString : String,
        _ inOrigin : CGPoint,
        _ inFont : NSFont,
        _ inHorizontalAlignment : EBTextHorizontalAlignment,
        _ inVerticalAlignment : EBTextVerticalAlignment,
        _ inKnobIndex : Int) {
    self.addTextKnob (inString, inOrigin, inFont, inHorizontalAlignment, inVerticalAlignment, inKnobIndex)
  }

  //····················································································································
  //  add
  //····················································································································

  mutating func add (_ inShape : EBShape) {
    self.mElements += inShape.mElements
    self.mCachedBoundingBox = nil
  }

  //····················································································································
  //  addFilledBezierPathes
  //····················································································································

  mutating func addFilledBezierPathes (_ inFilledPaths : [EBBezierPath],
                                       _ inColor : NSColor?,
                                       _ inKnobIndex : Int? = nil,
                                       clip inClipBezierPath : EBBezierPath? = nil) {
    let nonEmptyPathes = filterOutEmptyPathes (inFilledPaths)
    if nonEmptyPathes.count > 0 {
      let e = EBShapeElement (inFilledPaths, inColor, inKnobIndex, inClipBezierPath)
      self.mElements.append (e)
      self.mCachedBoundingBox = nil
    }
  }

  //····················································································································
  //  addStrokeBezierPathes
  //····················································································································

  mutating func addStrokeBezierPathes (_ inStrokePathes : [EBBezierPath],
                                       _ inColor : NSColor?,
                                       _ inKnobIndex : Int? = nil,
                                       clip inClipBezierPath : EBBezierPath? = nil) {
    var filledBezierPathes = [EBBezierPath] ()
    for path in inStrokePathes {
      if !path.isEmpty, path.lineWidth > 0.0 {
        filledBezierPathes.append (path.pathByStroking)
      }
    }
    if filledBezierPathes.count > 0 {
      let e = EBShapeElement (filledBezierPathes, inColor, inKnobIndex, inClipBezierPath)
      self.mElements.append (e)
      self.mCachedBoundingBox = nil
    }
  }

  //····················································································································
  //  Add Knob
  //····················································································································

  mutating func addKnob (at inPoint: NSPoint, index inKobIndex : Int, _ inKind : EBKnobKind, _ inKnobSize : CGFloat) {
    let r = NSRect (x: inPoint.x - inKnobSize / 2.0, y: inPoint.y - inKnobSize / 2.0, width: inKnobSize, height: inKnobSize)
    var bp : EBBezierPath
    switch inKind {
    case .rect :
      bp = EBBezierPath (rect: r)
    case .circ :
      bp = EBBezierPath (ovalIn: r)
    }
  //--- Background
    let e = EBShapeElement ([bp], .white, inKobIndex, nil)
    self.mElements.append (e)
    self.mCachedBoundingBox = nil
  //--- Line
    bp.lineWidth = 0.1
    bp.lineCapStyle = .round
    bp.lineJoinStyle = .round
    self.addStrokeBezierPathes ([bp], .black)
  }

  //····················································································································
  //  Add Text
  //····················································································································

  mutating func addText (_ inString: String,
                         _ inOrigin : CGPoint,
                         _ inTextAttributes : [NSAttributedString.Key : Any],
                         _ inHorizontalAlignment : EBTextHorizontalAlignment,
                         _ inVerticalAlignment : EBTextVerticalAlignment) {
    if inString != "" {
    //--- Forecolor
      let textColor : NSColor
      if let c = inTextAttributes [NSAttributedString.Key.foregroundColor] as? NSColor {
        textColor = c
      }else{
        textColor = .black
      }
    //--- Transform text into filled bezier path
      let filledBezierPath = EBBezierPath (
        with: inString,
        at: inOrigin,
        inHorizontalAlignment,
        inVerticalAlignment,
        withAttributes: inTextAttributes
      )
    //--- Append background ?
      if let backColor = inTextAttributes [NSAttributedString.Key.backgroundColor] as? NSColor {
        let bp = EBBezierPath (rect: filledBezierPath.bounds)
        let e = EBShapeElement ([bp], backColor, nil, nil)
        self.mElements.append (e)
      }
    //--- Append text
      let e = EBShapeElement ([filledBezierPath], textColor, nil, nil)
      self.mElements.append (e)
      self.mCachedBoundingBox = nil
    }
  }

  //····················································································································
  //  Text knob
  //····················································································································

  mutating func addTextKnob (_ inString : String,
                             _ inOrigin : CGPoint,
                             _ inFont : NSFont,
                             _ inHorizontalAlignment : EBTextHorizontalAlignment,
                             _ inVerticalAlignment : EBTextVerticalAlignment,
                             _ inKnobIndex : Int) {
    let string = (inString == "") ? " " : inString
    let textAttributes : [NSAttributedString.Key : Any] = [
      NSAttributedString.Key.font : inFont
    ]
  //--- Transform text into filled bezier path
    let filledBezierPath = EBBezierPath (
      with: string,
      at: inOrigin,
      inHorizontalAlignment,
      inVerticalAlignment,
      withAttributes: textAttributes
    )
  //--- Append background
    do{
      let bp = EBBezierPath (rect: filledBezierPath.bounds)
      let e = EBShapeElement ([bp], .white, inKnobIndex, nil)
      self.mElements.append (e)
    }
  //--- Append text
    let e = EBShapeElement ([filledBezierPath], .black, nil, nil)
    self.mElements.append (e)
    self.mCachedBoundingBox = nil
  }

  //····················································································································
  //  Tool tips
  //····················································································································

  mutating func addToolTip (_ inRect : NSRect, _ inText : String) {
    self.mToolTips.append (EBToolTip (path: EBBezierPath (rect: inRect), string: inText))
  }

  //····················································································································

  func installToolTips (toView inView : EBGraphicView) {
    for tooltip in self.mToolTips {
      inView.addToolTip (tooltip.path.bounds, owner: tooltip.string, userData: nil)
    }
  }

  //····················································································································
  //  Draw
  //····················································································································

  func draw (_ inView : NSView, _ inDirtyRect: NSRect) {
    for element in self.mElements {
      if inView.needsToDraw (element.boundingBox) {
        element.draw (inView, inDirtyRect)
      }
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

//  mutating func boundingBox () -> NSRect {
//    if let cachedBoundingBox = self.mCachedBoundingBox {
//      return cachedBoundingBox
//    }else{
//      var r = NSRect.null
//      for shape in self.mElements {
//        r = r.union (shape.boundingBox)
//      }
//      self.mCachedBoundingBox = r
//      return r
//    }
//  }

  var boundingBox : NSRect {
    var r = NSRect.null
    for shape in self.mElements {
      r = r.union (shape.boundingBox)
    }
    return r
  }

  //····················································································································
  //   Contains point
  //····················································································································

  func contains (point inPoint : NSPoint) -> Bool {
    var result = false
    var idx = 0
    while (idx < self.mElements.count) && !result {
      result = self.mElements [idx].contains (point: inPoint)
      idx += 1
    }
    return result
  }

  //····················································································································
  //   intersects
  //····················································································································

  func intersects (rect inRect : NSRect) -> Bool {
    var result = false
    var idx = 0
    while (idx < self.mElements.count) && !result {
      result = self.mElements [idx].intersects (rect: inRect)
      idx += 1
    }
    return result
  }

  //····················································································································
  //   Knob Index
  //····················································································································

  func knobIndex (at inPoint : NSPoint) -> Int? {
    for element in self.mElements.reversed () {
      if let idx = element.knobIndex (at: inPoint) {
        return idx
      }
    }
    return nil
  }

  //····················································································································
  //  Transformed shape using NSAffineTransform object
  //····················································································································

  func transformed (by inAffineTransform : AffineTransform) -> EBShape {
    var result = EBShape ()
    for element in self.mElements {
      result.mElements.append (element.transformed (by: inAffineTransform))
    }
    for tooltip in self.mToolTips {
      result.mToolTips.append (EBToolTip (path: tooltip.path.transformed (by: inAffineTransform), string: tooltip.string))
    }
    return result
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBKnobKind
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum EBKnobKind {
  case rect
  case circ
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// OCBezierPath
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate final class EBShapeElement : EBObject {

  //····················································································································
  // Properties
  //····················································································································

  private let mFilledPathes : [EBBezierPath]
  private let mColor : NSColor?
  private let mKnobIndex : Int?
  private let mClipBezierPath : EBBezierPath?

  //····················································································································
  //  init
  //····················································································································

  init (_ inFilledPathes : [EBBezierPath],
         _ inColor : NSColor?,
         _ inKnobIndex : Int? = nil,
         _ inClipBezierPath : EBBezierPath?) {
    mFilledPathes = inFilledPathes
    mColor = inColor
    mKnobIndex = inKnobIndex
    if let clipBezierPath = inClipBezierPath, !clipBezierPath.isEmpty {
      mClipBezierPath = inClipBezierPath
    }else{
      mClipBezierPath = nil
    }
    super.init ()
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  func draw (_ inView : NSView, _ inDirtyRect: NSRect) {
    if let color = self.mColor {
      color.setFill ()
      if let clipBezierPath = self.mClipBezierPath {
        NSGraphicsContext.saveGraphicsState ()
        clipBezierPath.addClip ()
      }
      for bp in self.mFilledPathes {
        if !bp.isEmpty && inView.needsToDraw (bp.bounds) {
          bp.fill ()
        }
      }
      if self.mClipBezierPath != nil {
        NSGraphicsContext.restoreGraphicsState ()
      }
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  var boundingBox : NSRect {
    var r = NSRect.null
    for bp in self.mFilledPathes {
      if !bp.isEmpty {
        r = r.union (bp.bounds)
      }
    }
    if let path = self.mClipBezierPath {
      r = r.intersection (path.bounds)
    }
    return r
  }

  //····················································································································
  //   Contains point
  //····················································································································

  func contains (point inPoint : NSPoint) -> Bool {
    var result = false
    if self.mClipBezierPath?.contains (inPoint) ?? true {
      var idx = 0
      while (idx < self.mFilledPathes.count) && !result {
        result = self.mFilledPathes [idx].contains (inPoint)
        idx += 1
      }
    }
    return result
  }

  //····················································································································
  //   intersects
  //····················································································································

  func intersects (rect inRect : NSRect) -> Bool {
    var result = false
    if self.mClipBezierPath?.intersects (rect: inRect) ?? true {
      var idx = 0
      while (idx < self.mFilledPathes.count) && !result {
        result = self.mFilledPathes [idx].intersects (rect: inRect)
        idx += 1
      }
    }
    return result
  }

  //····················································································································
  //   Knob Index
  //····················································································································

  func knobIndex (at inPoint : NSPoint) -> Int? {
    for path in self.mFilledPathes.reversed () {
      if let idx = self.mKnobIndex, path.contains (inPoint) {
        return idx
      }
    }
    return nil
  }

  //····················································································································
  //  transformedBy
  //····················································································································

  func transformed (by inAffineTransform : AffineTransform) -> EBShapeElement {
    var paths = [EBBezierPath] ()
    for path in self.mFilledPathes {
      paths.append (path.transformed(by: inAffineTransform))
    }
    let clipBezierPath : EBBezierPath?
    if let path = self.mClipBezierPath {
      clipBezierPath = path.transformed (by: inAffineTransform)
    }else{
      clipBezierPath = nil
    }
    return EBShapeElement (paths, self.mColor, self.mKnobIndex, clipBezierPath)
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate struct EBToolTip : Hashable {
  let path : EBBezierPath
  let string : String
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate func filterOutEmptyPathes (_ inPathes : [EBBezierPath]) -> [EBBezierPath] {
  var nonEmptyBezierPathes = [EBBezierPath] ()
  for path in inPathes {
    if !path.isEmpty {
      nonEmptyBezierPathes.append (path)
    }
  }
  return nonEmptyBezierPathes
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
