//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    EBShape
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class EBShape : Hashable, Equatable, EBUserClassNameProtocol {

  //····················································································································
  //  Properties
  //····················································································································

  private var mShapes : [EBShape]
  private var mCachedBoundingBox : NSRect? = nil

  //····················································································································
  //  init
  //····················································································································

  init () {
    mShapes = []
    noteObjectAllocation (self)
  }

  //····················································································································

  init (shape inShape : EBShape) {
    mShapes = [inShape]
    noteObjectAllocation (self)
  }

  //····················································································································

  init (shapes inShapes : [EBShape]) {
    mShapes = inShapes
    noteObjectAllocation (self)
  }

  //····················································································································
  //  deinit
  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //  append
  //····················································································································

  final func append (_ inShape : EBShape) {
    self.mShapes.append (inShape)
    self.mCachedBoundingBox = nil
  }

  //····················································································································

  final func append (_ inShapes : [EBShape]) {
    self.mShapes += inShapes
    self.mCachedBoundingBox = nil
  }

  //····················································································································
  //  Transformed shape using NSAffineTransform object
  //····················································································································

  func transformedBy (_ inAffineTransform : NSAffineTransform) -> EBShape {
    let result = EBShape ()
    self.internalTransform (result, by: inAffineTransform)
    return result
  }

  //····················································································································

  final func internalTransform (_ result : EBShape, by inAffineTransform : NSAffineTransform) {
    for shape in self.mShapes {
      result.append (shape.transformedBy (inAffineTransform))
    }
  }

  //····················································································································
  //  Draw Rect
  //····················································································································

  func draw (_ inView : NSView, _ inDirtyRect: NSRect) {
    for shape in self.mShapes {
      if inView.needsToDraw (shape.boundingBox) {
        shape.draw (inView, inDirtyRect)
      }
    }
  }

  //····················································································································
  // boundingBox
  //····················································································································

  final var boundingBox : NSRect {
    if let cachedBoundingBox = self.mCachedBoundingBox {
      return cachedBoundingBox
    }else{
      var r = self.internalBoundingBox ()
      for shape in self.mShapes {
        r = r.union (shape.boundingBox)
      }
      self.mCachedBoundingBox = r
      return r
    }
  }

  //····················································································································

  internal func internalBoundingBox () -> NSRect {
    return .null
  }

  //····················································································································
  //   intersects
  //····················································································································

  func intersects (rect inRect : NSRect) -> Bool {
    var result = false
    var idx = 0
    while (idx < self.mShapes.count) && !result {
      let shape = self.mShapes [idx]
      idx += 1
      result = shape.intersects (rect: inRect)
    }
    return result
  }

  //····················································································································
  //   Contains point
  //····················································································································

  func contains (point inPoint : NSPoint) -> Bool {
    for shape in self.mShapes {
      if shape.contains (point: inPoint) {
        return true
      }
    }
    return false
  }

  //····················································································································
  //   Knob Index
  //····················································································································

  func knobIndex (at inPoint : NSPoint) -> Int? {
    for shape in self.mShapes.reversed () {
      if let idx = shape.knobIndex (at: inPoint) {
        return idx
      }
    }
    return nil
  }

  //····················································································································
  /// Returns a Boolean value indicating whether two values are equal.
  ///
  /// Equality is the inverse of inequality. For any values `a` and `b`,
  /// `a == b` implies that `a != b` is `false`.
  ///
  /// - Parameters:
  ///   - lhs: A value to compare.
  ///   - rhs: Another value to compare.
  //····················································································································

  public static func == (lhs: EBShape, rhs: EBShape) -> Bool {
    return (lhs === rhs) || lhs.isEqualToShape (rhs)
  }

  //····················································································································

  public static func != (lhs: EBShape, rhs: EBShape) -> Bool {
    return !(lhs == rhs)
  }

  //····················································································································

  func isEqualToShape (_ inOperand : EBShape) -> Bool {
    var equal = type (of: self) == type (of: inOperand)
    if equal {
      equal = self.mShapes.count == inOperand.mShapes.count
    }
    var idx = 0
    while (idx < self.mShapes.count) && equal {
      equal = self.mShapes [idx] == inOperand.mShapes [idx]
      idx += 1
    }
    return equal
  }

  //····················································································································
  /// The hash value.
  ///
  /// Hash values are not guaranteed to be equal across different executions of
  /// your program. Do not save hash values to use during a future execution.
  //····················································································································

  func hash (into hasher: inout Hasher) {
    for shape in self.mShapes {
      shape.hash (into: &hasher)
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension Array where Element == EBShape {

  //····················································································································

  var boundingBox : NSRect {
    var r = NSRect.null
    for shape in self {
      r = r.union (shape.boundingBox)
    }
    return r
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
