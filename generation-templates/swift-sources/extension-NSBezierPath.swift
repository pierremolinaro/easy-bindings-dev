//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  Extension NSBezierPath
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension NSBezierPath {

  //····················································································································

  func addArrow (fillPath : NSBezierPath, to endPoint : NSPoint, arrowSize : CGFloat) {
    if endPoint != self.currentPoint {
   //--- Compute angle
      let angle = CGPoint.angleInRadian (self.currentPoint, endPoint)
    //--- Affine transform
      let tr = NSAffineTransform ()
      tr.translateX (by: endPoint.x, yBy:endPoint.y)
      tr.rotate (byRadians:angle)
    //--- Draw path
      let path = NSBezierPath ()
      path.move (to: CGPoint (x: 0.0, y: 0.0))
      path.line (to:CGPoint (x: -2.0 * arrowSize, y:  arrowSize))
      path.curve (to:CGPoint (x: -2.0 * arrowSize, y: -arrowSize),
                  controlPoint1: CGPoint (x: -arrowSize, y: -arrowSize),
                  controlPoint2: CGPoint (x: -arrowSize, y:  arrowSize))
      path.close ()
    //--- Add path
      fillPath.append (tr.transform (path))
    //--- Draw line
      self.line (to:endPoint)
    }
  }

  //····················································································································
  // https://stackoverflow.com/questions/1815568/how-can-i-convert-nsbezierpath-to-cgpath

  public var cgPath: CGPath {
    let path = CGMutablePath ()
    var points = [CGPoint] (repeating: .zero, count: 3)
    for idx in 0 ..< self.elementCount {
      let type = self.element (at: idx, associatedPoints: &points)
      switch type {
      case .moveTo:
        path.move (to: points[0])
      case .lineTo:
        path.addLine (to: points[0])
      case .curveTo:
        path.addCurve (to: points[2], control1: points[0], control2: points[1])
      case .closePath:
        path.closeSubpath ()
      @unknown default:
         ()
      }
    }
    return path
  }

  //····················································································································

  public var pathByStroking : CGPath {
    let lineCap : CGLineCap
    switch self.lineCapStyle {
    case .butt : lineCap = .butt
    case .round : lineCap = .round
    case .square : lineCap = .square
    @unknown default:
      lineCap = .round
    }
    let lineJoin : CGLineJoin
    switch self.lineJoinStyle {
    case .bevel : lineJoin = .bevel
    case .miter : lineJoin = .miter
    case .round : lineJoin = .round
    @unknown default:
      lineJoin = .round
    }
    return self.cgPath.copy (
      strokingWithWidth: self.lineWidth,
      lineCap: lineCap,
      lineJoin: lineJoin,
      miterLimit: self.miterLimit
    )
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
