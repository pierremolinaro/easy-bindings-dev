//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension EBView {

  //····················································································································

  override func mouseMoved (with inEvent : NSEvent) {
    super.mouseMoved (with: inEvent)
    self.updateXYplacards (inEvent.locationInWindow)
  }

  //····················································································································

  override func mouseExited (with inEvent : NSEvent) {
    super.mouseExited (with: inEvent)
    self.clearXYplacards ()
  }

  //····················································································································

   override func mouseDown (with inEvent : NSEvent) {
    let selectedObjectSet = self.viewController?.selectedGraphicObjectSet ?? Set ()
    let mouseDownLocation = self.convert (inEvent.locationInWindow, from:nil)
    mLastMouseDraggedLocation = mouseDownLocation
    if let viewController = self.viewController {
    //--- Find index of object under mouse down
      let (possibleObjectIndex, possibleKnobIndex) = self.indexOfFrontmostObject (at: mouseDownLocation)
      let controlKey = inEvent.modifierFlags.contains (.control)
      if !controlKey {
        let shiftKey = inEvent.modifierFlags.contains (.shift)
        let commandKey = inEvent.modifierFlags.contains (.command)
        if shiftKey { // Shift key extends selection
          if let objectIndex = possibleObjectIndex {
            viewController.addToSelection (objectsWithIndex: [objectIndex])
          }
        }else if commandKey { // Command key toggles selection of object under click
          if let objectIndex = possibleObjectIndex {
            if viewController.selectedIndexesSet.contains (objectIndex) {
              viewController.removeFromSelection (objectWithIndex: objectIndex)
            }else{
              viewController.addToSelection (objectsWithIndex: [objectIndex])
            }
          }
        }else if let objectIndex = possibleObjectIndex {
          if let knobIndex = possibleKnobIndex {
            mPossibleKnob = (objectIndex, knobIndex)
          }
          if !viewController.selectedIndexesSet.contains (objectIndex) {
            viewController.setSelection (objectsWithIndexes: [objectIndex])
          }
        }else{ // Click outside an object : clear selection
          viewController.clearSelection ()
          mSelectionRectangleOrigin = mLastMouseDraggedLocation
        }
      }
    }else if selectedObjectSet.count > 0, let pbType = self.pasteboardType, inEvent.modifierFlags.contains (.option) {
      self.ebStartDragging (with: inEvent, dragType: pbType)
    }else{
      super.mouseDown (with: inEvent)
    }
  }

  //····················································································································

  override func mouseDragged (with inEvent : NSEvent) {
    super.mouseDragged (with: inEvent)
    self.updateXYplacards (inEvent.locationInWindow)
    let mouseDraggedLocation = self.convert (inEvent.locationInWindow, from:nil)
    if let selectionRectangleOrigin = mSelectionRectangleOrigin {
      self.handleSelectionRectangle (from: selectionRectangleOrigin, to: mouseDraggedLocation)
    }else if let lastMouseDraggedLocation = mLastMouseDraggedLocation {
      var proposedTranslation = CGPoint (
        x: mouseDraggedLocation.x - lastMouseDraggedLocation.x,
        y:mouseDraggedLocation.y - lastMouseDraggedLocation.y
      )
      if mDraggingObjectsIsAlignedOnArrowKeyMagnitude {
        let stepX = proposedTranslation.x / self.arrowKeyMagnitude
        proposedTranslation.x = stepX.rounded (.towardZero) * self.arrowKeyMagnitude ;
        let stepY = proposedTranslation.y / self.arrowKeyMagnitude
        proposedTranslation.y = stepY.rounded (.towardZero) * self.arrowKeyMagnitude ;
      }
      if let (objectIndex, knobIndex) = self.mPossibleKnob {
        self.drag (knob: knobIndex, objectIndex: objectIndex,proposedTranslation, lastMouseDraggedLocation)
      }else{
        self.dragSelection (proposedTranslation, lastMouseDraggedLocation)
      }
    }
  }

  //····················································································································

  fileprivate func handleSelectionRectangle (from inSelectionRectangleOrigin : NSPoint,
                                             to inMouseDraggedLocation : NSPoint) {
    let xMin = min (inSelectionRectangleOrigin.x, inMouseDraggedLocation.x)
    let yMin = min (inSelectionRectangleOrigin.y, inMouseDraggedLocation.y)
    let xMax = max (inSelectionRectangleOrigin.x, inMouseDraggedLocation.x)
    let yMax = max (inSelectionRectangleOrigin.y, inMouseDraggedLocation.y)
    let r = NSRect (x:xMin, y:yMin, width:xMax-xMin, height:yMax-yMin)
    var shapes = [EBShape] ()
    let bp = NSBezierPath (rect: r)
    bp.lineWidth = 0.0
    shapes.append (EBFilledBezierPathShape ([bp], NSColor.lightGray.withAlphaComponent (0.2)))
    shapes.append (EBStrokeBezierPathShape ([bp], NSColor.lightGray))
    self.selectionRectangleLayer = EBShape (shapes: shapes)
    let indexSet = self.indexesOfObjects (intersecting:r)
    self.viewController?.setSelection (objectsWithIndexes: Array (indexSet))
  }

  //····················································································································

  fileprivate func drag (knob knobIndex : Int,
                         objectIndex : Int,
                         _ inProposedTranslation: CGPoint,
                         _ inLastMouseDraggedLocation : CGPoint) {
    let objects = self.viewController?.objectArray ?? []
    if objects [objectIndex].canMove (knob: knobIndex, by: inProposedTranslation) {
      if !self.mPerformEndUndoGroupingOnMouseUp {
        self.mPerformEndUndoGroupingOnMouseUp = true
        self.viewController?.undoManager?.beginUndoGrouping ()
      }
      objects [objectIndex].move (knob: knobIndex, by: inProposedTranslation)
      let mouseDraggedLocation = CGPoint (
        x: inProposedTranslation.x + inLastMouseDraggedLocation.x,
        y: inProposedTranslation.y + inLastMouseDraggedLocation.y
      )
      mLastMouseDraggedLocation = mouseDraggedLocation
    }
  }

  //····················································································································

  fileprivate func dragSelection (_ proposedTranslation: CGPoint, _ lastMouseDraggedLocation : CGPoint) {
    var translation = proposedTranslation
    for object in self.viewController?.selectedGraphicObjectSet ?? [] {
      let p = object.acceptedTranslation (by: translation)
      translation = p
    }
    if (translation.x != 0.0) || (translation.y != 0.0) {
      if !self.mPerformEndUndoGroupingOnMouseUp {
        self.mPerformEndUndoGroupingOnMouseUp = true
        self.viewController?.undoManager?.beginUndoGrouping ()
      }
      for object in self.viewController?.selectedGraphicObjectSet ?? [] {
        object.translate (xBy: translation.x, yBy:translation.y)
      }
      let mouseDraggedLocation = CGPoint (x: translation.x + lastMouseDraggedLocation.x, y: translation.y + lastMouseDraggedLocation.y)
      mLastMouseDraggedLocation = mouseDraggedLocation
    }
  }

  //····················································································································

  override func mouseUp (with inEvent : NSEvent) {
    super.mouseUp (with: inEvent)
    if self.mPerformEndUndoGroupingOnMouseUp {
      self.mPerformEndUndoGroupingOnMouseUp = false
      self.viewController?.undoManager?.endUndoGrouping ()
    }
    self.mLastMouseDraggedLocation = nil
    self.mSelectionRectangleOrigin = nil
    self.selectionRectangleLayer = nil
    self.mPossibleKnob = nil
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
