import Cocoa

%
for () in ATTRIBUTE_LIST_FOR_GENERATION do
%//---------------------------------------------------------------------------------------------------------------------*

protocol %!ENTITY_NAME%_%!mAttributeName% {
  var %!mAttributeName% : %![mAttributeType swiftTypeName]% { get }
}

%
end
%//---------------------------------------------------------------------------------------------------------------------*

@objc(%!ENTITY_NAME%) class %!ENTITY_NAME% : PMManagedObject%
for () in ATTRIBUTE_LIST_FOR_GENERATION do
%, %!ENTITY_NAME%_%!mAttributeName
end
% {
  override func userClassName () -> String { return "%!ENTITY_NAME%" }


%for () in ATTRIBUTE_LIST_FOR_GENERATION do
%
  //-------------------------------------------------------------------------------------------------------------------*
  //    %!["Attribute: " + mAttributeName stringByRightPadding !111 !' ']%*
  //-------------------------------------------------------------------------------------------------------------------*\n\n%
%  private var %!mAttributeName%_explorer : NSTextField? = nil\n%
%  private var %!mAttributeName%_observers : [Int : PMTransientEventProtocol] = [:]\n%
%  var %!mAttributeName% : %![mAttributeType swiftTypeName]% = %!mDefaultValueInSwift% {
    didSet {
      if %!mAttributeName% != oldValue {
        mUndoManager?.registerUndoWithTarget (self, selector:"undoFor_%!mAttributeName%:", object:%![mAttributeType transformerForRegisterUndoWithTarget !"oldValue"]%)
        %!mAttributeName%_explorer?.stringValue = %![mAttributeType valueAccessorForExplorerWindow !mAttributeName]%
        for object in %!mAttributeName%_observers.values {
          postTransientEvent (object)
        }
      }
    }
  }

  func undoFor_%!mAttributeName% (value : %![mAttributeType swiftTypeUndoArgument]%) {
    %!mAttributeName% = %![mAttributeType transformerForUndo !"value"]%
  }

  func addObserverOf_%!mAttributeName% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mAttributeName%_observers [inObserver.uniqueIndex] = inObserver
    if inTrigger {
      postTransientEvent (inObserver)
    }
  }
 
  func removeObserverOf_%!mAttributeName% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mAttributeName%_observers [inObserver.uniqueIndex] = nil
    if inTrigger {
      postTransientEvent (inObserver)
    }
  }
%if not mNeedsValidation then%
  func validate_%!mAttributeName% (proposedValue : %![mAttributeType swiftTypeName]%) -> PMValidationResult { return PMValidationResult.ok }

%
end
end
for () in ENTITY_CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%  //-------------------------------------------------------------------------------------------------------------------*
  //    %!["To many relationship: " + mRelationshipName stringByRightPadding !111 !' ']%*
  //-------------------------------------------------------------------------------------------------------------------*

%
for () in [mRelationshipType mObservablePropertyMap] do
if not mIsCollection then
%  private var %!mRelationshipName%_%!lkey.string%_observers : [Int : PMTransientEventProtocol] = [:]

  func addObserverOf_%!mRelationshipName%_%!lkey.string% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mRelationshipName%_%!lkey.string%_observers [inObserver.uniqueIndex] = inObserver
    for object : AnyObject in %!mRelationshipName% {
      let managedObject = object as! NameEntity
      managedObject.addObserverOf_%!lkey.string% (inObserver, inTrigger:inTrigger)
    }
  }

  func removeObserverOf_%!mRelationshipName%_%!lkey.string% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mRelationshipName%_%!lkey.string%_observers [inObserver.uniqueIndex] = nil
    for object : AnyObject in %!mRelationshipName% {
      let managedObject = object as! NameEntity
      managedObject.removeObserverOf_%!lkey.string% (inObserver, inTrigger:inTrigger)
    }
  }

  //-------------------------------------------------------------------------------------------------------------------*

%
end
end

%  private var %!mRelationshipName%_observers : [Int : PMTransientEventProtocol] = [:]
  private var %!mRelationshipName%_explorer : NSPopUpButton?
  var %!mRelationshipName% : Array<%![mRelationshipType key]%> = Array () {
    didSet {
      if oldValue != %!mRelationshipName% {
      //--- Register old value in undo manager
        mUndoManager?.registerUndoWithTarget (self, selector:"undoFor_%!mRelationshipName%:", object:oldValue)
      //--- Update explorer
        if %!mRelationshipName%_explorer != nil {
          updateManagedObjectToManyRelationshipDisplayForKey ("%!mRelationshipName%", popUpButton:%!mRelationshipName%_explorer)
        }
      //--- Removed object set
        var removedObjectSet : Set<%![mRelationshipType key]%> = Set (oldValue)
        removedObjectSet.subtractInPlace (%!mRelationshipName%)
        for managedObject : %![mRelationshipType key]% in removedObjectSet {
%for () in [mRelationshipType mObservablePropertyMap] do
if not mIsCollection then
%          for observer in %!mRelationshipName%_%!lkey.string%_observers.values {
            managedObject.removeObserverOf_%!lkey.string% (observer, inTrigger:true)
          }
%end
end
%          managedObject.%!mOppositeRelationshipName% = nil ;
        }
      //--- Added object set
        var addedObjectSet : Set<%![mRelationshipType key]%> = Set (%!mRelationshipName%)
        addedObjectSet.subtractInPlace (oldValue)
        for managedObject : %![mRelationshipType key]% in addedObjectSet {
%for () in [mRelationshipType mObservablePropertyMap] do
if not mIsCollection then
%          for observer in %!mRelationshipName%_%!lkey.string%_observers.values {
            managedObject.addObserverOf_%!lkey.string% (observer, inTrigger:true)
          }
%end
end
%          managedObject.%!mOppositeRelationshipName% = self
        }
      //--- Notify observers object count did change
        for object in %!mRelationshipName%_observers.values {
          postTransientEvent (object)
        }
      }
    }
  }

  func undoFor_%!mRelationshipName% (object:NSArray) {
    %!mRelationshipName% = object as! Array<%![mRelationshipType key]%>
  }

  func addObserverOf_%!mRelationshipName% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mRelationshipName%_observers [inObserver.uniqueIndex] = inObserver
    if inTrigger {
      postTransientEvent (inObserver)
    }
  }

  func removeObserverOf_%!mRelationshipName% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mRelationshipName%_observers [inObserver.uniqueIndex] = nil
    if inTrigger {
      postTransientEvent (inObserver)
    }
  }
  
  var %!mRelationshipName%_count : Int { get { return %!mRelationshipName%.count } }

  func addObserverOf_%!mRelationshipName%_count (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    addObserverOf_%!mRelationshipName% (inObserver, inTrigger:inTrigger)
  }

  func removeObserverOf_%!mRelationshipName%_count (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    removeObserverOf_%!mRelationshipName% (inObserver, inTrigger:inTrigger)
  }
%
  end
end

for () in ENTITY_CURRENT_RELATIONSHIP_LIST do
  if not mIsToMany then
%  //-------------------------------------------------------------------------------------------------------------------*
  //    %!["To one relationship: " + mRelationshipName stringByRightPadding !111 !' ']%*
  //-------------------------------------------------------------------------------------------------------------------*

  private var %!mRelationshipName%_observers : [Int : PMTransientEventProtocol] = [:]
  private var %!mRelationshipName%_explorer : NSButton?
  var %!mRelationshipName% : %![mRelationshipType key]%? = nil {
    didSet {
      if oldValue !== %!mRelationshipName% {
      //--- Register old value in undo manager
        mUndoManager?.registerUndoWithTarget (self, selector:"undoFor_%!mRelationshipName%:", object:oldValue)
      //--- Update explorer
        if %!mRelationshipName%_explorer != nil {
          updateManagedObjectToOneRelationshipDisplayForKey ("%!mRelationshipName%", button : %!mRelationshipName%_explorer)
        }
%    if mOppositeRelationshipIsToMany then
%      //--- Reset old opposite relation ship
        if let unwrappedOldValue = oldValue {
          let idx = unwrappedOldValue.%!mOppositeRelationshipName%.indexOfObjectIdenticalTo (self)
          if idx != NSNotFound {
            var array = unwrappedOldValue.%!mOppositeRelationshipName%.mutableCopy () as! NSMutableArray
            array.removeObjectAtIndex (idx)
            unwrappedOldValue.%!mOppositeRelationshipName% = array
          }
        }
      //--- Set new opposite relation ship
        if let root = %!mRelationshipName% {
          let idx = root.%!mOppositeRelationshipName%.indexOfObjectIdenticalTo (self)
          if idx == NSNotFound {
            var array = root.%!mOppositeRelationshipName%.mutableCopy () as! NSMutableArray
            array.addObject (self)
            root.%!mOppositeRelationshipName% = array
          }
        }
%    else
%     //--- Reset old opposite relation ship
        oldValue?.%!mOppositeRelationshipName% = nil
      //--- Set new opposite relation ship
        %!mRelationshipName%?.%!mOppositeRelationshipName% = self
%    end
%      //--- Notify observers
        for object in %!mRelationshipName%_observers.values {
          postTransientEvent (object)
        }
      }
    }
  }

  func undoFor_%!mRelationshipName% (object:%![mRelationshipType key]%) {
    %!mRelationshipName% = object
  }

  func addObserverOf_%!mRelationshipName% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mRelationshipName%_observers [inObserver.uniqueIndex] = inObserver
    if inTrigger {
      postTransientEvent (inObserver)
    }
  }

  func removeObserverOf_%!mRelationshipName% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mRelationshipName%_observers [inObserver.uniqueIndex] = nil
    if inTrigger {
      postTransientEvent (inObserver)
    }
  }
%
  end
end

if [TRANSIENT_LIST_FOR_IMPLEMENTATION length] > 0 then
%
  //-------------------------------------------------------------------------------------------------------------------*
  //    init                                                                                                           *
  //-------------------------------------------------------------------------------------------------------------------*

  override init (undoManager : NSUndoManager) {
    super.init (undoManager:undoManager)
  //--- Register trigger objects
%
for () in TRANSIENT_LIST_FOR_IMPLEMENTATION do
for () in mDependencyList do
%    %![mDependency generateAddObserverCall]% (event_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%, inTrigger:true)\n%
end
end
%  }
%
end
%
  //-------------------------------------------------------------------------------------------------------------------*
  //  prepareForDeletion                                                                                               *
  //-------------------------------------------------------------------------------------------------------------------*

  override func prepareForDeletion () {
    super.prepareForDeletion ()
%
for () in ENTITY_CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
    %    %!mRelationshipName% = Array<%![mRelationshipType key]%> ()\n%
  else
    %    %!mRelationshipName% = nil\n%
  end
end
%  }
  
%
if [TRANSIENT_LIST_FOR_IMPLEMENTATION length] > 0 then
%
  //-------------------------------------------------------------------------------------------------------------------*
  //    deinit                                                                                                         *
  //-------------------------------------------------------------------------------------------------------------------*

  deinit {
  //--- Unregister trigger objects
%
for () in TRANSIENT_LIST_FOR_IMPLEMENTATION do
for () in mDependencyList do
%    %![mDependency generateRemoveObserverCall]% (event_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%, inTrigger:false)\n%
end
end
%  }
%
end
%
  //-------------------------------------------------------------------------------------------------------------------*
  //    populateExplorerWindowWithRect                                                                                 *
  //-------------------------------------------------------------------------------------------------------------------*

  override func populateExplorerWindowWithRect (inout ioRect : NSRect, view : NSView) {
    super.populateExplorerWindowWithRect (&ioRect, view:view)
%for () in ATTRIBUTE_LIST_FOR_GENERATION do
%    %!mAttributeName%_explorer = createEntryForAttributeNamed ("%!mAttributeName%", ioRect:&ioRect, view:view)\n%
%    if let explorer = %!mAttributeName%_explorer {\n%
%      explorer.stringValue = %![mAttributeType valueAccessorForExplorerWindow !mAttributeName]%\n%
%    }\n%
end
for () in ENTITY_CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%    %!mRelationshipName%_explorer = createEntryForToManyRelationshipNamed ("%!mRelationshipName%", ioRect: &ioRect, view: view)
    updateManagedObjectToManyRelationshipDisplayForKey ("%!mRelationshipName%", popUpButton:%!mRelationshipName%_explorer!)\n%
  else
%    %!mRelationshipName%_explorer = createEntryForToOneRelationshipNamed ("%!mRelationshipName%", ioRect: &ioRect, view: view)
    updateManagedObjectToOneRelationshipDisplayForKey ("%!mRelationshipName%", button:%!mRelationshipName%_explorer!)\n%
  end
end%  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    clearObjectExplorer                                                                                            *
  //-------------------------------------------------------------------------------------------------------------------*

  override func clearObjectExplorer () {
%for () in ATTRIBUTE_LIST_FOR_GENERATION do
%    %!mAttributeName%_explorer = nil\n%
end
for () in ENTITY_CURRENT_RELATIONSHIP_LIST do
%    %!mRelationshipName%_explorer = nil\n%
end
%    super.clearObjectExplorer ()
  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    saveIntoDictionary                                                                                             *
  //-------------------------------------------------------------------------------------------------------------------*

  override func saveIntoDictionary (ioDictionary : NSMutableDictionary) {
    super.saveIntoDictionary (ioDictionary)
%for () in ATTRIBUTE_LIST_FOR_GENERATION do
%    ioDictionary.setValue (%![mAttributeType transformForSavingInDictionary !mAttributeName]%, forKey: "%!mAttributeName%")\n%
end
for () in ENTITY_CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%    storeEntityArrayInDictionary (%!mRelationshipName%, inRelationshipName:"%!mRelationshipName%", ioDictionary:ioDictionary) ;\n%
  end
end
%  }

  //-------------------------------------------------------------------------------------------------------------------*
  //    setUpWithDictionary                                                                                            *
  //-------------------------------------------------------------------------------------------------------------------*

  override func setUpWithDictionary (inDictionary : NSDictionary,
                                     managedObjectArray : NSArray) {
    super.setUpWithDictionary (inDictionary, managedObjectArray:managedObjectArray)
%for () in ATTRIBUTE_LIST_FOR_GENERATION do
%    %!mAttributeName% = inDictionary.read%![mAttributeType swiftTypeName]% ("%!mAttributeName%")\n%
end
for () in ENTITY_CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%    %!mRelationshipName% = readEntityArrayFromDictionary ("%!mRelationshipName%", inDictionary:inDictionary, managedObjectArray:managedObjectArray)\n%
  elsif not mOppositeRelationshipIsToMany then
%    %!mRelationshipName% = readEntityFromDictionary ("%!mRelationshipName%", inDictionary:inDictionary, managedObjectArray:managedObjectArray) as? %![mRelationshipType key]%\n%
  end
end
%  }

%
for () in TRANSIENT_LIST_FOR_IMPLEMENTATION do
%  //-------------------------------------------------------------------------------------------------------------------*
  //    %!["Transient: " + mTransientName stringByRightPadding !111 !' ']%*
  //-------------------------------------------------------------------------------------------------------------------*\n\n%
%  private var %!mTransientName%_observers : [Int : PMTransientEventProtocol] = [:]\n%
%  private var %!mTransientName%_cache : %![mTransientType swiftTypeName]%?\n%
%  var %!mTransientName% : %![mTransientType swiftTypeName]% {\n%
%    get {\n%
%      if %!mTransientName%_cache == nil {\n%
%        %!mTransientName%_cache = compute_%!ENTITY_NAME%_%!mTransientName% (%
for () in mDependencyList
do ![mDependency generateActualParameterForComputeFunction]
between %, %
end
%)\n%
%      }\n%
%      return %!mTransientName%_cache!\n%
%    }
    set {
    }
  }

  func %!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%_noteDidChange () {
    %!mTransientName%_cache = nil
  }

  func %!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%_trigger () {
    for object in %!mTransientName%_observers.values {
      postTransientEvent (object)
    }
  }

   func addObserverOf_%!mTransientName% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mTransientName%_observers [inObserver.uniqueIndex] = inObserver
    if inTrigger {
      postTransientEvent (inObserver)
    }
  }
 
  func removeObserverOf_%!mTransientName% (inObserver : PMTransientEventProtocol, inTrigger:Bool) {
    %!mTransientName%_observers [inObserver.uniqueIndex] = nil
    if inTrigger {
      postTransientEvent (inObserver)
    }
  }

  var event_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%_cache : PMEvent_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%? = nil
  var event_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]% : PMEvent_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]% {
    if nil == event_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%_cache {
      event_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%_cache = PMEvent_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]% (object:self)
    }
    return event_%!["entity." + ENTITY_NAME + "." + mTransientName identifierRepresentation]%_cache!
  }
 
%
end
%  //-------------------------------------------------------------------------------------------------------------------*
  //   accessibleObjects                                                                                               *
  //-------------------------------------------------------------------------------------------------------------------*

  override func accessibleObjects (inout objects : NSMutableArray) {
    super.accessibleObjects (&objects)
%for () in ENTITY_CURRENT_RELATIONSHIP_LIST do
  if mIsToMany then
%    for object : AnyObject in %!mRelationshipName% {
      let managedObject = object as! PMManagedObject
      objects.addObject (managedObject)
    }\n%
  else
%    if %!mRelationshipName% != nil {\n%
%      objects.addObject (%!mRelationshipName%!)\n%
%    }\n%
  end
end%  }

  //-------------------------------------------------------------------------------------------------------------------*

}

