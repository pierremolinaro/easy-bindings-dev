#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   AST                                                                                                                *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @toOneRelationshipList {
  @lstring mDestinationEntityName
  @lstring mToOneRelationshipName
  @lstring mInverseRelationshipName # Empty string if not inverse relation ship
  @propertyMultiplicity mInverseRelationMultiplicity
  @bool mCascading
}

#·······················································································································

list @toManyRelationshipList {
  @lstring mDestinationEntityName
  @lstring mToManyRelationshipName
  @lstring mInverseRelationshipName
  @bool mCascading
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SYNTAX                                                                                                             *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <toMany_relationship> ?!@toManyRelationshipList ioToManyRelationshipList ?!@stringset ioSignatureList {
    $toMany$
    @bool usedForSignature = false
    @bool cascading = false
    repeat
    while
      $@attribute$ ?let attributeName
      if attributeName.string == "signature" then
        if usedForSignature then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        usedForSignature = true
      elsif attributeName.string == "cascading" then
        if cascading then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        cascading = true
      else
        error attributeName : "unknow attribute" fixit { replace "@signature" replace "@cascading" }
      end
    end
    $Identifier$ ?let destinationEntityName
    $identifier$ ?let relationshipName
    if usedForSignature then
      ioSignatureList += !relationshipName.string
    end
    @lstring inserseRelationshipName
    select
      $inverse$
      $toOne$
      $identifier$ ?inserseRelationshipName
    or
      inserseRelationshipName = .new {!"" !relationshipName.location}
    end
    $;$
    ioToManyRelationshipList +=
      !destinationEntityName
      !relationshipName
      !inserseRelationshipName
      !cascading
  }
  
  #·····················································································································

   rule <toOne_relationship> ?!@toOneRelationshipList ioToOneRelationshipList {
    $toOne$
    @bool cascading = false
    repeat
    while
      $@attribute$ ?let attributeName
      if attributeName.string == "cascading" then
        if cascading then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        cascading = true
      else
        error attributeName : "unknow attribute" fixit { replace "@cascading" }
      end
    end
    $Identifier$ ?let @lstring destinationEntityName
    $identifier$ ?let @lstring relationshipName
    @propertyMultiplicity inverseRelationMultiplicity
    @lstring inverseRelationshipName
    select
      inverseRelationMultiplicity = .single
      inverseRelationshipName = ["" here]
    or
      $inverse$
      select
        $toOne$
        inverseRelationMultiplicity = .single
      or
        $toMany$
        inverseRelationMultiplicity = .collection
      end
      $identifier$ ?inverseRelationshipName
      end
    $;$
    ioToOneRelationshipList +=
      !destinationEntityName
      !relationshipName
      !inverseRelationshipName
      !inverseRelationMultiplicity
      !cascading
  }
  
  #·····················································································································

}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   TYPE INVENTORY                                                                                                     *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

method @toOneRelationshipList typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  for () in self do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mDestinationEntityName
      ?*
    ]
  end
}

#·······················································································································

method @toManyRelationshipList typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  for () in self do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mDestinationEntityName
      ?*
    ]
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   OBSERVABLE PROPERTY MAP                                                                                            *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

method @toOneRelationshipList buildObservablePropertyMap
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMap ioObservableProperties
{
  for () in self do
  #--- Property type
    [inUnifiedTypeMap searchKey !mDestinationEntityName ?let type ?let actionMap]
  #--- Check type
    @bool graphic
    switch type
    case boolType, integerType, stringType, dateType, doubleType, fontType, colorType :
      error mDestinationEntityName: "a simple type cannot be used as entitytype" : graphic
    case enumType (* *) :
      error mDestinationEntityName: "an enumeration type cannot be used as entitytype" : graphic
    case classType (*) :
      error mDestinationEntityName: "a class type cannot be used as entitytype" : graphic
    case transientPropertyExternType (*) :
      error mInverseRelationshipName: "the opposite type cannot be used as entity type" : graphic
    case entityType (* isGraphic) : # Ok
      graphic = isGraphic
    end
  #--- Enter in property map
    [!?ioObservableProperties insertKey
      !mToOneRelationshipName
      !.toOne {!type: type !typeName: mDestinationEntityName !readOnly: false !graphic: graphic}
      !mInverseRelationshipName.string
      !actionMap
      !mCascading
    ]
  end
}

#·······················································································································

method @toManyRelationshipList buildObservablePropertyMap
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMap ioObservableProperties
{
  for () in self do
  #--- Property type
    [inUnifiedTypeMap searchKey !mDestinationEntityName ?let type ?let actionMap]
  #--- Check type
    @bool graphic
    switch type
    case boolType, integerType, stringType, dateType, doubleType, fontType, colorType :
      error mDestinationEntityName: "a simple type cannot be used as entitytype" : graphic
    case enumType (* *) :
      error mDestinationEntityName: "an enumeration type cannot be used as entitytype" : graphic
    case classType (*) :
      error mDestinationEntityName: "a class type cannot be used as entitytype" : graphic
    case transientPropertyExternType (*) :
      error mInverseRelationshipName: "the opposite type cannot be used as entity type" : graphic
    case entityType (* isGraphic) : # Ok
      graphic = isGraphic
    end
  #--- Enter in property map
    [!?ioObservableProperties insertKey
      !mToManyRelationshipName
      !.toMany {!type: type !typeName: mDestinationEntityName !readOnly: false !graphic: graphic}
      !mInverseRelationshipName.string
      !actionMap
      !mCascading
    ]
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

method @toOneRelationshipList semanticAnalysis
  ?let @semanticContext inSemanticContext
  !@toOneEntityRelationshipListForGeneration outToOneEntityRelationshipListForGeneration
{
  outToOneEntityRelationshipListForGeneration = {}
  for () in self do
    [inSemanticContext.mUnifiedTypeMap searchKey !mDestinationEntityName ?let type ?*]
    [inSemanticContext.mEntityObservablePropertyMap searchKey
      !mDestinationEntityName
      ?@observablePropertyMap destinationEntityObservablePropertyMap
    ]
    outToOneEntityRelationshipListForGeneration +=
      !mToOneRelationshipName.string
      !type
      !mInverseRelationshipName.string
      !mInverseRelationMultiplicity
      !destinationEntityObservablePropertyMap
      !mCascading
  #--- Check inverse relationship
    if mInverseRelationshipName.string != "" then
      [destinationEntityObservablePropertyMap searchForInverseRelationship
         !mInverseRelationshipName
         ?let @propertyKind oppositeKind
         ?let @string oppositeOfOpposite
         ?2*
       ]
     #--- Check opposite type
      switch [oppositeKind type]
      case boolType, integerType, stringType, dateType, doubleType, fontType, colorType :
        error mInverseRelationshipName: "the opposite type cannot be used as entity type"
      case enumType (* *) :
        error mInverseRelationshipName: "the opposite type cannot be used as entity type"
      case classType (*) :
        error mInverseRelationshipName: "the opposite type cannot be used as entity type"
      case transientPropertyExternType (*) :
        error mInverseRelationshipName: "the opposite type cannot be used as entity type"
      case entityType (2*) : # Ok
      end
      switch oppositeKind 
      case property (2*) :
        error mInverseRelationshipName : "a property cannot be an opposite of a relationship"
      case toMany (2* @bool readOnly *) :
        if readOnly then
          error mInverseRelationshipName : "this relationship is transient, should be stored"
        end
        if mInverseRelationMultiplicity != .collection then
          error mInverseRelationshipName : "inverse relationship multiplicity error (toMany <-> toOne)"
        end
      case toOne (2* @bool readOnly *) :
        if readOnly then
          error mInverseRelationshipName : "this relationship is transient, should be stored"
        end
        if mInverseRelationMultiplicity != .single then
          error mInverseRelationshipName : "inverse relationship multiplicity error (toMany <-> toOne)"
        end
      case arrayController (3*) :
         error mInverseRelationshipName : "an array controller cannot be an opposite of a relationship"
      case selectionController (2*) :
         error mInverseRelationshipName : "a selection controller cannot be an opposite of a relationship"
      end
      if oppositeOfOpposite != mToOneRelationshipName.string then
        error mInverseRelationshipName : "inverse relationship does not name '"
           + mToOneRelationshipName + "' as opposite"
      end
    end
  end
}

#·······················································································································

method @toManyRelationshipList semanticAnalysis
  ?let @semanticContext inSemanticContext
  !@toManyEntityRelationshipListForGeneration outToManyEntityRelationshipListForGeneration
{
  outToManyEntityRelationshipListForGeneration = {}
  for () in self do
    [inSemanticContext.mUnifiedTypeMap searchKey !mDestinationEntityName ?let type ?*]
    [inSemanticContext.mEntityObservablePropertyMap searchKey
      !mDestinationEntityName
      ?@observablePropertyMap destinationEntityObservablePropertyMap
    ]
    outToManyEntityRelationshipListForGeneration +=
      !mToManyRelationshipName.string
      !type
      !mInverseRelationshipName.string
      !destinationEntityObservablePropertyMap
      !mCascading
  #--- Check inverse relationship
    if mInverseRelationshipName.string != "" then
      [destinationEntityObservablePropertyMap searchForInverseRelationship
         !mInverseRelationshipName
         ?let @propertyKind oppositeKind
         ?let @string oppositeOfOpposite
         ?2*
      ]
      switch [oppositeKind type]
      case boolType, integerType, stringType, dateType, doubleType, fontType, colorType :
        error mInverseRelationshipName: "the opposite type cannot be used as entity type"
      case enumType (* *) :
        error mInverseRelationshipName: "the opposite type cannot be used as entity type"
      case classType (*) :
        error mInverseRelationshipName: "the opposite type cannot be used as entity type"
      case transientPropertyExternType (*) :
        error mInverseRelationshipName: "the opposite type cannot be used as entity type"
      case entityType (2*) : # Ok
      end
      switch oppositeKind 
      case property (2*) :
        error mInverseRelationshipName : "a property cannot be an opposite of a relationship"
      case toMany (2* @bool readOnly *) :
        if readOnly then
          error mInverseRelationshipName : "this relationship is transient, should be stored"
        end
#        if mInverseRelationMultiplicity != .collection then
#          error mInverseRelationshipName : "inverse relationship multiplicity error (toMany <-> toOne)"
#        end
      case toOne (2* @bool readOnly *) :
        if readOnly then
          error mInverseRelationshipName : "this relationship is transient, should be stored"
        end
#        if mInverseRelationMultiplicity != .single then
#          error mInverseRelationshipName : "inverse relationship multiplicity error (toMany <-> toOne)"
#        end
      case arrayController (3*) :
         error mInverseRelationshipName : "an array controller cannot be an opposite of a relationship"
      case selectionController (2*) :
         error mInverseRelationshipName : "a selection controller cannot be an opposite of a relationship"
      end
      if oppositeOfOpposite != mToManyRelationshipName.string then
        error mInverseRelationshipName : "inverse relationship does not name '"
           + mToManyRelationshipName + "' as opposite"
      end
    end
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION TYPES                                                                                                   *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @toOneEntityRelationshipListForGeneration {
  @string mToOneRelationshipName
  @typeKind mRelationshipType
  @string mOppositeRelationshipName
  @propertyMultiplicity mInverseRelationMultiplicity
  @observablePropertyMap mDestinationEntityObservablePropertyMap
  @bool mCascading
}

#·······················································································································

list @toManyEntityRelationshipListForGeneration {
  @string mToManyRelationshipName
  @typeKind mRelationshipType
  @string mOppositeRelationshipName
  @observablePropertyMap mDestinationEntityObservablePropertyMap
  @bool mCascading
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
