#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @transientPropertyTypeDeclaration : @astDeclaration {
  @lstring mPropertyTypeName
  @bool mIsClass # Is false, struct
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <class_declaration>
    ?let @bool inIsUserDefined
    ?!@astDeclarationStruct ioDeclarationAST
  {
    $transient$
    $property$
    @bool isClass
    select
      $class$
      isClass = true
    or
      $struct$
      isClass = false
    end
    $Identifier$ ?let @lstring propertyTypeName
    $;$
    ioDeclarationAST.mDeclarationList += !@transientPropertyTypeDeclaration.new {
      !inIsUserDefined
      !propertyTypeName
      !isClass
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TYPE INVENTORY                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @transientPropertyTypeDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  [!?ioUnifiedTypeMap insertKey
    !mPropertyTypeName
    !.transientPropertyExternType {!externTypeName:mPropertyTypeName.string}
    !{}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Only get current entity observable properties, do not collect in super entities
override method @transientPropertyTypeDeclaration buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@semanticContext unused ioSemanticContext
{
}

#·······················································································································

override method @transientPropertyTypeDeclaration buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList unused ioSecondaryDeclarationListWorkingList
  ?!@uint unused ioSecondaryDeclarationCount
{
}

#·······················································································································

override method @transientPropertyTypeDeclaration solveSecondaryProperty
  ?!@semanticContext unused ioSemanticContext
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @secondaryPropertyList unused inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties
{
  outUnsolvedProperties = {}
}

#·······················································································································

override method @transientPropertyTypeDeclaration semanticAnalysis
  ?let @semanticContext unused inSemanticContext
  ?!@structForGeneration ioGeneration
{
  ioGeneration.mTransientPropertyTypeList += !mPropertyTypeName.string !mIsClass
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
