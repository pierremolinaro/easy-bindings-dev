#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @transientPropertyTypeDeclarationEX : @astDeclaration {
  @lstring mPropertyTypeName
  @bool mIsClass # Is false, struct
}

#·······················································································································

class @transientClassDeclarationAST : @abstractDeclarationAST {
  @bool mIsClass # Is false, struct
}

#·······················································································································

override method @transientClassDeclarationAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  [!?ioGraph addNode !mClassName !self]
}

#·······················································································································

override getter @transientClassDeclarationAST lkey -> @lstring {
  result = mClassName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <class_declaration>
    ?let @bool inIsUserDefined
    ?!@astDeclarationStruct ioDeclarationAST
  {
    $transient$
    $property$
    @bool isClass
    select
      $class$
      isClass = true
    or
      $struct$
      isClass = false
    end
    $Identifier$ ?let @lstring propertyTypeName
    $;$
    ioDeclarationAST.mDeclarationList += !@transientPropertyTypeDeclarationEX.new {
      !inIsUserDefined
      !propertyTypeName
      !isClass
    }
    ioDeclarationAST.mUnifiedDeclarationList += !@transientClassDeclarationAST.new {
      !propertyTypeName
      !isClass
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @transientClassDeclarationAST classAndPropertySemanticAnalysis
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  [!?ioSemanticContext.mClassMap insertKey
    !mClassName
    !.atomic {!kind: .transientPropertyExternType {!externTypeName: mClassName}}
    !{}
    !{}
    !{}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SECOND ANALYSIS PHASE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @transientClassDeclarationAST secondAnalysisPhase
       ?!@semanticContext unused ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TYPE INVENTORY                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @transientPropertyTypeDeclarationEX typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  [!?ioUnifiedTypeMap insertKey
    !mPropertyTypeName
    !.transientPropertyExternType {!externTypeName:mPropertyTypeName.string}
    !{}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Only get current entity observable properties, do not collect in super entities
override method @transientPropertyTypeDeclarationEX buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@semanticContextEX unused ioSemanticContext
{
}

#·······················································································································

override method @transientPropertyTypeDeclarationEX buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList unused ioSecondaryDeclarationListWorkingList
  ?!@uint unused ioSecondaryDeclarationCount
{
}

#·······················································································································

override method @transientPropertyTypeDeclarationEX solveSecondaryProperty
  ?!@semanticContextEX unused ioSemanticContext
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @secondaryPropertyList unused inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties
  ?!@simpleStoredPropertyListForGenerationEX unused ioSimpleStoredPropertyListForGeneration
{
  outUnsolvedProperties = {}
}

#·······················································································································

override method @transientPropertyTypeDeclarationEX semanticAnalysis
  ?let @semanticContextEX unused inSemanticContext
  ?!@generationStruct ioGeneration
{
  ioGeneration.mTransientPropertyTypeList += !mPropertyTypeName.string !mIsClass
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
