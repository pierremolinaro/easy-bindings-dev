#-----------------------------------------------------------------------------------------------------------------------
#   AST   
#-----------------------------------------------------------------------------------------------------------------------

enum @multipleBindingDescriptor {
  case noBinding 
  case binding (@abstractBooleanMultipleBindingExpressionAST expression)
}

#·······················································································································

enum @multipleBindingComparisonAST {
  case equal
  case notEqual
  case lower
  case lowerOrEqual
  case greater
  case greaterOrEqual
}

#·······················································································································

abstract refclass @abstractBooleanMultipleBindingExpressionAST {
}

#·······················································································································

refclass @literalIntMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  public var @luint mValue
}

#·······················································································································

refclass @negateBooleanMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  public var @abstractBooleanMultipleBindingExpressionAST mBinding
}

#·······················································································································

refclass @comparisonMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  public var @abstractBooleanMultipleBindingExpressionAST mLeftBinding
  public var @multipleBindingComparisonAST mOperator
  public var @abstractBooleanMultipleBindingExpressionAST mRightBinding
}

#·······················································································································

refclass @andBooleanMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  public var @abstractBooleanMultipleBindingExpressionAST mLeftBinding
  public var @abstractBooleanMultipleBindingExpressionAST mRightBinding
}

#·······················································································································

refclass @orBooleanMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  public var @abstractBooleanMultipleBindingExpressionAST mLeftBinding
  public var @abstractBooleanMultipleBindingExpressionAST mRightBinding
}

#·······················································································································

refclass @xorBooleanMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  public var @abstractBooleanMultipleBindingExpressionAST mLeftBinding
  public var @abstractBooleanMultipleBindingExpressionAST mRightBinding
}

#·······················································································································

refclass @observablePropertyInMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  public var @observablePropertyAST mProperty
}

#-----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
#-----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <booleanMultipleBindingExpression> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    <booleanMultipleBindingComparison> ?outBinding
    repeat
    while
      $&$
      <booleanMultipleBindingComparison> ?let @abstractBooleanMultipleBindingExpressionAST binding
      outBinding = @andBooleanMultipleBindingExpressionAST. new { !outBinding !binding}
    end
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingComparison>  !@abstractBooleanMultipleBindingExpressionAST outBinding {
    <booleanMultipleBindingTerm> ?outBinding
    select
    or
      $>$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.greater !rightBinding}
    or
      $>=$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.greaterOrEqual !rightBinding}
    or
      $<=$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.lowerOrEqual !rightBinding}
    or
      $<$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.lower !rightBinding}
    or
      $==$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.equal !rightBinding}
    or
      $!=$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.notEqual !rightBinding}
    end
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingTerm> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    <booleanMultipleBindingOperand> ?outBinding
    repeat
    while
      $|$
      <booleanMultipleBindingOperand> ?let @abstractBooleanMultipleBindingExpressionAST binding
      outBinding = @orBooleanMultipleBindingExpressionAST. new { !outBinding !binding}
    while
      $^$
      <booleanMultipleBindingOperand> ?let @abstractBooleanMultipleBindingExpressionAST binding
      outBinding = @xorBooleanMultipleBindingExpressionAST. new { !outBinding !binding}
    end
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingOperand> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    <observable_property> ?let @observablePropertyAST observablePropertyAST
    outBinding = @observablePropertyInMultipleBindingExpressionAST.new { !observablePropertyAST}
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingOperand> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    $!$
    <booleanMultipleBindingOperand> ?let @abstractBooleanMultipleBindingExpressionAST binding
    outBinding = @negateBooleanMultipleBindingExpressionAST. new { !binding}
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingOperand> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    $($
    <booleanMultipleBindingExpression> ?outBinding
    $)$
  }

  #·····················································································································
  
  rule <booleanMultipleBindingOperand> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    $literal_integer$ ?let value
    outBinding = @literalIntMultipleBindingExpressionAST.new {!value}
  }

  #·····················································································································

}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC TYPES                        
#-----------------------------------------------------------------------------------------------------------------------

list @multipleBindingGenerationList {
  public var @string mOutletName
  public var @string mBindingName
  public var @abstractBooleanMultipleBindingExpressionForGeneration mBoundObjectExpression
}

#·······················································································································

abstract refclass @abstractBooleanMultipleBindingExpressionForGeneration {
}

#·······················································································································

refclass @observablePropertyAsBooleanMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  public var @string mObservedModelString
}

#·······················································································································

refclass @booleanMultipleBindingLiteralIntForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  public var @uint mValue
}

#·······················································································································

refclass @negateBooleanMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  public var @abstractBooleanMultipleBindingExpressionForGeneration mBinding
}

#·······················································································································

refclass @orBooleanMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  public var @abstractBooleanMultipleBindingExpressionForGeneration mLeftBinding
  public var @abstractBooleanMultipleBindingExpressionForGeneration mRightBinding
}

#·······················································································································

refclass @xorBooleanMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  public var @abstractBooleanMultipleBindingExpressionForGeneration mLeftBinding
  public var @abstractBooleanMultipleBindingExpressionForGeneration mRightBinding
}

#·······················································································································

refclass @andBooleanMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  public var @abstractBooleanMultipleBindingExpressionForGeneration mLeftBinding
  public var @abstractBooleanMultipleBindingExpressionForGeneration mRightBinding
}

#·······················································································································

refclass @comparisonMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  public var @abstractBooleanMultipleBindingExpressionForGeneration mLeftBinding
  public var @multipleBindingComparisonAST mOperator
  public var @abstractBooleanMultipleBindingExpressionForGeneration mRightBinding
}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC                              
#-----------------------------------------------------------------------------------------------------------------------

abstract method @abstractBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation

#·······················································································································

override method @literalIntMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @bool unused inPreferences
  ?let @propertyMap unused inRootObservablePropertyMap
  ?let @semanticContext unused inSemanticContext
  ?let @propertyMap unused inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  outEnableExpression = @booleanMultipleBindingLiteralIntForGeneration.new {!self.mValue.uint}
  outType = .integerType
  outErrorLocation = self.mValue.location
}

#·······················································································································

override method @observablePropertyInMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [self.mProperty analyzeObservableProperty
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?let @propertyKind kind
    ?let @string unused swiftTypeStringForTransientFunctionArgument
  ]
  switch kind
  case property (type *) :
    outType = type
  case toMany (4*) :
    error [self.mProperty location] : "only an atomic property can be observed" : outType
  case toOne (4*) :
    error [self.mProperty location] : "only an atomic property can be observed" : outType
  case arrayController (2*) :
    error [self.mProperty location] : "only an atomic property can be observed" : outType
  case selectionController (*) :
    error [self.mProperty location] : "only an atomic property can be observed" : outType
  end
  outEnableExpression = @observablePropertyAsBooleanMultipleBindingExpressionForGeneration.new {
    ![self.mProperty modelStringForSelf !if inPreferences then "preferences_" else "self." end]
  }
  outErrorLocation = [self.mProperty location]
}

#·······················································································································

override method @negateBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [self.mBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration expression
    ?outType
    ?outErrorLocation
  ]
  if not [outType isBoolType] then
    error outErrorLocation : "cannot apply negation: operand is not boolean"
  end
  outEnableExpression = @negateBooleanMultipleBindingExpressionForGeneration.new {!expression}
}

#·······················································································································

override method @orBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [self.mLeftBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration leftExpression
    ?let outLeftType
    ?let outLeftLocation
  ]
  if not [outLeftType isBoolType] then
    error outLeftLocation : "cannot apply 'or': left operand is not boolean"
  end
  [self.mRightBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration rightExpression
    ?let outRightType
    ?let outRightLocation
  ]
  if not [outRightType isBoolType] then
    error outRightLocation : "cannot apply 'or': right operand is not boolean"
  end
  outType = .boolType
  outErrorLocation = outRightLocation
  outEnableExpression = @orBooleanMultipleBindingExpressionForGeneration. new {!leftExpression !rightExpression}
}

#·······················································································································

override method @xorBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [self.mLeftBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration leftExpression
    ?let outLeftType
    ?let outLeftLocation
  ]
  if not [outLeftType isBoolType] then
    error outLeftLocation : "cannot apply 'or': left operand is not boolean"
  end
  [self.mRightBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration rightExpression
    ?let outRightType
    ?let outRightLocation
  ]
  if not [outRightType isBoolType] then
    error outRightLocation : "cannot apply 'or': right operand is not boolean"
  end
  outType = .boolType
  outErrorLocation = outRightLocation
  outEnableExpression = @xorBooleanMultipleBindingExpressionForGeneration. new {!leftExpression !rightExpression}
}

#·······················································································································

override method @andBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [self.mLeftBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration leftExpression
    ?let outLeftType
    ?let outLeftLocation
  ]
  if not [outLeftType isBoolType] then
    error outLeftLocation : "cannot apply 'and': left operand is not boolean"
  end
  [self.mRightBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration rightExpression
    ?let outRightType
    ?let outRightLocation
  ]
  if not [outRightType isBoolType] then
    error outRightLocation : "cannot apply 'and': right operand is not boolean"
  end
  outType = .boolType
  outErrorLocation = outRightLocation
  outEnableExpression = @andBooleanMultipleBindingExpressionForGeneration. new {!leftExpression !rightExpression}
}

#·······················································································································

override method @comparisonMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [self.mLeftBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration leftExpression
    ?let outLeftType
    ?let outLeftLocation
  ]
  [self.mRightBinding analyzeExpressionForMultipleBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration rightExpression
    ?let outRightType
    ?let outRightLocation
  ]
  if not ([outLeftType isBoolType] || [outLeftType isIntegerType]) then
    error outLeftLocation : "cannot compare: left operand is neither boolean nor integer"
  end
  if outRightType != outLeftType then
    error outRightLocation : "cannot compare: right operand type is different than left operand type"
  end
  outType = .boolType
  outErrorLocation = outRightLocation
  outEnableExpression = @comparisonMultipleBindingExpressionForGeneration. new {
    !leftExpression
    !self.mOperator
    !rightExpression
  }
}

#·······················································································································

#abstract getter @abstractBooleanMultipleBindingExpressionForGeneration observedModelSet
#  -> @stringset

#·······················································································································

#override getter @booleanMultipleBindingLiteralIntForGeneration observedModelSet
#  -> @stringset outObservedModelSet
#{
#  outObservedModelSet = {}
#}

#·······················································································································

#override getter @observablePropertyAsBooleanMultipleBindingExpressionForGeneration observedModelSet
#  -> @stringset outObservedModelSet
#{
#  outObservedModelSet = {!self.mObservedModelString}
#}

#·······················································································································

#override getter @negateBooleanMultipleBindingExpressionForGeneration observedModelSet
#  -> @stringset outObservedModelSet
#{
#  outObservedModelSet = [self.mBinding observedModelSet]
#}

#·······················································································································

#override getter @orBooleanMultipleBindingExpressionForGeneration observedModelSet
#  -> @stringset outObservedModelSet
#{
#  outObservedModelSet = {[self.mLeftBinding observedModelSet], [self.mRightBinding observedModelSet]}
#}

#·······················································································································

#override getter @xorBooleanMultipleBindingExpressionForGeneration observedModelSet
#  -> @stringset outObservedModelSet
#{
#  outObservedModelSet = {[self.mLeftBinding observedModelSet], [self.mRightBinding observedModelSet]}
#}

#·······················································································································

#override getter @andBooleanMultipleBindingExpressionForGeneration observedModelSet
#  -> @stringset outObservedModelSet
#{
#  outObservedModelSet = {[self.mLeftBinding observedModelSet], [self.mRightBinding observedModelSet]}
#}

#·······················································································································

#override getter @comparisonMultipleBindingExpressionForGeneration observedModelSet
#  -> @stringset outObservedModelSet
#{
#  outObservedModelSet = {[self.mLeftBinding observedModelSet], [self.mRightBinding observedModelSet]}
#}

#·······················································································································

abstract getter @abstractBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string

#·······················································································································

override getter @booleanMultipleBindingLiteralIntForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = ".literalInt (" + [self.mValue string] + ")"
}

#·······················································································································

override getter @observablePropertyAsBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = ".id (" + self.mObservedModelString + ")"
}

#·······················································································································

override getter @negateBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = ".not (" + [self.mBinding expressionString] + ")"
}

#·······················································································································

override getter @orBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = ".boolcmp (" + [self.mLeftBinding expressionString] +  ", .or, " + [self.mRightBinding expressionString] + ")"
}

#·······················································································································

override getter @xorBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = ".boolcmp (" + [self.mLeftBinding expressionString] +  ", .xor, " + [self.mRightBinding expressionString] + ")"
}

#·······················································································································

override getter @andBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = ".boolcmp (" + [self.mLeftBinding expressionString] +  ", .and, " + [self.mRightBinding expressionString] + ")"
}

#·······················································································································

override getter @comparisonMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = ".intcmp (" + [self.mLeftBinding expressionString] + ", "
  switch self.mOperator
  case equal : outExpressionString += ".eq"
  case notEqual : outExpressionString += ".ne"
  case lower : outExpressionString += ".lt"
  case lowerOrEqual : outExpressionString += ".le"
  case greater : outExpressionString += ".gt"
  case greaterOrEqual : outExpressionString += ".ge"
  end
  outExpressionString += ", " + [self.mRightBinding expressionString] + ")"
}

#-----------------------------------------------------------------------------------------------------------------------
