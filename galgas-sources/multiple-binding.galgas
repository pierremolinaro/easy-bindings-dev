#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @multipleBindingDescriptor {
  case noBinding 
  case binding (@abstractBooleanMultipleBindingExpressionAST expression)
}

#·······················································································································

enum @multipleBindingComparisonAST {
  case equal
  case notEqual
  case lower
  case lowerOrEqual
  case greater
  case greaterOrEqual
}

#·······················································································································

abstract class @abstractBooleanMultipleBindingExpressionAST {
}

#·······················································································································

class @literalIntMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  @luint mValue
}

#·······················································································································

class @negateBooleanMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  @abstractBooleanMultipleBindingExpressionAST mBinding
}

#·······················································································································

class @comparisonMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  @abstractBooleanMultipleBindingExpressionAST mLeftBinding
  @multipleBindingComparisonAST mOperator
  @abstractBooleanMultipleBindingExpressionAST mRightBinding
}

#·······················································································································

class @andBooleanMultipleBindingExpressionAST,
       @orBooleanMultipleBindingExpressionAST,
       @xorBooleanMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  @abstractBooleanMultipleBindingExpressionAST mLeftBinding
  @abstractBooleanMultipleBindingExpressionAST mRightBinding
}

#·······················································································································

class @observablePropertyInMultipleBindingExpressionAST : @abstractBooleanMultipleBindingExpressionAST {
  @observablePropertyAST mProperty
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <booleanMultipleBindingExpression> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    <booleanMultipleBindingComparison> ?outBinding
    repeat
    while
      $&$
      <booleanMultipleBindingComparison> ?let @abstractBooleanMultipleBindingExpressionAST binding
      outBinding = @andBooleanMultipleBindingExpressionAST. new { !outBinding !binding}
    end
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingComparison>  !@abstractBooleanMultipleBindingExpressionAST outBinding {
    <booleanMultipleBindingTerm> ?outBinding
    select
    or
      $>$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.greater !rightBinding}
    or
      $>=$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.greaterOrEqual !rightBinding}
    or
      $<=$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.lowerOrEqual !rightBinding}
    or
      $<$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.lower !rightBinding}
    or
      $==$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.equal !rightBinding}
    or
      $!=$
      <booleanMultipleBindingTerm> ?let rightBinding
      outBinding = @comparisonMultipleBindingExpressionAST.new {!outBinding !.notEqual !rightBinding}
    end
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingTerm> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    <booleanMultipleBindingOperand> ?outBinding
    repeat
    while
      $|$
      <booleanMultipleBindingOperand> ?let @abstractBooleanMultipleBindingExpressionAST binding
      outBinding = @orBooleanMultipleBindingExpressionAST. new { !outBinding !binding}
    while
      $^$
      <booleanMultipleBindingOperand> ?let @abstractBooleanMultipleBindingExpressionAST binding
      outBinding = @xorBooleanMultipleBindingExpressionAST. new { !outBinding !binding}
    end
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingOperand> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    <observable_property> ?let @observablePropertyAST observablePropertyAST
    outBinding = @observablePropertyInMultipleBindingExpressionAST.new { !observablePropertyAST}
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingOperand> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    $!$
    <booleanMultipleBindingOperand> ?let @abstractBooleanMultipleBindingExpressionAST binding
    outBinding = @negateBooleanMultipleBindingExpressionAST. new { !binding}
  }
  
  #·····················································································································
  
  rule <booleanMultipleBindingOperand> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    $($
    <booleanMultipleBindingExpression> ?outBinding
    $)$
  }

  #·····················································································································
  
  rule <booleanMultipleBindingOperand> 
    !@abstractBooleanMultipleBindingExpressionAST outBinding
  {
    $literal_integer$ ?let value
    outBinding = @literalIntMultipleBindingExpressionAST.new {!value}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC TYPES                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @multipleBindingGenerationList {
  @string mOutletName
  @string mBindingName
  @abstractBooleanMultipleBindingExpressionForGeneration mBoundObjectExpression
}

#·······················································································································

abstract class @abstractBooleanMultipleBindingExpressionForGeneration {
}

#·······················································································································

class @observablePropertyAsBooleanMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  @string mObservedModelString
}

#·······················································································································

class @booleanMultipleBindingLiteralIntForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  @uint mValue
}

#·······················································································································

class @negateBooleanMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  @abstractBooleanMultipleBindingExpressionForGeneration mBinding
}

#·······················································································································

class @orBooleanMultipleBindingExpressionForGeneration,
      @xorBooleanMultipleBindingExpressionForGeneration,
      @andBooleanMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  @abstractBooleanMultipleBindingExpressionForGeneration mLeftBinding
  @abstractBooleanMultipleBindingExpressionForGeneration mRightBinding
}

#·······················································································································

class @comparisonMultipleBindingExpressionForGeneration : @abstractBooleanMultipleBindingExpressionForGeneration {
  @abstractBooleanMultipleBindingExpressionForGeneration mLeftBinding
  @multipleBindingComparisonAST mOperator
  @abstractBooleanMultipleBindingExpressionForGeneration mRightBinding
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC                              
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation

#·······················································································································

override method @literalIntMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @propertyMap unused inRootObservablePropertyMap
  ?let @semanticContext unused inSemanticContext
  ?let @propertyMap unused inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  outEnableExpression = @booleanMultipleBindingLiteralIntForGeneration.new {!mValue.uint}
  outType = .integerType
  outErrorLocation = mValue.location
}

#·······················································································································

override method @observablePropertyInMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [mProperty analyzeObservableProperty
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?let @propertyKind kind
    ?let @string unused swiftTypeStringForTransientFunctionArgument
  ]
  switch kind
  case property (type *) :
    outType = type
  case toMany (4*) :
    error [mProperty location] : "only an atomic property can be observed" : outType
  case toOne (4*) :
    error [mProperty location] : "only an atomic property can be observed" : outType
  case arrayController (2*) :
    error [mProperty location] : "only an atomic property can be observed" : outType
  case objectController (2*) :
    error [mProperty location] : "only an atomic property can be observed" : outType
  case selectionController (*) :
    error [mProperty location] : "only an atomic property can be observed" : outType
  end
  outEnableExpression = @observablePropertyAsBooleanMultipleBindingExpressionForGeneration.new {
    ![mProperty modelStringForSelf !"self"]
  }
  outErrorLocation = [mProperty location]
}

#·······················································································································

override method @negateBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [mBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration expression
    ?outType
    ?outErrorLocation
  ]
  if not [outType isBoolType] then
    error outErrorLocation : "cannot apply negation: operand is not boolean"
  end
  outEnableExpression = @negateBooleanMultipleBindingExpressionForGeneration.new {!expression}
}

#·······················································································································

override method @orBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [mLeftBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration leftExpression
    ?let outLeftType
    ?let outLeftLocation
  ]
  if not [outLeftType isBoolType] then
    error outLeftLocation : "cannot apply 'or': left operand is not boolean"
  end
  [mRightBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration rightExpression
    ?let outRightType
    ?let outRightLocation
  ]
  if not [outRightType isBoolType] then
    error outRightLocation : "cannot apply 'or': right operand is not boolean"
  end
  outType = .boolType
  outErrorLocation = outRightLocation
  outEnableExpression = @orBooleanMultipleBindingExpressionForGeneration. new {!leftExpression !rightExpression}
}

#·······················································································································

override method @xorBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [mLeftBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration leftExpression
    ?let outLeftType
    ?let outLeftLocation
  ]
  if not [outLeftType isBoolType] then
    error outLeftLocation : "cannot apply 'or': left operand is not boolean"
  end
  [mRightBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration rightExpression
    ?let outRightType
    ?let outRightLocation
  ]
  if not [outRightType isBoolType] then
    error outRightLocation : "cannot apply 'or': right operand is not boolean"
  end
  outType = .boolType
  outErrorLocation = outRightLocation
  outEnableExpression = @xorBooleanMultipleBindingExpressionForGeneration. new {!leftExpression !rightExpression}
}

#·······················································································································

override method @andBooleanMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [mLeftBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration leftExpression
    ?let outLeftType
    ?let outLeftLocation
  ]
  if not [outLeftType isBoolType] then
    error outLeftLocation : "cannot apply 'and': left operand is not boolean"
  end
  [mRightBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration rightExpression
    ?let outRightType
    ?let outRightLocation
  ]
  if not [outRightType isBoolType] then
    error outRightLocation : "cannot apply 'and': right operand is not boolean"
  end
  outType = .boolType
  outErrorLocation = outRightLocation
  outEnableExpression = @andBooleanMultipleBindingExpressionForGeneration. new {!leftExpression !rightExpression}
}

#·······················································································································

override method @comparisonMultipleBindingExpressionAST analyzeExpressionForMultipleBinding
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inCurrentObservablePropertyMap
  !@abstractBooleanMultipleBindingExpressionForGeneration outEnableExpression
  !@typeKind outType
  !@location outErrorLocation
{
  [mLeftBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration leftExpression
    ?let outLeftType
    ?let outLeftLocation
  ]
  [mRightBinding analyzeExpressionForMultipleBinding
    !inRootObservablePropertyMap
    !inSemanticContext
    !inCurrentObservablePropertyMap
    ?var @abstractBooleanMultipleBindingExpressionForGeneration rightExpression
    ?let outRightType
    ?let outRightLocation
  ]
  if not ([outLeftType isBoolType] || [outLeftType isIntegerType]) then
    error outLeftLocation : "cannot compare: left operand is neither boolean nor integer"
  end
  if outRightType != outLeftType then
    error outRightLocation : "cannot compare: right operand type is different than left operand type"
  end
  outType = .boolType
  outErrorLocation = outRightLocation
  outEnableExpression = @comparisonMultipleBindingExpressionForGeneration. new {
    !leftExpression
    !mOperator
    !rightExpression
  }
}

#·······················································································································

abstract getter @abstractBooleanMultipleBindingExpressionForGeneration observedModelSet
  -> @stringset

#·······················································································································

override getter @booleanMultipleBindingLiteralIntForGeneration observedModelSet
  -> @stringset outObservedModelSet
{
  outObservedModelSet = {}
}

#·······················································································································

override getter @observablePropertyAsBooleanMultipleBindingExpressionForGeneration observedModelSet
  -> @stringset outObservedModelSet
{
  outObservedModelSet = {!mObservedModelString}
}

#·······················································································································

override getter @negateBooleanMultipleBindingExpressionForGeneration observedModelSet
  -> @stringset outObservedModelSet
{
  outObservedModelSet = [mBinding observedModelSet]
}

#·······················································································································

override getter @orBooleanMultipleBindingExpressionForGeneration observedModelSet
  -> @stringset outObservedModelSet
{
  outObservedModelSet = {[mLeftBinding observedModelSet], [mRightBinding observedModelSet]}
}

#·······················································································································

override getter @xorBooleanMultipleBindingExpressionForGeneration observedModelSet
  -> @stringset outObservedModelSet
{
  outObservedModelSet = {[mLeftBinding observedModelSet], [mRightBinding observedModelSet]}
}

#·······················································································································

override getter @andBooleanMultipleBindingExpressionForGeneration observedModelSet
  -> @stringset outObservedModelSet
{
  outObservedModelSet = {[mLeftBinding observedModelSet], [mRightBinding observedModelSet]}
}

#·······················································································································

override getter @comparisonMultipleBindingExpressionForGeneration observedModelSet
  -> @stringset outObservedModelSet
{
  outObservedModelSet = {[mLeftBinding observedModelSet], [mRightBinding observedModelSet]}
}

#·······················································································································

abstract getter @abstractBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string

#·······················································································································

override getter @booleanMultipleBindingLiteralIntForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = "EBSelection.single (" + [mValue string] + ")"
}

#·······················································································································

override getter @observablePropertyAsBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = mObservedModelString + "_selection"
}

#·······················································································································

override getter @negateBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = "!" + [mBinding expressionString]
}

#·······················································································································

override getter @orBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = "(" + [mLeftBinding expressionString] +  " || " + [mRightBinding expressionString] + ")"
}

#·······················································································································

override getter @xorBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = "(" + [mLeftBinding expressionString] +  " ^ " + [mRightBinding expressionString] + ")"
}

#·······················································································································

override getter @andBooleanMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = "(" + [mLeftBinding expressionString] +  " && " + [mRightBinding expressionString] + ")"
}

#·······················································································································

override getter @comparisonMultipleBindingExpressionForGeneration expressionString
  -> @string outExpressionString {
  outExpressionString = "(" + [mLeftBinding expressionString] + " "
  switch mOperator
  case equal : outExpressionString += "=="
  case notEqual : outExpressionString += "!="
  case lower : outExpressionString += "<"
  case lowerOrEqual : outExpressionString += "<="
  case greater : outExpressionString += ">"
  case greaterOrEqual : outExpressionString += ">="
  end
  outExpressionString += " " + [mRightBinding expressionString] + ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
