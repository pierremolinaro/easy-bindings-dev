#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   AST                                                                                                                *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @atomicClassPropertyList {
  @lstring mTypeName
  @lstring mPropertyName
}

#·······················································································································

class @atomicClassDeclaration : @astDeclaration {
  @lstring mClassName
  @atomicClassPropertyList mPropertyList
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SYNTAX                                                                                                             *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <class_declaration>
    ?let @bool inIsUserDefined
    ?!@astDeclarationStruct ioDeclarationAST
  {
    $atomic$
    $class$
    $Identifier$ ?let @lstring entityName
    ${$
    @atomicClassPropertyList propertyList = {}
    @simpleStoredPropertyList simpleStoredAttributeList = {}
    @stringset signatureList = {}
    repeat
    while
      $Identifier$ ?var @lstring propertyTypeName
      $identifier$ ?var @lstring propertyName
      $;$
      propertyList += !propertyTypeName !propertyName
    end
    $}$
    ioDeclarationAST.mDeclarationList += !@atomicClassDeclaration.new {
      !inIsUserDefined
      !entityName
      !propertyList
    }
  }

  #·····················································································································

}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   TYPE INVENTORY                                                                                                     *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

override method @atomicClassDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  @unifiedTypeMapProxyList proxyList = {}
  for (typeName *) in mPropertyList do
    [@unifiedTypeMap-proxy makeProxy !?ioUnifiedTypeMap !typeName ?let proxy]
    proxyList += !proxy
  end
  [!?ioUnifiedTypeMap insertKey !mClassName !.atomicClassType {!className:mClassName.string !typeProxyList:proxyList} !{}]
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

# Only get current entity observable properties, do not collect in super entities
override method @atomicClassDeclaration buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@semanticContext unused ioSemanticContext
{
}

#·······················································································································

override method @atomicClassDeclaration buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList unused ioSecondaryDeclarationListWorkingList
  ?!@uint unused ioSecondaryDeclarationCount
{
}

#·······················································································································

override method @atomicClassDeclaration solveSecondaryProperty
  ?!@semanticContext ioSemanticContext
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @secondaryPropertyList inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties
{
  outUnsolvedProperties = {}
  [ioSemanticContext.mEntityObservablePropertyMap searchKey
    !mClassName
    ?@observablePropertyMap observablePropertyMap
  ]
  for (property) in inPropertiesToSolve do
    [property tryToSolveSecondaryProperty
      !?ioSemanticContext
      !{} # No root entity
      !?observablePropertyMap
      !?outUnsolvedProperties
    ]
  end
  [!?ioSemanticContext.mEntityObservablePropertyMap setMObservablePropertyMapForKey
    !observablePropertyMap
    !mClassName.string
  ]
}

#·······················································································································

override method @atomicClassDeclaration semanticAnalysis
  ?let @semanticContext unused inSemanticContext
  ?!@structForGeneration ioGeneration
{
#--- Generation
  ioGeneration.mAtomicClassListForGeneration +=
    !mClassName.string
    !mPropertyList
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION TYPES                                                                                                   *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @atomicClassListForGeneration {
  @string mClassName
  @atomicClassPropertyList mPropertyList
}

#·······················································································································

private filewrapper atomicClassGenerationTemplate in "../generation-templates" {
}{
}{
  template classImplementationInSwift "atomic-class.swift.galgasTemplate"
    ?@string CLASS_NAME
    ?@atomicClassPropertyList PROPERTY_LIST_FOR_GENERATION
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION                                                                                                         *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

proc generateAtomicClasses
  ?let @atomicClassListForGeneration inClassListForGeneration
  ?let @string inOutputDirectory
  ?!@stringset ioGeneratedFileSet
{
  for () in inClassListForGeneration do
    let s = [filewrapper atomicClassGenerationTemplate.classImplementationInSwift
      !mClassName
      !mPropertyList
    ]
    let fileName = mClassName + ".swift"
    ioGeneratedFileSet += !fileName
    [@string generateFile
      !inOutputDirectory
      !fileName
      !s
    ]
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
