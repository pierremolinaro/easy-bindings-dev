#-----------------------------------------------------------------------------------------------------------------------
#   AST   
#-----------------------------------------------------------------------------------------------------------------------

class @enumerationDeclarationAST : @abstractDeclarationAST {
  public var @lstringlist mEnumConstantNameList
}

#·······················································································································

override proc @enumerationDeclarationAST.enterInPrecedenceGraph (?!@declarationPrecedenceGraph ioGraph) {
  [!?ioGraph addNode !self.mClassName !self]
}

#·······················································································································

override func @enumerationDeclarationAST.nodeKey() -> @lstring {
  result = self.mClassName
}

#·······················································································································

list @enumerationFunctionListAST {
  public var @lstring mEnumName
  public var @lstring mFunctionName
  public var @2lstringlist mAssociationList
}

#-----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
#-----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <enum_declaration> (?!@astDeclarationStruct ioDeclarationAST) {
    $enum$
    $Identifier$ (?let @lstring enumName)
    ${$
    var @lstringlist enumConstants = {}
    repeat
      $identifier$ (?let @lstring constantName)
      enumConstants += !constantName
    while
      $,$
    end
    $}$
    ioDeclarationAST.mUnifiedDeclarationList += !@enumerationDeclarationAST (!enumName !enumConstants)
  }

  #·····················································································································
  
  rule <enum_function_declaration> (?!@astDeclarationStruct ioDeclarationAST) {
    $func$
    $enum$
    $Identifier$ (?let @lstring enumName)
    $.$    
    $identifier$ (?let @lstring funcName)
    ${$
    var @2lstringlist associationList = {}
    repeat
    while
      $identifier$ (?let @lstring constantName)
      $:$
      $literal_string$ (?let @lstring associatedString)
      $;$
      associationList += !constantName !associatedString
    end 
    $}$
    ioDeclarationAST.mEnumerationFunctionListAST += !enumName !funcName !associationList
  }
  
  #·····················································································································

}

#-----------------------------------------------------------------------------------------------------------------------
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#-----------------------------------------------------------------------------------------------------------------------

map @enumConstantMap {
  public var @uint mIndex
  insert insertKey error message "there is already a '%K' constant"
  search searchKey error message "the '%K' constant is not defined"
}

#-----------------------------------------------------------------------------------------------------------------------

sortedlist @enumFunAssociationSortedList {
  public var @uint mIndex
  public var @string mAssociatedString
}{
  mIndex <
}

#-----------------------------------------------------------------------------------------------------------------------

map @enumFuncMap {
  public var @enumFunAssociationSortedList mAssociationSortedList
  insert insertKey error message "there is already a '%K' enum function"
  search searchKey error message "the '%K' enum function is not defined"
}

#·······················································································································

override proc @enumerationDeclarationAST.firstAnalysisPhase(
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct ioGeneration)
{
  var @enumConstantMap enumConstantMap = {}
  for (s) in self.mEnumConstantNameList do
    [!?enumConstantMap insertKey !s ![enumConstantMap count]]
  end
  var @enumFuncMap enumFuncMap = {}
  for (enumTypeName funcName associationList) in ioSemanticContext.mEnumerationFunctionListAST do
    if enumTypeName.string == self.mClassName.string then
      var @stringset definedConstantNameSet = {}
      var @enumFunAssociationSortedList associationSortedList = {}
      for (constantName associatedString) in associationList do
        [enumConstantMap searchKey !constantName ?let idx]
        associationSortedList += !idx !associatedString.string
        if [definedConstantNameSet hasKey !constantName] then
          error constantName : "Duplicated constant"
        end
        definedConstantNameSet += !constantName
      end
      for (s) in self.mEnumConstantNameList do
        if not [definedConstantNameSet hasKey !s] then
          error funcName : "No association for '" + s + "' constant"
        end
      end
      [!?enumFuncMap insertKey !funcName !associationSortedList]
    end
  end
  [!?ioSemanticContext.mClassMap insertKey
    !self.mClassName
    !.atomic (!kind: .enumType (!enumTypeName:self.mClassName !constantMap: enumConstantMap !funcMap: enumFuncMap))
    !{}
    !{}
    !{}
  ]
#--- Generation
  ioGeneration.mFileGenerationList += !@enumForGeneration (
    !self.mClassName
    !self.mEnumConstantNameList
    !enumFuncMap
  )
}

#-----------------------------------------------------------------------------------------------------------------------
#   GENERATION
#-----------------------------------------------------------------------------------------------------------------------

class @enumForGeneration : @abstractFileGeneration {
  public var @string mEnumName
  public var @lstringlist mEnumConstantList
  public var @enumFuncMap mEnumFuncMap
}

#·······················································································································

private filewrapper enumGenerationTemplate in "../generation-templates" {
}{
}{
  template enumGenerationInSwift "enum.swift.galgasTemplate"
    ?@string ENUM_TYPE_NAME
    ?@lstringlist CONSTANT_ORDERED_LIST
    ?@enumFuncMap FUNCTION_MAP
}

#·······················································································································

override proc @enumForGeneration.generateCode(
    ?let @string inOutputDirectory
    ?let @generationStruct unused inGenerationStruct
    ?!@stringset ioGeneratedFileSet) {
  if [self.mEnumConstantList length] > 0 then # Empty list is the generic type "Enum"
    let s = [filewrapper enumGenerationTemplate.enumGenerationInSwift
      !self.mEnumName
      !self.mEnumConstantList
      !self.mEnumFuncMap
    ]
    let fileName = "enum-" + self.mEnumName + ".swift"
    ioGeneratedFileSet += !fileName
    [@string generateFile
      !inOutputDirectory
      !fileName
      !s
    ]
  end
}

#-----------------------------------------------------------------------------------------------------------------------
