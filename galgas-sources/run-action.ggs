#-----------------------------------------------------------------------------------------------------------------------
#   AST   
#-----------------------------------------------------------------------------------------------------------------------

enum @runActionDescriptor {
  case noAction 
  case action (@lstring target  @lstring action)
}

#-----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
#-----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <action_declaration> (?!@lstringlist ioActionDeclarationList) {
    $action$
    $identifier$ (?let @lstring actionName)
    $;$
    ioActionDeclarationList += !actionName
  }

  #·····················································································································

}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC TYPES                        
#-----------------------------------------------------------------------------------------------------------------------

map @actionMap {
  insert insertKey error message "there is already a '%K' action"
  search searchKey error message "the '%K' action is not defined"
}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC ACTIONS                      
#-----------------------------------------------------------------------------------------------------------------------

proc buildActionMap(
  let @lstringlist inActionDeclarationList,
  !@actionMap outActionMap)
{
  outActionMap = []
  for (mValue) in inActionDeclarationList do
    !?outActionMap.insertKey (mValue)
  end
}

#-----------------------------------------------------------------------------------------------------------------------
#   GENERATION                      
#-----------------------------------------------------------------------------------------------------------------------

class @actionFileGeneration : @abstractFileGeneration {
  public var @string mClassName
  public var @string mActionName
}

#·······················································································································

override proc @actionFileGeneration.generateCode(
    let @string inOutputDirectory,
    let @generationStruct unused inGenerationStruct,
    ?!@stringset ioGeneratedFileSet) {
 let s = filewrapper [actionGenerationTemplate.actionGeneration:
    self.mClassName,
    self.mActionName
  ]
  let fileName = "action-" + self.mClassName + "-" + self.mActionName + ".swift"
  ioGeneratedFileSet += !fileName
  @string.generateFileWithPattern (
    !startPath:inOutputDirectory,
    !fileName:fileName,
    !lineComment:"//",
    !header:"",
    !defaultUserZone1:"\n\n", # Defaut user zone1
    !generatedZone2:s,
    !defaultUserZone2:"    ENTER USER CODE HERE\n", # Defaut user zone2
    !generatedZone3:"  }\n}\n\n//" + @string.stringWithSequenceOfCharacters  ('—', 118) + "\n",
    !makeExecutable:false
  )
}

#·······················································································································

filewrapper actionGenerationTemplate in "generation-templates" {
}{
}{
  template actionGeneration "action-extension.swift.galgasTemplate"
    ?@string EXTENDED_CLASS_NAME
    ?@string ACTION_NAME
 }

#-----------------------------------------------------------------------------------------------------------------------
