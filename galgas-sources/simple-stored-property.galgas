#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @simpleStoredPropertyList {
  @lstring mPropertyTypeName
  @lstring mPropertyName
  @abstractDefaultValue mDefaultValue
  @bool mNeedsValidation
}

#·······················································································································

class @atomicPropertyDeclarationAST : @abstractDeclarationAST {
  @lstring mPropertyTypeName
  @lstring mPropertyName
  @abstractDefaultValue mDefaultValue
  @bool mNeedsValidation
}

#·······················································································································

override method @atomicPropertyDeclarationAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  let node = @lstring.new {!mClassName.string + " " + mPropertyName !mPropertyName.location}
  [!?ioGraph addNode !node !self]
  [!?ioGraph addEdge !node !mClassName]
  [!?ioGraph addEdge !node !mPropertyTypeName]
}

#·······················································································································

override getter @atomicPropertyDeclarationAST lkey -> @lstring {
  result = @lstring.new {!mClassName.string + " " + mPropertyName !mPropertyName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <simple_stored_declaration>
    ?let @lstring inClassName
    ?!@simpleStoredPropertyList ioAttributeList
    ?!@stringset ioSignatureList
    ?!@astDeclarationStruct ioDeclarationAST
  {
    $property$
    @bool usedForSignature = false
    @bool needsValidation = false
    repeat
    while
      $@attribute$ ?let attributeName
      if attributeName.string == "signature" then
        if needsValidation then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        usedForSignature = true
      elsif attributeName.string == "validation" then
        if needsValidation then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        needsValidation = true
      else
        error attributeName : "unknow attribute" fixit { replace "@signature" replace "@validation" }
      end
    end
    $Identifier$ ?var @lstring attributeTypeName
    $identifier$ ?var @lstring attributeName
    if usedForSignature then
      ioSignatureList += !attributeName.string
    end
    $default$
    <explicit_value> ?var @abstractDefaultValue defaultValue
    $;$
    ioDeclarationAST.mUnifiedDeclarationList += !@atomicPropertyDeclarationAST.new{
      !inClassName
      !attributeTypeName
      !attributeName
      !defaultValue
      !needsValidation

    }
    ioAttributeList +=
      !attributeTypeName
      !attributeName
      !defaultValue
      !needsValidation
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @atomicPropertyDeclarationAST classAndPropertySemanticAnalysis ?!@classMap ioClassMap {
  with mClassName in !?ioClassMap 
    error message searchKey
  do
    [ioClassMap searchKey !mPropertyTypeName ?let classKind ?*]
    switch classKind
    case prefs :
      error mPropertyTypeName : "an atomic class is required here"
    case simpleClass :
      error mPropertyTypeName : "an atomic class is required here"
    case atomic (kind) :
      [!?mPropertyMap insertKey !mPropertyName !.property {!type: kind !accessibility: .stored}]
    case document (*) :
      error mPropertyTypeName : "an atomic class is required here"
    case entity (*) :
      error mPropertyTypeName : "an atomic class is required here"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TYPE INVENTORY                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @simpleStoredPropertyList typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  for () in self do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mPropertyTypeName
      ?*
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @simpleStoredPropertyList buildObservablePropertyMap
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMap ioObservableProperties
{
  for () in self do
  #--- Property type
    [inUnifiedTypeMap searchKey !mPropertyTypeName ?let type ?let actionMap]
  #--- Check type
    @typeKindList typeList
    switch type
    case boolType, integerType, stringType, dateType, doubleType, fontType, colorType : # Ok
      typeList = {!type}
    case enumType (* *) : # Ok
      typeList = {!type}
    case classType (*) :
      error mPropertyName: "a class cannot be used as simple property type" : typeList
    case transientPropertyExternType (*) :
      typeList = {!type}
    case entityType (2*) :
      error mPropertyName: "an entity cannot be used as simple property type" : typeList
    end
  #--- Enter in property map
    [!?ioObservableProperties insertKey
      !mPropertyName
      !.property {!type: type !accessibility: .stored}
      !""
      !actionMap
      !false
    ]
  end
}

#·······················································································································

method @simpleStoredPropertyList simpleStoredPropertySemanticAnalysis
  ?let @string inSwiftClassName
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@validationStubRoutineListForGeneration ioValidationStubRoutineListForGeneration
  !@simpleStoredPropertyListForGeneration outSimpleStoredPropertyListForGeneration
{
  outSimpleStoredPropertyListForGeneration = {}
  for () in self do
  #--- Property type
    [inUnifiedTypeMap searchKey !mPropertyTypeName ?let type ?*]
  #--- Check type
    @typeKindList typeList
    switch type
    case boolType, integerType, stringType, dateType, doubleType, fontType, colorType : # Ok
      typeList = {!type}
    case enumType (* *) : # Ok
      typeList = {!type}
    case classType (*) :
      error mPropertyName: "a class cannot be used as simple property type" : typeList
    case transientPropertyExternType (*) :
      error mPropertyName: "a transient property class cannot be used as simple property type" : typeList
    case entityType (2*) :
      error mPropertyName: "an entity cannot be used as simple property type" : typeList
    end
  #--- Analyze default value
    [mDefaultValue analyzeDefaultValueType !typeList ?let@string swiftDefaultValueAsString]
  #--- Code Generation
    outSimpleStoredPropertyListForGeneration +=
      !type
      !mPropertyName.string
      !false
      !swiftDefaultValueAsString
      !mNeedsValidation
    if mNeedsValidation then
      ioValidationStubRoutineListForGeneration +=
        !inSwiftClassName
        !mPropertyName.string
        ![type swiftTypeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @simpleStoredPropertyListForGeneration {
  @typeKind mType
  @string mStoredOrProxyPropertyName
  @bool mIsProxy
  @string mDefaultValueInSwift
  @bool mNeedsValidation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
