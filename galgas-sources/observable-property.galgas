#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  AST                                                                                                                 *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

enum @observablePropertyAST {
  case rootProperty (@lstring propertyName)
  case rootPropertyWithOption (@lstring propertyName @lstring optionName)
  case rootPropertyRelationship (@lstring relationshipName @lstring propertyName)
  case selfProperty (@lstring propertyName)
  case selfPropertyWithOption (@lstring propertyName @lstring optionName)
  case selfPropertyArray (@lstring propertyName @lstring elementPropertyName)
  case prefsProperty (@lstring propertyName)
  case prefsPropertyWithOption (@lstring propertyName @lstring optionName)
  case controllerProperty (@lstring controllerName @lstring propertyName)
  case controllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName)
  case signatureProperty (@location location)
  case versionProperty (@location location)
  case versionShouldChangeProperty (@location location)
}

#......................................................................................................................*

list @observablePropertyList {
  @observablePropertyAST mObservableProperty
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  SYNTAX                                                                                                              *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  rule <observable_property>
    !@observablePropertyAST outObservablePropertyAST
  {
    select
      $root$
      $.$
      $identifier$ ?let propertyName
      select
        outObservablePropertyAST = .rootProperty {!propertyName:propertyName}
      or
        $.$
        select
          $identifier$ ?let optionName
          outObservablePropertyAST = .rootPropertyWithOption {!propertyName:propertyName !optionName:optionName}
        or
          $all$
          $.$
          $identifier$ ?let observablePropertyName
          outObservablePropertyAST = .rootPropertyRelationship {
            !relationshipName:propertyName !propertyName:observablePropertyName
          }
        end
      end
    or
      $self$
      $.$
      $identifier$ ?let propertyName
      select
        outObservablePropertyAST = .selfProperty {!propertyName:propertyName}
      or
        $.$ ;
        select
          $all$
          $.$
          $identifier$ ?let elementPropertyName
          outObservablePropertyAST = .selfPropertyArray {!propertyName:propertyName !elementPropertyName:elementPropertyName}
        or
          $identifier$ ?let optionName
          outObservablePropertyAST = .selfPropertyWithOption {!propertyName:propertyName !optionName:optionName}
        end
      end
    or
      $prefs$
      $.$
      $identifier$ ?let propertyName
      select
        outObservablePropertyAST = .prefsProperty {!propertyName:propertyName}
      or
        $.$ ;
        $identifier$ ?let optionName
        outObservablePropertyAST = .prefsPropertyWithOption {!propertyName:propertyName !optionName:optionName}
      end
    or
      $identifier$ ?let controllerName
      $.$
      $identifier$ ?let propertyName
      select
        outObservablePropertyAST = .controllerProperty {!controllerName:controllerName !propertyName:propertyName}
      or
        $.$
        $identifier$ ?let secondaryPropertyName
        outObservablePropertyAST = .controllerSecondaryProperty {
          !controllerName:controllerName
          !propertyName:propertyName
          !secondaryPropertyName:secondaryPropertyName
        }
      end
    or
      $signature$
      outObservablePropertyAST = .signatureProperty {!location:.here}
    or
      $version$
      outObservablePropertyAST = .versionProperty {!location:.here}
    or
      $versionShouldChange$
      outObservablePropertyAST = .versionShouldChangeProperty {!location:.here}
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

}
   
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  SEMANTICS                                                                                                           *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

getter @observablePropertyAST modelString ?let @string inSelf -> @string outResult {
  switch self
  case rootProperty (@lstring propertyName) :
    outResult = inSelf + ".rootObject." + propertyName
  case rootPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = inSelf + ".rootObject." + propertyName + "." + optionName
  case rootPropertyRelationship (@lstring relationshipName *) :
    outResult = inSelf + ".rootObject." + relationshipName
  case selfProperty (@lstring propertyName) :
    outResult = inSelf + "." + propertyName
  case selfPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = inSelf + "." + propertyName + "." + optionName
  case selfPropertyArray (@lstring propertyName @lstring unused elementPropertyName) :
    outResult = inSelf + "." + propertyName # + ".all." + elementPropertyName
  case prefsProperty (@lstring propertyName) :
    outResult = "g_" + preferencesName () + "!." + propertyName
  case prefsPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = "g_" + preferencesName () + "!." + propertyName + "." + optionName
  case controllerProperty (@lstring controllerName @lstring propertyName) :
    outResult = inSelf + "." + controllerName + "." + propertyName
  case controllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) :
    outResult = inSelf + "." + controllerName + "." + propertyName + "." + secondaryPropertyName
  case signatureProperty (*) :
    outResult = "self.signatureObserver ()"
  case versionProperty (*) :
    outResult = "self.versionObserver ()"
  case versionShouldChangeProperty (*) :
    outResult = "self.versionShouldChangeObserver ()"
  end  
}

#......................................................................................................................*

getter @observablePropertyAST needs_unwSelf -> @bool outResult {
  switch self
  case rootProperty (*) :
    outResult = true
  case rootPropertyWithOption (* *) :
    outResult = true
  case rootPropertyRelationship (* *) :
    outResult = true
  case selfProperty (*) :
    outResult = true
  case selfPropertyWithOption (* *) :
    outResult = true
  case selfPropertyArray (* *) :
    outResult = true
  case prefsProperty (*) :
    outResult = false
  case prefsPropertyWithOption (* *) :
    outResult = false
  case controllerProperty (* *) :
    outResult = true
  case controllerSecondaryProperty (* * *) :
    outResult = true
  case signatureProperty (*) :
    outResult = true
  case versionProperty (*) :
    outResult = true
  case versionShouldChangeProperty (*) :
    outResult = true
  end  
}

#......................................................................................................................*

getter @observablePropertyAST isPropertyDefined
  ?let @semanticContext inSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?let @observablePropertyMap inObservableProperties
  -> @bool outResult
{
  switch self
  case rootProperty (@lstring propertyName) :
    outResult = [inRootObservableProperties hasKey !propertyName.string]
  case rootPropertyWithOption (@lstring propertyName @lstring unused optionName) :
    outResult = [inRootObservableProperties hasKey !propertyName.string]
  case rootPropertyRelationship (@lstring relationshipName *) :
    outResult = [inRootObservableProperties hasKey !relationshipName.string]
  case selfProperty (@lstring propertyName) :
    outResult = [inObservableProperties hasKey !propertyName.string]
  case selfPropertyWithOption (@lstring propertyName @lstring unused optionName) :
    outResult = [inObservableProperties hasKey !propertyName.string]
  case selfPropertyArray (@lstring propertyName @lstring unused elementPropertyName) :
    outResult = [inObservableProperties hasKey !propertyName.string]
  case prefsProperty (@lstring propertyName) :
    outResult = [inSemanticContext.mPreferencesObservablePropertyMap hasKey !propertyName.string]
  case prefsPropertyWithOption (@lstring propertyName @lstring unused optionName) :
    outResult = [inSemanticContext.mPreferencesObservablePropertyMap hasKey !propertyName.string]
  case controllerProperty (@lstring controllerName @lstring unused propertyName) :
    outResult = [inObservableProperties hasKey !controllerName.string]
  case controllerSecondaryProperty (@lstring controllerName @lstring unused propertyName @lstring unused secondaryPropertyName) :
    outResult = [inObservableProperties hasKey !controllerName.string]
  case signatureProperty (*) :
    outResult = true
  case versionProperty (*) :
    outResult = true
  case versionShouldChangeProperty (*) :
    outResult = true
  end  
}

#......................................................................................................................*

getter @observablePropertyAST location -> @location outResult {
  switch self
  case rootProperty (@lstring propertyName) :
    outResult = propertyName.location
  case rootPropertyWithOption (* @lstring optionName) :
    outResult = optionName.location
  case rootPropertyRelationship (* @lstring propertyName) :
    outResult = propertyName.location
  case selfProperty (@lstring propertyName) :
    outResult = propertyName.location
  case selfPropertyWithOption (@lstring propertyName *) :
    outResult = propertyName.location
  case selfPropertyArray (@lstring propertyName *) :
    outResult = propertyName.location
  case prefsProperty (@lstring propertyName) :
    outResult = propertyName.location
  case prefsPropertyWithOption (@lstring propertyName *) :
    outResult = propertyName.location
  case controllerProperty (* @lstring propertyName) :
    outResult = propertyName.location
  case controllerSecondaryProperty (* * @lstring secondaryPropertyName) :
    outResult = secondaryPropertyName.location
  case signatureProperty (@location location) :
    outResult = location
  case versionProperty (@location location) :
    outResult = location
  case versionShouldChangeProperty (@location location) :
    outResult = location
  end  
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

method @observablePropertyAST analyzeObservableProperty
  ?let @observablePropertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @observablePropertyMap inObservablePropertyMap
  !@typeKind outType
  !@propertyKind outKind
  !@propertyMultiplicity outMultiplicity
  !@string outSwiftTypeStringForTransientFunctionArgument
{
  switch self
  case versionShouldChangeProperty (*) :
    outKind = .transient
    outMultiplicity = .single
    outType = .boolType
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case versionProperty (*) :
    outKind = .transient
    outMultiplicity = .single
    outType = .integerType
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case signatureProperty (*) :
    outKind = .transient
    outMultiplicity = .single
    outType = .integerType
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case rootProperty (@lstring propertyName) :
    [inRootObservablePropertyMap searchKey
      !propertyName
      ?outType
      ?outKind
      ?outMultiplicity
      ?2*
    ]
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case rootPropertyWithOption (@lstring propertyName @lstring optionName) :
    [inRootObservablePropertyMap searchKey
      !propertyName
      ?outType
      ?outKind
      ?outMultiplicity
      ?2*
    ]
    if outMultiplicity == .single then
      error optionName : "a property cannot accept any option"
    else
      outKind = .transient
      outMultiplicity = .single
      if optionName.string == "count" then
        outType = .integerType
      elsif optionName.string == "empty" then
        outType = .boolType
      else
        error optionName : "uknown option (accepted : 'count', 'empty')"
      end
    end
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case rootPropertyRelationship (@lstring relationshipName @lstring propertyName) : # xxx.all.xxx
    [inRootObservablePropertyMap searchKey
      !relationshipName
      ?let relationshipType
      ?outKind
      ?outMultiplicity
      ?2*
    ]
    if outMultiplicity == .single then
      error relationshipName : "a property cannot accept 'all'"
    end
    switch relationshipType
    case stringType, boolType, dateType, doubleType, integerType, fontType :
      error relationshipName : "a property cannot accept 'all'" : outType
    case enumType (* *) :
      error relationshipName : "a property cannot accept 'all'" : outType
    case classType (*) :
      error relationshipName : "a property cannot accept 'all'" : outType
    case propertyClassType (**) :
      error relationshipName : "a property cannot accept 'all'" : outType
    case transientPropertyClassType (*) :
      error propertyName : "a property cannot accept 'all'" : outType
    case entityType (@string entityName) :
      [inSemanticContext.mEntityObservablePropertyMap searchKey
        ![entityName nowhere]
        ?let @observablePropertyMap entityObservablePropertyMap
      ]
      [entityObservablePropertyMap searchKey
        !propertyName
        ?outType
        ?outKind
        ?outMultiplicity
        ?2*
      ]
      if outMultiplicity == .collection then
        error propertyName : "the observed property cannot be a collection"
      end
    end
    outSwiftTypeStringForTransientFunctionArgument = "[" + [relationshipType swiftTypeName] + " /* _" + propertyName + " */]"
  case selfProperty (@lstring propertyName) :
    [inObservablePropertyMap searchKey
      !propertyName
      ?outType
      ?outKind
      ?outMultiplicity
      ?2*
    ]
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case selfPropertyWithOption (@lstring propertyName @lstring optionName) :
    [inObservablePropertyMap searchKey
      !propertyName
      ?outType
      ?outKind
      ?outMultiplicity
      ?2*
    ]
    if outMultiplicity == .single then
      error optionName : "a property cannot accept any option"
    elsif outMultiplicity == .collection then
      outKind = .transient
      outMultiplicity = .single
      if optionName.string == "count" then
        outType = .integerType
      else
        error optionName : "uknown option (accepted : 'count', 'empty')"
      end
    end
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case selfPropertyArray (@lstring propertyName @lstring elementPropertyName) : # self.xxx.all.xxx
    [inObservablePropertyMap searchKey
      !propertyName
      ?let propertyType
      ?outKind
      ?outMultiplicity
      ?2*
    ]
    if outMultiplicity == .single then
      error propertyName : "a property cannot accept 'all'"
    end
    switch propertyType
    case stringType, boolType, dateType, doubleType, integerType, fontType :
      error propertyName : "a property cannot accept 'all'" : outType
    case enumType (* *) :
      error propertyName : "a property cannot accept 'all'" : outType
    case classType (*) :
      error propertyName : "a property cannot accept 'all'" : outType
    case propertyClassType (**) :
      error propertyName : "a property cannot accept 'all'" : outType
    case transientPropertyClassType (*) :
      error propertyName : "a property cannot accept 'all'" : outType
    case entityType (@string entityName) :
      [inSemanticContext.mEntityObservablePropertyMap searchKey
        ![entityName nowhere]
        ?let @observablePropertyMap entityObservablePropertyMap
      ]
      [entityObservablePropertyMap searchKey
        !elementPropertyName
        ?outType
        ?outKind
        ?outMultiplicity
        ?2*
      ]
      if outMultiplicity == .collection then
        error elementPropertyName : "the observed property cannot be a collection"
      end
    end
    outSwiftTypeStringForTransientFunctionArgument = "[" + [propertyType swiftTypeName]
       + " /* _" + elementPropertyName + " */]"
  case prefsProperty (@lstring propertyName) :
    [inSemanticContext.mPreferencesObservablePropertyMap searchKey
      !propertyName
      ?outType
      ?outKind
      ?outMultiplicity
      ?2*
    ]
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case prefsPropertyWithOption (@lstring propertyName @lstring optionName) :
    [inSemanticContext.mPreferencesObservablePropertyMap searchKey
      !propertyName
      ?outType
      ?outKind
      ?outMultiplicity
      ?2*
    ]
    if outMultiplicity == .single then
      error optionName : "a single property cannot accept any option"
    elsif outMultiplicity == .collection then
      outKind = .transient
      outMultiplicity = .single
      if optionName.string == "count" then
        outType = .integerType
      else
        error optionName : "uknown option (accepted : 'count', 'empty')"
      end
    end
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case controllerProperty (@lstring controllerName @lstring propertyName) :
    [inObservablePropertyMap searchKey
      !controllerName
      ?let @typeKind type
      ?let @propertyKind propertyKind
      ?3*
    ]
    switch propertyKind
    case selectionController :
      switch type
      case stringType, boolType, dateType, doubleType, integerType, fontType :
        error controllerName : "the bound model should be an entity" : outMultiplicity, outKind, outType
      case classType (*) :
        error controllerName : "the bound model should be an entity" : outMultiplicity, outKind, outType
      case propertyClassType (**) :
        error controllerName : "the bound model should be an entity" : outMultiplicity, outKind, outType
      case transientPropertyClassType (*) :
        error controllerName : "the bound model should be an entity" : outMultiplicity, outKind, outType
      case enumType (* *) :
        error controllerName : "the bound model should be an entity" : outMultiplicity, outKind, outType
      case entityType (entityName) :
        [inSemanticContext.mEntityObservablePropertyMap searchKey
          !.new {!entityName !controllerName.location}
          ?let @observablePropertyMap observablePropertyMap
        ]
        [observablePropertyMap searchKey
          !propertyName
          ?outType
          ?outKind
          ?outMultiplicity
          ?2*
        ]
      end
    case arrayController :
      if (propertyName.string == "sortedArray") || (propertyName.string == "selectedArray") then
        outMultiplicity = .collection
        outKind = .transient
        outType = type
      else
        error propertyName
          : "uknown option (accepted : 'sortedArray' or 'selectedArray')"
          : outMultiplicity, outKind, outType
      end
    case stored, transient :
      error controllerName : "this property should be a controller" : outMultiplicity, outKind, outType
    end
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  case controllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) :
    [inObservablePropertyMap searchKey
      !controllerName
      ?5*
    ]
    if (propertyName.string == "sortedArray") && (secondaryPropertyName.string == "count") then
      outMultiplicity = .single
      outKind = .transient
      outType = .integerType
    elsif (propertyName.string == "selectedArray") && (secondaryPropertyName.string == "count") then
      outMultiplicity = .single
      outKind = .transient
      outType = .integerType
    else
      error propertyName
        : "uknown option"
        : outMultiplicity, outKind, outType
    end
    outSwiftTypeStringForTransientFunctionArgument = [outType swiftTypeName]
  end  
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

