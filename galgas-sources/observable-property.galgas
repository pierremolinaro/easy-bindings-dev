#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @observablePropertyAST {
  case rootProperty (@lstring propertyName)
  case rootPropertyWithOption (@lstring propertyName @lstring optionName)
  case rootPropertyRelationship (@lstring relationshipName @lstring propertyName)
  case rootPropertyNone (@lstring relationshipName)
  case selfProperty (@lstring propertyName)
  case selfPropertyWithOption (@lstring propertyName @lstring optionName)
  case selfPropertyArray (@lstring propertyName @lstring elementPropertyName)
  case selfPropertyObject (@lstring propertyName @lstring elementPropertyName)
  case selfPropertyNone (@lstring propertyName)
  case prefsProperty (@lstring propertyName)
  case prefsPropertyWithOption (@lstring propertyName @lstring optionName)
  case selfControllerProperty (@lstring controllerName @lstring propertyName)
  case selfControllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName)
  case signatureProperty (@location location)
  case versionProperty (@location location)
  case versionShouldChangeProperty (@location location)
}

#·······················································································································

list @observablePropertyList {
  @observablePropertyAST mObservableProperty
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  rule <observable_property>
    !@observablePropertyAST outObservablePropertyAST
  {
    select
      $root$
      $.$
      $identifier$ ?let propertyName
      select
        outObservablePropertyAST = .rootProperty {!propertyName:propertyName}
      or
        $.$
        select
          $identifier$ ?let optionName
          outObservablePropertyAST = .rootPropertyWithOption {!propertyName:propertyName !optionName:optionName}
        or
          $all$
          $.$
          $identifier$ ?let observablePropertyName
          outObservablePropertyAST = .rootPropertyRelationship {
            !relationshipName:propertyName !propertyName:observablePropertyName
          }
        or
          $none$
          outObservablePropertyAST = .rootPropertyNone {!relationshipName:propertyName}
        end
      end
    or
      $self$
      $.$
      $identifier$ ?let propertyName
      select
        outObservablePropertyAST = .selfProperty {!propertyName:propertyName}
      or
        $.$ ;
        select
          $all$
          $.$
          $identifier$ ?let elementPropertyName
          outObservablePropertyAST = .selfPropertyArray {!propertyName:propertyName !elementPropertyName:elementPropertyName}
        or
          $one$
          $.$
          $identifier$ ?let elementPropertyName
          outObservablePropertyAST = .selfPropertyObject {!propertyName:propertyName !elementPropertyName:elementPropertyName}
        or
          $none$
          outObservablePropertyAST = .selfPropertyNone {!propertyName:propertyName}
        or
          $identifier$ ?let optionName
          outObservablePropertyAST = .selfPropertyWithOption {!propertyName:propertyName !optionName:optionName}
        end
      end
    or
      $prefs$
      $.$
      $identifier$ ?let propertyName
      select
        outObservablePropertyAST = .prefsProperty {!propertyName:propertyName}
      or
        $.$ ;
        $identifier$ ?let optionName
        outObservablePropertyAST = .prefsPropertyWithOption {!propertyName:propertyName !optionName:optionName}
      end
    or
      $identifier$ ?let controllerName
      $.$
      $identifier$ ?let propertyName
      select
        outObservablePropertyAST = .selfControllerProperty {!controllerName:controllerName !propertyName:propertyName}
      or
        $.$
        $identifier$ ?let secondaryPropertyName
        outObservablePropertyAST = .selfControllerSecondaryProperty {
          !controllerName:controllerName
          !propertyName:propertyName
          !secondaryPropertyName:secondaryPropertyName
        }
      end
    or
      $signature$
      outObservablePropertyAST = .signatureProperty {!location:.here}
    or
      $version$
      outObservablePropertyAST = .versionProperty {!location:.here}
    or
      $versionShouldChange$
      outObservablePropertyAST = .versionShouldChangeProperty {!location:.here}
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

}
   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                              
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @observablePropertyAST modelStringForSelf ?let @string inSelf -> @string outResult {
  switch self
  case rootProperty (@lstring propertyName) :
    outResult = inSelf + ".rootObject." + propertyName + "_property"
  case rootPropertyNone (@lstring propertyName) :
    outResult = inSelf + ".rootObject." + propertyName + "_property"
  case rootPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = inSelf + ".rootObject." + propertyName + "_property" + "." + optionName + "_property"
  case rootPropertyRelationship (@lstring relationshipName *) :
    outResult = inSelf + ".rootObject." + relationshipName + "_property"
  case selfProperty (@lstring propertyName) :
    outResult = inSelf + "." + propertyName + "_property"
  case selfPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = inSelf + "." + propertyName + "_property" + "." + optionName + "_property"
  case selfPropertyArray (@lstring propertyName @lstring unused elementPropertyName) :
    outResult = inSelf + "." + propertyName + "_property"
  case selfPropertyObject (@lstring propertyName @lstring unused elementPropertyName) :
    outResult = inSelf + "." + propertyName + "_property." + elementPropertyName + "_property"
  case selfPropertyNone (@lstring propertyName) :
    outResult = inSelf + "." + propertyName + "_property"
  case prefsProperty (@lstring propertyName) :
    outResult = "g_" + preferencesName () + "!." + propertyName + "_property"
  case prefsPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = "g_" + preferencesName () + "!." + propertyName + "_property" + "." + optionName + "_property"
  case selfControllerProperty (@lstring controllerName @lstring propertyName) :
    outResult = inSelf + "." + controllerName + "." + propertyName + "_property"
  case selfControllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) :
    outResult = inSelf + "." + controllerName + "." + propertyName + "_property" + "." + secondaryPropertyName + "_property"
  case signatureProperty (*) :
    outResult = "self.signatureObserver_property"
  case versionProperty (*) :
    outResult = "self.versionObserver_property"
  case versionShouldChangeProperty (*) :
    outResult = "self.versionShouldChangeObserver_property"
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @observablePropertyAST modelStringFunctionArgument -> @string outResult {
  switch self
  case rootProperty (@lstring propertyName) :
    outResult = "root_" + propertyName 
  case rootPropertyNone (@lstring propertyName) :
    outResult = "root_" + propertyName + "_none"
  case rootPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = "root_" + propertyName + "_" + optionName
  case rootPropertyRelationship (@lstring relationshipName @lstring elementPropertyName) :
    outResult = "root_" + relationshipName + "_" + elementPropertyName
  case selfProperty (@lstring propertyName) :
    outResult = "self_" + propertyName
  case selfPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = "self_" + propertyName + "_" + optionName
  case selfPropertyArray (@lstring propertyName @lstring elementPropertyName) :
    outResult = "self_" + propertyName + "_" + elementPropertyName
  case selfPropertyObject (@lstring propertyName @lstring elementPropertyName) :
    outResult = "self_" + propertyName + "_" + elementPropertyName
  case selfPropertyNone (@lstring propertyName) :
    outResult = "self_" + propertyName + "_none"
  case prefsProperty (@lstring propertyName) :
    outResult = "prefs_" + propertyName
  case prefsPropertyWithOption (@lstring propertyName @lstring optionName) :
    outResult = "prefs_" + propertyName + "_" + optionName
  case selfControllerProperty (@lstring controllerName @lstring propertyName) :
    outResult = "self_" + controllerName + "_" + propertyName
  case selfControllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) :
    outResult = "self_" + controllerName + "_" + propertyName + "_" + secondaryPropertyName
  case signatureProperty (*) :
    outResult = "self_signatureObserver"
  case versionProperty (*) :
    outResult = "self_versionObserver"
  case versionShouldChangeProperty (*) :
    outResult = "self_versionShouldChangeObserver"
  end  
}

#·······················································································································

getter @observablePropertyAST needs_unwSelf -> @bool outResult {
  switch self
  case rootProperty (*) :
    outResult = true
  case rootPropertyNone (*) :
    outResult = true
  case rootPropertyWithOption (* *) :
    outResult = true
  case rootPropertyRelationship (* *) :
    outResult = true
  case selfProperty (*) :
    outResult = true
  case selfPropertyWithOption (* *) :
    outResult = true
  case selfPropertyArray (* *) :
    outResult = true
  case selfPropertyObject (* *) :
    outResult = true
  case selfPropertyNone (*) :
    outResult = true
  case prefsProperty (*) :
    outResult = false
  case prefsPropertyWithOption (* *) :
    outResult = false
  case selfControllerProperty (* *) :
    outResult = true
  case selfControllerSecondaryProperty (* * *) :
    outResult = true
  case signatureProperty (*) :
    outResult = true
  case versionProperty (*) :
    outResult = true
  case versionShouldChangeProperty (*) :
    outResult = true
  end  
}

#·······················································································································

getter @observablePropertyAST location -> @location outResult {
  switch self
  case rootProperty (@lstring propertyName) :
    outResult = propertyName.location
  case rootPropertyNone (@lstring propertyName) :
    outResult = propertyName.location
  case rootPropertyWithOption (* @lstring optionName) :
    outResult = optionName.location
  case rootPropertyRelationship (* @lstring propertyName) :
    outResult = propertyName.location
  case selfProperty (@lstring propertyName) :
    outResult = propertyName.location
  case selfPropertyWithOption (@lstring propertyName *) :
    outResult = propertyName.location
  case selfPropertyArray (@lstring propertyName *) :
    outResult = propertyName.location
  case selfPropertyObject (@lstring propertyName *) :
    outResult = propertyName.location
  case selfPropertyNone (@lstring propertyName) :
    outResult = propertyName.location
  case prefsProperty (@lstring propertyName) :
    outResult = propertyName.location
  case prefsPropertyWithOption (@lstring propertyName *) :
    outResult = propertyName.location
  case selfControllerProperty (* @lstring propertyName) :
    outResult = propertyName.location
  case selfControllerSecondaryProperty (* * @lstring secondaryPropertyName) :
    outResult = secondaryPropertyName.location
  case signatureProperty (@location location) :
    outResult = location
  case versionProperty (@location location) :
    outResult = location
  case versionShouldChangeProperty (@location location) :
    outResult = location
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @observablePropertyAST analyzeObservableProperty
  ?let @propertyMap inRootPropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inBoundModelPropertyMap
  !@propertyKind outKind
  !@string outSwiftTypeStringForTransientFunctionArgument
{
  switch self
  case versionShouldChangeProperty (*) :
    let type = @typeKind.boolType
    outKind = .property {!type: type !accessibility: .transient {!isAbstract: false}}
    outSwiftTypeStringForTransientFunctionArgument = [type swiftTypeName]
  case versionProperty (*) :
    let type = @typeKind.integerType
    outKind = .property {!type: type !accessibility: .transient {!isAbstract: false}}
    outSwiftTypeStringForTransientFunctionArgument = [type swiftTypeName]
  case signatureProperty (*) :
    let type = @typeKind.integerType
    outKind = .property {!type: type !accessibility: .transient {!isAbstract: false}}
    outSwiftTypeStringForTransientFunctionArgument = [type swiftTypeName]
  case rootProperty (@lstring propertyName) :
    [inRootPropertyMap searchKey
      !propertyName
      ?outKind
      ?*
    ]
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  case rootPropertyNone (@lstring propertyName) :
    [inRootPropertyMap searchKey
      !propertyName
      ?let kind
      ?*
    ]
    switch kind
    case property (2*) :
      error propertyName : "a property cannot accept 'none'" : outKind
    case toMany (4*) :
      error propertyName : "an array property cannot accept 'none'" : outKind
    case toOne (4*) :
      outKind = .property {!type: .boolType !accessibility: .transient {!isAbstract: false}}
    case arrayController (2*) :
      error propertyName : "an array controller cannot accept 'none'" : outKind
    case selectionController (*) :
      error propertyName : "a selection controller cannot accept 'none'" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  case rootPropertyWithOption (@lstring propertyName @lstring optionName) :
    [inRootPropertyMap searchKey
      !propertyName
      ?let kind
      ?*
    ]
    switch kind
    case property (2*) :
      error propertyName : "a property cannot accept any option" : outKind
    case toMany (4*) :
      if optionName.string == "count" then
        outKind = .property {!type: .integerType !accessibility: .transient {!isAbstract: false}}
      else
        error optionName : "unknown option (accepted : 'count')" : outKind
      end
    case toOne (4*) :
      error propertyName : "a toOne property cannot accept any option" : outKind
    case arrayController (2*) :
      if optionName.string == "count" then
        outKind = .property {!type: .integerType !accessibility: .transient {!isAbstract: false}}
      elsif optionName.string == "empty" then
        outKind = .property {!type: .boolType !accessibility: .transient {!isAbstract: false}}
      else
        error optionName : "unknown option (accepted : 'count', 'empty')" : outKind
      end
    case selectionController (*) :
      error propertyName : "a selection controller cannot accept any option" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  case rootPropertyRelationship (@lstring relationshipName @lstring propertyName) : # root.xxx.all.xxx
    [inRootPropertyMap searchKey
      !relationshipName
      ?let kind
      ?*
    ]
    switch kind
    case property (2*) :
      error relationshipName : "a property cannot accept 'all'" : outKind
    case toMany (typeName 3*) : # Ok
      [inSemanticContext.mClassMap searchKey !.new {!typeName !relationshipName.location} ?* ?let observablePropertyMap ?2*]
      [observablePropertyMap searchKey
        !propertyName
        ?outKind
        ?*
      ]
    case toOne (4*) :
      error relationshipName : "a toOne property cannot accept 'all'" : outKind
    case arrayController (2*) :
      error relationshipName : "an array controller cannot accept 'all'" : outKind
    case selectionController (*) :
      error relationshipName : "an array controller cannot accept 'all'" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = "[" + [kind swiftTypeName] + "_" + propertyName + "]"
  case selfProperty (@lstring propertyName) :
    [inBoundModelPropertyMap searchKey
      !propertyName
      ?outKind
      ?*
    ]
    switch outKind
    case property (2*) :
      outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
    case toMany (4*) :
      error propertyName : "a toMany property cannot accept be observed" : outSwiftTypeStringForTransientFunctionArgument
    case toOne (4*) :
      error propertyName : "a toOne property cannot accept be observed" : outSwiftTypeStringForTransientFunctionArgument
    case arrayController (2*) :
      error propertyName : "an array controller cannot be observed" : outSwiftTypeStringForTransientFunctionArgument
    case selectionController (*) :
      error propertyName : "a selection controller cannot be observed" : outSwiftTypeStringForTransientFunctionArgument
    end
  case selfPropertyWithOption (@lstring propertyName @lstring optionName) :
    [inBoundModelPropertyMap searchKey
      !propertyName
      ?let kind
      ?*
    ]
    switch kind
    case property (2*) :
      error propertyName : "an atomic property accepts no option" : outKind
    case toMany (4*) :
      if optionName.string == "count" then
        outKind = .property {!type: .integerType !accessibility: .transient {!isAbstract: false}}
      else
        error optionName : "unknown option (accepted : 'count')" : outKind
      end
    case toOne (4*) :
      error propertyName : "a toOne property accepts no option" : outKind
    case arrayController (2*) :
      if optionName.string == "count" then
        outKind = .property {!type: .integerType !accessibility: .transient {!isAbstract: false}}
      elsif optionName.string == "empty" then
        outKind = .property {!type: .boolType !accessibility: .transient {!isAbstract: false}}
      else
        error optionName : "unknown option (accepted : 'count', 'empty')" : outKind
      end
    case selectionController (*) :
      error propertyName : "a selection controller accepts no option" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  case selfPropertyArray (@lstring propertyName @lstring elementPropertyName) : # self.xxx.all.xxx
    [inBoundModelPropertyMap searchKey
      !propertyName
      ?let kind
      ?*
    ]
    switch kind
    case property (2*) :
      error propertyName : "an atomic property accepts no option" : outKind
    case toMany (typeName 3*) :
      [inSemanticContext.mClassMap searchKey !typeName ?* ?let observablePropertyMap ?2*]
      [observablePropertyMap searchKey
        !elementPropertyName
        ?outKind
        ?*
      ]
    case toOne (4*) :
      error propertyName : "a toOne property accepts no option" : outKind
    case arrayController (2*) :
      error propertyName : "an array controller accepts no option" : outKind
    case selectionController (*) :
      error propertyName : "a selection controller accepts no option" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = "[" + [kind swiftTypeName]
       + "_" + elementPropertyName + "]"
  case selfPropertyObject (@lstring propertyName @lstring elementPropertyName) : # self.xxx.one.xxx
    [inBoundModelPropertyMap searchKey
      !propertyName
      ?let kind
      ?*
    ]
    switch kind
    case property (2*) :
      error propertyName : "an atomic property does not accept 'one'" : outKind
    case toMany (4*) :
      error propertyName : "a toOne property does not accept 'one'" : outKind
    case toOne (typeName 3*) :
      [inSemanticContext.mClassMap searchKey !typeName ?* ?let observablePropertyMap ?2*]
      [observablePropertyMap searchKey
        !elementPropertyName
        ?outKind
        ?*
      ]
    case arrayController (2*) :
      error propertyName : "an array controller does not accept 'one'" : outKind
    case selectionController (*) :
      error propertyName : "a selection controller does not accept 'one'" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName] + "?"
  case selfPropertyNone (@lstring propertyName) : # self.xxx.none
    [inBoundModelPropertyMap searchKey
      !propertyName
      ?let kind
      ?*
    ]
    switch kind
    case property (2*) :
      error propertyName : "an atomic property does not accept 'none'" : outKind
    case toMany (4*) :
      error propertyName : "a toOne property does not accept 'none'" : outKind
    case toOne (4*) :
      outKind = .property {!type: .boolType !accessibility: .transient {!isAbstract: false}}
    case arrayController (2*) :
      error propertyName : "an array controller does not accept 'none'" : outKind
    case selectionController (*) :
      error propertyName : "a selection controller does not accept 'none'" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  case prefsProperty (@lstring propertyName) :
    [inSemanticContext.mClassMap searchKey !.new {!preferencesName () !.nowhere} ?* ?let observablePropertyMap ?2*]
    [observablePropertyMap searchKey
      !propertyName
      ?outKind
      ?*
    ]
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  case prefsPropertyWithOption (@lstring propertyName @lstring optionName) :
    [inSemanticContext.mClassMap searchKey !.new {!preferencesName () !.nowhere} ?* ?let observablePropertyMap ?2*]
    [observablePropertyMap searchKey
      !propertyName
      ?let kind
      ?*
    ]
    switch kind
    case property (2*) :
      error propertyName : "a property cannot accept any option" : outKind
    case toMany (4*) :
      error propertyName : "a toMany property cannot accept any option" : outKind
    case toOne (4*) :
      error propertyName : "a toOne property cannot accept any option" : outKind
    case arrayController (2*) :
      if optionName.string == "count" then
        outKind = .property {!type: .integerType !accessibility: .transient {!isAbstract: false}}
      elsif optionName.string == "empty" then
        outKind = .property {!type: .boolType !accessibility: .transient {!isAbstract: false}}
      else
        error optionName : "unknown option (accepted : 'count', 'empty')" : outKind
      end
    case selectionController (*) :
      error propertyName : "a selection controller cannot accept any option" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  case selfControllerProperty (@lstring controllerName @lstring propertyName) :
    [inBoundModelPropertyMap searchKey
      !controllerName
      ?let @propertyKind propertyKind
      ?*
    ]
    switch propertyKind
    case property (2*) :
      error propertyName : "a property cannot accept any option" : outKind
    case toMany (4*) :
      error propertyName : "a toMany property cannot accept any option" : outKind
    case toOne (4*) :
      error propertyName : "a toOne property cannot accept any option" : outKind
    case arrayController (typeName graphic) :
      if (propertyName.string == "sortedArray") || (propertyName.string == "selectedArray") then
        outKind = .toMany {
          !typeName: typeName
          !accessibility: .transient {!isAbstract: false}
          !graphic: graphic
          !optionKind: .none
        }
      else
        error propertyName
          : "unknown option (accepted : 'sortedArray' or 'selectedArray')"
          : outKind
      end
    case selectionController (entityName) :
      [inSemanticContext.mClassMap searchKey !.new {!entityName !controllerName.location} ?* ?let observablePropertyMap ?2*]
#      [inSemanticContext.mEntityObservablePropertyMap searchKey
#        !.new {!entityName !controllerName.location}
#        ?let observablePropertyMap
#        ?*
#      ]
      [observablePropertyMap searchKey !propertyName ?outKind ?*]
    end
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  case selfControllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) :
    [inBoundModelPropertyMap searchKey !controllerName ?2*]
    if (propertyName.string == "sortedArray") && (secondaryPropertyName.string == "count") then
      outKind = .property {!type: .integerType !accessibility: .transient {!isAbstract: false}}
    elsif (propertyName.string == "selectedArray") && (secondaryPropertyName.string == "count") then
      outKind = .property {!type: .integerType !accessibility: .transient {!isAbstract: false}}
    else
      error propertyName : "unknown option" : outKind
    end
    outSwiftTypeStringForTransientFunctionArgument = [outKind swiftTypeName]
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

