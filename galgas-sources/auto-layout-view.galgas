#-----------------------------------------------------------------------------------------------------------------------
#   AST
#-----------------------------------------------------------------------------------------------------------------------

abstract class @astAbstractViewDeclaration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @astHorizontalStackViewDeclaration : @astAbstractViewDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astVerticalStackViewDeclaration : @astAbstractViewDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astComputedHorizontalViewDeclaration : @astAbstractViewDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @astViewInstructionList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astComputedVerticalViewDeclaration : @astAbstractViewDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @astViewInstructionList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

list @astViewDeclarationList {
  @lstring mViewName
  @astAbstractViewDeclaration mView
}

#-----------------------------------------------------------------------------------------------------------------------

abstract class @astAbstractViewInstructionDeclaration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @astHStackViewInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @astViewInstructionList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astVStackViewInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @astViewInstructionList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astSpaceViewInstruction : @astAbstractViewInstructionDeclaration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @astLocalViewInstruction : @astAbstractViewInstructionDeclaration {
  @lstring mLocalView
}

#-----------------------------------------------------------------------------------------------------------------------

class @astComputedViewInstruction : @astAbstractViewInstructionDeclaration {
  @lstring mAutoLayoutViewClassName
  @astAutoLayoutViewInstructionParameterList mParameterList
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @tableValueBinding mTableValueBinding
  @runActionDescriptor mRunActionDescriptor
  @multipleBindingDescriptor mEnabledBindingDescriptor
  @multipleBindingDescriptor mHiddenBindingDescriptor
  @graphicController mGraphicController
  @regularBindingList mRegularBindingList
}

#-----------------------------------------------------------------------------------------------------------------------

list @astAutoLayoutViewFunctionCallList {
  @lstring mFunctionName
  @astAutoLayoutViewInstructionParameterList mParameterList
}

#-----------------------------------------------------------------------------------------------------------------------

list @astAutoLayoutViewInstructionParameterList {
  @lstring mParameterName
  @autoLayoutClassParameterType mParameterType
  @string mParameterValue
}

#-----------------------------------------------------------------------------------------------------------------------

list @astViewInstructionList {
  @astAbstractViewInstructionDeclaration mInstruction
}

#-----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
#-----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

   #·····················································································································
  
  rule <view_declaration> ?!@astViewDeclarationList ioViewDeclarationList {
    $view$
    $identifier$ ?let viewName
    $:$
    select
      $hStack$
      <auto_layout_func_call_list> ?let functionCallList
      ioViewDeclarationList += !viewName !@astHorizontalStackViewDeclaration.new {!functionCallList}
    or
      $vStack$
      <auto_layout_func_call_list> ?let functionCallList
      ioViewDeclarationList += !viewName !@astVerticalStackViewDeclaration.new {!functionCallList}
    end
    $;$
  }
 
  #·····················································································································
  
  rule <view_declaration> ?!@astViewDeclarationList ioViewDeclarationList {
    $view$
    $identifier$ ?let viewName
    $vStack$
    <auto_layout_func_call_list> ?let functionCallList
    ${$
    var instructionList = @astViewInstructionList {}
    <view_instruction_list> !?instructionList
    $}$
    ioViewDeclarationList +=
      !viewName
      !@astComputedVerticalViewDeclaration.new {!functionCallList !instructionList}
  }
 
  #·····················································································································
  
  rule <auto_layout_func_call_list> !@astAutoLayoutViewFunctionCallList outFunctionCallList {
   outFunctionCallList = {}
   repeat
    while
       $identifier$ ?let functionName
       <view_actual_parameter_list> ?let actualParameterList
       outFunctionCallList += !functionName !actualParameterList
    end
  }
   
  #·····················································································································
  
  rule <view_declaration> ?!@astViewDeclarationList ioViewDeclarationList {
    $view$
    $identifier$ ?let viewName
    $hStack$
    <auto_layout_func_call_list> ?let functionCallList
    ${$
    var instructionList = @astViewInstructionList {}
    <view_instruction_list> !?instructionList
    $}$
    ioViewDeclarationList +=
      !viewName
      !@astComputedHorizontalViewDeclaration.new {!functionCallList !instructionList}
  }
 
  #·····················································································································
 
  rule <view_instruction_list> ?!@astViewInstructionList ioInstructionList {
    repeat
    while
      <view_instruction> ?let instruction
      ioInstructionList += !instruction
    end
  }
  
  #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    $space$
    $;$
    outInstruction = @astSpaceViewInstruction.new
  }
  
  #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    $view$
    $identifier$ ?let localViewName
    $;$
    outInstruction = @astLocalViewInstruction.new {!localViewName}
  }
  
 #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    <computed_view_instruction> ?let instruction
    outInstruction = instruction
  }
  
  #·····················································································································
 
  rule <computed_view_instruction> !@astComputedViewInstruction outInstruction {
    $Identifier$ ? let viewClassName
    <view_actual_parameter_list> ?let instanciationParameterList
    <auto_layout_func_call_list> ?let autoLayoutViewFunctionCallList
    <outlet_binding> ?let @tableValueBinding tableValueBinding
                     ?let @runActionDescriptor runActionDescriptor
                     ?let @multipleBindingDescriptor enabledBindingDescriptor
                     ?let @multipleBindingDescriptor hiddenBindingDescriptor
                     ?let @graphicController graphicController
                     ?let @regularBindingList regularBindingList
    $;$
    outInstruction = @astComputedViewInstruction.new {
      !viewClassName
      !instanciationParameterList
      !autoLayoutViewFunctionCallList
      !tableValueBinding
      !runActionDescriptor
      !enabledBindingDescriptor
      !hiddenBindingDescriptor
      !graphicController
      !regularBindingList
    }
  }
  
 #·····················································································································
 
  rule <view_actual_parameter_list> !@astAutoLayoutViewInstructionParameterList outParameterList {
    outParameterList = {}
    select
    or
      $($
      repeat
        $identifier$ ?let parameterName
        $:$
        select
          $identifier$ ?let viewName
          outParameterList += !parameterName !.typeView !"self." + viewName.string
        or
          $yes$
          outParameterList += !parameterName !.typeBool !"true"
        or
          $no$
          outParameterList += !parameterName !.typeBool !"false"
        or
          $literal_integer$ ?let uint32
          outParameterList += !parameterName !.typeInt ![uint32.uint string]
        or
          $-$
          $literal_integer$ ?let uint32
          outParameterList += !parameterName !.typeInt !"-" + [uint32.uint string]
        or
          $literal_string$ ?let literalString
          outParameterList += !parameterName !.typeString ![literalString.string cStringRepresentation]
        end
      while
        $,$
      end
      $)$
    end
  }
  
  #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    $vStack$
    <auto_layout_func_call_list> ?let functionCallList
    ${$
    var instructionList = @astViewInstructionList {}
    <view_instruction_list> !?instructionList
    outInstruction = @astVStackViewInstructionDeclaration.new {!functionCallList !instructionList}
    $}$
  }
  
  #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    $hStack$
    <auto_layout_func_call_list> ?let functionCallList
    ${$
    var instructionList = @astViewInstructionList {}
    <view_instruction_list> !?instructionList
    outInstruction = @astHStackViewInstructionDeclaration.new {!functionCallList !instructionList}
    $}$
  }
  
  #·····················································································································

}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC ANALYSIS                            
#-----------------------------------------------------------------------------------------------------------------------

map @autoLayoutViewDeclarationMap {
  insert insertKey error message "the '%K' view is already declared in %L"
  search searchKey error message "there is no '%K' view"
}

#·······················································································································

abstract method @astAbstractViewDeclaration check
  ?let @string inViewName
  ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @propertyMap inPreferencesPropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inObservablePropertyMap
  ?let @actionMap inActionMap
  ?let @string inReceiverSwiftTypeName
  !@abstractViewGeneration outGeneration

#·······················································································································

method @astAutoLayoutViewFunctionCallList check ?let @astAutoLayoutViewFunctionMap inFunctionMap
                                                !@autoLayoutViewInstructionGenerationFuncCallList outFuncCallList {
  outFuncCallList = {}
  for (functionName actualParameterList) in self do
    var mangleName = functionName.string + "("
    for (parameterName 2*) in actualParameterList do
      mangleName += parameterName.string + ":"
    end
    mangleName += ")"
    [inFunctionMap searchKey !.new {!mangleName !functionName.location} ?let formalParameterList]
    @autoLayoutViewInstructionGenerationParameterList parameterList = {}
    if [formalParameterList length] != [actualParameterList length] then
      error functionName 
      : [[formalParameterList length] string] + " parameter(s) required, " + [actualParameterList length] + " provided"
    else
      for (name type value) in actualParameterList, (formalName formalType) in formalParameterList do
        if type != formalType then
          error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
        end
        if name.string != formalName.string then
          error name : "the parameter name should be '" + formalName + "'"
        end
        parameterList += !name !value
      end
    end
    outFuncCallList += !functionName.string !parameterList
  end
}

#·······················································································································

override method @astHorizontalStackViewDeclaration check ?let @string unused inViewName
                                ?let @autoLayoutViewDeclarationMap unused inViewDeclarationMap
                                ?let @bool unused inPreferences
                                ?let @propertyMap unused inRootObservablePropertyMap
                                ?let @propertyMap unused inPreferencesPropertyMap
                                ?let @semanticContext inSemanticContext
                                ?let @propertyMap unused inObservablePropertyMap
                                ?let @actionMap unused inActionMap
                                ?let @string unused inReceiverSwiftTypeName
                                !@abstractViewGeneration outGeneration {
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutHStackFunctionMap
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  outGeneration = @newHorizontalStackViewGeneration.new {!funcCallList}
}

#·······················································································································

override method @astVerticalStackViewDeclaration check ?let @string unused inViewName
                                  ?let @autoLayoutViewDeclarationMap unused inViewDeclarationMap
                                  ?let @bool unused inPreferences
                                  ?let @propertyMap unused inRootObservablePropertyMap
                                  ?let @propertyMap unused inPreferencesPropertyMap
                                  ?let @semanticContext inSemanticContext
                                  ?let @propertyMap unused inObservablePropertyMap
                                  ?let @actionMap unused inActionMap
                                  ?let @string unused inReceiverSwiftTypeName
                                  !@abstractViewGeneration outGeneration {
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutVStackFunctionMap
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  outGeneration = @newVerticalStackViewGeneration.new {!funcCallList}
}

#·······················································································································

override method @astComputedHorizontalViewDeclaration check
                                  ?let @string unused inViewName
                                  ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                  ?let @bool inPreferences
                                  ?let @propertyMap inRootObservablePropertyMap
                                  ?let @propertyMap inPreferencesPropertyMap
                                  ?let @semanticContext inSemanticContext
                                  ?let @propertyMap inObservablePropertyMap
                                  ?let @actionMap inActionMap
                                  ?let @string inReceiverSwiftTypeName
                                  !@abstractViewGeneration outGeneration {
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutVStackFunctionMap
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
#  @autoLayoutViewInstructionGenerationFuncCallList funcCallList = {}
#  for (functionName actualParameterList) in mFunctionCallList do
#    [inSemanticContext.mAutoLayoutVStackFunctionMap searchKey !functionName ?let formalParameterList]
#    @autoLayoutViewInstructionGenerationParameterList parameterList = {}
#    if [formalParameterList length] != [actualParameterList length] then
#      error functionName 
#      : [[formalParameterList length] string] + " parameter(s) required, " + [actualParameterList length] + " provided"
#    else
#      for (name type value) in actualParameterList, (formalName formalType) in formalParameterList do
#        if type != formalType then
#          error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
#        end
#        if name.string != formalName.string then
#          error name : "the parameter name should be '" + formalName + "'"
#        end
#        parameterList += !name !value
#      end
#    end
#    funcCallList += !functionName.string !parameterList
#  end
  @autoLayoutViewInstructionGenerationList instructionList = {}
  for (instruction) in mInstructionList do
    [instruction generateCode
      !inViewDeclarationMap
      !inPreferences
      !inRootObservablePropertyMap
      !inPreferencesPropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !inActionMap
      !inReceiverSwiftTypeName
      ?let generatedInstruction
    ]
    instructionList += !generatedInstruction
  end
  outGeneration = @computedHorizontalViewGeneration.new {!funcCallList !instructionList}
}

#·······················································································································

override method @astComputedVerticalViewDeclaration check ?let @string unused inViewName
                                  ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                  ?let @bool inPreferences
                                  ?let @propertyMap inRootObservablePropertyMap
                                  ?let @propertyMap inPreferencesPropertyMap
                                  ?let @semanticContext inSemanticContext
                                  ?let @propertyMap inObservablePropertyMap
                                  ?let @actionMap inActionMap
                                  ?let @string inReceiverSwiftTypeName
                                  !@abstractViewGeneration outGeneration {
  @autoLayoutViewInstructionGenerationList instructionList = {}
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutVStackFunctionMap
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  for (instruction) in mInstructionList do
   [instruction generateCode
      !inViewDeclarationMap
      !inPreferences
      !inRootObservablePropertyMap
      !inPreferencesPropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !inActionMap
      !inReceiverSwiftTypeName
      ?let generatedInstruction
    ]
    instructionList += !generatedInstruction
  end
  outGeneration = @computedVerticalViewGeneration.new {!funcCallList !instructionList}
}

#·······················································································································

abstract method @astAbstractViewInstructionDeclaration generateCode ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                                      ?let @bool inPreferences
                                                      ?let @propertyMap inRootObservablePropertyMap
                                                      ?let @propertyMap inPreferencesPropertyMap
                                                      ?let @semanticContext inSemanticContext
                                                      ?let @propertyMap inObservablePropertyMap
                                                      ?let @actionMap inActionMap
                                                      ?let @string inReceiverSwiftTypeName
                                                       !@abstractViewInstructionGeneration outInstruction

#·······················································································································

override method @astSpaceViewInstruction generateCode
                                ?let @autoLayoutViewDeclarationMap unused inViewDeclarationMap
                                ?let @bool unused inPreferences
                                ?let @propertyMap unused inRootObservablePropertyMap
                                ?let @propertyMap unused inPreferencesPropertyMap
                                ?let @semanticContext unused inSemanticContext
                                ?let @propertyMap unused inObservablePropertyMap
                                ?let @actionMap unused inActionMap
                                ?let @string unused inReceiverSwiftTypeName
                                !@abstractViewInstructionGeneration outInstruction {
  outInstruction = @autoLayoutSpaceViewInstructionGeneration.new
}

#·······················································································································

override method @astLocalViewInstruction generateCode
                                ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                ?let @bool unused inPreferences
                                ?let @propertyMap unused inRootObservablePropertyMap
                                ?let @propertyMap unused inPreferencesPropertyMap
                                ?let @semanticContext unused inSemanticContext
                                ?let @propertyMap unused inObservablePropertyMap
                                ?let @actionMap unused inActionMap
                                ?let @string unused inReceiverSwiftTypeName
                                !@abstractViewInstructionGeneration outInstruction {
  [inViewDeclarationMap searchKey !mLocalView]
  outInstruction = @autoLayoutLocalViewInstructionGeneration.new {!mLocalView.string}
}

#·······················································································································

override method @astComputedViewInstruction generateCode
                                ?let @autoLayoutViewDeclarationMap unused inViewDeclarationMap
                                ?let @bool inPreferences
                                ?let @propertyMap inRootObservablePropertyMap
                                ?let @propertyMap inPreferencesPropertyMap
                                ?let @semanticContext inSemanticContext
                                ?let @propertyMap inObservablePropertyMap
                                ?let @actionMap inActionMap
                                ?let @string inReceiverSwiftTypeName
                                !@abstractViewInstructionGeneration outInstruction {
  [inSemanticContext.mAutolayoutViewClassMap searchKey !mAutoLayoutViewClassName
     ?7*
     ?let formalParameterList
     ?let functionMap
  ]
  @autoLayoutViewInstructionGenerationParameterList parameterList = {}
  if [formalParameterList length] != [mParameterList length] then
    error mAutoLayoutViewClassName 
    : [[formalParameterList length] string] + " parameter(s) required, " + [mParameterList length] + " provided"
  else
    for (name type value) in mParameterList, (formalName formalType) in formalParameterList do
      if type != formalType then
        error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
      end
      if name.string != formalName.string then
        error name : "the parameter name should be '" + formalName + "'"
      end
      parameterList += !name !value
    end
  end
#--- Bindings
  analyzeAutoLayoutBinding (
    !inPreferences
    !inRootObservablePropertyMap
    !inPreferencesPropertyMap
    !inSemanticContext
    !inObservablePropertyMap
    !inActionMap
    !inReceiverSwiftTypeName

    !mAutoLayoutViewClassName # ?let @lstring inTypeName

    ! mTableValueBinding
    ! mRunActionDescriptor
    ! mEnabledBindingDescriptor
    ! mHiddenBindingDescriptor
    ! mGraphicController
    ! mRegularBindingList

    ?let @autoLayoutRegularBindingsGenerationList regularBindingsGenerationList
    ?let @multipleBindingGenerationList multipleBindingGenerationList
    ?let @actionBindingListForGeneration targetActionList
    ?let @tableViewBindingGenerationList tableViewBindingGenerationList
    ?let @ebViewGraphicControllerBindingGenerationList ebViewGraphicControllerBindingGenerationList
  )
  [mFunctionCallList check
     !functionMap
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
#---  
  outInstruction = @autoLayoutComputedViewInstructionGeneration.new {
    !mAutoLayoutViewClassName
    !parameterList
    !funcCallList
    !regularBindingsGenerationList
    !multipleBindingGenerationList
    !targetActionList
    !tableViewBindingGenerationList
    !ebViewGraphicControllerBindingGenerationList
  }
}

#·······················································································································

proc analyzeAutoLayoutBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @propertyMap inPreferencesPropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inObservablePropertyMap
  ?let @actionMap inActionMap
  ?let @string inReceiverSwiftTypeName

  ?let @lstring inTypeName

  ?let @tableValueBinding inTableValueBinding
  ?let @runActionDescriptor inRunActionDescriptor
  ?let @multipleBindingDescriptor inEnabledBindingDescriptor
  ?let @multipleBindingDescriptor inHiddenBindingDescriptor
  ?let @graphicController inGraphicController
  ?let @regularBindingList inRegularBindingList

  !@autoLayoutRegularBindingsGenerationList outRegularBindingsGenerationList
  !@multipleBindingGenerationList outMultipleBindingGenerationList
  !@actionBindingListForGeneration outTargetActionList
  !@tableViewBindingGenerationList outTableViewBindingGenerationList
  !@ebViewGraphicControllerBindingGenerationList outEBViewGraphicControllerBindingGenerationList
{
  outRegularBindingsGenerationList = {}
  outTargetActionList = {}
  outMultipleBindingGenerationList = {}
  outTableViewBindingGenerationList = {}
  outEBViewGraphicControllerBindingGenerationList = {}
  [inSemanticContext.mAutolayoutViewClassMap searchKey
    !inTypeName
    ?*
    ?let @bool handlesRunAction
    ?let @bool handlesTableViewBinding
    ?let @bool handlesEnabledBinding
    ?let @bool handlesHiddenBinding
    ?let @bool handleGraphicControllerBinding
    ?3*
  ]
#--- $graphicController
  switch inGraphicController
  case none :
  case defined (@lstring controllerName @lstring propertyName) :
    if not handleGraphicControllerBinding then
      error inTypeName : "the '" + inTypeName + "' type does not handle the $graphicController binding"
    else
      [inObservablePropertyMap searchKey
        !controllerName
        ?let @propertyKind kind
        ?2*
      ]
      switch kind 
      case property (2*) :
        error controllerName : "the bound model should be an array controller"
      case toMany (4*) :
        error controllerName : "the bound model should be an array controller"
      case toOne (4*) :
        error controllerName : "the bound model should be an array controller"
      case arrayController (entityName graphic) :
        if propertyName.string == "" then
          if not graphic then
            error controllerName : "the controlled entity (" + entityName + ") should be a graphic entity"
          end
        else
          [inSemanticContext.mClassMap searchKey
            !entityName
            ?*
            ?let observablePropertyMap
            ?2*
          ]
          [observablePropertyMap searchKey !propertyName ?let propertyKind ?2*]
          switch propertyKind 
          case property (2*) :
            error controllerName : "the bound model should be a toMany property"
          case toMany (kEntityName * isGraphic *) :
            if not isGraphic then
              error controllerName : "the controlled entity (" + kEntityName + ") should be a graphic entity"
            end
          case toOne (4*) :
            error controllerName : "the bound model should be a toMany property"
          case arrayController (2*) :
            error controllerName : "the bound model should be a toMany property"
          case selectionController (*) :
            error controllerName : "the bound model should be a toMany property"
          end
       end
      case selectionController (*) :
        error controllerName : "the bound model should be an array controller"
      end
      outEBViewGraphicControllerBindingGenerationList += !"<<1>>" !controllerName.string
    end
  end
#--- $tableView
  switch inTableValueBinding
  case noTableValueBinding :
  case tableValueBinding (@lstring controllerName) :
    if not handlesTableViewBinding then
      error inTypeName : "the '" + inTypeName + "' type does not handle the $tableView binding"
    else
      [inObservablePropertyMap searchKey
        !controllerName
        ?let @propertyKind unused kind
        ?2*
      ]
      if not [kind isArrayController] then
        error controllerName : "the bound model should be an array controller"
      end
      outTableViewBindingGenerationList += !"<<2>>" !controllerName.string
    end
  end
#--- $run
  switch inRunActionDescriptor
  case noAction :
  case action (@lstring target @lstring action) :
    if not handlesRunAction then
      error inTypeName : "the '" + inTypeName + "' type does not handle run action"
    elsif target.string == "self" then
      [inActionMap searchKey !action]
      outTargetActionList +=
        !"<<3>>"
        !"self"
        !action.string
        !inReceiverSwiftTypeName
    else # It is a controller
      [inObservablePropertyMap searchKey
        !target
        ?*
        ?let @actionMap controllerActionMap
        ?*
      ]
      [controllerActionMap searchKey !action]
      outTargetActionList +=
        !"<<4>>"
        !if inPreferences then "prefs_" else "" end + target.string
        !action.string
        !"Controller_" + inReceiverSwiftTypeName + "_" + target
    end
  end
#--- Enabled
  switch inEnabledBindingDescriptor
  case noBinding :
  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
    [expression analyzeExpressionForMultipleBinding
      !inPreferences
      !inRootObservablePropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      ?let @abstractBooleanMultipleBindingExpressionForGeneration enableExpression
      ?let @typeKind type
      ?let @location errorLocation
    ]
    if not handlesEnabledBinding then
      error errorLocation : "cet outlet n'accepte pas le binding $enabled"
    end
    if not [type isBoolType] then
      error errorLocation : "expression is not boolean"
    end
    outMultipleBindingGenerationList +=
      !"<<5>>"
      !"enabled"
      !enableExpression
  end
#--- Hidden
  switch inHiddenBindingDescriptor
  case noBinding :
  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
    [expression analyzeExpressionForMultipleBinding
      !inPreferences
      !inRootObservablePropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression
      ?let @typeKind type
      ?let @location errorLocation
    ]
    if not [type isBoolType] then
      error errorLocation : "expression is not boolean"
    end
    if not handlesHiddenBinding then
      error errorLocation : "cet outlet n'accepte pas le binding $hidden"
    end
    outMultipleBindingGenerationList +=
      !"<<6>>"
      !"hidden"
      !hiddenExpression
  end
#---------------------------------- Regular bindings
  analyzeAutoLayoutRegularBinding (
    !inRootObservablePropertyMap
    !inPreferencesPropertyMap
    !inSemanticContext
    !inObservablePropertyMap
    !inTypeName
    !inRegularBindingList
    !if inPreferences then "prefs_" else "self." end
    !?outRegularBindingsGenerationList
  )
}

#·······················································································································

proc analyzeAutoLayoutRegularBinding
  ?let @propertyMap inRootPropertyMap
  ?let @propertyMap inPreferencesPropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inBoundModelPropertyMap
  ?let @lstring inOutletTypeName
  ?let @regularBindingList inRegularBindingList
  ?let @string inSelfSwiftName
  ?!@autoLayoutRegularBindingsGenerationList ioRegularBindingsGenerationList
{
  for () in inRegularBindingList do
  #--- Analyze model
    @outletBindingModelList boundModelTypeList = {}
    @boundObjectList boundModelListForGeneration = {}
    for () in mObservablePropertyList do
      [mObservableProperty analyzeObservableProperty
        !inRootPropertyMap
        !inSemanticContext
        !inBoundModelPropertyMap
        ?@propertyKind kind
        ?let @string unused swiftTypeStringForTransientFunctionArgument
      ]
      switch kind
      case property (2*) : # Ok
      case toMany (4*) :
        error [mObservableProperty location]:"a toMany property cannot be bound"
      case toOne (4*) :
        error [mObservableProperty location]:"a toOne property cannot be bound"
      case arrayController (2*) :
        error [mObservableProperty location]:"an array controller cannot be bound"
      case selectionController (*) :
        error [mObservableProperty location]:"a selection controller cannot be bound"
      end
      boundModelListForGeneration += ![mObservableProperty modelStringForSelf !inSelfSwiftName] !kind
      boundModelTypeList += !kind ![mObservableProperty location]
    end
  #--- Analyze outlet binding
    @outletBindingSpecificationModelList outletBindingSpecificationModelList = {}
    @controllerBindingOptionDecoratedList controllerBindingOptionDecoratedList = {}
    var outletTypeName = inOutletTypeName
    var continues = true
    loop ([inSemanticContext.mBindingSpecificationMap count] + 1) while (outletTypeName.string != "") & continues do
      continues = false
      [inSemanticContext.mAutoLayoutBindingSpecificationMap searchKey
        !outletTypeName
        ?let superOutletClassName
        ?let bindingMap
      ]
      if [bindingMap hasKey !mBindingName.string] then
        [bindingMap searchKey
          !mBindingName
          ?outletBindingSpecificationModelList
          ?controllerBindingOptionDecoratedList
        ]
      else
        continues = true
        outletTypeName = superOutletClassName
      end
    end
    if continues then
      error mBindingName : "this binding is not defined"
    elsif [boundModelTypeList length] != [outletBindingSpecificationModelList length] then
      error mBindingName
      : [[outletBindingSpecificationModelList length] string]
        + " model(s) required for this binding (found: "
        + [boundModelTypeList length] + ")"
    else
      for () required_ in outletBindingSpecificationModelList, () found_ in boundModelTypeList do
        if required_mModelShouldBeWritableProperty && [found_mKind isTransient] then
          error found_mErrorLocation : "the model is transient and the binding requires an writable model"
        end
        if [required_mModelType isEnumType] && [found_mKind isEnumType] then # Ok
        elsif [required_mModelType swiftTypeName] != [found_mKind swiftTypeName] then
          error found_mErrorLocation : "the model type should be " + [required_mModelType swiftTypeName]
        end
      end
    end
  #--- Check options
    var bindingOptionString = ""
    if [controllerBindingOptionDecoratedList length] != [mBindingOptionList length] then
      @string s
      if [controllerBindingOptionDecoratedList length] == 0 then
        s = "this binding has no option"
      else 
        s = "this binding requires the following options:"
        for () in controllerBindingOptionDecoratedList do
          s += "\n  - " + mOptionName + " : " + [mOptionType swiftTypeName]
        end
      end
      error mBindingName : s
    else
      for () controller_ in controllerBindingOptionDecoratedList, () binding_ in mBindingOptionList do
        if controller_mOptionName.string != binding_mOptionName.string then
          error binding_mOptionName : "the option name should be '" + controller_mOptionName + "'"
        end
        [binding_mOptionValue analyzeDefaultValueType 
          !{!controller_mOptionType}
          !inPreferencesPropertyMap
          ?let @string optionValueAsString
        ]
        bindingOptionString += ", " + controller_mOptionName.string + ":" + optionValueAsString
      end
    end
  #--- Generate binding
    ioRegularBindingsGenerationList +=
      !mBindingName.string
      !boundModelListForGeneration
      !bindingOptionString
  end
}

#·······················································································································

override method @astHStackViewInstructionDeclaration generateCode
                        ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                        ?let @bool inPreferences
                        ?let @propertyMap inRootObservablePropertyMap
                        ?let @propertyMap inPreferencesPropertyMap
                        ?let @semanticContext inSemanticContext
                        ?let @propertyMap inObservablePropertyMap
                        ?let @actionMap inActionMap
                        ?let @string inReceiverSwiftTypeName
                        !@abstractViewInstructionGeneration outInstruction {
  @autoLayoutViewInstructionGenerationList instructionList = {}
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutHStackFunctionMap
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  for (instruction) in mInstructionList do
   [instruction generateCode
      !inViewDeclarationMap
      !inPreferences
      !inRootObservablePropertyMap
      !inPreferencesPropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !inActionMap
      !inReceiverSwiftTypeName
      ?let generatedInstruction
    ]
    instructionList += !generatedInstruction
  end
  outInstruction = @hStackViewInstructionGeneration.new {!funcCallList !instructionList}
}

#·······················································································································

override method @astVStackViewInstructionDeclaration generateCode
                        ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                        ?let @bool inPreferences
                        ?let @propertyMap inRootObservablePropertyMap
                        ?let @propertyMap inPreferencesPropertyMap
                        ?let @semanticContext inSemanticContext
                        ?let @propertyMap inObservablePropertyMap
                        ?let @actionMap inActionMap
                        ?let @string inReceiverSwiftTypeName
                        !@abstractViewInstructionGeneration outInstruction {
  @autoLayoutViewInstructionGenerationList instructionList = {}
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutVStackFunctionMap
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  for (instruction) in mInstructionList do
   [instruction generateCode
      !inViewDeclarationMap
      !inPreferences
      !inRootObservablePropertyMap
      !inPreferencesPropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !inActionMap
      !inReceiverSwiftTypeName
      ?let generatedInstruction
    ]
    instructionList += !generatedInstruction
  end
  outInstruction = @vStackViewInstructionGeneration.new {!funcCallList !instructionList}
}

#-----------------------------------------------------------------------------------------------------------------------
#   GENERATION                            
#-----------------------------------------------------------------------------------------------------------------------

abstract class @abstractViewGeneration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @newHorizontalStackViewGeneration : @abstractViewGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
}

#-----------------------------------------------------------------------------------------------------------------------

class @newVerticalStackViewGeneration : @abstractViewGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
}

#-----------------------------------------------------------------------------------------------------------------------

class @computedHorizontalViewGeneration : @abstractViewGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  @autoLayoutViewInstructionGenerationList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @computedVerticalViewGeneration : @abstractViewGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  @autoLayoutViewInstructionGenerationList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

list @viewGenerationList {
  @string mViewName
  @abstractViewGeneration mView
}

#-----------------------------------------------------------------------------------------------------------------------

abstract class @abstractViewInstructionGeneration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @hStackViewInstructionGeneration : @abstractViewInstructionGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  @autoLayoutViewInstructionGenerationList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @vStackViewInstructionGeneration : @abstractViewInstructionGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  @autoLayoutViewInstructionGenerationList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @autoLayoutSpaceViewInstructionGeneration : @abstractViewInstructionGeneration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @autoLayoutLocalViewInstructionGeneration : @abstractViewInstructionGeneration {
  @string mLocalView
}

#·······················································································································

list @autoLayoutRegularBindingsGenerationList {
  @string mBindingName
  @boundObjectList mBoundObjectList
  @string mBindingOptionsString
}

#-----------------------------------------------------------------------------------------------------------------------

class @autoLayoutComputedViewInstructionGeneration : @abstractViewInstructionGeneration {
  @lstring mAutoLayoutViewClassName
  @autoLayoutViewInstructionGenerationParameterList mParameterList
  @autoLayoutViewInstructionGenerationFuncCallList mFunctionCallList
  @autoLayoutRegularBindingsGenerationList mRegularBindingsGenerationList
  @multipleBindingGenerationList mMultipleBindingGenerationList
  @actionBindingListForGeneration mTargetActionList
  @tableViewBindingGenerationList mTableViewBindingGenerationList
  @ebViewGraphicControllerBindingGenerationList mEBViewGraphicControllerBindingGenerationList
}

#-----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationParameterList {
  @string mParameterName
  @string mParameterValue
}

#-----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationFuncCallList {
  @string mFunctionName
  @autoLayoutViewInstructionGenerationParameterList mParameters
}

#-----------------------------------------------------------------------------------------------------------------------

method @autoLayoutViewInstructionGenerationFuncCallList generate ?let @string inIndentation ?!@string ioStr {
  for (funcName parameterList) in self do
    ioStr += inIndentation + "  ." + funcName + " ("
    for (parameterName parameterStringValue) in parameterList
      do ioStr += parameterName + ": " + parameterStringValue
      between ioStr += ", "
    end
    ioStr += ")\n"
  end
}

#-----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationList {
  @abstractViewInstructionGeneration mInstruction
}

#·······················································································································

abstract getter @abstractViewGeneration generate ?let @string inViewName -> @string

#·······················································································································

override getter @newHorizontalStackViewGeneration generate ?let @string inViewName -> @string {
  result = "  let " + inViewName + " : AutoLayoutStackView = AutoLayoutHorizontalStackView ()\n"
  [mFuncCallList generate !"    " !?result]
}

#·······················································································································

override getter @newVerticalStackViewGeneration generate ?let @string inViewName -> @string {
  result = "  let " + inViewName + " : AutoLayoutStackView = AutoLayoutVerticalStackView ()\n"
  [mFuncCallList generate !"    " !?result]
}

#·······················································································································

override getter @computedHorizontalViewGeneration generate ?let @string inViewName -> @string {
  result = "  lazy var " + inViewName + " = self." + inViewName + "_make ()\n\n"
  result += "  fileprivate final func " + inViewName + "_make () -> AutoLayoutStackView {\n"
  result += "    let hStackView = AutoLayoutHorizontalStackView ()\n"
  [mFuncCallList generate !"    " !?result]
  for (instruction) in mInstructionList do (index)
    let name = "view_" + index
    result += [instruction generate !name !"    "]
    result += "    hStackView.appendView (" + name + ")\n"
  end
  result += "    return hStackView\n"
  result += "  }\n\n"
}

#·······················································································································

override getter @computedVerticalViewGeneration generate ?let @string inViewName -> @string {
  result = "  lazy var " + inViewName + " = self." + inViewName + "_make ()\n\n"
  result += "  fileprivate final func " + inViewName + "_make () -> AutoLayoutStackView {\n"
  result += "    let vStackView = AutoLayoutVerticalStackView ()\n"
  [mFuncCallList generate !"    " !?result]
  for (instruction) in mInstructionList do (index)
    let name = "view_" + index
    result += [instruction generate !name !"    "]
    result += "    vStackView.appendView (" + name + ")\n"
  end
  result += "    return vStackView\n"
  result += "  }\n\n"
}

#·······················································································································

abstract getter  @abstractViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string

#·······················································································································

override getter @autoLayoutSpaceViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutFlexibleSpaceView ()\n"
}

#·······················································································································

override getter @autoLayoutLocalViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = self." + mLocalView + "\n"
}

#·······················································································································

override getter @autoLayoutComputedViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = " + mAutoLayoutViewClassName.string + " ("
  for parameter in mParameterList
  do
    result += parameter.mParameterName + ": " + parameter.mParameterValue
  between
    result += ", "
  end
  result += ")\n"
  [mFunctionCallList generate !inIndentation !?result]
  for (bindingName boundObjectList optionListString) in mRegularBindingsGenerationList do
    result += inIndentation + "    .bind_" + bindingName + " ("
    for (boundObjectString *) in boundObjectList
      do result += boundObjectString
      between result += ", "
    end
    result += optionListString + ")\n"
  end
}

#·······················································································································

override getter @hStackViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView ()\n"
  [mFuncCallList generate !inIndentation !?result]
  result += inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  for (instruction) in mInstructionList do (index)
     let name = inName + "_" + index
     result += [instruction generate !name !indentation]
     result += indentation + inName + ".appendView (" + name + ")\n"
  end
  result += inIndentation + "}\n"
}

#·······················································································································

override getter @vStackViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutVerticalStackView ()\n"
  [mFuncCallList generate !inIndentation !?result]
  result += inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  for (instruction) in mInstructionList do (index)
     let name = inName + "_" + index
     result += [instruction generate !name !indentation]
     result += indentation + inName + ".appendView (" + name + ")\n"
  end
  result += inIndentation + "}\n"
}

#-----------------------------------------------------------------------------------------------------------------------
