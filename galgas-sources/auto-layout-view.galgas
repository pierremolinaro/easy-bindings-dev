#-----------------------------------------------------------------------------------------------------------------------
#   AST
#-----------------------------------------------------------------------------------------------------------------------

abstract class @astAbstractViewDeclaration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @astHorizontalStackViewDeclaration : @astAbstractViewDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astVerticalStackViewDeclaration : @astAbstractViewDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astComputedHorizontalViewDeclaration : @astAbstractViewDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @astViewInstructionList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astComputedVerticalViewDeclaration : @astAbstractViewDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @astViewInstructionList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

list @astViewDeclarationList {
  @lstring mViewName
  @astAbstractViewDeclaration mView
}

#-----------------------------------------------------------------------------------------------------------------------

abstract class @astAbstractViewInstructionDeclaration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @astHStackViewInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @astViewInstructionList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astVStackViewInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @astViewInstructionList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @astSpaceViewInstruction : @astAbstractViewInstructionDeclaration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @astLocalViewInstruction : @astAbstractViewInstructionDeclaration {
  @lstring mLocalView
}

#-----------------------------------------------------------------------------------------------------------------------

class @astComputedViewInstruction : @astAbstractViewInstructionDeclaration {
  @lstring mAutoLayoutViewClassName
  @astAutoLayoutViewInstructionParameterList mParameterList
  @astAutoLayoutViewFunctionCallList mFunctionCallList
  @tableValueBinding mTableValueBinding
  @runActionDescriptor mRunActionDescriptor
  @multipleBindingDescriptor mEnabledBindingDescriptor
  @multipleBindingDescriptor mHiddenBindingDescriptor
  @graphicController mGraphicController
  @regularBindingList mRegularBindingList
}

#-----------------------------------------------------------------------------------------------------------------------

list @astAutoLayoutViewFunctionCallList {
  @lstring mFunctionName
  @astAutoLayoutViewInstructionParameterList mParameterList
}

#-----------------------------------------------------------------------------------------------------------------------

enum @astAutoLayoutViewInstructionParameterValue {
  case string (@string value)
  case menuItem (@string title @runActionDescriptor run @multipleBindingDescriptor enabled)
  case enumFunc (@lstring enumTypeName @lstring enumFuncName)
  case viewFunc (@astAbstractViewInstructionDeclaration instruction)
}
#-----------------------------------------------------------------------------------------------------------------------

list @astAutoLayoutViewInstructionParameterList {
  @lstring mParameterName
  @autoLayoutClassParameterType mParameterType
  @astAutoLayoutViewInstructionParameterValue mParameter
}

#-----------------------------------------------------------------------------------------------------------------------

list @astViewInstructionList {
  @astAbstractViewInstructionDeclaration mInstruction
}

#-----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
#-----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

   #·····················································································································
  
  rule <stack_view_declaration> ?!@astViewDeclarationList ioViewDeclarationList {
    $stackView$
    $identifier$ ?let viewName
    $:$
    select
      $hStack$
      <auto_layout_func_call_list> ?let functionCallList
      ioViewDeclarationList += !viewName !@astHorizontalStackViewDeclaration.new {!functionCallList}
    or
      $vStack$
      <auto_layout_func_call_list> ?let functionCallList
      ioViewDeclarationList += !viewName !@astVerticalStackViewDeclaration.new {!functionCallList}
    end
    $;$
  }
 
  #·····················································································································
  
  rule <stack_view_declaration> ?!@astViewDeclarationList ioViewDeclarationList {
    $stackView$
    $identifier$ ?let viewName
    $vStack$
    <auto_layout_func_call_list> ?let functionCallList
    ${$
    var instructionList = @astViewInstructionList {}
    <view_instruction_list> !?instructionList
    $}$
    ioViewDeclarationList +=
      !viewName
      !@astComputedVerticalViewDeclaration.new {!functionCallList !instructionList}
  }
 
  #·····················································································································
  
  rule <auto_layout_func_call_list> !@astAutoLayoutViewFunctionCallList outFunctionCallList {
   outFunctionCallList = {}
   repeat
    while
       $identifier$ ?let functionName
       <view_actual_parameter_list> ?let actualParameterList
       outFunctionCallList += !functionName !actualParameterList
    end
  }
   
  #·····················································································································
  
  rule <stack_view_declaration> ?!@astViewDeclarationList ioViewDeclarationList {
    $stackView$
    $identifier$ ?let viewName
    $hStack$
    <auto_layout_func_call_list> ?let functionCallList
    ${$
    var instructionList = @astViewInstructionList {}
    <view_instruction_list> !?instructionList
    $}$
    ioViewDeclarationList +=
      !viewName
      !@astComputedHorizontalViewDeclaration.new {!functionCallList !instructionList}
  }
 
  #·····················································································································
 
  rule <view_instruction_list> ?!@astViewInstructionList ioInstructionList {
    repeat
    while
      <view_instruction> ?let instruction
      ioInstructionList += !instruction
    end
  }
  
  #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    $space$
    outInstruction = @astSpaceViewInstruction.new
  }
  
  #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    $view$
    $identifier$ ?let localViewName
    outInstruction = @astLocalViewInstruction.new {!localViewName}
  }
  
 #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    <computed_view_instruction> ?let instruction
    outInstruction = instruction
  }
  
  #·····················································································································
 
  rule <computed_view_instruction> !@astComputedViewInstruction outInstruction {
    $Identifier$ ? let viewClassName
    @astAutoLayoutViewInstructionParameterList instanciationParameterList
    select
      instanciationParameterList = {}
    or
      <view_actual_parameter_list> ?instanciationParameterList
    end
    @tableValueBinding tableValueBinding
    @runActionDescriptor runActionDescriptor
    @multipleBindingDescriptor enabledBindingDescriptor
    @multipleBindingDescriptor hiddenBindingDescriptor
    @graphicController graphicController
    @regularBindingList regularBindingList
    @astAutoLayoutViewFunctionCallList autoLayoutViewFunctionCallList
    select
      tableValueBinding = .noTableValueBinding
      runActionDescriptor = .noAction
      enabledBindingDescriptor = .noBinding
      hiddenBindingDescriptor = .noBinding
      graphicController = .none
      regularBindingList = {}
      autoLayoutViewFunctionCallList = {}
    or
      ${$
      <auto_layout_func_call_list> ?autoLayoutViewFunctionCallList
      <outlet_binding> ?tableValueBinding
                       ?runActionDescriptor
                       ?enabledBindingDescriptor
                       ?hiddenBindingDescriptor
                       ?graphicController
                       ?regularBindingList
      $}$
    end
    outInstruction = @astComputedViewInstruction.new {
      !viewClassName
      !instanciationParameterList
      !autoLayoutViewFunctionCallList
      !tableValueBinding
      !runActionDescriptor
      !enabledBindingDescriptor
      !hiddenBindingDescriptor
      !graphicController
      !regularBindingList
    }
  }
  
 #·····················································································································
 
  rule <view_actual_parameter_list> !@astAutoLayoutViewInstructionParameterList outParameterList {
    outParameterList = {}
    $($
    select
    or
      repeat
        $identifier$ ?let parameterName
        $:$
        select
          <view_instruction> ?let @astAbstractViewInstructionDeclaration instruction
          outParameterList += !parameterName !.typeView !.viewFunc {!instruction: instruction}
        or
          $menuItem$
          $literal_string$ ?let menuItemTitle
          @runActionDescriptor runActionDescriptor
          select
            runActionDescriptor = .noAction
          or
            $run$
            @lstring runTargetName
            select
              runTargetName = @lstring.new {!"self" !.here}
            or
              $controllerName$ ?runTargetName
              $.$
            end
            $identifier$ ?let @lstring runActionName
            runActionDescriptor = .action {!target:runTargetName !action:runActionName}
          end
          @multipleBindingDescriptor enabledBindingDescriptor = .noBinding
          select
            enabledBindingDescriptor = .noBinding
          or
            $enabled$
            <booleanMultipleBindingExpression> ?let @abstractBooleanMultipleBindingExpressionAST bindingExpression
            enabledBindingDescriptor = .binding {!expression:bindingExpression}
          end
          outParameterList +=
           !parameterName
           !.menuItem
           !.menuItem {!title: menuItemTitle !run: runActionDescriptor !enabled: enabledBindingDescriptor}
        or
          $stackView$
          $identifier$ ?let viewName
          outParameterList += !parameterName !.typeView !.string {!value: "self." + viewName.string}
        or
          $yes$
          outParameterList += !parameterName !.typeBool !.string {!value: "true"}
        or
          $no$
          outParameterList += !parameterName !.typeBool !.string {!value: "false"}
        or
          $literal_integer$ ?let uint32
          outParameterList += !parameterName !.typeInt !.string {!value: [uint32.uint string]}
        or
          $-$
          $literal_integer$ ?let uint32
          outParameterList += !parameterName !.typeInt !.string {!value: "-" + [uint32.uint string]}
        or
          $literal_string$ ?let literalString
          outParameterList += !parameterName !.typeString !.string {!value: [literalString.string cStringRepresentation]}
        or
          $enum$
          $Identifier$ ?let enumTypeName
          $.$
          $identifier$ ?let enumFuncName
          outParameterList +=
           !parameterName 
           !.typeStringArray !.enumFunc {!enumTypeName: enumTypeName !enumFuncName: enumFuncName}
        end
      while
        $,$
      end
    end
    $)$
  }
  
  #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    $vStack$
    <auto_layout_func_call_list> ?let functionCallList
    ${$
    var instructionList = @astViewInstructionList {}
    <view_instruction_list> !?instructionList
    outInstruction = @astVStackViewInstructionDeclaration.new {!functionCallList !instructionList}
    $}$
  }
  
  #·····················································································································
 
  rule <view_instruction> !@astAbstractViewInstructionDeclaration outInstruction {
    $hStack$
    <auto_layout_func_call_list> ?let functionCallList
    ${$
    var instructionList = @astViewInstructionList {}
    <view_instruction_list> !?instructionList
    outInstruction = @astHStackViewInstructionDeclaration.new {!functionCallList !instructionList}
    $}$
  }
  
  #·····················································································································

}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC ANALYSIS                            
#-----------------------------------------------------------------------------------------------------------------------

map @autoLayoutViewDeclarationMap {
  insert insertKey error message "the '%K' view is already declared in %L"
  search searchKey error message "there is no '%K' view"
}

#·······················································································································

list @implicitViewFunctionGenerationList {
  @abstractViewInstructionGeneration mInstruction
}

#·······················································································································

abstract method @astAbstractViewDeclaration check
  ?let @string inViewName
  ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @propertyMap inPreferencesPropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inObservablePropertyMap
  ?let @actionMap inActionMap
  ?let @string inReceiverSwiftTypeName
  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
  !@abstractViewGeneration outGeneration

#·······················································································································

method @astAutoLayoutViewFunctionCallList check
                                ?let @astAutoLayoutViewFunctionMap inFunctionMap
                                ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                ?let @bool inPreferences
                                ?let @propertyMap inRootObservablePropertyMap
                                ?let @propertyMap inPreferencesPropertyMap
                                ?let @semanticContext inSemanticContext
                                ?let @propertyMap inObservablePropertyMap
                                ?let @actionMap inActionMap
                                ?let @string inReceiverSwiftTypeName
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                                !@autoLayoutViewInstructionGenerationFuncCallList outFuncCallList {
  outFuncCallList = {}
  for (functionName actualParameterList) in self do
    var mangleName = functionName.string + "("
    for (parameterName 2*) in actualParameterList do
      mangleName += parameterName.string + ":"
    end
    mangleName += ")"
    [inFunctionMap searchKey !.new {!mangleName !functionName.location} ?let formalParameterList]
    @autoLayoutViewInstructionGenerationParameterList parameterList = {}
    if [formalParameterList length] != [actualParameterList length] then
      error functionName 
      : [[formalParameterList length] string] + " parameter(s) required, " + [actualParameterList length] + " provided"
    else
      for (name type value) in actualParameterList, (formalName formalType) in formalParameterList do
        if type != formalType then
          error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
        end
        if name.string != formalName.string then
          error name : "the parameter name should be '" + formalName + "'"
        end
        switch value
        case viewFunc (instruction) :
          [instruction generateCode 
            !inViewDeclarationMap
            !inPreferences
            !inRootObservablePropertyMap
            !inPreferencesPropertyMap
            !inSemanticContext
            !inObservablePropertyMap
            !inActionMap
            !inReceiverSwiftTypeName
            !?ioImplicitViewFunctionGenerationList
            ?let @abstractViewInstructionGeneration viewInstruction
          ]
          parameterList += !name !"self.computeImplicitView_" + [ioImplicitViewFunctionGenerationList length] + " ()"
          ioImplicitViewFunctionGenerationList += !viewInstruction
        case string (stringValue) :
          parameterList += !name !stringValue
        case menuItem (title run enabledBinding) :
          analyzeAutoLayoutRunBinding (
            !run
            !handlesRunAction: true
            !inPreferences
            !["" nowhere] # mAutoLayoutViewClassName # inTypeName
            !inActionMap
            !inObservablePropertyMap
            !inReceiverSwiftTypeName
            ?let runBindingGeneration
          )
          analyzeAutoLayoutEnableBinding (
            !enabledBinding
            !handlesEnabledBinding: true
            !inPreferences
            !inRootObservablePropertyMap
            !inSemanticContext
            !inObservablePropertyMap
            ?let enabledBindingGeneration
          )
          var s = "AutoLayoutMenuItemDescriptor (title: " + [title utf8Representation]
          switch runBindingGeneration 
          case none :
            s += ", target: nil, selector: nil"
          case run (targetName actionName runTargetName) :
            s += ", target: " + targetName + ", selector: #selector (" + runTargetName + "." + actionName + " (_:))"
          end
          switch enabledBindingGeneration 
          case none :
            s += ", observedObjects: [], computeFunction: { return .empty }"
          case enabled (binding) :
            s += ", observedObjects: ["
            for () in [binding observedModelSet]
              do s += key
              between s += ", "
            end
            s += "], computeFunction: { return " + [binding expressionString] + " }"
          end
          s += ")"
          parameterList += !name !s
        case enumFunc (enumTypeName funcName) :
          [inSemanticContext.mClassMap searchKey !enumTypeName ?let type ?3*]
          if not [type isAtomic] then
            error enumTypeName : "this type should be an enum type"
          else
            [type atomic ?kind:let typeKind]
            if [typeKind isEnumType] then
              [typeKind enumType ?2* ?funcMap:let funcMap]
              [funcMap searchKey !funcName ?*]
            else
              error enumTypeName : "this type should be an enum type"
            end
          end
          parameterList += !name !enumTypeName.string + "." + funcName + " ()"
        end
      end
    end
    outFuncCallList += !functionName.string !parameterList
  end
}

#·······················································································································

override method @astHorizontalStackViewDeclaration check ?let @string unused inViewName
                                ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                ?let @bool inPreferences
                                ?let @propertyMap inRootObservablePropertyMap
                                ?let @propertyMap inPreferencesPropertyMap
                                ?let @semanticContext inSemanticContext
                                ?let @propertyMap inObservablePropertyMap
                                ?let @actionMap inActionMap
                                ?let @string inReceiverSwiftTypeName
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                                !@abstractViewGeneration outGeneration {
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutHStackFunctionMap
     !inViewDeclarationMap
     !inPreferences
     !inRootObservablePropertyMap
     !inPreferencesPropertyMap
     !inSemanticContext
     !inObservablePropertyMap
     !inActionMap
     !inReceiverSwiftTypeName
     !?ioImplicitViewFunctionGenerationList
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  outGeneration = @newHorizontalStackViewGeneration.new {!funcCallList}
}

#·······················································································································

override method @astVerticalStackViewDeclaration check ?let @string unused inViewName
                                  ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                  ?let @bool inPreferences
                                  ?let @propertyMap inRootObservablePropertyMap
                                  ?let @propertyMap inPreferencesPropertyMap
                                  ?let @semanticContext inSemanticContext
                                  ?let @propertyMap inObservablePropertyMap
                                  ?let @actionMap inActionMap
                                  ?let @string inReceiverSwiftTypeName
                                  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                                  !@abstractViewGeneration outGeneration {
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutVStackFunctionMap
     !inViewDeclarationMap
     !inPreferences
     !inRootObservablePropertyMap
     !inPreferencesPropertyMap
     !inSemanticContext
     !inObservablePropertyMap
     !inActionMap
     !inReceiverSwiftTypeName
     !?ioImplicitViewFunctionGenerationList
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  outGeneration = @newVerticalStackViewGeneration.new {!funcCallList}
}

#·······················································································································

override method @astComputedHorizontalViewDeclaration check
                                  ?let @string unused inViewName
                                  ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                  ?let @bool inPreferences
                                  ?let @propertyMap inRootObservablePropertyMap
                                  ?let @propertyMap inPreferencesPropertyMap
                                  ?let @semanticContext inSemanticContext
                                  ?let @propertyMap inObservablePropertyMap
                                  ?let @actionMap inActionMap
                                  ?let @string inReceiverSwiftTypeName
                                  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                                  !@abstractViewGeneration outGeneration {
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutVStackFunctionMap
     !inViewDeclarationMap
     !inPreferences
     !inRootObservablePropertyMap
     !inPreferencesPropertyMap
     !inSemanticContext
     !inObservablePropertyMap
     !inActionMap
     !inReceiverSwiftTypeName
     !?ioImplicitViewFunctionGenerationList
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  @autoLayoutViewInstructionGenerationList instructionList = {}
  for (instruction) in mInstructionList do
    [instruction generateCode
      !inViewDeclarationMap
      !inPreferences
      !inRootObservablePropertyMap
      !inPreferencesPropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !inActionMap
      !inReceiverSwiftTypeName
      !?ioImplicitViewFunctionGenerationList
      ?let generatedInstruction
    ]
    instructionList += !generatedInstruction
  end
  outGeneration = @computedHorizontalViewGeneration.new {!funcCallList !instructionList}
}

#·······················································································································

override method @astComputedVerticalViewDeclaration check ?let @string unused inViewName
                                  ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                  ?let @bool inPreferences
                                  ?let @propertyMap inRootObservablePropertyMap
                                  ?let @propertyMap inPreferencesPropertyMap
                                  ?let @semanticContext inSemanticContext
                                  ?let @propertyMap inObservablePropertyMap
                                  ?let @actionMap inActionMap
                                  ?let @string inReceiverSwiftTypeName
                                  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                                  !@abstractViewGeneration outGeneration {
  @autoLayoutViewInstructionGenerationList instructionList = {}
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutVStackFunctionMap
     !inViewDeclarationMap
     !inPreferences
     !inRootObservablePropertyMap
     !inPreferencesPropertyMap
     !inSemanticContext
     !inObservablePropertyMap
     !inActionMap
     !inReceiverSwiftTypeName
     !?ioImplicitViewFunctionGenerationList
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  for (instruction) in mInstructionList do
   [instruction generateCode
      !inViewDeclarationMap
      !inPreferences
      !inRootObservablePropertyMap
      !inPreferencesPropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !inActionMap
      !inReceiverSwiftTypeName
      !?ioImplicitViewFunctionGenerationList
      ?let generatedInstruction
    ]
    instructionList += !generatedInstruction
  end
  outGeneration = @computedVerticalViewGeneration.new {!funcCallList !instructionList}
}

#·······················································································································

abstract method @astAbstractViewInstructionDeclaration generateCode ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                                      ?let @bool inPreferences
                                                      ?let @propertyMap inRootObservablePropertyMap
                                                      ?let @propertyMap inPreferencesPropertyMap
                                                      ?let @semanticContext inSemanticContext
                                                      ?let @propertyMap inObservablePropertyMap
                                                      ?let @actionMap inActionMap
                                                      ?let @string inReceiverSwiftTypeName
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                                                       !@abstractViewInstructionGeneration outInstruction

#·······················································································································

override method @astSpaceViewInstruction generateCode
                                ?let @autoLayoutViewDeclarationMap unused inViewDeclarationMap
                                ?let @bool unused inPreferences
                                ?let @propertyMap unused inRootObservablePropertyMap
                                ?let @propertyMap unused inPreferencesPropertyMap
                                ?let @semanticContext unused inSemanticContext
                                ?let @propertyMap unused inObservablePropertyMap
                                ?let @actionMap unused inActionMap
                                ?let @string unused inReceiverSwiftTypeName
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList
                                !@abstractViewInstructionGeneration outInstruction {
  outInstruction = @autoLayoutSpaceViewInstructionGeneration.new
}

#·······················································································································

override method @astLocalViewInstruction generateCode
                                ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                ?let @bool unused inPreferences
                                ?let @propertyMap unused inRootObservablePropertyMap
                                ?let @propertyMap unused inPreferencesPropertyMap
                                ?let @semanticContext unused inSemanticContext
                                ?let @propertyMap unused inObservablePropertyMap
                                ?let @actionMap unused inActionMap
                                ?let @string unused inReceiverSwiftTypeName
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList
                                !@abstractViewInstructionGeneration outInstruction {
  [inViewDeclarationMap searchKey !mLocalView]
  outInstruction = @autoLayoutLocalViewInstructionGeneration.new {!mLocalView.string}
}

#·······················································································································

override method @astComputedViewInstruction generateCode
                                ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                                ?let @bool inPreferences
                                ?let @propertyMap inRootObservablePropertyMap
                                ?let @propertyMap inPreferencesPropertyMap
                                ?let @semanticContext inSemanticContext
                                ?let @propertyMap inObservablePropertyMap
                                ?let @actionMap inActionMap
                                ?let @string inReceiverSwiftTypeName
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                                !@abstractViewInstructionGeneration outInstruction {
  [inSemanticContext.mAutolayoutViewClassMap searchKey !mAutoLayoutViewClassName
     ?7*
     ?let formalParameterList
     ?let functionMap
  ]
  @autoLayoutViewInstructionGenerationParameterList parameterList = {}
  if [formalParameterList length] != [mParameterList length] then
    error mAutoLayoutViewClassName 
    : [[formalParameterList length] string] + " parameter(s) required, " + [mParameterList length] + " provided"
  else
    for (name type value) in mParameterList, (formalName formalType) in formalParameterList do
      if type != formalType then
        error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
      end
      if name.string != formalName.string then
        error name : "the parameter name should be '" + formalName + "'"
      end
      switch value
        case viewFunc (instruction) :
          [instruction generateCode 
            !inViewDeclarationMap
            !inPreferences
            !inRootObservablePropertyMap
            !inPreferencesPropertyMap
            !inSemanticContext
            !inObservablePropertyMap
            !inActionMap
            !inReceiverSwiftTypeName
            !?ioImplicitViewFunctionGenerationList
            ?let @abstractViewInstructionGeneration viewInstruction
          ]
          parameterList += !name !"self.computeImplicitView_" + [ioImplicitViewFunctionGenerationList length] + " ()"
          ioImplicitViewFunctionGenerationList += !viewInstruction
      case string (stringValue) :
        parameterList += !name !stringValue
      case menuItem (title run enabledBinding) :
        analyzeAutoLayoutRunBinding (
          !run
          !handlesRunAction: true
          !inPreferences
          !["" nowhere] # mAutoLayoutViewClassName # inTypeName
          !inActionMap
          !inObservablePropertyMap
          !inReceiverSwiftTypeName
          ?let runBindingGeneration
        )
        analyzeAutoLayoutEnableBinding (
          !enabledBinding
          !handlesEnabledBinding: true
          !inPreferences
          !inRootObservablePropertyMap
          !inSemanticContext
          !inObservablePropertyMap
          ?let enabledBindingGeneration
        )
        var s = "AutoLayoutMenuItemDescriptor (title: " + [title utf8Representation]
        switch runBindingGeneration 
        case none :
          s += ", target: nil, selector: nil"
        case run (targetName actionName runTargetName) :
          s += ", target: " + targetName + ", selector: #selector (" + runTargetName + "." + actionName + " (_:))"
        end
        switch enabledBindingGeneration 
        case none :
          s += ", observedObjects: [], computeFunction: { return .empty }"
        case enabled (binding) :
          s += ", observedObjects: ["
          for () in [binding observedModelSet]
            do s += key
            between s += ", "
          end
          s += "], computeFunction: { return " + [binding expressionString] + " }"
        end
        s += ")"
        parameterList += !name !s
      case enumFunc (enumTypeName funcName) :
        [inSemanticContext.mClassMap searchKey !enumTypeName ?let type ?3*]
        if not [type isAtomic] then
          error enumTypeName : "this type should be an enum type"
        else
          [type atomic ?kind:let typeKind]
          if [typeKind isEnumType] then
            [typeKind enumType ?2* ?funcMap:let funcMap]
            [funcMap searchKey !funcName ?*]
          else
            error enumTypeName : "this type should be an enum type"
          end
        end
        parameterList += !name !enumTypeName.string + "." + funcName + " ()"
      end
    end
  end
#--- Bindings
  analyzeAutoLayoutBinding (
    !inPreferences
    !inRootObservablePropertyMap
    !inPreferencesPropertyMap
    !inSemanticContext
    !inObservablePropertyMap
    !inActionMap
    !inReceiverSwiftTypeName

    !mAutoLayoutViewClassName

    ! mTableValueBinding
    ! mRunActionDescriptor
    ! mEnabledBindingDescriptor
    ! mHiddenBindingDescriptor
    ! mGraphicController
    ! mRegularBindingList

    ?let @autoLayoutRegularBindingsGenerationList regularBindingsGenerationList
    ?let @autoLayoutMultipleBindingGenerationList multipleBindingGenerationList
    ?let @autolayoutRunBindingForGeneration runBindingGeneration
    ?let @tableViewBindingGenerationList tableViewBindingGenerationList
    ?let @autoLayoutViewGraphicControllerBindingGeneration ebViewGraphicControllerBindingGeneration
  )
  [mFunctionCallList check
     !functionMap
     !inViewDeclarationMap
     !inPreferences
     !inRootObservablePropertyMap
     !inPreferencesPropertyMap
     !inSemanticContext
     !inObservablePropertyMap
     !inActionMap
     !inReceiverSwiftTypeName
     !?ioImplicitViewFunctionGenerationList
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
#---  
  outInstruction = @autoLayoutComputedViewInstructionGeneration.new {
    !mAutoLayoutViewClassName
    !parameterList
    !funcCallList
    !regularBindingsGenerationList
    !multipleBindingGenerationList
    !runBindingGeneration
    !tableViewBindingGenerationList
    !ebViewGraphicControllerBindingGeneration
  }
}

#·······················································································································

proc analyzeAutoLayoutBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @propertyMap inPreferencesPropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inObservablePropertyMap
  ?let @actionMap inActionMap
  ?let @string inReceiverSwiftTypeName

  ?let @lstring inTypeName

  ?let @tableValueBinding inTableValueBinding
  ?let @runActionDescriptor inRunActionDescriptor
  ?let @multipleBindingDescriptor inEnabledBindingDescriptor
  ?let @multipleBindingDescriptor inHiddenBindingDescriptor
  ?let @graphicController inGraphicController
  ?let @regularBindingList inRegularBindingList

  !@autoLayoutRegularBindingsGenerationList outRegularBindingsGenerationList
  !@autoLayoutMultipleBindingGenerationList outMultipleBindingGenerationList
  !@autolayoutRunBindingForGeneration outRunBindingGeneration
  !@tableViewBindingGenerationList outTableViewBindingGenerationList
  !@autoLayoutViewGraphicControllerBindingGeneration outEBViewGraphicControllerBindingGeneration
{
  outRegularBindingsGenerationList = {}
  outMultipleBindingGenerationList = {}
  outTableViewBindingGenerationList = {}
#  outEBViewGraphicControllerBindingGenerationList = {}
  [inSemanticContext.mAutolayoutViewClassMap searchKey
    !inTypeName
    ?*
    ?let @bool handlesRunAction
    ?let @bool handlesTableViewBinding
    ?let @bool handlesEnabledBinding
    ?let @bool handlesHiddenBinding
    ?let @bool handleGraphicControllerBinding
    ?3*
  ]
#--- $graphicController
  outEBViewGraphicControllerBindingGeneration = .none
  switch inGraphicController
  case none :
  case defined (@lstring controllerName @lstring propertyName) :
    if not handleGraphicControllerBinding then
      error inTypeName : "the '" + inTypeName + "' type does not handle the $graphicController binding"
    else
      [inObservablePropertyMap searchKey
        !controllerName
        ?let @propertyKind kind
        ?2*
      ]
      switch kind 
      case property (2*) :
        error controllerName : "the bound model should be an array controller"
      case toMany (4*) :
        error controllerName : "the bound model should be an array controller"
      case toOne (4*) :
        error controllerName : "the bound model should be an array controller"
      case arrayController (entityName graphic) :
        if propertyName.string == "" then
          if not graphic then
            error controllerName : "the controlled entity (" + entityName + ") should be a graphic entity"
          end
        else
          [inSemanticContext.mClassMap searchKey
            !entityName
            ?*
            ?let observablePropertyMap
            ?2*
          ]
          [observablePropertyMap searchKey !propertyName ?let propertyKind ?2*]
          switch propertyKind 
          case property (2*) :
            error controllerName : "the bound model should be a toMany property"
          case toMany (kEntityName * isGraphic *) :
            if not isGraphic then
              error controllerName : "the controlled entity (" + kEntityName + ") should be a graphic entity"
            end
          case toOne (4*) :
            error controllerName : "the bound model should be a toMany property"
          case arrayController (2*) :
            error controllerName : "the bound model should be a toMany property"
          case selectionController (*) :
            error controllerName : "the bound model should be a toMany property"
          end
       end
      case selectionController (*) :
        error controllerName : "the bound model should be an array controller"
      end
      outEBViewGraphicControllerBindingGeneration = .binding {!arrayControllerControllerName: controllerName.string}
    end
  end
#--- $tableView
  switch inTableValueBinding
  case noTableValueBinding :
  case tableValueBinding (@lstring controllerName) :
    if not handlesTableViewBinding then
      error inTypeName : "the '" + inTypeName + "' type does not handle the $tableView binding"
    else
      [inObservablePropertyMap searchKey
        !controllerName
        ?let @propertyKind unused kind
        ?2*
      ]
      if not [kind isArrayController] then
        error controllerName : "the bound model should be an array controller"
      end
      outTableViewBindingGenerationList += !"<<2>>" !controllerName.string
    end
  end
#--- $run
  analyzeAutoLayoutRunBinding (
    !inRunActionDescriptor
    !handlesRunAction: handlesRunAction
    !inPreferences
    !inTypeName
    !inActionMap
    !inObservablePropertyMap
    !inReceiverSwiftTypeName
    ?outRunBindingGeneration
  )
#--- Enabled
  analyzeAutoLayoutEnableBinding (
    !inEnabledBindingDescriptor
    !handlesEnabledBinding: handlesEnabledBinding
    !inPreferences
    !inRootObservablePropertyMap
    !inSemanticContext
    !inObservablePropertyMap
    ?let enabledBindingGeneration
  )
  switch enabledBindingGeneration
  case none :
  case enabled (binding) :
    outMultipleBindingGenerationList += !"enabled" !binding
  end
#  switch inEnabledBindingDescriptor
#  case noBinding :
#  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
#    [expression analyzeExpressionForMultipleBinding
#      !inPreferences
#      !inRootObservablePropertyMap
#      !inSemanticContext
#      !inObservablePropertyMap
#      ?let @abstractBooleanMultipleBindingExpressionForGeneration enableExpression
#      ?let @typeKind type
#      ?let @location errorLocation
#    ]
#    if not handlesEnabledBinding then
#      error errorLocation : "cet outlet n'accepte pas le binding $enabled"
#    end
#    if not [type isBoolType] then
#      error errorLocation : "expression is not boolean"
#    end
#    outMultipleBindingGenerationList +=
#      !"enabled"
#      !enableExpression
#  end
#--- Hidden
  switch inHiddenBindingDescriptor
  case noBinding :
  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
    [expression analyzeExpressionForMultipleBinding
      !inPreferences
      !inRootObservablePropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression
      ?let @typeKind type
      ?let @location errorLocation
    ]
    if not [type isBoolType] then
      error errorLocation : "expression is not boolean"
    end
    if not handlesHiddenBinding then
      error errorLocation : "cet outlet n'accepte pas le binding $hidden"
    end
    outMultipleBindingGenerationList +=
      !"hidden"
      !hiddenExpression
  end
#---------------------------------- Regular bindings
  analyzeAutoLayoutRegularBinding (
    !inRootObservablePropertyMap
    !inPreferencesPropertyMap
    !inSemanticContext
    !inObservablePropertyMap
    !inTypeName
    !inRegularBindingList
    !if inPreferences then "prefs_" else "self." end
    !?outRegularBindingsGenerationList
  )
}

#·······················································································································

proc analyzeAutoLayoutEnableBinding
  ?let @multipleBindingDescriptor inEnabledBindingDescriptor
  ?handlesEnabledBinding: let @bool inHandlesEnabledBinding
  ?let @bool inPreferences
  ?let @propertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inObservablePropertyMap
  !@autolayoutEnabledBindingForGeneration outEnabledBindingGeneration
{
  switch inEnabledBindingDescriptor
  case noBinding :
    outEnabledBindingGeneration = .none
  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
    [expression analyzeExpressionForMultipleBinding
      !inPreferences
      !inRootObservablePropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      ?let @abstractBooleanMultipleBindingExpressionForGeneration enableExpression
      ?let @typeKind type
      ?let @location errorLocation
    ]
    if not inHandlesEnabledBinding then
      error errorLocation : "cet outlet n'accepte pas le binding $enabled"
    end
    if not [type isBoolType] then
      error errorLocation : "expression is not boolean"
    end
    outEnabledBindingGeneration = .enabled {!binding: enableExpression}
  end
}

#·······················································································································

proc analyzeAutoLayoutRunBinding
  ?let @runActionDescriptor inRunActionDescriptor
  ?handlesRunAction: let @bool inHandlesRunAction
  ?let @bool inPreferences
  ?let @lstring inTypeName
  ?let @actionMap inActionMap
  ?let @propertyMap inObservablePropertyMap
  ?let @string inReceiverSwiftTypeName
  !@autolayoutRunBindingForGeneration outRunBindingGeneration
{
  switch inRunActionDescriptor
  case noAction :
    outRunBindingGeneration = .none
  case action (@lstring target @lstring action) :
    if not inHandlesRunAction then
      error inTypeName : "the '" + inTypeName + "' type does not handle run action" : outRunBindingGeneration
    elsif target.string == "self" then
      [inActionMap searchKey !action]
      outRunBindingGeneration = .run {
        !targetName: "self"
        !actionName: action.string
        !targetTypeName: inReceiverSwiftTypeName
      }
    else # It is a controller
      [inObservablePropertyMap searchKey
        !target
        ?*
        ?let @actionMap controllerActionMap
        ?*
      ]
      [controllerActionMap searchKey !action]
      outRunBindingGeneration = .run {
        !targetName: if inPreferences then "prefs_" else "" end + target.string
        !actionName: action.string
        !targetTypeName: "Controller_" + inReceiverSwiftTypeName + "_" + target
      }
    end
  end
}

#·······················································································································

proc analyzeAutoLayoutRegularBinding
  ?let @propertyMap inRootPropertyMap
  ?let @propertyMap inPreferencesPropertyMap
  ?let @semanticContext inSemanticContext
  ?let @propertyMap inBoundModelPropertyMap
  ?let @lstring inOutletTypeName
  ?let @regularBindingList inRegularBindingList
  ?let @string inSelfSwiftName
  ?!@autoLayoutRegularBindingsGenerationList ioRegularBindingsGenerationList
{
  for () in inRegularBindingList do
  #--- Analyze model
    @outletBindingModelList boundModelTypeList = {}
    @boundObjectList boundModelListForGeneration = {}
    for () in mObservablePropertyList do
      [mObservableProperty analyzeObservableProperty
        !inRootPropertyMap
        !inSemanticContext
        !inBoundModelPropertyMap
        ?@propertyKind kind
        ?let @string unused swiftTypeStringForTransientFunctionArgument
      ]
      switch kind
      case property (2*) : # Ok
      case toMany (4*) :
        error [mObservableProperty location]:"a toMany property cannot be bound"
      case toOne (4*) :
        error [mObservableProperty location]:"a toOne property cannot be bound"
      case arrayController (2*) :
        error [mObservableProperty location]:"an array controller cannot be bound"
      case selectionController (*) :
        error [mObservableProperty location]:"a selection controller cannot be bound"
      end
      boundModelListForGeneration += ![mObservableProperty modelStringForSelf !inSelfSwiftName] !kind
      boundModelTypeList += !kind ![mObservableProperty location]
    end
  #--- Analyze outlet binding
    @outletBindingSpecificationModelList outletBindingSpecificationModelList = {}
    @controllerBindingOptionDecoratedList controllerBindingOptionDecoratedList = {}
    var outletTypeName = inOutletTypeName
    var continues = true
    loop ([inSemanticContext.mBindingSpecificationMap count] + 1) while (outletTypeName.string != "") & continues do
      continues = false
      [inSemanticContext.mAutoLayoutBindingSpecificationMap searchKey
        !outletTypeName
        ?let superOutletClassName
        ?let bindingMap
      ]
      if [bindingMap hasKey !mBindingName.string] then
        [bindingMap searchKey
          !mBindingName
          ?outletBindingSpecificationModelList
          ?controllerBindingOptionDecoratedList
        ]
      else
        continues = true
        outletTypeName = superOutletClassName
      end
    end
    if continues then
      error mBindingName : "this binding is not defined"
    elsif [boundModelTypeList length] != [outletBindingSpecificationModelList length] then
      error mBindingName
      : [[outletBindingSpecificationModelList length] string]
        + " model(s) required for this binding (found: "
        + [boundModelTypeList length] + ")"
    else
      for () required_ in outletBindingSpecificationModelList, () found_ in boundModelTypeList do
        if required_mModelShouldBeWritableProperty && [found_mKind isTransient] then
          error found_mErrorLocation : "the model is transient and the binding requires an writable model"
        end
        if [required_mModelType isEnumType] && [found_mKind isEnumType] then # Ok
        elsif [required_mModelType swiftTypeName] != [found_mKind swiftTypeName] then
          error found_mErrorLocation : "the model type should be " + [required_mModelType swiftTypeName]
        end
      end
    end
  #--- Check options
    var bindingOptionString = ""
    if [controllerBindingOptionDecoratedList length] != [mBindingOptionList length] then
      @string s
      if [controllerBindingOptionDecoratedList length] == 0 then
        s = "this binding has no option"
      else 
        s = "this binding requires the following options:"
        for () in controllerBindingOptionDecoratedList do
          s += "\n  - " + mOptionName + " : " + [mOptionType swiftTypeName]
        end
      end
      error mBindingName : s
    else
      for () controller_ in controllerBindingOptionDecoratedList, () binding_ in mBindingOptionList do
        if controller_mOptionName.string != binding_mOptionName.string then
          error binding_mOptionName : "the option name should be '" + controller_mOptionName + "'"
        end
        [binding_mOptionValue analyzeDefaultValueType 
          !{!controller_mOptionType}
          !inPreferencesPropertyMap
          ?let @string optionValueAsString
        ]
        bindingOptionString += ", " + controller_mOptionName.string + ":" + optionValueAsString
      end
    end
  #--- Generate binding
    ioRegularBindingsGenerationList +=
      !mBindingName.string
      !boundModelListForGeneration
      !bindingOptionString
  end
}

#·······················································································································

override method @astHStackViewInstructionDeclaration generateCode
                        ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                        ?let @bool inPreferences
                        ?let @propertyMap inRootObservablePropertyMap
                        ?let @propertyMap inPreferencesPropertyMap
                        ?let @semanticContext inSemanticContext
                        ?let @propertyMap inObservablePropertyMap
                        ?let @actionMap inActionMap
                        ?let @string inReceiverSwiftTypeName
                        ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                        !@abstractViewInstructionGeneration outInstruction {
  @autoLayoutViewInstructionGenerationList instructionList = {}
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutHStackFunctionMap
     !inViewDeclarationMap
     !inPreferences
     !inRootObservablePropertyMap
     !inPreferencesPropertyMap
     !inSemanticContext
     !inObservablePropertyMap
     !inActionMap
     !inReceiverSwiftTypeName
     !?ioImplicitViewFunctionGenerationList
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  for (instruction) in mInstructionList do
   [instruction generateCode
      !inViewDeclarationMap
      !inPreferences
      !inRootObservablePropertyMap
      !inPreferencesPropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !inActionMap
      !inReceiverSwiftTypeName
      !?ioImplicitViewFunctionGenerationList
      ?let generatedInstruction
    ]
    instructionList += !generatedInstruction
  end
  outInstruction = @hStackViewInstructionGeneration.new {!funcCallList !instructionList}
}

#·······················································································································

override method @astVStackViewInstructionDeclaration generateCode
                        ?let @autoLayoutViewDeclarationMap inViewDeclarationMap
                        ?let @bool inPreferences
                        ?let @propertyMap inRootObservablePropertyMap
                        ?let @propertyMap inPreferencesPropertyMap
                        ?let @semanticContext inSemanticContext
                        ?let @propertyMap inObservablePropertyMap
                        ?let @actionMap inActionMap
                        ?let @string inReceiverSwiftTypeName
                        ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList
                        !@abstractViewInstructionGeneration outInstruction {
  @autoLayoutViewInstructionGenerationList instructionList = {}
  [mFunctionCallList check
     !inSemanticContext.mAutoLayoutVStackFunctionMap
     !inViewDeclarationMap
     !inPreferences
     !inRootObservablePropertyMap
     !inPreferencesPropertyMap
     !inSemanticContext
     !inObservablePropertyMap
     !inActionMap
     !inReceiverSwiftTypeName
     !?ioImplicitViewFunctionGenerationList
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  ]
  for (instruction) in mInstructionList do
   [instruction generateCode
      !inViewDeclarationMap
      !inPreferences
      !inRootObservablePropertyMap
      !inPreferencesPropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !inActionMap
      !inReceiverSwiftTypeName
      !?ioImplicitViewFunctionGenerationList
      ?let generatedInstruction
    ]
    instructionList += !generatedInstruction
  end
  outInstruction = @vStackViewInstructionGeneration.new {!funcCallList !instructionList}
}

#-----------------------------------------------------------------------------------------------------------------------
#   GENERATION                            
#-----------------------------------------------------------------------------------------------------------------------

abstract class @abstractViewGeneration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @newHorizontalStackViewGeneration : @abstractViewGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
}

#-----------------------------------------------------------------------------------------------------------------------

class @newVerticalStackViewGeneration : @abstractViewGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
}

#-----------------------------------------------------------------------------------------------------------------------

class @computedHorizontalViewGeneration : @abstractViewGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  @autoLayoutViewInstructionGenerationList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @computedVerticalViewGeneration : @abstractViewGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  @autoLayoutViewInstructionGenerationList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

list @viewGenerationList {
  @string mViewName
  @abstractViewGeneration mView
}

#-----------------------------------------------------------------------------------------------------------------------

abstract class @abstractViewInstructionGeneration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @hStackViewInstructionGeneration : @abstractViewInstructionGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  @autoLayoutViewInstructionGenerationList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @vStackViewInstructionGeneration : @abstractViewInstructionGeneration {
  @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  @autoLayoutViewInstructionGenerationList mInstructionList
}

#-----------------------------------------------------------------------------------------------------------------------

class @autoLayoutSpaceViewInstructionGeneration : @abstractViewInstructionGeneration {
}

#-----------------------------------------------------------------------------------------------------------------------

class @autoLayoutLocalViewInstructionGeneration : @abstractViewInstructionGeneration {
  @string mLocalView
}

#·······················································································································

list @autoLayoutRegularBindingsGenerationList {
  @string mBindingName
  @boundObjectList mBoundObjectList
  @string mBindingOptionsString
}

#-----------------------------------------------------------------------------------------------------------------------

list @autoLayoutMultipleBindingGenerationList {
  @string mBindingName
  @abstractBooleanMultipleBindingExpressionForGeneration mBoundObjectExpression
}

#·······················································································································

enum @autolayoutRunBindingForGeneration {
  case none
  case run (@string targetName @string actionName @string targetTypeName)
}

#·······················································································································

enum @autoLayoutViewGraphicControllerBindingGeneration {
  case none
  case binding (@string arrayControllerControllerName)
}

#·······················································································································

enum @autolayoutEnabledBindingForGeneration {
  case none
  case enabled (@abstractBooleanMultipleBindingExpressionForGeneration binding)
}

#-----------------------------------------------------------------------------------------------------------------------

class @autoLayoutComputedViewInstructionGeneration : @abstractViewInstructionGeneration {
  @lstring mAutoLayoutViewClassName
  @autoLayoutViewInstructionGenerationParameterList mParameterList
  @autoLayoutViewInstructionGenerationFuncCallList mFunctionCallList
  @autoLayoutRegularBindingsGenerationList mRegularBindingsGenerationList
  @autoLayoutMultipleBindingGenerationList mMultipleBindingGenerationList
  @autolayoutRunBindingForGeneration mRunBindingGeneration
  @tableViewBindingGenerationList mTableViewBindingGeneration
  @autoLayoutViewGraphicControllerBindingGeneration mEBViewGraphicControllerBindingGeneration
}

#-----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationParameterList {
  @string mParameterName
  @string mParameterValue
}

#-----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationFuncCallList {
  @string mFunctionName
  @autoLayoutViewInstructionGenerationParameterList mParameters
}

#-----------------------------------------------------------------------------------------------------------------------

method @autoLayoutViewInstructionGenerationFuncCallList generate ?let @string inIndentation ?!@string ioStr {
  for (funcName parameterList) in self do
    ioStr += inIndentation + "  ." + funcName + " ("
    for (parameterName parameterStringValue) in parameterList
      do ioStr += parameterName + ": " + parameterStringValue
      between ioStr += ", "
    end
    ioStr += ")\n"
  end
}

#-----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationList {
  @abstractViewInstructionGeneration mInstruction
}

#·······················································································································

abstract getter @abstractViewGeneration generate ?let @string inViewName -> @string

#·······················································································································

override getter @newHorizontalStackViewGeneration generate ?let @string inViewName -> @string {
  result = "  let " + inViewName + " : AutoLayoutStackView = AutoLayoutHorizontalStackView ()\n"
  [mFuncCallList generate !"    " !?result]
  result += "\n"
}

#·······················································································································

override getter @newVerticalStackViewGeneration generate ?let @string inViewName -> @string {
  result = "  let " + inViewName + " : AutoLayoutStackView = AutoLayoutVerticalStackView ()\n"
  [mFuncCallList generate !"    " !?result]
  result += "\n"
}

#·······················································································································

override getter @computedHorizontalViewGeneration generate ?let @string inViewName -> @string {
  result = "  lazy var " + inViewName + " = self." + inViewName + "_make ()\n\n"
  result += "  fileprivate final func " + inViewName + "_make () -> AutoLayoutStackView {\n"
  result += "    let hStackView = AutoLayoutHorizontalStackView ()\n"
  [mFuncCallList generate !"    " !?result]
  for (instruction) in mInstructionList do (index)
    let name = "view_" + index
    result += [instruction generate !name !"    "]
    result += "    hStackView.appendView (" + name + ")\n"
  end
  result += "    return hStackView\n"
  result += "  }\n\n"
}

#·······················································································································

override getter @computedVerticalViewGeneration generate ?let @string inViewName -> @string {
  result = "  lazy var " + inViewName + " = self." + inViewName + "_make ()\n\n"
  result += "  fileprivate final func " + inViewName + "_make () -> AutoLayoutStackView {\n"
  result += "    let vStackView = AutoLayoutVerticalStackView ()\n"
  [mFuncCallList generate !"    " !?result]
  for (instruction) in mInstructionList do (index)
    let name = "view_" + index
    result += [instruction generate !name !"    "]
    result += "    vStackView.appendView (" + name + ")\n"
  end
  result += "    return vStackView\n"
  result += "  }\n\n"
}

#·······················································································································

abstract getter  @abstractViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string

#·······················································································································

override getter @autoLayoutSpaceViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutFlexibleSpace ()\n"
}

#·······················································································································

override getter @autoLayoutLocalViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = self." + mLocalView + "\n"
}

#·······················································································································

override getter @autoLayoutComputedViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = AutoLayout" + mAutoLayoutViewClassName.string + " ("
  for parameter in mParameterList
  do
    result += parameter.mParameterName + ": " + parameter.mParameterValue
  between
    result += ", "
  end
  result += ")\n"
  [mFunctionCallList generate !inIndentation !?result]
  for (bindingName boundObjectList optionListString) in mRegularBindingsGenerationList do
    result += inIndentation + "  .bind_" + bindingName + " ("
    for (boundObjectString *) in boundObjectList
      do result += boundObjectString
      between result += ", "
    end
    result += optionListString + ")\n"
  end
  for (bindingName binding) in mMultipleBindingGenerationList do 
    result += inIndentation + "  .bind_" + bindingName + " (\n"
    result += inIndentation + "    observedObjects: ["
    for () in [binding observedModelSet]
      do result += key
      between result += ", "
    end
    result += "],\n"
    result += inIndentation + "    computeFunction: { return " + [binding expressionString] + " }\n"
    result += inIndentation + "  )\n"
  end
  switch mRunBindingGeneration
  case none :
  case run (targetName actionName targetTypeName) :
    result += inIndentation + "  .bind_run (\n"
    result += inIndentation + "    target: " + targetName + ",\n"
    result += inIndentation + "    selector: #selector (" + targetTypeName + "." + actionName + " (_:))\n"
    result += inIndentation + "  )\n"
  end
  switch mEBViewGraphicControllerBindingGeneration
  case none :
  case binding (controllerName) :
    result += inIndentation + "  .bind_graphic_controller (self." + controllerName + ")\n"
  end
}

#·······················································································································

override getter @hStackViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView ()\n"
  [mFuncCallList generate !inIndentation !?result]
  result += inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  for (instruction) in mInstructionList do (index)
     let name = inName + "_" + index
     result += [instruction generate !name !indentation]
     result += indentation + inName + ".appendView (" + name + ")\n"
  end
  result += inIndentation + "}\n"
}

#·······················································································································

override getter @vStackViewInstructionGeneration generate ?let @string inName ?let @string inIndentation -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutVerticalStackView ()\n"
  [mFuncCallList generate !inIndentation !?result]
  result += inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  for (instruction) in mInstructionList do (index)
     let name = inName + "_" + index
     result += [instruction generate !name !indentation]
     result += indentation + inName + ".appendView (" + name + ")\n"
  end
  result += inIndentation + "}\n"
}

#-----------------------------------------------------------------------------------------------------------------------
