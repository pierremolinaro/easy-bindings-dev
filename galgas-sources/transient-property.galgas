#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @transientAST : @abstractSecondaryProperty {
  @lstring mTransientTypeName
  @lstring mTransientName
  @observablePropertyList mDependencyList
  @lstring mExternFunctionName
}

#·······················································································································

class @transientDeclarationAST : @abstractDeclarationAST {
  @lstring mRootEntityName
  @lstring mTransientTypeName
  @lstring mTransientName
  @observablePropertyList mDependencyList
  @lstring mExternFunctionName
}

#·······················································································································

override method @transientDeclarationAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  let node = @lstring.new {!mClassName.string + " " + mTransientName !mTransientName.location}
  [!?ioGraph addNode !node !self]
  [!?ioGraph addEdge !node !mClassName]
  [!?ioGraph addEdge !node !mTransientTypeName]
  for dependency in mDependencyList do
    switch dependency.mObservableProperty
    case rootProperty (propertyName) :
      if mRootEntityName.string != "" then
        [!?ioGraph addEdge !node !.new {!mRootEntityName.string + " " + propertyName !propertyName.location}]
      end
    case rootPropertyWithOption (propertyName *) :
      if mRootEntityName.string != "" then
        [!?ioGraph addEdge !node !.new {!mRootEntityName.string + " " + propertyName !propertyName.location}]
      end
    case rootPropertyRelationship (relationshipName *) :
      if mRootEntityName.string != "" then
        [!?ioGraph addEdge !node !.new {!mRootEntityName.string + " " + relationshipName !relationshipName.location}]
      end
    case rootPropertyNone (relationshipName) :
      if mRootEntityName.string != "" then
        [!?ioGraph addEdge !node !.new {!mRootEntityName.string + " " + relationshipName !relationshipName.location}]
      end
    case selfProperty (propertyName) :
      [!?ioGraph addEdge !node !.new {!mClassName.string + " " + propertyName !propertyName.location}]
    case selfPropertyWithOption (@lstring propertyName *) :
      [!?ioGraph addEdge !node !.new {!mClassName.string + " " + propertyName !propertyName.location}]
    case selfPropertyArray (@lstring propertyName *) :
      [!?ioGraph addEdge !node !.new {!mClassName.string + " " + propertyName !propertyName.location}]
    case selfPropertyObject (@lstring propertyName *) :
      [!?ioGraph addEdge !node !.new {!mClassName.string + " " + propertyName !propertyName.location}]
    case selfPropertyNone (@lstring propertyName) :
      [!?ioGraph addEdge !node !.new {!mClassName.string + " " + propertyName !propertyName.location}]
    case prefsProperty (@lstring propertyName) :
      [!?ioGraph addEdge !node !.new {!preferencesName () + " " + propertyName !propertyName.location}]
    case prefsPropertyWithOption (@lstring propertyName *) :
      [!?ioGraph addEdge !node !.new {!preferencesName () + " " + propertyName !propertyName.location}]
    case selfControllerProperty (@lstring controllerName unused propertyName) :
      [!?ioGraph addEdge !node !.new {!mClassName.string  + " " + controllerName !controllerName.location}]
    case selfControllerSecondaryProperty (@lstring controllerName unused propertyName unused secondaryPropertyName) :
      [!?ioGraph addEdge !node !.new {!mClassName.string  + " " + controllerName !controllerName.location}]
    case signatureProperty (*) :
    case versionProperty (*) :
    case versionShouldChangeProperty (*) :
    end
  end
}

#·······················································································································

override getter @transientDeclarationAST lkey -> @lstring {
  result = @lstring.new {!mClassName.string + " " + mTransientName !mTransientName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <transient_declaration>
            ?let @lstring inCurrentEntity
            ?let @lstring inRootEntity
            ?!@secondaryPropertyList ioSecondaryPropertyList
            ?!@astDeclarationStruct ioDeclarationAST
  {
    $transient$
    $Identifier$ ?let transientTypeName
    $identifier$ ?let @lstring transientName
    @lstring externFunctionName
    select
      externFunctionName = ["" here] # Generate stub
    or
      $externFunc$
      $identifier$ ?externFunctionName    
    end
    $dependsFrom$
    @observablePropertyList dependanceList = {}
    repeat
      <observable_property> ?let @observablePropertyAST observablePropertyAST
      dependanceList += !observablePropertyAST
    while
      $,$
    end
    $;$
    ioSecondaryPropertyList += !@transientAST.new {
      !transientTypeName
      !transientName
      !dependanceList
      !externFunctionName
    }
    ioDeclarationAST.mUnifiedDeclarationList += !@transientDeclarationAST.new {
      !inCurrentEntity
      !inRootEntity
      !transientTypeName
      !transientName
      !dependanceList
      !externFunctionName
    }
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @transientDeclarationAST firstAnalysisPhase
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  with mClassName in !?ioSemanticContext.mClassMap 
    error message searchKey
  do
    [ioSemanticContext.mClassMap searchKey !mTransientTypeName ?let classKind ?3*]
    switch classKind
    case prefs :
      error mTransientTypeName : "an atomic class is required here"
    case simpleClass :
      error mTransientTypeName : "an atomic class is required here"
    case atomic (kind) :
      [!?mPropertyMap insertKey !mTransientName !.property {!type: kind !accessibility: .transient} !{}]
    case document (*) :
      error mTransientTypeName : "an atomic class is required here"
    case entity (*) :
      error mTransientTypeName : "an atomic class is required here"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SECOND ANALYSIS PHASE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @transientDeclarationAST secondAnalysisPhase
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct ioGeneration
{
#--- Property type
  [ioSemanticContext.mClassMap searchKey !mTransientTypeName ?let classKind ?3*]
#--- Check type
  @typeKind typeKind
  switch classKind
  case prefs, simpleClass :
    error mTransientTypeName: "an atomic class is required here" : typeKind
  case atomic (@typeKind kind) :
    typeKind = kind
  case document (*) :
    error mTransientTypeName: "an atomic class is required here" : typeKind
  case entity (*) :
    error mTransientTypeName: "an atomic class is required here" : typeKind
  end
#--- Root properties
  @propertyMap rootProperties
  if mRootEntityName.string == "" then
    rootProperties = {}
  else
    [ioSemanticContext.mClassMap searchKey !mRootEntityName ?* ?rootProperties ?2*]
  end
#--- Current class properties
  [ioSemanticContext.mClassMap searchKey !mClassName ?let currentClassKind ?let properties ?2*]
#--- Analyse master properties
  @transientDependencyListForGeneration dependencies = {}
  for () in mDependencyList do
    [mObservableProperty analyzeObservableProperty
      !rootProperties
      !ioSemanticContext
      !properties
      ?let @propertyKind dependencyKind
      ?let @string swiftTypeStringForTransientFunctionArgument
    ]
    switch dependencyKind
    case property (* *) :
    case toMany (4*) :
      error [mObservableProperty location] : "only an atomic property can be observed"
    case toOne (3*) :
      error [mObservableProperty location] : "only an atomic property can be observed"
    case arrayController (3*) :
      error [mObservableProperty location] : "only an atomic property can be observed"
    case selectionController (*) :
      error [mObservableProperty location] : "only an atomic property can be observed"
    end
    dependencies +=
      !mObservableProperty
      ![mObservableProperty modelStringFunctionArgument]
      !swiftTypeStringForTransientFunctionArgument
  end
  ioGeneration.mFileGenerationList += !@ptransientRoutineGeneration.new {
    !mClassName
    !mTransientName.string
    !typeKind
    !dependencies
    !mExternFunctionName.string
  }
  with mClassName in !?ioSemanticContext.mClassMap 
    error message searchKey
  do
    @bool generate
    switch currentClassKind
    case prefs, simpleClass :
      generate = true
    case document (*) :
      generate = true
    case atomic (*) :
      generate = true
    case entity (graphic):
      if graphic then
        generate = (mTransientName.string != "selectionDisplay") & (mTransientName.string != "objectDisplay")
      else
        generate = true
      end
    end
    mPropertyGenerationList += !@transientPropertyGeneration.new {
      !mTransientName.string
      !mClassName.string
      !typeKind
      !dependencies
      !mExternFunctionName.string
      !generate
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @transientPropertyGeneration : @propertyGeneration {
  @string mClassName
  @typeKind mType
  @transientDependencyListForGeneration mDependencyList
  @string mExternFunctionName
  @bool mGenerate
}

#·······················································································································

list @transientPropertyGenerationList {
  @transientPropertyGeneration mProperty
}

#·······················································································································

override getter @transientPropertyGeneration declarationCode -> @string {
  result  = ""
  if mGenerate then
    result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n"
    result += "  //   Transient property: " + mPropertyName + "\n"
    result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
    result += "  var " + mPropertyName + "_property = EBTransientProperty_" + [mType swiftTypeName] + " ()\n\n"
    result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
    result += "  var " + mPropertyName + "_property_selection : EBSelection <" + [mType swiftTypeName] + "> {\n"
    result += "    return self." + mPropertyName + "_property.prop\n"
    result += "  }\n\n"
    result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
    result += "    var " + mPropertyName + " : " + [mType swiftTypeName] + "? {\n"
    result += "    switch self." + mPropertyName + "_property_selection {\n"
    result += "    case .empty, .multiple :\n"
    result += "      return nil\n"
    result += "    case .single (let v) :\n"
    result += "      return v\n"
    result += "    }\n"
    result += "  }\n\n"
  end
}

#·······················································································································

override getter @transientPropertyGeneration configurationCode -> @string {
  result  = "  //--- Atomic property: " + mPropertyName + "\n"
  result += "    self." + mPropertyName + "_property.readModelFunction = { [weak self] in\n"
  result += "      if let unwSelf = self {\n"
  result += [mDependencyList transientComputeFunctionCall !mClassName !mPropertyName !mExternFunctionName]
  result += "      }else{\n"
  result += "        return .empty\n"
  result += "      }\n"
  result += "    }\n"
  for () in mDependencyList do
    result += "    " + [mDependency generateAddObserverCall] + " (self." + mPropertyName + "_property)\n"
  end
}

#·······················································································································

override getter @transientPropertyGeneration terminationCode -> @string {
  result = ""
  for () in mDependencyList do
    result += "    " + [mDependency generateRemoveObserverCall] + " (self." + mPropertyName + "_property)\n"
  end
}

















#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TYPE INVENTORY                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @transientAST typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  [@unifiedTypeMap-proxy makeProxy
    !?ioUnifiedTypeMap
    !mTransientTypeName
    ?*
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @transientAST tryToDefineSecondaryProperty
  ?!@semanticContextEX ioSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?!@observablePropertyMap ioObservableProperties
  ?!@secondaryPropertyList ioUnsolvedProperties
  ?!@simpleStoredPropertyListForGenerationEX unused ioSimpleStoredPropertyListForGeneration
{
  @bool solved = true
  for () in mDependencyList while solved do
    solved = [mObservableProperty isPropertyDefined
      !ioSemanticContext
      !inRootObservableProperties
      !ioObservableProperties
    ]
  end
  if solved then
    [ioSemanticContext.mUnifiedTypeMap searchKey !mTransientTypeName ?let type ?let actionMap]
    @propertyKind kind
    if [type isEntityType] then
      kind = .toOne {!typeName: mTransientTypeName !accessibility: .transient !graphic:[type isGraphic]}
    else
      kind = .property {!type:type !accessibility: .transient}
    end
    [!?ioObservableProperties insertKey
      !mTransientName
      !kind
      !""
      !actionMap
      !false
    ]
  else
    ioUnsolvedProperties += !self
  end
}

#·······················································································································

override method @transientAST secondaryPropertySemanticAnalysisEX
  ?let @string inOwnerName
  ?let @string unused inRootEntityName
  ?let @observablePropertyMap inRootObservableProperties
  ?let @semanticContextEX inSemanticContext
  ?let @observablePropertyMap inObservableProperties
  ?!@transientDefinitionListForGenerationEX ioTransientDefinitionListForGeneration
  ?!@arrayControllerForGenerationEX unused ioArrayControllerForGeneration
  ?!@selectionControllerForGeneration unused ioSelectionControllerForGeneration
  ?!@stringset unused ioNeededOutletClasses
{
#--- Property type
  [inSemanticContext.mUnifiedTypeMap searchKey !mTransientTypeName ?let type ?*]
#--- Check type
  @typeKindList typeList
  switch type
  case boolType, integerType, stringType, dateType, doubleType, fontType, colorType :
    typeList = {!type}
  case enumType (* *) :
    typeList = {!type}
  case entityType (2*) :
    error mTransientName: "an entity cannot be used as simple property type" : typeList
  case classType (*) :
    typeList = {!type}
  case transientPropertyExternType (*) :
    typeList = {!type}
  end
#--- Analyse master properties
  @transientDependencyListForGeneration dependencies = {}
  for () in mDependencyList do
    [mObservableProperty analyzeObservablePropertyEX
      !inRootObservableProperties
      !inSemanticContext
      !inObservableProperties
      ?let @propertyKind dependencyKind
      ?let @string swiftTypeStringForTransientFunctionArgument
    ]
    switch dependencyKind
    case property (* *) :
    case toMany (4*) :
      error [mObservableProperty location] : "only an atomic property can be observed"
    case toOne (3*) :
      error [mObservableProperty location] : "only an atomic property can be observed"
    case arrayController (3*) :
      error [mObservableProperty location] : "only an atomic property can be observed"
    case selectionController (*) :
      error [mObservableProperty location] : "only an atomic property can be observed"
    end
    dependencies +=
      !mObservableProperty
      ![mObservableProperty modelStringFunctionArgument]
      !swiftTypeStringForTransientFunctionArgument
  end
#--- Code generation
  ioTransientDefinitionListForGeneration +=
    !inOwnerName
    !mTransientName.string
    !type
    !dependencies
    !mExternFunctionName.string
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION TYPE                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @transientDefinitionListForGenerationEX {
  @string mOwnerName
  @string mTransientName
  @typeKind mTransientType
  @transientDependencyListForGeneration mDependencyList
  @string mExternFunctionName
}

#·······················································································································

list @transientDependencyListForGeneration {
  @observablePropertyAST mDependency
  @string mFunctionArgumentName
  @string mFunctionArgumentTypeString
}

#·······················································································································

getter @transientDependencyListForGeneration transientComputeFunctionCall
  ?let @string inOwnerName
  ?let @string inTransientName
  ?let @string inExternFunctionName
  -> @string outResult
{
  @string ident = "        "
  outResult = ""
  if [self length] == 1 then
    [self first ?let @observablePropertyAST first ?2*]
    outResult += ident + "let kind = " + [first modelStringForSelf !"unwSelf"] + "_selection.kind ()\n"
  else
    var dependencies = self
    [!?dependencies popFirst ?let @observablePropertyAST first ?* ?*]
    outResult += ident + "var kind = " + [first modelStringForSelf !"unwSelf"] + "_selection.kind ()\n"
    for () in dependencies do
      outResult += ident + "kind &= " + [mDependency modelStringForSelf !"unwSelf"] + "_selection.kind ()\n"
    end
  end
  outResult += ident + "switch kind {\n"
  outResult += ident + "case .noSelectionKind :\n"
  outResult += ident + "  return .empty\n"
  outResult += ident + "case .multipleSelectionKind :\n"
  outResult += ident + "  return .multiple\n"
  outResult += ident + "case .singleSelectionKind :\n"
  outResult += ident + "  switch ("
  for () in self
  do outResult += [mDependency modelStringForSelf !"unwSelf"] + "_selection"
  between outResult += ", "
  end
  outResult += ") {\n"
  outResult += ident + "  case ("
  for () in self
  do (idx) outResult += ".single (let v" + idx + ")"
  between outResult += ", "
  end
  outResult += ") :\n"
  outResult += ident + "    return .single ("
  if inExternFunctionName == "" then
    outResult += "transient_" + inOwnerName + "_" + inTransientName
  else
    outResult += "transient_" + inExternFunctionName
  end
  outResult += " ("
  for () in self
  do (idx) outResult += "v" + idx
  between outResult += ", "
  end
  outResult += "))\n"
  outResult += ident + "  default :\n"
  outResult += ident + "    return .empty\n"
  outResult += ident + "  }\n"
  outResult += ident + "}\n"
}

#·······················································································································

getter @transientDependencyListForGeneration needs_unwSelf
  -> @bool outResult
{
  outResult = false
  for (dep 2*) in self while not outResult do
    outResult = [dep needs_unwSelf]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @observablePropertyAST generateAddObserverCall -> @string outResult {
  switch self
  case selfControllerProperty (@lstring controllerName @lstring propertyName) : 
    outResult = "self." + controllerName.string + "." + propertyName + "_property.addEBObserver"
  case selfControllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) : 
    outResult = "self." + controllerName.string + "." + propertyName + "_property." + secondaryPropertyName + "_property.addEBObserver"
  case selfProperty (@lstring masterName) :
    outResult = "self." + masterName.string + "_property.addEBObserver"
  case selfPropertyWithOption (@lstring masterName *) :
    outResult = "self." + masterName.string + "_property.addEBObserver"
  case selfPropertyArray (@lstring masterName @lstring elementPropertyName) :
    outResult = "self." + masterName.string + "_property.addEBObserverOf_" + elementPropertyName
  case selfPropertyObject (@lstring masterName @lstring elementPropertyName) :
    outResult = "self." + masterName.string + "_property.addEBObserverOf_" + elementPropertyName
  case selfPropertyNone (@lstring masterName) :
    outResult = "self." + masterName.string + "_property.addEBObserver"
  case prefsProperty (@lstring propertyName) :
    outResult = "g_" + preferencesName () + "?."  + propertyName + "_property.addEBObserver"
  case prefsPropertyWithOption (@lstring propertyName *) :
    outResult = "g_" + preferencesName () + "?."  + propertyName + "_property.addEBObserver"
  case rootProperty (@lstring masterName) :
    outResult = "self.rootObject." + masterName + "_property.addEBObserver"
  case rootPropertyNone (@lstring masterName) :
    outResult = "self.rootObject." + masterName + "_property.addEBObserver"
  case rootPropertyWithOption (@lstring masterName @lstring optionName) :
    outResult = "self.rootObject." + masterName + "_property." + optionName + "_property.addEBObserver"
  case rootPropertyRelationship (@lstring relationshipName @lstring propertyName) :
    outResult = "self.rootObject." + relationshipName + "_property.addEBObserverOf_" + propertyName
  case signatureProperty (*) :
    outResult = "<< ligne 243 >>"
  case versionProperty (*) :
    outResult = "<< ligne 245 >>"
  case versionShouldChangeProperty (*) :
    outResult = "<< ligne 247 >>"
  end
}

#·······················································································································

getter @observablePropertyAST generateRemoveObserverCall -> @string outResult {
  switch self
  case selfControllerProperty (@lstring controllerName @lstring propertyName) : 
    outResult = "self." + controllerName.string + "." + propertyName + "_property.removeEBObserver"
  case selfControllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) : 
    outResult = "self." + controllerName.string + "." + propertyName + "_property." + secondaryPropertyName + "_property.removeEBObserver"
  case selfProperty (@lstring masterName) :
    outResult = "self." + masterName.string + "_property.removeEBObserver"
  case selfPropertyWithOption (@lstring masterName *) :
    outResult = "self." + masterName.string + "_property.removeEBObserver"
  case selfPropertyArray (@lstring masterName @lstring elementPropertyName) :
    outResult = "self." + masterName.string + "_property.removeEBObserverOf_" + elementPropertyName
  case selfPropertyObject (@lstring masterName @lstring elementPropertyName) :
    outResult = "self." + masterName.string + "_property.removeEBObserverOf_" + elementPropertyName
  case selfPropertyNone (@lstring masterName) :
    outResult = "self." + masterName.string + "_property.removeEBObserver"
  case prefsProperty (@lstring propertyName) :
    outResult = "g_" + preferencesName () + "?."  + propertyName + "_property.removeEBObserver"
  case prefsPropertyWithOption (@lstring propertyName *) :
    outResult = "g_" + preferencesName () + "?."  + propertyName + "_property.removeEBObserver"
  case rootProperty (@lstring masterName) :
    outResult = "self.rootObject." + masterName + "_property.removeEBObserver"
  case rootPropertyWithOption (@lstring masterName @lstring optionName) :
    outResult = "self.rootObject." + masterName + "_property." + optionName + "_property.removeEBObserver"
  case rootPropertyNone (@lstring masterName) :
    outResult = "self.rootObject." + masterName + "_property.removeEBObserver"
  case rootPropertyRelationship (@lstring relationshipName @lstring propertyName) :
    outResult = "self.rootObject." + relationshipName + "_property.removeEBObserverOf_" + propertyName
  case signatureProperty (*) :
    outResult = "<< ligne 270 >>"
  case versionProperty (*) :
    outResult = "<< ligne 272 >>"
  case versionShouldChangeProperty (*) :
    outResult = "<< ligne 274 >>"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    TRANSIENT ROUTINE GENERATION         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @ptransientRoutineGeneration : @abstractFileGeneration {
  @string mOwnerName
  @string mTransientName
  @typeKind mTransientType
  @transientDependencyListForGeneration mDependencyList
  @string mExternFunctionName
}

#·······················································································································

override method @ptransientRoutineGeneration generateCode
    ?let @string inOutputDirectory
    ?!@stringset ioGeneratedFileSet
{
  if ([mDependencyList length] > 0) & (mExternFunctionName == "") then
    let s = [filewrapper transientManager.transientComputationFunctionFile
      !mOwnerName
      !mTransientName
      !mDependencyList
      !mTransientType 
    ]
    let fileName = "transient-" + mOwnerName + "-" + mTransientName + ".swift"
    ioGeneratedFileSet += !fileName
    [@string generateFileWithPattern
      !startPath:inOutputDirectory
      !fileName:fileName
      !lineComment:"//"
      !header:""
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:s
      !defaultUserZone2:"\n" # Defaut user zone2
      !generatedZone3:"}\n\n//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\n"
      !makeExecutable:false
    ]
  end
}

#·······················································································································

#proc generateTransients
#  ?let @string inOutputDirectory
#  ?let @transientDefinitionListForGenerationEX inTransientListForGeneration
#  ?!@stringset ioGeneratedFileSet
#{
##--------------------------- Generate transient routines
#  for () in inTransientListForGeneration do
#    if ([mDependencyList length] > 0) & (mExternFunctionName == "") then
#      let s = [filewrapper transientManager.transientComputationFunctionFile
#        !mOwnerName
#        !mTransientName
#        !mDependencyList
#        !mTransientType 
#      ]
#      let fileName = "transient-" + mOwnerName + "-" + mTransientName + ".swift"
#      ioGeneratedFileSet += !fileName
#      [@string generateFileWithPattern
#        !startPath:inOutputDirectory
#        !fileName:fileName
#        !lineComment:"//"
#        !header:""
#        !defaultUserZone1:"\n\n" # Defaut user zone1
#        !generatedZone2:s
#        !defaultUserZone2:"\n" # Defaut user zone2
#        !generatedZone3:"}\n\n//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\n"
#        !makeExecutable:false
#      ]
#    end
#  end
#}

#·······················································································································

private filewrapper transientManager in "../generation-templates" {
}{
}{
  template transientComputationFunctionFile "transient-computation-function.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string TRANSIENT_NAME
    ?@transientDependencyListForGeneration DEPENDENCY_LIST
    ?@typeKind TRANSIENT_TYPE
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
