#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   AST                                                                                                                *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

class @transientAST : @abstractSecondaryProperty {
  @lstring mTransientTypeName
  @bool mIsArray
  @lstring mTransientName
  @observablePropertyList mDependencyList
  @bool mIsCopy
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SYNTAX                                                                                                             *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <transient_declaration>
    ?!@secondaryPropertyList ioSecondaryPropertyList
  {
    $transient$
    @bool isArray
    select
      isArray = false
    or
      $array$
      isArray = true
    end
    $Identifier$ ?var @lstring transientTypeName
    $identifier$ ?let @lstring transientName
    $dependsFrom$
    @observablePropertyList dependanceList = {}
    repeat
      <observable_property> ?let @observablePropertyAST observablePropertyAST
      dependanceList += !observablePropertyAST
    while
      $,$
    end
    $;$
    ioSecondaryPropertyList += !@transientAST.new {
      !transientTypeName
      !isArray
      !transientName
      !dependanceList
      !false
    }
  }

  #·····················································································································

  rule <transient_declaration>
    ?!@secondaryPropertyList ioSecondaryPropertyList
  {
    $copy$
    $transient$
    @bool isArray
    select
      isArray = false
    or
      $array$
      isArray = true
    end
    $Identifier$ ?var @lstring transientTypeName
    $identifier$ ?let @lstring transientName
    $:$
    @observablePropertyList dependanceList = {}
    <observable_property> ?let @observablePropertyAST observablePropertyAST
    dependanceList += !observablePropertyAST
    $;$
    ioSecondaryPropertyList += !@transientAST.new {
      !transientTypeName
      !isArray
      !transientName
      !dependanceList
      !true
    }
  }

}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   TYPE INVENTORY                                                                                                     *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

override method @transientAST typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  [@unifiedTypeMap-proxy makeProxy
    !?ioUnifiedTypeMap
    !mTransientTypeName
    ?*
  ]
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

override method @transientAST tryToSolveSecondaryProperty
  ?!@semanticContext ioSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?!@observablePropertyMap ioObservableProperties
  ?!@secondaryPropertyList ioUnsolvedProperties
{
  @bool solved = true
  for () in mDependencyList while solved do
    solved = [mObservableProperty isPropertyDefined
      !ioSemanticContext
      !inRootObservableProperties
      !ioObservableProperties
    ]
  end
  if solved then
    [ioSemanticContext.mUnifiedTypeMap searchKey !mTransientTypeName ?let type ?let actionMap]
    [!?ioObservableProperties insertKey
      !mTransientName
      !type
      !.transient
      !if mIsArray then .collection else .single end
      !""
      !actionMap
      !false
    ]
  else
    ioUnsolvedProperties += !self
  end
}

#·······················································································································

override method @transientAST secondaryPropertySemanticAnalysis
  ?let @string inOwnerName
  ?let @string unused inRootEntityName
  ?let @observablePropertyMap inRootObservableProperties
  ?let @semanticContext inSemanticContext
  ?let @observablePropertyMap inObservableProperties
  ?!@transientDefinitionListForGeneration ioTransientDefinitionListForGeneration
#  ?!@copyTransientDefinitionListForGeneration unused ioCopyTransientDefinitionListForGeneration
  ?!@arrayControllerForGeneration unused ioArrayControllerForGeneration
  ?!@selectionControllerForGeneration unused ioSelectionControllerForGeneration
  ?!@customObjectControllerForGeneration unused ioCustomObjectControllerDeclaration
  ?!@stringset unused ioNeededOutletClasses
{
#--- Property type
  [inSemanticContext.mUnifiedTypeMap searchKey !mTransientTypeName ?let type ?*]
#--- Check type
  @typeKindList typeList
  switch type
  case boolType, integerType, stringType, dateType, doubleType, fontType : # Ok
    typeList = {!type}
  case enumType (* *) : # Ok
    typeList = {!type}
  case entityType (*) :
    error mTransientName: "an entity cannot be used as simple property type" : typeList
  case classType (*) :
    typeList = {!type}
  case transientPropertyExternType (*) :
    typeList = {!type}
  case propertyClassType (**) :
    typeList = {!type}
  end
#--- Analyse master properties
  @transientDependencyListForGeneration dependencies = {}
  for () in mDependencyList do (idx)
    [mObservableProperty analyzeObservableProperty
      !inRootObservableProperties
      !inSemanticContext
      !inObservableProperties
      ?let @typeKind unused dependencyType
      ?let @propertyKind unused dependencyKind
      ?@propertyMultiplicity outMultiplicity
      ?let @string swiftTypeStringForTransientFunctionArgument
    ]
    if (outMultiplicity == .collection) && (dependencyKind == .stored)  then
      error [mObservableProperty location] : "a collection property cannot be observed"
    end
    dependencies +=
      !mObservableProperty
      ![[mObservableProperty modelStringForSelf !"self"] nameRepresentation] + "_" + idx
      !swiftTypeStringForTransientFunctionArgument
  end
#--- Code generation
  ioTransientDefinitionListForGeneration +=
    !inOwnerName
    !mTransientName.string
    !mIsArray
    !type
    !dependencies
    !mIsCopy
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION TYPE                                                                                                    *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @transientDefinitionListForGeneration {
  @string mOwnerName
  @string mTransientName
  @bool mIsArray
  @typeKind mTransientType
  @transientDependencyListForGeneration mDependencyList
  @bool mIsCopy
}

#·······················································································································

list @transientDependencyListForGeneration {
  @observablePropertyAST mDependency
  @string mFunctionArgumentName
  @string mFunctionArgumentTypeString
}

#·······················································································································

getter @transientDependencyListForGeneration transientComputeFunctionCall
  ?let @string inOwnerName
  ?let @string inTransientName
  ?let @bool inIsCopy
  -> @string outResult
{
  @string ident = "        "
  outResult = ""
  if [self length] == 1 then
    [self first ?let @observablePropertyAST first ?* ?*]
    outResult += ident + "let kind = " + [first modelStringForSelf !"unwSelf"] + "_selection.kind ()\n"
  else
    var dependencies = self
    [!?dependencies popFirst ?let @observablePropertyAST first ?* ?*]
    outResult += ident + "var kind = " + [first modelStringForSelf !"unwSelf"] + "_selection.kind ()\n"
    for () in dependencies do
      outResult += ident + "kind &= " + [mDependency modelStringForSelf !"unwSelf"] + "_selection.kind ()\n"
    end
  end
  outResult += ident + "switch kind {\n"
  outResult += ident + "case .noSelectionKind :\n"
  outResult += ident + "  return .empty\n"
  outResult += ident + "case .multipleSelectionKind :\n"
  outResult += ident + "  return .multiple\n"
  outResult += ident + "case .singleSelectionKind :\n"
  outResult += ident + "  switch ("
  for () in self
  do outResult += [mDependency modelStringForSelf !"unwSelf"] + "_selection"
  between outResult += ", "
  end
  outResult += ") {\n"
  outResult += ident + "  case ("
  for () in self
  do (idx) outResult += ".single (let v" + idx + ")"
  between outResult += ", "
  end
  outResult += ") :\n"
  if inIsCopy then
    outResult += ident + "    return .single (v0)\n"
  else
    outResult += ident + "    return .single (compute_" + inOwnerName + "_" + inTransientName + " ("
    for () in self
    do (idx) outResult += "v" + idx
    between outResult += ", "
    end
    outResult += "))\n"
  end
  outResult += ident + "  default :\n"
  outResult += ident + "    return .empty\n"
  outResult += ident + "  }\n"
  outResult += ident + "}\n"
}

#·······················································································································

getter @transientDependencyListForGeneration needs_unwSelf
  -> @bool outResult
{
  outResult = false
  for (dep * *) in self while not outResult do
    outResult = [dep needs_unwSelf]
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION                                                                                                         *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

getter @observablePropertyAST generateAddObserverCall -> @string outResult {
  switch self
  case controllerProperty (@lstring controllerName @lstring propertyName) : 
    outResult = "self." + controllerName.string + "." + propertyName + "_property.addEBObserver"
  case controllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) : 
    outResult = "self." + controllerName.string + "." + propertyName + "_property." + secondaryPropertyName + "_property.addEBObserver"
  case selfProperty (@lstring masterName) :
    outResult = "self." + masterName.string + "_property.addEBObserver"
  case selfPropertyWithOption (@lstring masterName *) :
    outResult = "self." + masterName.string + "_property.addEBObserver"
  case selfPropertyArray (@lstring masterName @lstring elementPropertyName) :
    outResult = "self." + masterName.string + "_property.addEBObserverOf_" + elementPropertyName
  case selfPropertyObject (@lstring masterName @lstring elementPropertyName) :
    outResult = "self." + masterName.string + "_property.addEBObserverOf_" + elementPropertyName
  case prefsProperty (@lstring propertyName) :
    outResult = "g_" + preferencesName () + "?."  + propertyName + "_property.addEBObserver"
  case prefsPropertyWithOption (@lstring propertyName *) :
    outResult = "g_" + preferencesName () + "?."  + propertyName + "_property.addEBObserver"
  case rootProperty (@lstring masterName) :
    outResult = "self.rootObject." + masterName + "_property.addEBObserver"
  case rootPropertyWithOption (@lstring masterName @lstring optionName) :
    outResult = "self.rootObject." + masterName + "_property." + optionName + "_property.addEBObserver"
  case rootPropertyRelationship (@lstring relationshipName @lstring propertyName) :
    outResult = "self.rootObject." + relationshipName + "_property.addEBObserverOf_" + propertyName
  case signatureProperty (*) :
    outResult = "<< ligne 243 >>"
  case versionProperty (*) :
    outResult = "<< ligne 245 >>"
  case versionShouldChangeProperty (*) :
    outResult = "<< ligne 247 >>"
  end
}

#·······················································································································

getter @observablePropertyAST generateRemoveObserverCall -> @string outResult {
  switch self
  case controllerProperty (@lstring controllerName @lstring propertyName) : 
    outResult = "self." + controllerName.string + "." + propertyName + "_property.removeEBObserver"
  case controllerSecondaryProperty (@lstring controllerName @lstring propertyName @lstring secondaryPropertyName) : 
    outResult = "self." + controllerName.string + "." + propertyName + "_property." + secondaryPropertyName + "_property.removeEBObserver"
  case selfProperty (@lstring masterName) :
    outResult = "self." + masterName.string + "_property.removeEBObserver"
  case selfPropertyWithOption (@lstring masterName *) :
    outResult = "self." + masterName.string + "_property.removeEBObserver"
  case selfPropertyArray (@lstring masterName @lstring elementPropertyName) :
    outResult = "self." + masterName.string + "_property.removeEBObserverOf_" + elementPropertyName
  case selfPropertyObject (@lstring masterName @lstring elementPropertyName) :
    outResult = "self." + masterName.string + "_property.removeEBObserverOf_" + elementPropertyName
  case prefsProperty (@lstring propertyName) :
    outResult = "g_" + preferencesName () + "?."  + propertyName + "_property.removeEBObserver"
  case prefsPropertyWithOption (@lstring propertyName *) :
    outResult = "g_" + preferencesName () + "?."  + propertyName + "_property.removeEBObserver"
  case rootProperty (@lstring masterName) :
    outResult = "self.rootObject." + masterName + "_property.removeEBObserver"
  case rootPropertyWithOption (@lstring masterName @lstring optionName) :
    outResult = "self.rootObject." + masterName + "_property." + optionName + "_property.removeEBObserver"
  case rootPropertyRelationship (@lstring relationshipName @lstring propertyName) :
    outResult = "self.rootObject." + relationshipName + "_property.removeEBObserverOf_" + propertyName
  case signatureProperty (*) :
    outResult = "<< ligne 270 >>"
  case versionProperty (*) :
    outResult = "<< ligne 272 >>"
  case versionShouldChangeProperty (*) :
    outResult = "<< ligne 274 >>"
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#    TRANSIENT ROUTINE GENERATION                                                                                      *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

proc generateTransients
  ?let @string inOutputDirectory
  ?let @transientDefinitionListForGeneration inTransientListForGeneration
  ?!@stringset ioGeneratedFileSet
{
#--------------------------- Generate transient routines
  for () in inTransientListForGeneration do
    if not mIsCopy then
      let s = [filewrapper transientManager.transientComputationFunctionFile
        !mOwnerName
        !mTransientName
        !mIsArray
        !mDependencyList
        !mTransientType 
      ]
      let fileName = "transient-" + mOwnerName + "-" + mTransientName + ".swift"
      ioGeneratedFileSet += !fileName
      [@string generateFileWithPattern
        !startPath:inOutputDirectory
        !fileName:fileName
        !lineComment:"//"
        !header:""
        !defaultUserZone1:"\n\n" # Defaut user zone1
        !generatedZone2:s
        !defaultUserZone2:"\n" # Defaut user zone2
        !generatedZone3:"}\n\n//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\n"
        !makeExecutable:false
      ]
    end
  end
}

#·······················································································································

private filewrapper transientManager in "../generation-templates" {
}{
}{
  template transientComputationFunctionFile "transient-computation-function.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string TRANSIENT_NAME
    ?@bool IS_ARRAY
    ?@transientDependencyListForGeneration DEPENDENCY_LIST
    ?@typeKind TRANSIENT_TYPE
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
