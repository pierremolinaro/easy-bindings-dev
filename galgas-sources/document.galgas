#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @documentDeclarationEX : @astDeclaration {
  @lstring mDocumentName
  @lstring mRootEntityName
  @outletDeclarationList mOutletDeclarationList
  @lstringlist mActionDeclarationList
  @secondaryPropertyList mSecondaryPropertyList
}

#·······················································································································

class @documentDeclarationAST : @abstractDeclarationAST {
  @lstring mRootEntityName
  @outletDeclarationList mOutletDeclarationList
  @lstringlist mActionDeclarationList
  @secondaryPropertyList mSecondaryPropertyList
}

#·······················································································································

override method @documentDeclarationAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  [!?ioGraph addNode !mClassName !self]
}

#·······················································································································

override getter @documentDeclarationAST lkey -> @lstring {
  result = mClassName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <document_declaration>
    ?let @bool inIsUserDefined
    ?!@astDeclarationStruct ioDeclarationAST
  {
    $document$
    $Identifier$ ?let @lstring documentName
    $root$
    $Identifier$ ?let @lstring rootEntityName
    ${$
    @secondaryPropertyList secondaryPropertyList = {}
    @outletDeclarationList outletDeclarationList = {}
    @regularBindingList bindingList = {}
    @lstringlist actionDeclarationList = {}
    @stringset signatureList = {}
    repeat
    while
      <action_declaration> !?actionDeclarationList
    while
      <transient_declaration> !documentName !rootEntityName !?secondaryPropertyList !?ioDeclarationAST
    while
      <outlet_declaration> !?outletDeclarationList
    while
      <controller_declaration> !documentName !rootEntityName !?secondaryPropertyList !?ioDeclarationAST
    end
    $}$
  #--- Add documentFilePath transient property
    secondaryPropertyList += !@transientAST.new {
      !["String" here]
      !["documentFilePath" here]
      !{}
      !["" here]
    }
  #---
    ioDeclarationAST.mDeclarationList += !@documentDeclarationEX.new {
      !inIsUserDefined
      !documentName
      !rootEntityName
      !outletDeclarationList
      !actionDeclarationList
      !secondaryPropertyList
    }
    ioDeclarationAST.mUnifiedDeclarationList += !@documentDeclarationAST.new {
      !documentName
      !rootEntityName
      !outletDeclarationList
      !actionDeclarationList
      !secondaryPropertyList
    }
    ioDeclarationAST.mUnifiedDeclarationList += !@transientDeclarationAST.new {
      !documentName
      !rootEntityName
      !["String" here]
      !["documentFilePath" here]
      !{}
      !["" here]
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @documentDeclarationAST firstAnalysisPhase
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  buildActionMap (!mActionDeclarationList ?let @actionMap actionMap)
  [!?ioSemanticContext.mClassMap insertKey
    !mClassName
    !.document {!rootEntityName: mRootEntityName}
    !{}
    !actionMap
    !{}
  ]
}






#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TYPE INVENTORY
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @documentDeclarationEX typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
#  [mSimpleStoredAttributeList typeInventory !?ioUnifiedTypeMap]
  for (item) in mSecondaryPropertyList do
    [item typeInventory
      !?ioUnifiedTypeMap
    ]
  end
  [@unifiedTypeMap-proxy makeProxy !?ioUnifiedTypeMap !mRootEntityName ?*]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC TYPES                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @documentObservablePropertyMap {
  @observablePropertyMap mObservablePropertyMap
  insert insertKey error message "the '%K' document is already declared in %L"
  search searchKey error message "there is no '%K' document"
}

#·······················································································································

override method @documentDeclarationEX buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList ioSecondaryDeclarationListWorkingList
  ?!@uint ioSecondaryDeclarationCount
{
  ioSecondaryDeclarationCount = ioSecondaryDeclarationCount + [mSecondaryPropertyList length]
  ioSecondaryDeclarationListWorkingList += !self !mSecondaryPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @documentDeclarationEX buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@semanticContextEX ioSemanticContext
{
  [!?ioSemanticContext.mDocumentObservablePropertyMap insertKey
    !mDocumentName
    !{}
  ]
}

#·······················································································································

override method @documentDeclarationEX solveSecondaryProperty
  ?!@semanticContextEX ioSemanticContext
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @secondaryPropertyList inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties
  ?!@simpleStoredPropertyListForGenerationEX ioSimpleStoredPropertyListForGeneration
{
  outUnsolvedProperties = {}
  [ioSemanticContext.mDocumentObservablePropertyMap searchKey
    !mDocumentName
    ?@observablePropertyMap observablePropertyMap
  ]
  [ioSemanticContext.mEntityObservablePropertyMap searchKey
    !mRootEntityName
    ?@observablePropertyMap rootObservablePropertyMap
    ?*
  ]
  for (property) in inPropertiesToSolve do
    [property tryToDefineSecondaryProperty
      !?ioSemanticContext
      !rootObservablePropertyMap
      !?observablePropertyMap
      !?outUnsolvedProperties
      !?ioSimpleStoredPropertyListForGeneration
    ]
  end
  [!?ioSemanticContext.mDocumentObservablePropertyMap setMObservablePropertyMapForKey
    !observablePropertyMap
    !mDocumentName.string
  ]
}

#·······················································································································

override method @documentDeclarationEX semanticAnalysisEX
  ?let @semanticContextEX inSemanticContext
  ?!@generationStruct ioGeneration
{
  [inSemanticContext.mDocumentObservablePropertyMap searchKey
    !mDocumentName
    ?let @observablePropertyMap observablePropertyMap
  ]
  [inSemanticContext.mEntityObservablePropertyMap searchKey
    !mRootEntityName
    ?let @observablePropertyMap rootObservablePropertyMap
    ?*
  ]
#--- Analyze secondary
  @transientDefinitionListForGenerationEX transientDefinitionListForGeneration = {}
  @arrayControllerForGenerationEX documentArrayControllerListForGeneration = {}
  @selectionControllerForGeneration selectionControllerListForGeneration = {}
  for (item) in mSecondaryPropertyList do
    [item secondaryPropertySemanticAnalysisEX
      !mDocumentName.string
      !mRootEntityName.string
      !rootObservablePropertyMap
      !inSemanticContext
      !observablePropertyMap
      !?transientDefinitionListForGeneration
      !?documentArrayControllerListForGeneration
      !?selectionControllerListForGeneration
      !?ioGeneration.mNeededOutletClasses
    ]
  end
  ioGeneration.mTransientListForGeneration += transientDefinitionListForGeneration
  ioGeneration.mArrayControllerListForGeneration += documentArrayControllerListForGeneration
  ioGeneration.mSelectionControllerListForGeneration += selectionControllerListForGeneration
#--- Build action map
  buildActionMap (!mActionDeclarationList ?let @actionMap actionMap)
  for () in actionMap do
    ioGeneration.mActionListForGeneration +=
      !mDocumentName.string
      !lkey.string
  end
#--- Analyze outlets and bindings
  analyzeOutletsEX (
    !rootObservablePropertyMap
    !mRootEntityName.string
    !inSemanticContext
    !mOutletDeclarationList
    !observablePropertyMap
    !actionMap
    !mDocumentName.string
    !?ioGeneration
    ?let @regularBindingsGenerationList regularBindingsGenerationList
    ?let @multipleBindingGenerationList multipleBindingGenerationList
    ?let @actionBindingListForGeneration actionBindingListForGeneration
    ?let @decoratedOutletMap outletMap
    ?let @tableViewBindingGenerationList tableViewBindingGenerationList
    ?let @ebViewGraphicControllerBindingGenerationList ebViewBindingGenerationList
  )
#--- Code generation
  ioGeneration.mDocumentListForGeneration +=
    !mDocumentName.string
    !mRootEntityName.string
    !transientDefinitionListForGeneration
    !outletMap
    !actionBindingListForGeneration
    !regularBindingsGenerationList
    !multipleBindingGenerationList
    !documentArrayControllerListForGeneration
    !tableViewBindingGenerationList
    !ebViewBindingGenerationList
    !selectionControllerListForGeneration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION TYPES                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @documentListForGeneration {
  @string mDocumentName
  @string mRootEntityName
  @transientDefinitionListForGenerationEX mTransientListForGeneration
  @decoratedOutletMap mOutletMap
  @actionBindingListForGeneration mTargetActionList 
  @regularBindingsGenerationList mRegularBindingsGenerationList 
  @multipleBindingGenerationList multipleBindingGenerationList
  @arrayControllerForGenerationEX mArrayControllerForGeneration
  @tableViewBindingGenerationList mTableViewBindingGenerationList
  @ebViewGraphicControllerBindingGenerationList mEBViewBindingGenerationList
  @selectionControllerForGeneration mSelectionControllerListForGeneration
}

#·······················································································································

private filewrapper documentGenerationTemplate in "../generation-templates" {
}{
}{
  template documentImplementation "document.swift.galgasTemplate"
    ?@string DOCUMENT_NAME
    ?@string ROOT_ENTITY_NAME
    ?@transientDefinitionListForGenerationEX TRANSIENT_LIST_FOR_IMPLEMENTATION
    ?@decoratedOutletMap OUTLET_GENERATION_MAP
    ?@arrayControllerForGenerationEX ARRAY_CONTROLLER_LIST
    ?@actionBindingListForGeneration TARGET_ACTION_LIST
    ?@regularBindingsGenerationList REGULAR_BINDINGS_GENERATION_LIST 
    ?@multipleBindingGenerationList MULTIPLE_BINDING_GENERATION_LIST
    ?@tableViewBindingGenerationList TABLE_VALUE_BINDING_GENERATION_LIST
    ?@ebViewGraphicControllerBindingGenerationList EB_VIEW_GRAPHIC_CONTROLLER_BINDING_GENERATION_LIST
    ?@selectionControllerForGeneration SELECTION_CONTROLLER_LIST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateDocuments
  ?let @documentListForGeneration inDocumentListForGeneration
  ?let @string inOutputDirectory
  ?!@stringset ioGeneratedFileSet
{
  if [inDocumentListForGeneration length] > 0 then
    let fileName = "EBManagedDocument.swift"
    var fw = [filewrapper swift_sources]
    let contents = [fw textFileContentsAtPath !fileName]
    ioGeneratedFileSet += !fileName
    [@string generateFile
      !inOutputDirectory
      !fileName
      !contents
    ]
  end
  for () in inDocumentListForGeneration do
    let s = [filewrapper documentGenerationTemplate.documentImplementation
      !mDocumentName
      !mRootEntityName
      !mTransientListForGeneration
      !mOutletMap
      !mArrayControllerForGeneration
      !mTargetActionList
      !mRegularBindingsGenerationList
      !multipleBindingGenerationList
      !mTableViewBindingGenerationList
      !mEBViewBindingGenerationList
      !mSelectionControllerListForGeneration
    ]
    let fileName = mDocumentName + ".swift"
    ioGeneratedFileSet += !fileName
    [@string generateFile
      !inOutputDirectory
      !fileName
      !s
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
