#-----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
#-----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <graphviz_declaration> ?!@astDeclarationStruct ioDeclarationAST {
    $graphviz$
    $Identifier$ ?let @lstring entityName
    ioDeclarationAST.mGraphvizList += !entityName
    $;$
 }
 
  #·····················································································································

}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC TYPES                        
#-----------------------------------------------------------------------------------------------------------------------

proc graphvizAnalysis 
  ?let @string inSourceFileDirectory
  ?let @semanticContext inSemanticContext
  ?let @lstringlist inGraphvizList
{
  if @uint.errorCount == 0 then
    for (rootEntityName) in inGraphvizList do
      graphvizRootEntityAnalysis (!inSourceFileDirectory !inSemanticContext !rootEntityName.string)
    end
  end
}

#-----------------------------------------------------------------------------------------------------------------------

private proc graphvizRootEntityAnalysis
  ?let @string inSourceFileDirectory
  ?let @semanticContext inSemanticContext
  ?let @string inRootEntityName
{
  @stringset reachableEntityNameSet = {!inRootEntityName}
  @stringlist exploreArray = {!inRootEntityName}
  @stringlist nodeList = {}
  @stringlist arrowList = {}
  loop ([inSemanticContext.mClassMap count] + 1) while [exploreArray length] > 0 do
    [!?exploreArray popLast ?let @string entityName]
    var node = "  " + entityName + "[label=\"<" + entityName + ">" + entityName
    [inSemanticContext.mClassMap searchKey ![entityName nowhere] ?let entityKind ?let @propertyMap propertyMap ?2*]
    [entityKind entity ?superEntityName: let superEntityName ?2*]
    if superEntityName != "" then
      if not [reachableEntityNameSet hasKey !superEntityName] then
        reachableEntityNameSet += !superEntityName
        exploreArray += !superEntityName
      end
      arrowList += !"  " + entityName + " -> " + superEntityName +  " [arrowhead=dot]"
    end
    for (propertyName propertyKind 2*) in propertyMap do
      switch propertyKind
      case property (type accessibility) :
        switch accessibility 
        case stored :
          node += "|" + [type swiftTypeName] + " " + propertyName
        case transient (*) :
        case computed :
        end
      case arrayController (2*) :
      case selectionController (*) :
      case toMany (@lstring typeName @propertyAccessibility accessibility * optionKind) :
       if [accessibility isStored] then
         node += "|<" + propertyName + ">[" + typeName + "] " + propertyName
         switch optionKind
         case none :
           if not [reachableEntityNameSet hasKey !typeName] then
              reachableEntityNameSet += !typeName
              exploreArray += !typeName
            end
           arrowList += !"  " + entityName + ":" + propertyName
             + " -> " + typeName + ":" + typeName + " [dir=both arrowtail=none arrowhead=vee]"
         case hasOpposite (oppositeName) :
           if not [reachableEntityNameSet hasKey !typeName] then
             reachableEntityNameSet += !typeName
             exploreArray += !typeName
           end
           arrowList += !"  " + entityName + ":" + propertyName
              + " -> " + typeName + ":" + oppositeName + " [dir=both arrowtail=onormal arrowhead=vee]"
         case hasDependance (*) :
         end
        end
      case toOne (@lstring typeName @propertyAccessibility accessibility * opposite) :
        if [accessibility isStored] then
          node += "|<" + propertyName + ">" + typeName + "? " + propertyName
          switch opposite
          case none :
            if not [reachableEntityNameSet hasKey !typeName] then
              reachableEntityNameSet += !typeName
              exploreArray += !typeName
            end
            arrowList += !"  " + entityName + ":" + propertyName 
               + " -> " + typeName + ":" + typeName + " [dir=both arrowtail=none arrowhead=onormal]"
          case oppositeIsToMany (*) : # No generation
          case oppositeIsToOne (oppositeName) :
            if not [reachableEntityNameSet hasKey !typeName] then
              reachableEntityNameSet += !typeName
              exploreArray += !typeName
            end
            if propertyName.string > oppositeName.string then
              arrowList += !"  " + entityName + ":" + propertyName 
                   + " -> " + typeName + ":" + oppositeName + " [dir=both arrowtail=onormal arrowhead=onormal]"
            end
          end
        end
      end
    end
    node += "\"]"
    nodeList += !node
  end
#--- Generation
  var s = "digraph G {\n"
  s += "  rankdir=LR ;\n"
  s += "  node [shape=record fontname=helvetica style=rounded] ;\n"
  for (node) in nodeList do
    s += node + " ;\n"
  end
  for (arrow) in arrowList do
    s += arrow + " ;\n"
  end
  s += "}\n"
  let filePath = inSourceFileDirectory + "/models/" + inRootEntityName + ".dot"
  [[filePath stringByDeletingLastPathComponent] makeDirectory]
  [s writeToFileWhenDifferentContents !filePath ?*]
}

#-----------------------------------------------------------------------------------------------------------------------

