
  
#----------------------------------------------------------------------------*
#! buildTransientDependencyGraph
#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyAST buildTransientDependencyGraph
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ?let @lstring inTransientName
  ?let @decoratedObservablePropertyMap inLocalObservablePropertyMap
  ?let @unifiedTypeMap-proxy inRootEntityType
  ?let @arrayControllerMap inArrayControllerMap
  ?let @lstring inTransientPropertySignature

#----------------------------------------------------------------------------*

override method @transientRootSignDependencyAST buildTransientDependencyGraph
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph unused ioTransientDependencyGraph
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @lstring unused inTransientPropertySignature {
}

#----------------------------------------------------------------------------*

override method @transientLocalDependencyAST buildTransientDependencyGraph
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap inLocalObservablePropertyMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @lstring inTransientPropertySignature {
  [inLocalObservablePropertyMap searchKey
    !mMasterName
    ?var @unifiedTypeMap-proxy masterType
    ?*
    ?var @lstring masterPropertySignature
    ?var @bool isCollection
  ]
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ]
}

#----------------------------------------------------------------------------*

override method @transientControllerDependencyAST buildTransientDependencyGraph
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  ?let @arrayControllerMap inArrayControllerMap
  ?let @lstring inTransientPropertySignature {
  [inArrayControllerMap searchKey
    !mControllerName
    ?4*
    ?let @decoratedObservablePropertyMap controllerObservablePropertyMap
    ?2*
  ]
#---
  [controllerObservablePropertyMap searchKey
    !mMasterName
    ?*
    ?*
    ?var @lstring masterPropertySignature
    ?*
  ]
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ]
}

#----------------------------------------------------------------------------*

override method @transientRootDependencyAST buildTransientDependencyGraph
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ?let @unifiedTypeMap-proxy inRootEntityType
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @lstring inTransientPropertySignature {
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap = [inRootEntityType mObservablePropertyMap]
  var t = [inRootEntityType mSuperType]
  loop( [inUnifiedTypeMap count]) while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ]
    end
    t = [t mSuperType]
  end 
  [allObservablePropertyMap searchKey
    !mMasterName
    ?*
    ?*
    ?var @lstring masterPropertySignature
    ?var @bool isCollection
  ]
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ]
}

#----------------------------------------------------------------------------*

override method @transientRootRelationshipDependencyAST buildTransientDependencyGraph
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ?let @unifiedTypeMap-proxy inRootEntityType
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @lstring inTransientPropertySignature {
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap = [inRootEntityType mObservablePropertyMap]
  var t = [inRootEntityType mSuperType]
  loop( [inUnifiedTypeMap count]) while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ]
    end
    t = [t mSuperType]
  end 
  [allObservablePropertyMap searchKey
    !mRelationshipName
    ?let @unifiedTypeMap-proxy relationshipElementType
    ?*
    ?*
    ?var @bool isCollection
  ]
  if not isCollection then
    error mRelationshipName : "this property should be a tomany relationship"
  end
  [[relationshipElementType mObservablePropertyMap] searchKey
    !mMasterName
    ?*
    ?*
    ?var @lstring masterPropertySignature
    ?isCollection
  ]
  if isCollection then
    error mMasterName : "this property should not be a collection"
  end
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ]
}

#----------------------------------------------------------------------------*

override method @transientPreferenceDependencyAST buildTransientDependencyGraph
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@transientDependencyGraph ioTransientDependencyGraph
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inLocalObservablePropertyMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @lstring inTransientPropertySignature {
#--- Get preferences observables properties
  [inUnifiedTypeMap searchKey
    !mPreferencesName
    ?* #?@typeKind kind
    ?5*
    ?let @decoratedObservablePropertyMap observablePropertyMap
    ?5*
  ]
#---
  [observablePropertyMap searchKey
    !mMasterName
    ?2*
    ?let @lstring masterPropertySignature
    ?*
  ]
#--- Add dependency arc
  [!?ioTransientDependencyGraph addEdge
    !masterPropertySignature
    !inTransientPropertySignature
  ]
}

#----------------------------------------------------------------------------*

proc buildTransientDependencyGraph
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @string inSourceFile
{
#------------------------------------------- Build transient dependancy graph
  var transientDependencyGraph = @transientDependencyGraph. emptyGraph
  for () type_ in inUnifiedTypeMap do
    for () property_ in type_mObservablePropertyMap do
      [!?transientDependencyGraph addNode
        !property_mPropertySignature
        !property_mPropertySignature.string
        !property_mIsTransient
      ]
    end
    for () arrayController_ in type_mArrayControllerMap do
      [!?transientDependencyGraph addNode
        !arrayController_mPropertySignature
        !arrayController_mPropertySignature.string
        !true # Is transient
      ]
    #--- Add dependency arc from model to array controller
      [!?transientDependencyGraph addEdge
        ![arrayController_mBoundModel propertySignature
           ![type_mTypeKind kindName]
           !type_lkey.string
           !type_mRootEntityType
         ]
        !arrayController_mPropertySignature
      ]
    end
    for () transient_ in type_mDecoratedTransientMap do
      @decoratedObservablePropertyMap allObservableProperties = type_mObservablePropertyMap
      @unifiedTypeMap-proxy t = type_mSuperType
      loop( [inUnifiedTypeMap count]) while not [t isNull] do
        for () super_ in [t mObservablePropertyMap] do
          [!?allObservableProperties insertKey
            !super_lkey
            !super_mPropertyType
            !super_mIsTransient
            !super_mPropertySignature
            !super_mIsCollection
         ]
        end
        t = [t mSuperType]
      end 
      for () in transient_mDependencyList do
        [mDependency buildTransientDependencyGraph
          !inUnifiedTypeMap
          !?transientDependencyGraph
          !transient_lkey
          !allObservableProperties
          !type_mRootEntityType
          !type_mArrayControllerMap
          !transient_mTransientSignature
        ]
      end
    end
  end
#------------------------------------------- Output graphviz file ?
  if (@uint. errorCount == 0) && [option easyBindings_options.outputTransientDependencyGraph value] then
    let s = [transientDependencyGraph graphviz]
    let path = inSourceFile + ".transientDependancyGraph.dot"
    [s writeToFileWhenDifferentContents !path ?*]
  end
#------------------------------------------- Topological sort nodes
  @transientDependencyGraphNodeInfoList sortedTransientNodes
  if @uint. errorCount != 0 then
    sortedTransientNodes = {}
  else
    [transientDependencyGraph topologicalSort
      ?sortedTransientNodes
      ?*
      ?var @transientDependencyGraphNodeInfoList unsortedNodes
      ?*
    ]
    if [unsortedNodes length] > 0 then
      var s = "cannot sort properties and transient ; the following ones are involved in circular dependence:"
      for () in  unsortedNodes do
        s += "\n-- " + mSignature
      end
      error @location.here : s
    end
  end
}

#----------------------------------------------------------------------------*
#! transientDependencySemanticAnalysis
#----------------------------------------------------------------------------*

override method @transientRootSignDependencyAST transientDependencySemanticAnalysis
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  ?let @lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration unused ioTransientDependencyListForGeneration {
}

#----------------------------------------------------------------------------*

override method @transientLocalDependencyAST transientDependencySemanticAnalysis
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap inAllObservablePropertyMap
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  ?let @lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration {
  [inAllObservablePropertyMap searchKey
    !mMasterName
    ?var @unifiedTypeMap-proxy masterType
    ?*
    ?* #@lstring masterPropertySignature
    ?var @bool isCollection
  ]
  if mNamesCountOption && not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships"
  elsif isCollection && not mNamesCountOption then
    error mMasterName: "to-many relationships requires the 'count' option"
  end
  ioTransientDependencyListForGeneration += ![masterType transientFormalArgumentTypeName] !mMasterName.string
}

#----------------------------------------------------------------------------*

override method @transientControllerDependencyAST transientDependencySemanticAnalysis
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ?let @arrayControllerMap inArrayControllerMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  ?let @lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration {
  [inArrayControllerMap searchKey
    !mControllerName
    ?4*
    ?let @decoratedObservablePropertyMap arrayControllerObservablePropertyMap
    ?2*
  ]
  [arrayControllerObservablePropertyMap searchKey
    !mMasterName
    ?let @unifiedTypeMap-proxy masterType
    ?*
    ?*
    ?*
  ]
#---
  ioTransientDependencyListForGeneration += ![masterType transientFormalArgumentTypeName] !mMasterName.string
}

#----------------------------------------------------------------------------*

override method @transientRootDependencyAST transientDependencySemanticAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @unifiedTypeMap-proxy inRootEntityType
  ?let @lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration {
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap = [inRootEntityType mObservablePropertyMap]
  var t = [inRootEntityType mSuperType]
  loop( [inUnifiedTypeMap count]) while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ]
    end
    t = [t mSuperType]
  end 
  [allObservablePropertyMap searchKey
    !mMasterName
    ?let @unifiedTypeMap-proxy masterType
    ?*
    ?*
    ?var @bool isCollection
  ]
#--- Has 'count' option ?
  if mNamesCountOption && not isCollection then
    error mMasterName: "the 'count' option is only allowed for to-many relationships"
  end
#---
  ioTransientDependencyListForGeneration += ![masterType transientFormalArgumentTypeName] !mMasterName.string
}

#----------------------------------------------------------------------------*

override method @transientRootRelationshipDependencyAST transientDependencySemanticAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @unifiedTypeMap-proxy inRootEntityType
  ?let @lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration {
#--- Get root entity observables properties
  @decoratedObservablePropertyMap allObservablePropertyMap = [inRootEntityType mObservablePropertyMap]
  var t = [inRootEntityType mSuperType]
  loop( [inUnifiedTypeMap count]) while not [t isNull] do
    for () super_ in [t mObservablePropertyMap] do
      [!?allObservablePropertyMap insertKey
        !super_lkey
        !super_mPropertyType
        !super_mIsTransient
        !super_mPropertySignature
        !super_mIsCollection
     ]
    end
    t = [t mSuperType]
  end 
  [allObservablePropertyMap searchKey
    !mRelationshipName
    ?let @unifiedTypeMap-proxy relationshipElementType
    ?*
    ?*
    ?var @bool isCollection
  ]
  if not isCollection then
    error mRelationshipName : "this property should be a tomany relationship"
  end
  [[relationshipElementType mObservablePropertyMap] searchKey
    !mMasterName
    ?2*
    ?var @lstring masterPropertySignature
    ?isCollection
  ]
  if isCollection then
    error mMasterName : "this property should not be a collection"
  end
#---
  ioTransientDependencyListForGeneration += !"NSArray /* [" + [relationshipElementType key] + "_" + mMasterName + "] */" !"arrayOf_" + mMasterName
}

#----------------------------------------------------------------------------*

override method @transientPreferenceDependencyAST transientDependencySemanticAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @lstring unused inTransientName
  ?let @decoratedObservablePropertyMap unused inAllObservablePropertyMap
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  ?let @lstring unused inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration {
#--- Get preferences observables properties
  [inUnifiedTypeMap searchKey
    !mPreferencesName
    ?let @typeKind kind
    ?5*
    ?let @decoratedObservablePropertyMap observablePropertyMap
    ?5*
  ]
#--- Check
  if kind != @typeKind. preferencesType then
    error mPreferencesName : "'" + mPreferencesName + "' is not a preference"
  end
#---
  [observablePropertyMap searchKey
    !mMasterName
    ?let @unifiedTypeMap-proxy masterType
    ?*
    ?* # ?@lstring masterPropertySignature
    ?*
  ]
  ioTransientDependencyListForGeneration += ![masterType transientFormalArgumentTypeName] !mMasterName.string
}

#----------------------------------------------------------------------------*

