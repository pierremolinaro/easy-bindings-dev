#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @toManyRelationshipOptionAST {
  case none
  case hasOpposite (@lstring oppositeName)
  case hasDependance (@lstring masterPropertyName)
}

#·······················································································································

class @toManyRelationshipAST : @abstractDeclarationAST {
  @lstring mDestinationEntityName
  @lstring mToManyRelationshipName
  @toManyRelationshipOptionAST mOption
  @bool mCustomStore
}

#·······················································································································

override method @toManyRelationshipAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  let node = @lstring.new {!mClassName.string + " " + mToManyRelationshipName !mToManyRelationshipName.location}
  [!?ioGraph addNode !node !self]
  [!?ioGraph addEdge !node !mClassName]
  [!?ioGraph addEdge !node !mDestinationEntityName]
}

#·······················································································································

override getter @toManyRelationshipAST lkey -> @lstring {
  result = @lstring.new {!mClassName.string + " " + mToManyRelationshipName !mToManyRelationshipName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <toMany_relationship>
            ?let @lstring inCurrentEntity
            ?!@stringset ioSignatureList
            ?!@astDeclarationStruct ioDeclarationAST
  {
    $toMany$
    @bool usedForSignature = false
    @bool customStore = false
    repeat
    while
      $@attribute$ ?let attributeName
      if attributeName.string == "signature" then
        if usedForSignature then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        usedForSignature = true
      elsif attributeName.string == "customStore" then
        if customStore then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        customStore = true
      else
        error attributeName : "unknow attribute" fixit { replace "@signature" replace "@customStore" }
      end
    end
    $Identifier$ ?let destinationEntityName
    $identifier$ ?let relationshipName
    if usedForSignature then
      ioSignatureList += !relationshipName.string
    end
    @toManyRelationshipOptionAST toManyRelationshipOption
    select
      $inverse$
      $toOne$
      $identifier$ ?let inserseRelationshipName
      toManyRelationshipOption = .hasOpposite {!oppositeName: inserseRelationshipName}
    or
      $dependsFrom$
      $self$
      $.$
      $identifier$ ?let masterPropertyName
      toManyRelationshipOption = .hasDependance {!masterPropertyName: masterPropertyName}
   or
      toManyRelationshipOption = .none
    end
    $;$
    ioDeclarationAST.mUnifiedDeclarationList += !@toManyRelationshipAST.new {
      !inCurrentEntity
      !destinationEntityName
      !relationshipName
      !toManyRelationshipOption
      !customStore
    }
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @toManyRelationshipAST firstAnalysisPhase
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  with mClassName in !?ioSemanticContext.mClassMap 
    error message searchKey
  do
    [ioSemanticContext.mClassMap searchKey !mDestinationEntityName ?let classKind ?3*]
    switch classKind
    case prefs :
      error mDestinationEntityName : "an entity is required here"
    case atomic (*) :
      error mDestinationEntityName : "an entity is required here"
    case document (*) :
      error mDestinationEntityName : "an entity is required here"
    case entity (* graphic *) :
      let kind = @propertyKind.toMany {
        !typeName: mDestinationEntityName
        !accessibility: .stored
        !graphic: graphic
        !optionKind: mOption
      }
      [!?mPropertyMap insertKey !mToManyRelationshipName !kind !{}]
    #--- Current class is preferences ?
      let inPrefs = mClassName.string == preferencesName ()
    #--- Code Generation
      mPropertyGenerationList += !@toManyPropertyGeneration.new {
        !mToManyRelationshipName.string
        !kind
        !mOption
        !inPrefs
        !mCustomStore
      }
    end
  end
}

#·······················································································································

class @toManyPropertyGeneration : @propertyGeneration {
  @propertyKind mRelationshipType
  @toManyRelationshipOptionAST mOption
  @bool mInPreferences
  @bool mCustomStore
}

#·······················································································································

list @toManyPropertyGenerationList {
  @toManyPropertyGeneration mProperty
}

#·······················································································································

override getter @toManyPropertyGeneration propertyDeclarationCode ?let @stringset unused inOverriddenTransients -> @string {
  result  = "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n"
  result += "  //   To many property: " + mPropertyName + "\n"
  result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
  if [mOption isHasDependance] then
    result += "  var " + mPropertyName + "_property = TransientArrayOf_" + [mRelationshipType swiftTypeName] + " ()\n\n"
  elsif mInPreferences then
    result += "  var " + mPropertyName + "_property = StoredArrayOf_" + [mRelationshipType swiftTypeName]
           + " (prefKey: Preferences_" + mPropertyName + ")\n\n"
  else
    result += "  var " + mPropertyName + "_property = StoredArrayOf_" + [mRelationshipType swiftTypeName] + " ()\n\n"
  end
  result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
  result += "  var " + mPropertyName + "_property_selection : EBSelection < [" + [mRelationshipType swiftTypeName] + "] > {\n"
  result += "      return self." + mPropertyName + "_property.prop\n"
  result += "  }\n\n"
}

#·······················································································································

override getter @toManyPropertyGeneration prefKeyDefinitionCode -> @string {
  result = "let Preferences_" + mPropertyName + " = \"Preferences:" + mPropertyName + "\"\n"
}

#·······················································································································

override getter @toManyPropertyGeneration configurationCode -> @string {
  switch mOption
  case none :
    result  = "  //--- To many property: " + mPropertyName + " (no option)\n"
    result += "    self." + mPropertyName + "_property.ebUndoManager = self.ebUndoManager\n"
  case hasDependance (@lstring unused masterPropertyName) :
    result = ""
  case hasOpposite (@lstring oppositeName) :
    result  = "  //--- To many property: " + mPropertyName + " (has opposite relationship)\n"
    result += "    self." + mPropertyName + "_property.ebUndoManager = self.ebUndoManager\n"
    result += "    self." + mPropertyName + "_property.setOppositeRelationship ="
            + " { [weak self] (_ inManagedObject :" + [mRelationshipType swiftTypeName] + "?) in\n"
    result += "      inManagedObject?." + oppositeName + "_property.setProp (self)\n"
    result += "    }\n"
  end
}

#·······················································································································

override getter @toManyPropertyGeneration setupRelationshipFromDictionaryCode -> @string {
  if [mOption isHasDependance] then
    result = ""
  elsif mCustomStore then
    result  = "  //--- To many property: " + mPropertyName + " (Custom store)\n"
    result += "    self." + mPropertyName + "_property.setProp (customRead_" + [mRelationshipType swiftTypeName] + "_" + mPropertyName + " (from: inDictionary, with: self.ebUndoManager))\n"

    result += "    /* self." + mPropertyName + "_property.setProp (readEntityArrayFromDictionary (\n"
    result += "      inRelationshipName: \"" + mPropertyName + "\",\n"
    result += "      inDictionary: inDictionary,\n"
    result += "      managedObjectArray: &managedObjectArray\n"
    result += "    ) as! [" + [mRelationshipType swiftTypeName] + "]) */\n"
  else
    result  = "  //--- To many property: " + mPropertyName + "\n"
    result += "    self." + mPropertyName + "_property.setProp (readEntityArrayFromDictionary (\n"
    result += "      inRelationshipName: \"" + mPropertyName + "\",\n"
    result += "      inDictionary: inDictionary,\n"
    result += "      managedObjectArray: &managedObjectArray\n"
    result += "    ) as! [" + [mRelationshipType swiftTypeName] + "])\n"
  end
}

#·······················································································································

override getter @toManyPropertyGeneration saveIntoDictionaryCode -> @string {
  if [mOption isHasDependance] then
    result = ""
  elsif mCustomStore then
    result  = "  //--- To many property: " + mPropertyName + " (Custom store)\n"
    result += "    customStore_" + [mRelationshipType swiftTypeName] + "_" + mPropertyName + " (self." + mPropertyName + "_property.propval, intoDictionary: ioDictionary)\n"
    result += "    /* self.store (\n"
    result += "      managedObjectArray: self." + mPropertyName + "_property.propval,\n"
    result += "      relationshipName: \"" + mPropertyName + "\",\n"
    result += "      intoDictionary: ioDictionary\n"
    result += "    ) */\n"
  else
    result  = "  //--- To many property: " + mPropertyName + "\n"
    result += "    self.store (\n"
    result += "      managedObjectArray: self." + mPropertyName + "_property.propval,\n"
    result += "      relationshipName: \"" + mPropertyName + "\",\n"
    result += "      intoDictionary: ioDictionary\n"
    result += "    )\n"
  end
}

#·······················································································································

override getter @toManyPropertyGeneration objectAccessibilityCode -> @string {
  result  = "  //--- To many property: " + mPropertyName + "\n"
  result += "    for managedObject in self." + mPropertyName + "_property.propval {\n"
  result += "      objects.append (managedObject)\n"
  result += "    }\n"
}
#·······················································································································

override getter @toManyPropertyGeneration objectAccessibilityCodeForSaveOperation -> @string {
  if mCustomStore then
    result  = "  //--- To many property: " + mPropertyName + " (custom store)\n"
    result += "    /* for managedObject in self." + mPropertyName + "_property.propval {\n"
    result += "      objects.append (managedObject)\n"
    result += "    } */\n"
  
  else
    result  = "  //--- To many property: " + mPropertyName + "\n"
    result += "    for managedObject in self." + mPropertyName + "_property.propval {\n"
    result += "      objects.append (managedObject)\n"
    result += "    }\n"
  end
}

#·······················································································································

override getter @toManyPropertyGeneration clearObjectExplorerCode -> @string {
  if [mOption isHasDependance] then
    result = ""
  else
    result  = "  //--- To many property: " + mPropertyName + "\n"
    result += "    self." + mPropertyName + "_property.mValueExplorer = nil\n"
  end
}

#·······················································································································

override getter @toManyPropertyGeneration resetToManyRelationships -> @string {
  if [mOption isHasDependance] then
    result = ""
  else
    result  = "  //--- To many property: " + mPropertyName + "\n"
    result += "    self." + mPropertyName + "_property.setProp ([])\n"
  end
}
#·······················································································································

override getter @toManyPropertyGeneration terminationCode -> @string {
  switch mOption 
  case hasDependance (masterPropertyName) :
    result  = "  //--- To many property: " + mPropertyName + "\n"
    result += "    self." + masterPropertyName.string + "_property.removeEBObserver (self." + mPropertyName + "_property)\n"
  case none :
    result = ""
  case hasOpposite (*) :
    result = ""
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
