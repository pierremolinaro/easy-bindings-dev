#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   AST                                                                                                                *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @arrayControllerBoundColumnListAST {
  @lstring mColumnName
  @lstring mColumnOutletTypeName
  @lstring mObservablePropertyName
  @bindingOptionList mBindingOptionList
}

#......................................................................................................................*

enum @arrayControllerModel {
  case rootToManyRelationship (@lstring rootRelationshipName)
  case selfCollection (@lstring collectionPropertyName)
  case controllerArray (@lstring controllerName @lstring propertyName)
}

#......................................................................................................................*

class @arrayControllerDeclaration : @abstractSecondaryProperty {
  @lstring mControllerName
  @arrayControllerModel mArrayControllerModel
  @lstringlist mFilterProperties
  @arrayControllerBoundColumnListAST mArrayControllerBoundColumnListAST
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SYNTAX                                                                                                             *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  #....................................................................................................................*
  
  rule <array_controller_declaration>
    ?!@secondaryPropertyList ioSecondaryPropertyList
  {
    $arrayController$
    $identifier$ ?let @lstring controllerName
    $:$
    @arrayControllerModel arrayControllerModel
    select
      $root$
      $.$
      $identifier$ ?let @lstring relationshipName
      arrayControllerModel = .rootToManyRelationship {!rootRelationshipName:relationshipName}
    or
      $self$
      $.$
      $identifier$ ?let @lstring storedPropertyName
      arrayControllerModel = .selfCollection {!collectionPropertyName:storedPropertyName}
    or
      $identifier$ ?let @lstring controllerName
      $.$
      $identifier$ ?let @lstring propertyName
      arrayControllerModel = .controllerArray {!controllerName:controllerName !propertyName:propertyName}
    end
    @arrayControllerBoundColumnListAST arrayControllerBoundColumnListAST = {}
    @lstringlist filterProperties = {}
    select
    or
      $filter$
      repeat
        $identifier$ ?let @lstring filterProperty
        filterProperties += !filterProperty
      while
        $,$
      end
    end
    repeat
      $column$
      $literal_string$ ?let columnName
      $Identifier$ ?let columnOutletTypeName
      $identifier$ ?let observablePropertyName
      <binding_option_list> ?let bindingOptions
      arrayControllerBoundColumnListAST +=
        !columnName
        !columnOutletTypeName
        !observablePropertyName
        !bindingOptions
    while
    end
    $;$
    ioSecondaryPropertyList += !@arrayControllerDeclaration.new {
      !controllerName
      !arrayControllerModel
      !filterProperties
      !arrayControllerBoundColumnListAST
    }
  }

  #....................................................................................................................*

}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

override method @arrayControllerDeclaration typeInventory
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
{
}

#......................................................................................................................*

override method @arrayControllerDeclaration tryToSolveSecondaryProperty
  ?!@semanticContext unused ioSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?!@observablePropertyMap ioObservableProperties
  ?!@secondaryPropertyList ioUnsolvedProperties
{
  @bool solved
  switch mArrayControllerModel
  case selfCollection (@lstring storedPropertyName) :
    solved = [ioObservableProperties hasKey !storedPropertyName.string]
    if solved then
      [ioObservableProperties searchKey
        !storedPropertyName
        ?let type
        ?let kind
        ?let multiplicity
        ?2*
      ]
      @actionMap controllerActions = {}
      if kind == .stored then
        [!?controllerActions insertKey !["add" nowhere]]
        [!?controllerActions insertKey !["remove" nowhere]]
      end
      [!?ioObservableProperties insertKey
        !mControllerName
        !type
        !.arrayController
        !multiplicity
        !""
        !controllerActions
      ]
    end
  case rootToManyRelationship (@lstring relationshipName) :
    solved = [inRootObservableProperties hasKey !relationshipName.string]
    if solved then
      [inRootObservableProperties searchKey
        !relationshipName
        ?let type
        ?let kind
        ?let multiplicity
        ?2*
      ]
      @actionMap controllerActions = {}
      if kind == .stored then
        [!?controllerActions insertKey !["add" nowhere]]
        [!?controllerActions insertKey !["remove" nowhere]]
      end
      [!?ioObservableProperties insertKey
        !mControllerName
        !type
        !.arrayController
        !multiplicity
        !""
        !controllerActions
      ]
    end
  case controllerArray (@lstring controllerName @lstring unused propertyName) :
    solved = [ioObservableProperties hasKey !controllerName.string]
    if solved then
      [ioObservableProperties searchKey
        !controllerName
        ?let type
        ?let kind
        ?let multiplicity
        ?2*
      ]
      @actionMap controllerActions = {}
      if kind == .stored then
        [!?controllerActions insertKey !["add" nowhere]]
        [!?controllerActions insertKey !["remove" nowhere]]
      end
      [!?ioObservableProperties insertKey
        !mControllerName
        !type
        !.arrayController
        !multiplicity
        !""
        !controllerActions
      ]
    end
  end
  if not solved then
    ioUnsolvedProperties += !self
  end
}

#......................................................................................................................*

override method @arrayControllerDeclaration secondaryPropertySemanticAnalysis
  ?let @string inOwnerName
  ?let @string inRootEntityName
  ?let @observablePropertyMap inRootObservableProperties
  ?let @semanticContext inSemanticContext
  ?let @observablePropertyMap inObservableProperties
  ?!@transientDefinitionListForGeneration unused ioTransientDefinitionListForGeneration
  ?!@arrayControllerForGeneration ioArrayControllerForGeneration
  ?!@selectionControllerForGeneration unused ioSelectionControllerForGeneration
  ?!@stringset ioNeededOutletClasses
{
  @typeKind modelType
  @propertyKind kind
  @location errorLocation
  @arrayControllerModelKind modelKind
  @string entityName
  switch mArrayControllerModel
  case selfCollection (@lstring storedPropertyName) :
    errorLocation = storedPropertyName.location
    modelKind = .storedArrayModel
    [inObservableProperties searchKey
      !storedPropertyName
      ?modelType
      ?kind
      ?let @propertyMultiplicity multiplicity
      ?2*
    ]
  #--- Check bound model is a collection
    if multiplicity != .collection then
      error errorLocation : "the bound property should be a collection"
    end
  #--- Check bound model type is an entity
    switch modelType
    case boolType, colorType, dateType, doubleType, integerType, stringType, fontType, imageType :
      error errorLocation : "the model should be a tomany relationship" : entityName
    case enumType (* *) :
      error errorLocation : "the model should be a tomany relationship" : entityName
    case classType (@string kClassTypeName) :
      entityName = kClassTypeName
     case entityType (*) :
      error errorLocation : "the model should be a stored class array" : entityName
    end
  case rootToManyRelationship (@lstring relationshipName) :
    errorLocation = relationshipName.location
    modelKind = .relationshipModel
    [inRootObservableProperties searchKey
      !relationshipName
      ?modelType
      ?kind
      ?let @propertyMultiplicity multiplicity
      ?2*
    ]
  #--- Check bound model is a collection
    if multiplicity != .collection then
      error errorLocation : "the bound property should be a collection"
    end
  #--- Check bound model type is an entity
    switch modelType
    case boolType, colorType, dateType, doubleType, integerType, stringType, fontType, imageType :
      error errorLocation : "the model should be a tomany relationship" : entityName
    case enumType (* *) :
      error errorLocation : "the model should be a tomany relationship" : entityName
    case classType (*) :
      error errorLocation : "the model should be a tomany relationship" : entityName
     case entityType (@string kEntityName) :
      entityName = kEntityName
    end
  case controllerArray (@lstring controllerName @lstring propertyName) :
    errorLocation = propertyName.location
    modelKind = .transientModel
    [inObservableProperties searchKey
      !controllerName
      ?modelType
      ?kind
      ?3*
    ]
    if (propertyName.string != "sortedArray") && (propertyName.string != "selectedArray") then
      error errorLocation : "'sortedArray' or 'selectedArray' are required here"
    end
  #--- Check bound model type is an entity
    switch modelType
    case boolType, colorType, dateType, doubleType, integerType, stringType, fontType, imageType :
      error errorLocation : "the model should be a tomany relationship" : entityName
    case enumType (* *) :
      error errorLocation : "the model should be a tomany relationship" : entityName
    case classType (*) :
      error errorLocation : "the model should be a tomany relationship" : entityName
     case entityType (@string kEntityName) :
      entityName = kEntityName
    end
  end
#--- Check colum bound models (TODO : get also super entity observable property)
  [inSemanticContext.mEntityObservablePropertyMap searchKey
    ![entityName nowhere]
    ?let @observablePropertyMap boundModelObservablePropertyMap
  ]
  @arrayControllerBoundColumnListForGeneration arrayControllerBoundColumnListForGeneration = {}
  for () in mArrayControllerBoundColumnListAST do
    [boundModelObservablePropertyMap searchKey
      !mObservablePropertyName
      ?let @typeKind columnType
      ?let @propertyKind unused columnKind
      ?let @propertyMultiplicity columnMultiplicity
      ?let @string unused inverseRelationshipName # "" if not a relationship
      ?*
    ]
  #--- Check bound model type is a simple type
    switch columnType
    case boolType, colorType, dateType, doubleType, integerType, stringType, fontType, imageType : # Ok
    case enumType (* *) : # Ok
    case classType (*) :
      error [mObservablePropertyName location] : "the model should not be a relationship"
    case entityType (@string unused entityTypeName) :
      error [mObservablePropertyName location] : "the model should not be a relationship"
    end
    if columnMultiplicity == .collection then
      error mObservablePropertyName : "the bound column property should not be a collection"
    end
    arrayControllerBoundColumnListForGeneration +=
      !mColumnName.string
      !mColumnOutletTypeName.string
      !mObservablePropertyName.string
      !columnType
      !mBindingOptionList
    ioNeededOutletClasses += !mColumnOutletTypeName.string
  end
#--- Check filter properties
  @arrayControllerFilterListForGeneration arrayControllerFilterListForGeneration = {}
  for (filterPropertyName) in mFilterProperties do
    [boundModelObservablePropertyMap searchKey
      !filterPropertyName
      ?let @typeKind filterType
      ?let @propertyKind unused columnKind
      ?let @propertyMultiplicity filterMultiplicity
      ?let @string unused inverseRelationshipName # "" if not a relationship
      ?*
    ]
    if filterMultiplicity == .collection then
      error filterPropertyName : "the filter property should not be a collection"
    end
    arrayControllerFilterListForGeneration += !filterPropertyName.string !filterType
  end%for
#---
  ioArrayControllerForGeneration +=
    !inOwnerName
    !mControllerName.string
    !arrayControllerFilterListForGeneration
    ![mArrayControllerModel modelString]
    !arrayControllerBoundColumnListForGeneration
    ![mArrayControllerModel modelTypeName !inRootEntityName !inObservableProperties]
    ![mArrayControllerModel modelTypeName2 !inRootEntityName !inObservableProperties]
    !modelKind
    ![modelType swiftTypeName]
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION TYPES                                                                                                   *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

enum @arrayControllerModelKind {
  case relationshipModel
  case storedArrayModel
  case transientModel
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @arrayControllerForGeneration {
  @string mOwnerName # document name, prefs name, ...
  @string mControllerName
  @arrayControllerFilterListForGeneration mArrayControllerFilterListForGeneration
  @string mModelString
  @arrayControllerBoundColumnListForGeneration mArrayControllerBoundColumnListForGeneration
  @string mModelTypeName
  @string mModelTypeName2
  @arrayControllerModelKind mModelKind
  @string mElementTypeName
}

#......................................................................................................................*

getter @arrayControllerModel modelString -> @string outResult {
  switch self
  case selfCollection (@lstring storedPropertyName) :
    outResult = "self." + storedPropertyName
  case rootToManyRelationship (@lstring rootRelationshipName) :
    outResult = "rootObject." + rootRelationshipName
  case controllerArray (@lstring controllerName @lstring propertyName) :
    outResult = controllerName.string + "." + propertyName
  end
}

#......................................................................................................................*

getter @arrayControllerModel modelTypeName
  ?let @string inRootEntityName
  ?let @observablePropertyMap inObservablePropertyMap
   -> @string outResult
{
  switch self
  case selfCollection (@lstring storedPropertyName) :
    outResult = "Ligne328_" + inRootEntityName + "_" + storedPropertyName
  case rootToManyRelationship (@lstring rootRelationshipName) :
    outResult = "ToManyRelationship_" + inRootEntityName + "_" + rootRelationshipName
  case controllerArray (@lstring controllerName *) :
    [inObservablePropertyMap searchKey
      !controllerName
      ?let modelType
      ?4*
    ]
    outResult = "TransientArrayOf_" + [modelType swiftTypeName] # ReadOnlyArrayOf_%!ELEMENT_TYPE_NAME%?
  end
}

#......................................................................................................................*

getter @arrayControllerModel modelTypeName2
  ?let @string inRootEntityName
  ?let @observablePropertyMap inObservablePropertyMap
   -> @string outResult
{
  switch self
  case selfCollection (@lstring storedProprtyName) :
    [inObservablePropertyMap searchKey
      !storedProprtyName
      ?let modelType
      ?4*
    ]
    outResult = "EBClassArray_" + [modelType swiftTypeName]
  case rootToManyRelationship (@lstring rootRelationshipName) :
    outResult = "ToManyRelationship_" + inRootEntityName + "_" + rootRelationshipName
  case controllerArray (@lstring controllerName *) :
    [inObservablePropertyMap searchKey
      !controllerName
      ?let modelType
      ?4*
    ]
    outResult = "ReadOnlyArrayOf_" + [modelType swiftTypeName] # ReadOnlyArrayOf_%!ELEMENT_TYPE_NAME%?
  end
}

#......................................................................................................................*

list @arrayControllerFilterListForGeneration {
  @string mFilterPropertyName
  @typeKind mFilterPropertyType
}

#......................................................................................................................*

list @arrayControllerBoundColumnListForGeneration {
  @string mColumnName
  @string mColumnOutletTypeName
  @string mObservablePropertyName
  @typeKind mPropertyType
  @bindingOptionList mBindingOptionList
}

#......................................................................................................................*

getter @typeKind transformerForTableViewAction ?let @string inSenderOutletName -> @string outResult {
  switch self
  case stringType : outResult = inSenderOutletName + ".stringValue"
  case integerType : outResult = inSenderOutletName + ".integerValue"
#--- TODO
  case imageType : outResult = "<<TODO @typeKind transformerForTableViewAction " + inSenderOutletName + " >>"
  case boolType : outResult = "NSNumber (bool:" + inSenderOutletName + ")"
  case doubleType : outResult = "NSNumber (double:" + inSenderOutletName + ")"
  case colorType, fontType : outResult = inSenderOutletName + ".stringValue"
  case dateType : outResult = "NSDate"
  case enumType (* *) :
    outResult = "<unhandled enum for transformerForTableViewAction>"
  case classType (*) :
    outResult = "<unhandled class for transformerForTableViewAction>"
  case entityType (*) :
    outResult = "<unhandled entity for transformerForTableViewAction>"
  end
}

#......................................................................................................................*

getter @typeKind formatterStringForFormatPrinting -> @string outResult {
  switch self
  case stringType : outResult = "%@"
  case integerType : outResult = "%d"
  case boolType : outResult = "%d"
  case doubleType : outResult = "%g"
  case colorType : outResult = "%@"
  case dateType, fontType, imageType : outResult = "%@"
  case enumType (* *) :
    outResult = "<internal error enum, formatterStringForFormatPrinting' >"
  case classType (*) :
    outResult = "<internal error 'class', formatterStringForFormatPrinting' >"
  case entityType (*) :
    outResult = "<internal error entity, formatterStringForFormatPrinting' >"
  end
}

#......................................................................................................................*

getter @arrayControllerFilterListForGeneration filterCode ?let @string inFilterFunction -> @string outResult {
  var filterProperties = self
  [!?filterProperties popFirst ?let firstFilterProperty ?*]
  @string indent = "          "
  outResult  = indent + "switch object." +firstFilterProperty + ".prop {\n"
  outResult += indent + "case .noSelection :\n"
  outResult += indent + "  return .noSelection\n"
  outResult += indent + "case .multipleSelection :\n"
  outResult += indent + "  isMultiple = true\n"
  outResult += indent + "case .singleSelection (let v1) :\n"
  @uint idx = 2
  @string args = ""
  @string blockEnd = indent + "}\n"
  for () in filterProperties do
    indent += "  "
    outResult += indent + "switch object." + mFilterPropertyName + ".prop {\n"
    outResult += indent + "case .noSelection :\n"
    outResult += indent + "  return .noSelection\n"
    outResult += indent + "case .multipleSelection :\n"
    outResult += indent + "  isMultiple = true\n"
    outResult += indent + "case .singleSelection (let v" + idx + ") :\n"
    blockEnd = indent + "}\n" + blockEnd
    args += ", v" + idx
    idx ++
  end
  indent += "  "
  outResult += indent + "if " + inFilterFunction + " (v1" + args + ") {\n"
  outResult += indent + "  array.addObject (object)\n"
  outResult += indent + "}\n"
  outResult += blockEnd
}

#......................................................................................................................*

private filewrapper collectionControllerGenerationTemplate in "../generation-templates/collection-controller-templates" {
}{
}{
  template arrayControllerImplementationInSwift "array-controller.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string ARRAY_CONTROLLER_NAME
    ?@arrayControllerFilterListForGeneration FILTER_PROPERTIES
    ?@string MODEL_STRING
    ?@arrayControllerModelKind MODEL_KIND
    ?@string MODEL_TYPE_NAME
    ?@string MODEL_TYPE_NAME_2
    ?@arrayControllerBoundColumnListForGeneration BOUND_COLUMNS
    ?@string ELEMENT_TYPE_NAME

  template filterFunction "array-controller-filter-function.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string ARRAY_CONTROLLER_NAME
    ?@arrayControllerFilterListForGeneration FILTER_PROPERTIES
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION                                                                                                         *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

proc generateArrayControllers
  ?let @arrayControllerForGeneration inArrayControllerListForGeneration
  ?let @string inOutputDirectory
  ?!@stringset ioGeneratedFileSet
{
  for () in inArrayControllerListForGeneration do
    let s = [filewrapper collectionControllerGenerationTemplate.arrayControllerImplementationInSwift
      !mOwnerName
      !mControllerName
      !mArrayControllerFilterListForGeneration
      !mModelString
      !mModelKind
      !mModelTypeName
      !mModelTypeName2
      !mArrayControllerBoundColumnListForGeneration
      !mElementTypeName
    ]
    [@string generateFile
      !inOutputDirectory
      !"arrayController-" + mOwnerName + "-" +  mControllerName + ".swift"
      !s
    ]
    if [mArrayControllerFilterListForGeneration length] > 0 then
    let s = [filewrapper collectionControllerGenerationTemplate.filterFunction
      !mOwnerName
      !mControllerName
      !mArrayControllerFilterListForGeneration
    ]
    let fileName = "arrayControllerFilter-" + mOwnerName + "-" +  mControllerName + ".swift"
    ioGeneratedFileSet += !fileName
    [@string generateFileWithPattern
      !startPath:inOutputDirectory
      !fileName:fileName
      !lineComment:"//"
      !header:""
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:s
      !defaultUserZone2:"  return WHAT ?\n" # Defaut user zone2
      !generatedZone3:"}\n\n//" + ["" stringByRightPadding !117 !'—'] + "\n"
      !makeExecutable:false
    ]
    end
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
