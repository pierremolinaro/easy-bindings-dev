#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   AST                                                                                                                *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @arrayControllerBoundColumnListAST {
  @lstring mColumnName
  @lstring mColumnOutletTypeName
  @columnBindingAST mColumnBindingAST
  @lstring mSortPropertyName
}

#·······················································································································

struct @columnBindingAST {
  @lstring mRunActionName # Empty string if no run binding
  @multipleBindingDescriptor mEnabledBindingDescriptor
  @multipleBindingDescriptor mHiddenBindingDescriptor
  @regularBindingList mRegularBindingList
}

#·······················································································································

list @arrayControllerAttributListAST {
  @lstring mAttributeName
  @abstractDefaultValue mAttributeValue
}

#·······················································································································

enum @arrayControllerModel {
  case rootControllerProperty (@lstring rootControllerName @lstring controllerPropertyName)
  case rootToManyRelationship (@lstring rootRelationshipName)
  case selfCollection (@lstring collectionPropertyName)
  case controllerArray (@lstring controllerName @lstring propertyName)
}

#·······················································································································

class @arrayControllerDeclaration : @abstractSecondaryProperty {
  @lstring mControllerName
  @arrayControllerModel mArrayControllerModel
  @lstringlist mFilterProperties
  @arrayControllerBoundColumnListAST mArrayControllerBoundColumnListAST
  @arrayControllerAttributListAST mArrayControllerAttributListAST
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SYNTAX                                                                                                             *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <controller_declaration>
    ?!@secondaryPropertyList ioSecondaryPropertyList
  {
    $arrayController$
    $identifier$ ?let @lstring controllerName
    @arrayControllerAttributListAST arrayControllerAttributListAST = {}
    ${$
    repeat
      $identifier$ ?let @lstring attributeName
      $:$
      <explicit_value> ?let @abstractDefaultValue attributeValue
      arrayControllerAttributListAST += !attributeName !attributeValue
    while
      $,$
    end
    $}$
  #--- Model
    @arrayControllerModel arrayControllerModel
    select
      $root$
      $.$
      $identifier$ ?let @lstring relationshipName
      select
        arrayControllerModel = .rootToManyRelationship {!rootRelationshipName:relationshipName}
      or
        $.$
        $identifier$ ?let @lstring controllerPropertyName
        arrayControllerModel = .rootControllerProperty {
          !rootControllerName: relationshipName
          !controllerPropertyName: controllerPropertyName
        }
      end
    or
      $self$
      $.$
      $identifier$ ?let @lstring storedPropertyName
      arrayControllerModel = .selfCollection {!collectionPropertyName:storedPropertyName}
    or
      $identifier$ ?let @lstring controllerName
      $.$
      $identifier$ ?let @lstring propertyName
      arrayControllerModel = .controllerArray {!controllerName:controllerName !propertyName:propertyName}
    end
    @lstringlist filterProperties = {}
    select
    or
      $filter$
      repeat
        $identifier$ ?let @lstring filterProperty
        filterProperties += !filterProperty
      while
        $,$
      end
    end
    @arrayControllerBoundColumnListAST arrayControllerBoundColumnListAST = {}
    select
      $;$
    or
      ${$
      repeat
      while
        $column$
        $literal_string$ ?let columnName
        @lstring sortPropertyName
        select
          sortPropertyName = ["" nowhere]
        or
          $sort$
          $identifier$ ?sortPropertyName
        end
        $Identifier$ ?let columnOutletTypeName
        <column_bindings> ?let @columnBindingAST columnBindingAST
        arrayControllerBoundColumnListAST +=
          !columnName
          !columnOutletTypeName
          !columnBindingAST
          !sortPropertyName
      end
      $}$
    end
    ioSecondaryPropertyList += !@arrayControllerDeclaration.new {
      !controllerName
      !arrayControllerModel
      !filterProperties
      !arrayControllerBoundColumnListAST
      !arrayControllerAttributListAST
    }
  }

#·······················································································································

  rule <column_bindings> !@columnBindingAST outColumnBindingAST {
    @lstring runActionDescriptor = ["" nowhere]
    var enabledBindingDescriptor = @multipleBindingDescriptor.noBinding
    var hiddenBindingDescriptor = @multipleBindingDescriptor.noBinding
    @regularBindingList regularBindingList = {}
    repeat
    while
      $run$
      if runActionDescriptor.string != "" then
        error .here : "duplicated $run binding"
      end
      $self$
      $.$
      $identifier$ ?runActionDescriptor
  #--- Enabled
    while
      $enabled$
      if enabledBindingDescriptor != .noBinding then
        error .here : "duplicated $enabled binding"
      end
      <booleanMultipleBindingExpression> ?let @abstractBooleanMultipleBindingExpressionAST bindingExpression
      enabledBindingDescriptor = .binding {!expression:bindingExpression}
  #--- Hidden
    while
      $hidden$
      if hiddenBindingDescriptor != .noBinding then
        error .here : "duplicated $hidden binding"
      end
      <booleanMultipleBindingExpression> ?let @abstractBooleanMultipleBindingExpressionAST bindingExpression
      hiddenBindingDescriptor = .binding {!expression:bindingExpression}
  #--- Regular binding
    while
      $bindingName$ ?let @lstring bindingName
      @observablePropertyList observablePropertyList = {}
      repeat
        <observable_property> ?let @observablePropertyAST observableProperty
        observablePropertyList += !observableProperty
      while
        $,$
      end
      <binding_option_list> ?let bindingOptions
      regularBindingList +=
        !bindingName
        !observablePropertyList
        !bindingOptions
    end
  #---
    outColumnBindingAST = @columnBindingAST.new {
      !runActionDescriptor
      !enabledBindingDescriptor
      !hiddenBindingDescriptor
      !regularBindingList
    }
  }
  
  #·····················································································································

}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

override method @arrayControllerDeclaration typeInventory
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
{
}

#·······················································································································

override method @arrayControllerDeclaration tryToSolveSecondaryProperty
  ?!@semanticContext unused ioSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?!@observablePropertyMap ioObservableProperties
  ?!@secondaryPropertyList ioUnsolvedProperties
{
  @bool solved
  switch mArrayControllerModel
  case rootControllerProperty (@lstring rootControllerName @lstring controllerPropertyName) :
    solved = [ioObservableProperties hasKey !rootControllerName.string]
    if solved then
      [ioObservableProperties searchKey
        !rootControllerName
        ?let type
        ?let kind
        ?let multiplicity
        ?3*
      ]
      error rootControllerName : "NOT HANDLED YET"
    end
  case selfCollection (@lstring storedPropertyName) :
    solved = [ioObservableProperties hasKey !storedPropertyName.string]
    if solved then
      [ioObservableProperties searchKey
        !storedPropertyName
        ?let type
        ?let kind
        ?let multiplicity
        ?2*
        ?let cascading
      ]
      @actionMap controllerActions = {}
      if kind == .stored then
        [!?controllerActions insertKey !["add" nowhere]]
        [!?controllerActions insertKey !["remove" nowhere]]
      end
      [!?ioObservableProperties insertKey
        !mControllerName
        !type
        !.arrayController
        !multiplicity
        !""
        !controllerActions
        !cascading
      ]
    end
  case rootToManyRelationship (@lstring relationshipName) :
    solved = [inRootObservableProperties hasKey !relationshipName.string]
    if solved then
      [inRootObservableProperties searchKey
        !relationshipName
        ?let type
        ?let kind
        ?let multiplicity
        ?2*
        ?let cascading
      ]
      @actionMap controllerActions = {}
      if kind == .stored then
        [!?controllerActions insertKey !["add" nowhere]]
        [!?controllerActions insertKey !["remove" nowhere]]
      end
      [!?ioObservableProperties insertKey
        !mControllerName
        !type
        !.arrayController
        !multiplicity
        !""
        !controllerActions
        !cascading
      ]
    end
  case controllerArray (@lstring controllerName @lstring unused propertyName) :
    solved = [ioObservableProperties hasKey !controllerName.string]
    if solved then
      [ioObservableProperties searchKey
        !controllerName
        ?let type
        ?let kind
        ?let multiplicity
        ?2*
        ?let cascading
      ]
      @actionMap controllerActions = {}
      if kind == .stored then
        [!?controllerActions insertKey !["add" nowhere]]
        [!?controllerActions insertKey !["remove" nowhere]]
      end
      [!?ioObservableProperties insertKey
        !mControllerName
        !type
        !.arrayController
        !multiplicity
        !""
        !controllerActions
        !cascading
      ]
    end
  end
  if not solved then
    ioUnsolvedProperties += !self
  end
}

#·······················································································································

override method @arrayControllerDeclaration secondaryPropertySemanticAnalysis
  ?let @string inOwnerName
  ?let @string unused inRootEntityName
  ?let @observablePropertyMap inRootObservableProperties
  ?let @semanticContext inSemanticContext
  ?let @observablePropertyMap inObservableProperties
  ?!@transientDefinitionListForGeneration unused ioTransientDefinitionListForGeneration
  ?!@arrayControllerForGeneration ioArrayControllerForGeneration
  ?!@selectionControllerForGeneration unused ioSelectionControllerForGeneration
  ?!@objectControllerForGeneration unused ioObjectControllerDeclaration
  ?!@stringset ioNeededOutletClasses
{
#------------------------------------------------------------ Check array controller attributes
  let attributes = @stringset {!"allowsEmptySelection", !"allowsMultipleSelection"}
  let allowedTypes = @typeKindList {!.boolType}
  @stringset definedAttributes = {}
  @2stringlist attributeListForGeneration = {}
  for (name value) in mArrayControllerAttributListAST do
    if not [attributes hasKey !name.string] then
      error name : "unknown attribute"
    elsif [definedAttributes hasKey !name.string] then
      error name : "attribute multiply defined"
    else
      definedAttributes += !name.string
    end
    [value analyzeDefaultValueType !allowedTypes ?let valueAsString]
    attributeListForGeneration += !name.string !valueAsString
  end
  for s in attributes do
    if not [definedAttributes hasKey !s] then
      error mControllerName : "attribute '" + s + "' not defined"
    end
  end
#------
  @typeKind modelType
  @propertyKind kind
  @string elementSwiftTypeName
  @location errorLocation
  @arrayControllerModelKind modelKind
  @string entityName
  @bool entityTypeIsGraphic
  @actionMap actionMap
  switch mArrayControllerModel
  case rootControllerProperty (@lstring rootControllerName @lstring controllerPropertyName) :
    error rootControllerName
    : "NOT HANDLED YET"
    : elementSwiftTypeName, modelKind, actionMap, entityName, errorLocation, entityTypeIsGraphic, kind, modelType
  case selfCollection (@lstring storedPropertyName) :
    errorLocation = storedPropertyName.location
    [inObservableProperties searchKey
      !storedPropertyName
      ?modelType
      ?kind
      ?let multiplicity
      ?*
      ?actionMap
      ?*
    ]
    elementSwiftTypeName = [modelType swiftTypeName]
    modelKind = if [kind isStored] then .storedArrayModel else .transientModel end
  #------------------------------------------------------------ Check bound model is a collection
    if multiplicity != .collection then
      error errorLocation : "the bound property should be a collection"
    end
  #------------------------------------------------------------ Check bound model type is an entity
    switch modelType
    case boolType, dateType, doubleType, integerType, stringType, fontType :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case enumType (* *) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case propertyClassType (**) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case transientPropertyExternType (*) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case classType (@string kClassTypeName) :
      entityName = kClassTypeName
      entityTypeIsGraphic = false
    case entityType (kClassTypeName kIsGraphic) :
      entityName = kClassTypeName
      entityTypeIsGraphic = kIsGraphic
      modelKind = .selfRelationshipModel
    end
  case rootToManyRelationship (@lstring relationshipName) :
    errorLocation = relationshipName.location
    modelKind = .rootRelationshipModel
    [inRootObservableProperties searchKey
      !relationshipName
      ?modelType
      ?kind
      ?let multiplicity
      ?*
      ?actionMap
      ?*
    ]
    elementSwiftTypeName = [modelType swiftTypeName]
  #------------------------------------------------------------ Check bound model is a collection
    if multiplicity != .collection then
      error errorLocation : "the bound property should be a collection"
    end
  #------------------------------------------------------------ Check bound model type is an entity
    switch modelType
    case boolType, dateType, doubleType, integerType, stringType, fontType :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case enumType (* *) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case classType (*) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case propertyClassType (**) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case transientPropertyExternType (*) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case entityType (@string kEntityName @bool isGraphic) :
      entityName = kEntityName
      entityTypeIsGraphic = isGraphic
    end
  case controllerArray (@lstring controllerName @lstring propertyName) :
    errorLocation = propertyName.location
    modelKind = .transientModel
    [inObservableProperties searchKey
      !controllerName
      ?modelType
      ?kind
      ?2*
      ?actionMap
      ?*
    ]
    elementSwiftTypeName = [modelType swiftTypeName]
    if (propertyName.string != "sortedArray") && (propertyName.string != "selectedArray") then
      error errorLocation : "'sortedArray' or 'selectedArray' are required here"
    end
  #------------------------------------------------------------ Check bound model type is an entity
    switch modelType
    case boolType, dateType, doubleType, integerType, stringType, fontType :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case enumType (* *) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case classType (*) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case propertyClassType (**) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case transientPropertyExternType (*) :
      error errorLocation : "the model should be a tomany relationship" : entityName, entityTypeIsGraphic
    case entityType (@string kEntityName @bool isGraphic) :
      entityName = kEntityName
      entityTypeIsGraphic = isGraphic
    end
  end
#------------------------------------------------------------ Check colum bound models
# (TODO : get also super entity observable property)
  [inSemanticContext.mEntityObservablePropertyMap searchKey
    ![entityName nowhere]
    ?let @observablePropertyMap boundModelObservablePropertyMap
  ]
  @arrayControllerBoundColumnListForGeneration arrayControllerBoundColumnListForGeneration = {}
  @arrayControllerSortedColumnListForGeneration arrayControllerSortedColumnListForGeneration = {}
  for () in mArrayControllerBoundColumnListAST do
  #-------- Run action ? Check action is declared
    if mColumnBindingAST.mRunActionName.string != "" then
      [actionMap searchKey !mColumnBindingAST.mRunActionName]
    end
  #-------- Simple bindings
    @regularBindingsGenerationList regularBindingsGenerationList = {}
    analyzeRegularBinding (
      !{} # No root observable property map
      !inSemanticContext
      !boundModelObservablePropertyMap
      !mColumnOutletTypeName
      !"<<not used>>"
      !mColumnBindingAST.mRegularBindingList
      !"object"
      !?regularBindingsGenerationList
    )
  #-------- Sort property
    if mSortPropertyName.string != "" then
      [boundModelObservablePropertyMap searchKey
        !mSortPropertyName
        ?let sortPropertyType
        ?5*
      ]
      if not [sortPropertyType isComparable] then
        error mSortPropertyName : "this property is not comparable"
      end 
      arrayControllerSortedColumnListForGeneration +=    
        !mColumnName.string
        !sortPropertyType
        !mSortPropertyName.string
    end
  #-------- Binding generation
    arrayControllerBoundColumnListForGeneration +=
      !mColumnName.string
      !mColumnOutletTypeName.string
      !mColumnBindingAST.mRunActionName.string
      !regularBindingsGenerationList
    ioNeededOutletClasses += !mColumnOutletTypeName.string
  end
#------------------------------------------------------------ Check filter properties
  @arrayControllerFilterListForGeneration arrayControllerFilterListForGeneration = {}
  for (filterPropertyName) in mFilterProperties do
    [boundModelObservablePropertyMap searchKey
      !filterPropertyName
      ?let @typeKind filterType
      ?let @propertyKind unused columnKind
      ?let @propertyMultiplicity filterMultiplicity
      ?let @string unused inverseRelationshipName # "" if not a relationship
      ?2*
    ]
    if filterMultiplicity == .collection then
      error filterPropertyName : "the filter property should not be a collection"
    end
    arrayControllerFilterListForGeneration += !filterPropertyName.string !filterType
  end
#---
  ioArrayControllerForGeneration +=
    !inOwnerName
    !mControllerName
    !arrayControllerFilterListForGeneration
    ![mArrayControllerModel modelString]
    !arrayControllerBoundColumnListForGeneration
    !arrayControllerSortedColumnListForGeneration
    ![mArrayControllerModel modelTypeName !elementSwiftTypeName !inObservableProperties]
    !modelKind
    ![modelType swiftTypeName]
    !entityTypeIsGraphic
    !attributeListForGeneration
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION TYPES                                                                                                   *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

enum @arrayControllerModelKind {
  case selfRelationshipModel
  case rootRelationshipModel
  case storedArrayModel
  case transientModel
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @arrayControllerForGeneration {
  @string mOwnerName # document name, prefs name, ...
  @lstring mControllerName
  @arrayControllerFilterListForGeneration mArrayControllerFilterListForGeneration
  @string mModelString
  @arrayControllerBoundColumnListForGeneration mArrayControllerBoundColumnListForGeneration
  @arrayControllerSortedColumnListForGeneration mArrayControllerSortedColumnListForGeneration
  @string mModelTypeName
  @arrayControllerModelKind mModelKind
  @string mElementTypeName
  @bool mElementTypeIsGraphic
  @2stringlist mAttributeListForGeneration
}

#·······················································································································

getter @arrayControllerModel modelString -> @string outResult {
  switch self
  case rootControllerProperty (@lstring rootControllerName @lstring controllerPropertyName) :
    error rootControllerName : "NOT HANDLED YET" : outResult
  case selfCollection (@lstring storedPropertyName) :
    outResult = "self." + storedPropertyName + "_property"
  case rootToManyRelationship (@lstring rootRelationshipName) :
    outResult = "self.rootObject." + rootRelationshipName + "_property"
  case controllerArray (@lstring controllerName @lstring propertyName) :
    outResult = "self." + controllerName.string + "." + propertyName + "_property"
  end
}

#·······················································································································

getter @arrayControllerModel modelTypeName
  ?let @string inElementSwiftTypeName
  ?let @observablePropertyMap inObservablePropertyMap
   -> @string outResult
{
  switch self
  case selfCollection (@lstring storedPropertyName) :
    [inObservablePropertyMap searchKey
      !storedPropertyName
      ?let modelType
      ?let @propertyKind kind
      ?4*
    ]
    switch kind
    case stored :
      if [modelType isEntityType] then
        outResult = "ToManyRelationshipReadWrite_" + inElementSwiftTypeName
      else
        outResult = "EBClassArray_" + inElementSwiftTypeName
      end
    case transient :
      outResult = "ReadOnlyArrayOf_" + inElementSwiftTypeName
    case arrayController :
      outResult = "<< arrayController >>"
    case selectionController :
      outResult = "<< selectionController >>"
    end
  case rootToManyRelationship (*) :
    outResult = "ToManyRelationshipReadWrite_" + inElementSwiftTypeName
  case controllerArray (2*) :
    outResult = "ReadOnlyArrayOf_" + inElementSwiftTypeName
  case rootControllerProperty (@lstring rootControllerName @lstring controllerPropertyName) :
    error rootControllerName : "NOT HANDLED YET" : outResult
  end
}

#·······················································································································

list @arrayControllerFilterListForGeneration {
  @string mFilterPropertyName
  @typeKind mFilterPropertyType
}

#·······················································································································

list @arrayControllerBoundColumnListForGeneration {
  @string mColumnName
  @string mColumnOutletTypeName
  @string mRunAction # Empty string if no action
  @regularBindingsGenerationList mRegularBindingsGenerationList
}

#·······················································································································

list @arrayControllerSortedColumnListForGeneration {
  @string mColumnName
  @typeKind mSortPropertyType
  @string mObservablePropertyForSorting
}

#·······················································································································

getter @arrayControllerFilterListForGeneration filterCode ?let @string inFilterFunction -> @string outResult {
  var filterProperties = self
  [!?filterProperties popFirst ?let firstFilterProperty ?*]
  @string indent = "            "
  outResult  = indent + "switch object." + firstFilterProperty + "_property_selection {\n"
  outResult += indent + "case .empty :\n"
  outResult += indent + "  return .empty\n"
  outResult += indent + "case .multiple :\n"
  outResult += indent + "  isMultiple = true\n"
  outResult += indent + "case .single (let v1) :\n"
  @uint idx = 2
  @string args = ""
  @string blockEnd = indent + "}\n"
  for () in filterProperties do
    indent += "  "
    outResult += indent + "switch object." + mFilterPropertyName + "_property_selection {\n"
    outResult += indent + "case .empty :\n"
    outResult += indent + "  return .empty\n"
    outResult += indent + "case .multiple :\n"
    outResult += indent + "  isMultiple = true\n"
    outResult += indent + "case .single (let v" + idx + ") :\n"
    blockEnd = indent + "}\n" + blockEnd
    args += ", v" + idx
    idx ++
  end
  indent += "  "
  outResult += indent + "if " + inFilterFunction + " (v1" + args + ") {\n"
  outResult += indent + "  filteredArray.append (object)\n"
  outResult += indent + "}\n"
  outResult += blockEnd
}

#·······················································································································

private filewrapper collectionControllerGenerationTemplate in "../generation-templates/controllers" {
}{
}{
  template arrayControllerImplementationInSwift "array-controller.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string ARRAY_CONTROLLER_NAME
    ?@arrayControllerFilterListForGeneration FILTER_PROPERTIES
    ?@string MODEL_STRING
    ?@arrayControllerModelKind MODEL_KIND
    ?@string MODEL_TYPE_NAME
    ?@arrayControllerBoundColumnListForGeneration BOUND_COLUMNS
    ?@arrayControllerSortedColumnListForGeneration SORTED_COLUMNS
    ?@string ELEMENT_TYPE_NAME
    ?@bool ELEMENT_TYPE_IS_GRAPHIC
    ?@stringset OBSERVED_PROPERTIES_FOR_SORTING_AND_FILERING
    ?@2stringlist ATTRIBUTE_VALUES

  template filterFunction "array-controller-filter-function.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string ARRAY_CONTROLLER_NAME
    ?@arrayControllerFilterListForGeneration FILTER_PROPERTIES
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION                                                                                                         *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

proc generateArrayControllers
  ?let @arrayControllerForGeneration inArrayControllerListForGeneration
  ?let @string inOutputDirectory
  ?!@stringset ioGeneratedFileSet
{
  for () in inArrayControllerListForGeneration do
  #--- Build observed property set (for sorting and filtering)
    @stringset observedProperties = {}
    for () in mArrayControllerSortedColumnListForGeneration do
      observedProperties += !mObservablePropertyForSorting
    end
    for () in mArrayControllerFilterListForGeneration do
      observedProperties += !mFilterPropertyName
    end
    let s = [filewrapper collectionControllerGenerationTemplate.arrayControllerImplementationInSwift
      !mOwnerName
      !mControllerName
      !mArrayControllerFilterListForGeneration
      !mModelString
      !mModelKind
      !mModelTypeName
      !mArrayControllerBoundColumnListForGeneration
      !mArrayControllerSortedColumnListForGeneration
      !mElementTypeName
      !mElementTypeIsGraphic
      !observedProperties
      !mAttributeListForGeneration
    ]
    [@string generateFile
      !inOutputDirectory
      !"arrayController-" + mOwnerName + "-" +  mControllerName + ".swift"
      !s
    ]
    if [mArrayControllerFilterListForGeneration length] > 0 then
    let s = [filewrapper collectionControllerGenerationTemplate.filterFunction
      !mOwnerName
      !mControllerName
      !mArrayControllerFilterListForGeneration
    ]
    let fileName = "arrayControllerFilter-" + mOwnerName + "-" +  mControllerName + ".swift"
    ioGeneratedFileSet += !fileName
    [@string generateFileWithPattern
      !startPath:inOutputDirectory
      !fileName:fileName
      !lineComment:"//"
      !header:""
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:s
      !defaultUserZone2:"  return WHAT ?\n" # Defaut user zone2
      !generatedZone3:"}\n\n//" + ["" stringByRightPadding !117 !'—'] + "\n"
      !makeExecutable:false
    ]
    end
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
