#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @storedArrayPropertyListAST {
  @lstring mElementClassName
  @lstring mStoredArrayPropertyName
}

#·······················································································································

class @propertyArrayDeclarationAST : @abstractDeclarationAST {
  @lstring mElementClassName
  @lstring mStoredArrayPropertyName
}

#·······················································································································

override method @propertyArrayDeclarationAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  let node = @lstring.new {!mClassName.string + " " + mStoredArrayPropertyName !mStoredArrayPropertyName.location}
  [!?ioGraph addNode !node !self]
  [!?ioGraph addEdge !node !mClassName]
  [!?ioGraph addEdge !node !mElementClassName]
}

#·······················································································································

override getter @propertyArrayDeclarationAST lkey -> @lstring {
  result = @lstring.new {!mClassName.string + " " + mStoredArrayPropertyName !mStoredArrayPropertyName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <stored_array_declaration>
    ?let @lstring inClassName
    ?!@storedArrayPropertyListAST ioStoredArrayList
    ?!@astDeclarationStruct ioDeclarationAST
  {
    $toMany$
    $Identifier$ ?var @lstring elementClassName
    $identifier$ ?var @lstring storedArrayPropertyName
    $;$
    ioStoredArrayList += !elementClassName !storedArrayPropertyName
    ioDeclarationAST.mUnifiedDeclarationList += !@propertyArrayDeclarationAST.new {
      !inClassName
      !elementClassName
      !storedArrayPropertyName
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @propertyArrayDeclarationAST classAndPropertySemanticAnalysis
       ?!@classMap ioClassMap
       ?!@generationStruct unused ioGeneration
{
  with mClassName in !?ioClassMap 
    error message searchKey
  do
    [ioClassMap searchKey !mElementClassName ?let classKind ?2*]
    switch classKind
    case prefs :
      error mElementClassName : "a simple class is required here"
    case simpleClass :
      let kind = @propertyKind.toMany {
        !typeName: mElementClassName
        !accessibility: .stored
        !graphic: false
        !isEntity: false
      }
      [!?mPropertyMap insertKey !mStoredArrayPropertyName !kind]
    case atomic (*) :
      error mElementClassName : "a simple class is required here"
    case document (*) :
      error mElementClassName : "a simple class is required here"
    case entity (*) :
      error mElementClassName : "a simple class is required here"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TYPE INVENTORY                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @storedArrayPropertyListAST typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  for () in self do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @storedArrayPropertyListAST buildObservablePropertyMap
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMap ioObservableProperties
{
  for () in self do
  #--- Property type
    [inUnifiedTypeMap searchKey !mElementClassName ?let type ?let actionMap]
  #--- Check type
    @typeKindList typeList
    switch type
    case boolType, integerType, stringType, dateType, doubleType, fontType, colorType :
      error mStoredArrayPropertyName: "a simple type cannot be used as array element type" : typeList
    case transientPropertyExternType (*) :
      error mStoredArrayPropertyName: "a property class type cannot be used as array element type" : typeList
    case enumType (* *) :
      error mStoredArrayPropertyName: "ae enumeration cannot be used as array element type" : typeList
    case entityType (2*) :
      error mStoredArrayPropertyName: "an entity cannot be used as array element type" : typeList
    case classType (*) :
      typeList = {!type}
      
    end
  #--- Enter in property map
    [!?ioObservableProperties insertKey
      !mStoredArrayPropertyName
      !.toMany {!typeName: mElementClassName !accessibility: .stored !graphic:false !isEntity: false}
      !""
      !actionMap
      !false
    ]
  end
}

#·······················································································································

method @storedArrayPropertyListAST storedArrayPropertySemanticAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  !@storedArrayPropertyListForGeneration outSimpleStoredPropertyListForGeneration
{
  outSimpleStoredPropertyListForGeneration = {}
  for () in self do
  #--- Property type
    [inUnifiedTypeMap searchKey !mElementClassName ?let type ?*]
  #--- Check type
    @typeKindList typeList
    switch type
    case boolType, integerType, stringType, dateType, doubleType, fontType, colorType :
      error mStoredArrayPropertyName: "a simple type cannot be used as array element type" : typeList
    case enumType (* *) :
      error mStoredArrayPropertyName: "ae enumeration cannot be used as array element type" : typeList
    case entityType (2*) :
      error mStoredArrayPropertyName: "an entity cannot be used as array element type" : typeList
    case classType (*) :
      typeList = {!type}
    case transientPropertyExternType (*) :
      error mStoredArrayPropertyName: "a property class type cannot be used as array element type" : typeList
    end
  #--- Code Generation
    outSimpleStoredPropertyListForGeneration +=
      !mElementClassName.string
      !mStoredArrayPropertyName.string
 end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @storedArrayPropertyListForGeneration {
  @string mElementClassName
  @string mStoredPropertyName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
