#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   AST                                                                                                                *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @arrayControllerBoundColumnListAST {
  @lstring mColumnName
  @lstring mColumnOutletTypeName
  @lstring mObservablePropertyName
  @bindingOptionList mBindingOptionList
}

#......................................................................................................................*

enum @arrayControllerModel {
  case rootToManyRelationship (@lstring rootRelationshipName)
  case controllerArray (@lstring controllerName @lstring propertyName)
}

#......................................................................................................................*

list @arrayControllerDeclarationListAST {
  @lstring mControllerName
  @arrayControllerModel mArrayControllerModel
  @lstringlist mTableViewOutletNameList
  @lstringlist mFilterProperties
  @arrayControllerBoundColumnListAST mArrayControllerBoundColumnListAST
}

#......................................................................................................................*

class @arrayControllerDeclaration: @abstractSecondaryProperty {
  @lstring mControllerName
  @arrayControllerModel mArrayControllerModel
  @lstringlist mTableViewOutletNameList
  @lstringlist mFilterProperties
  @arrayControllerBoundColumnListAST mArrayControllerBoundColumnListAST
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SYNTAX                                                                                                             *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  #....................................................................................................................*
  
  rule <array_controller_declaration>
    ?!@arrayControllerDeclarationListAST ioArrayControllerDeclarationListAST
  {
    $arrayController$
    $identifier$ ?let @lstring controllerName
    $bind$
    @arrayControllerModel arrayControllerModel
    select
      $root$
      $.$
      $identifier$ ?let @lstring relationshipName
      arrayControllerModel = .rootToManyRelationship {!rootRelationshipName:relationshipName}
    or
      $identifier$ ?let @lstring controllerName
      $.$
      $identifier$ ?let @lstring propertyName
      arrayControllerModel = .controllerArray {!controllerName:controllerName !propertyName:propertyName}
    end
    @lstringlist tableViewOutletNameList = {}
    select
    or
      $to$
      repeat
        $identifier$ ?let @lstring tableViewOutletName
        tableViewOutletNameList += !tableViewOutletName
      while
        $,$
      end
    end
    @arrayControllerBoundColumnListAST arrayControllerBoundColumnListAST = {}
    @lstringlist filterProperties = {}
    select
    or
      $filter$
      repeat
        $identifier$ ?let @lstring filterProperty
        filterProperties += !filterProperty
      while
        $,$
      end
    end
    repeat
      $column$
      $literal_string$ ?let columnName
      $Identifier$ ?let columnOutletTypeName
      $identifier$ ?let observablePropertyName
      <binding_option_list> ?let bindingOptions
      arrayControllerBoundColumnListAST +=
        !columnName
        !columnOutletTypeName
        !observablePropertyName
        !bindingOptions
    while
    end
    $;$
    ioArrayControllerDeclarationListAST +=
      !controllerName
      !arrayControllerModel
      !tableViewOutletNameList
      !filterProperties
      !arrayControllerBoundColumnListAST
  }

  #....................................................................................................................*

}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC TYPE                                                                                                      *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

map @arrayControllerMap {
  @typeKind mType
  @propertyKind mKind
  insert insertKey error message "the '%K' array controller is already declared"
  search searchKey error message "the '%K' array controller is not declared"
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

override method @arrayControllerDeclaration typeInventory
  ?@string unused inDependencyGraphPrefix # i.e. prefs.preferencesName.
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  ?!@transientDependencyGraph unused ioTransientDependencyGraph
{
}

#......................................................................................................................*

override method @arrayControllerDeclaration buildObservablePropertyMap
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMap ioObservableProperties
{
#  @typeKind type
#  @propertyKind kind
#  @location errorLocation
#  switch mArrayControllerModel
#  case rootToManyRelationship (@lstring relationshipName) :
#    errorLocation = relationshipName.location
#    [inRootObservablePropertyMap searchKey
#      !relationshipName
#      ?type
#      ?kind
#      ?let @propertyMultiplicity multiplicity
#      ?*
#    ]
#    if multiplicity != .collection then
#      error errorLocation : "this property should be a tomany relationship"
#    end
#  case controllerArray (@lstring controllerName @lstring propertyName) :
#    errorLocation = propertyName.location
#    [outArrayControllerMap searchKey
#      !controllerName
#      ?type
#      ?kind
#    ]
#  end
#  switch type
#  case boolType, colorType, dateType, doubleType, integerType, stringType :
#    error errorLocation : "this property should be a tomany relationship"
#  case enumType (* *) :
#    error errorLocation : "this property should be a tomany relationship"
#  case entityType (*) : #Ok
#  end
}

#......................................................................................................................*

override method @arrayControllerDeclaration tryToSolveSecondaryProperty
  ?!@semanticContext ioSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?!@observablePropertyMap ioObservableProperties
  ?!@secondaryPropertyList ioUnsolvedProperties
{
  @bool solved
  switch mArrayControllerModel
  case rootToManyRelationship (@lstring relationshipName) :
    solved = [inRootObservableProperties hasKey !relationshipName.string]
    if solved then
      [inRootObservableProperties searchKey
        !relationshipName
        ?let type
        ?let kind
        ?let multiplicity
        ?*
      ]
      [!?ioObservableProperties insertKey
        !relationshipName
        !type
        !.transient
        !multiplicity
        !""
      ]
    end
  case controllerArray (@lstring controllerName @lstring propertyName) :
    solved = [ioObservableProperties hasKey !controllerName.string]
  end
  if not solved then
    ioUnsolvedProperties += !self
  end
}

#......................................................................................................................*

override method @arrayControllerDeclaration secondaryPropertySemanticAnalysis
  ?let @string inOwnerName
  ?let @observablePropertyMap inRootObservableProperties
  ?let @semanticContext inSemanticContext
  ?let @observablePropertyMap inObservableProperties
  ?let @arrayControllerMap inArrayControllerMap
  ?!@transientDefinitionListForGeneration ioTransientDefinitionListForGeneration
{
}

#......................................................................................................................*

method @arrayControllerDeclarationListAST buildArrayControllerMap
  ?let @observablePropertyMap inRootObservablePropertyMap
  ?let @observablePropertyMap unused inSelfObservablePropertyMap
  !@arrayControllerMap outArrayControllerMap
{
  outArrayControllerMap = {}
  for () in self do
    @typeKind type
    @propertyKind kind
    @location errorLocation
    switch mArrayControllerModel
    case rootToManyRelationship (@lstring relationshipName) :
      errorLocation = relationshipName.location
      [inRootObservablePropertyMap searchKey
        !relationshipName
        ?type
        ?kind
        ?let @propertyMultiplicity multiplicity
        ?*
      ]
      if multiplicity != .collection then
        error errorLocation : "this property should be a tomany relationship"
      end
    case controllerArray (@lstring controllerName @lstring propertyName) :
      errorLocation = propertyName.location
      [outArrayControllerMap searchKey
        !controllerName
        ?type
        ?kind
      ]
    end
    switch type
    case boolType, colorType, dateType, doubleType, integerType, stringType :
      error errorLocation : "this property should be a tomany relationship"
    case enumType (* *) :
      error errorLocation : "this property should be a tomany relationship"
    case entityType (*) : #Ok
    end
    [!?outArrayControllerMap insertKey !mControllerName !type !kind]
  end
}

#......................................................................................................................*

method @arrayControllerDeclarationListAST arrayControllerSemanticAnalysis
  ?let @string inOwnerName
  ?let @observablePropertyMap inRootObservablePropertyMap
  ?let @string inRootEntityName
  ?let @semanticContext inSemanticContext
  ?let @decoratedOutletMap inOutletMap
  ?let @observablePropertyMap unused inObservablePropertyMap
  ?let @arrayControllerMap inArrayControllerMap
  !@arrayControllerForGeneration outDocumentArrayControllerForGeneration
{
  outDocumentArrayControllerForGeneration = {}
  for () in self do
    @typeKind modelType
    @propertyKind kind
    @location errorLocation
    @bool modelIsTransient
    switch mArrayControllerModel
    case rootToManyRelationship (@lstring relationshipName) :
      errorLocation = relationshipName.location
      modelIsTransient = false
      [inRootObservablePropertyMap searchKey
        !relationshipName
        ?modelType
        ?kind
        ?let @propertyMultiplicity multiplicity
        ?*
      ]
    #--- Check bound model is a collection
      if multiplicity != .collection then
        error errorLocation : "the bound property should be a collection"
      end
    case controllerArray (@lstring controllerName @lstring propertyName) :
      errorLocation = propertyName.location
      modelIsTransient = true
      [inArrayControllerMap searchKey
        !controllerName
        ?modelType
        ?kind
      ]
      if (propertyName.string != "sortedArray") && (propertyName.string != "selectedArray") then
        error errorLocation : "'sortedArray' or 'selectedArray' are required here"
      end
    end
  #--- Check bound model type is an entity
    @string entityName
    switch modelType
    case boolType, colorType, dateType, doubleType, integerType, stringType :
      error errorLocation : "the model should be a tomany relationship" : entityName
    case enumType (* *) :
      error errorLocation : "the model should be a tomany relationship" : entityName
    case entityType (@string kEntityName) :
      entityName = kEntityName
    end
  #--- Check bound model is stored
    if kind == .transient then
      error errorLocation : "the bound property should be stored (not a transient)"
    end
  #--- Check outlet is a PMTableView
    for (tableViewOutletName) in mTableViewOutletNameList do
      [inOutletMap searchKey !tableViewOutletName ?let outletTypeName]
      if outletTypeName != "PMTableView" then
        error tableViewOutletName : "this outlet is not an instance of PMTableView"
      end
    end
  #--- Check colum bound models (TODO : get also super entity observable property)
    [inSemanticContext.mEntityObservablePropertyMap searchKey
      ![entityName nowhere]
      ?let @observablePropertyMap boundModelObservablePropertyMap
    ]
    @arrayControllerBoundColumnListForGeneration arrayControllerBoundColumnListForGeneration = {}
    for () in mArrayControllerBoundColumnListAST do
      [boundModelObservablePropertyMap searchKey
        !mObservablePropertyName
        ?let @typeKind columnType
        ?let @propertyKind unused columnKind
        ?let @propertyMultiplicity columnMultiplicity
        ?let @string unused inverseRelationshipName # "" if not a relationship
      ]
    #--- Check bound model type is a simple type
      switch columnType
      case boolType, colorType, dateType, doubleType, integerType, stringType : # Ok
      case enumType (* *) : # Ok
      case entityType (@string unused entityTypeName) :
        error [mObservablePropertyName location] : "the model should not be a relationship"
      end
      if columnMultiplicity == .collection then
        error mObservablePropertyName : "the bound column property should not be a collection"
      end
      arrayControllerBoundColumnListForGeneration +=
        !mColumnName.string
        !mColumnOutletTypeName.string
        !mObservablePropertyName.string
        !columnType
        !mBindingOptionList
    end
  #--- Check filter properties
    @arrayControllerFilterListForGeneration arrayControllerFilterListForGeneration = {}
    for (filterPropertyName) in mFilterProperties do
      [boundModelObservablePropertyMap searchKey
        !filterPropertyName
        ?let @typeKind filterType
        ?let @propertyKind unused columnKind
        ?let @propertyMultiplicity filterMultiplicity
        ?let @string unused inverseRelationshipName # "" if not a relationship
      ]
      if filterMultiplicity == .collection then
        error filterPropertyName : "the filter property should not be a collection"
      end
      arrayControllerFilterListForGeneration += !filterPropertyName.string !filterType
    end%for
  #---
    outDocumentArrayControllerForGeneration +=
      !inOwnerName
      !mControllerName.string
      !arrayControllerFilterListForGeneration
      ![mArrayControllerModel modelString]
      !arrayControllerBoundColumnListForGeneration
      ![mArrayControllerModel modelTypeName !inRootEntityName !inArrayControllerMap]
      ![mArrayControllerModel modelTypeName2 !inRootEntityName !inArrayControllerMap]
      !modelIsTransient
      ![modelType swiftTypeName]
      !mTableViewOutletNameList
  end%for
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION TYPES                                                                                                   *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @arrayControllerForGeneration {
  @string mOwnerName # document name, prefs name, ...
  @string mControllerName
  @arrayControllerFilterListForGeneration mArrayControllerFilterListForGeneration
  @string mModelString
  @arrayControllerBoundColumnListForGeneration mArrayControllerBoundColumnListForGeneration
  @string mModelTypeName
  @string mModelTypeName2
  @bool mModelIsTransient
  @string mElementTypeName
  @lstringlist mTableViewOutletNameList
}

#......................................................................................................................*

getter @arrayControllerModel modelString -> @string outResult {
  switch self
  case rootToManyRelationship (@lstring rootRelationshipName) :
    outResult = "rootObject." + rootRelationshipName
  case controllerArray (@lstring controllerName @lstring propertyName) :
    outResult = controllerName.string + "." + propertyName
  end
}

#......................................................................................................................*

getter @arrayControllerModel modelTypeName
  ?let @string inRootEntityName
  ?let @arrayControllerMap inArrayControllerMap
   -> @string outResult
{
  switch self
  case rootToManyRelationship (@lstring rootRelationshipName) :
    outResult = "ToManyRelationship_" + inRootEntityName + "_" + rootRelationshipName
  case controllerArray (@lstring controllerName *) :
    [inArrayControllerMap searchKey
      !controllerName
      ?let modelType
      ?*
    ]
    outResult = "TransientArrayOf_" + [modelType swiftTypeName] # ReadOnlyArrayOf_%!ELEMENT_TYPE_NAME%?
  end
}

#......................................................................................................................*

getter @arrayControllerModel modelTypeName2
  ?let @string inRootEntityName
  ?let @arrayControllerMap inArrayControllerMap
   -> @string outResult
{
  switch self
  case rootToManyRelationship (@lstring rootRelationshipName) :
    outResult = "ToManyRelationship_" + inRootEntityName + "_" + rootRelationshipName
  case controllerArray (@lstring controllerName *) :
    [inArrayControllerMap searchKey
      !controllerName
      ?let modelType
      ?*
    ]
    outResult = "ReadOnlyArrayOf_" + [modelType swiftTypeName] # ReadOnlyArrayOf_%!ELEMENT_TYPE_NAME%?
  end
}

#......................................................................................................................*

list @arrayControllerFilterListForGeneration {
  @string mFilterPropertyName
  @typeKind mFilterPropertyType
}

#......................................................................................................................*

list @arrayControllerBoundColumnListForGeneration {
  @string mColumnName
  @string mColumnOutletTypeName
  @string mObservablePropertyName
  @typeKind mPropertyType
  @bindingOptionList mBindingOptionList
}

#......................................................................................................................*

getter @typeKind transformerForTableViewAction ?let @string inSenderOutletName -> @string outResult {
  switch self
  case stringType : outResult = inSenderOutletName + ".stringValue"
  case integerType : outResult = inSenderOutletName + ".integerValue"
#--- TODO
  case boolType : outResult = "NSNumber (bool:" + inSenderOutletName + ")"
  case doubleType : outResult = "NSNumber (double:" + inSenderOutletName + ")"
  case colorType : outResult = inSenderOutletName + ".stringValue"
  case dateType : outResult = "NSDate"
  case enumType (* *) :
    outResult = "<unhandled enum for transformerForTableViewAction>"
  case entityType (*) :
    outResult = "<unhandled entity for transformerForTableViewAction>"
  end
}

#......................................................................................................................*

getter @typeKind formatterStringForFormatPrinting -> @string outResult {
  switch self
  case stringType : outResult = "%@"
  case integerType : outResult = "%d"
  case boolType : outResult = "%d"
  case doubleType : outResult = "%g"
  case colorType : outResult = "%@"
  case dateType : outResult = "%@"
  case enumType (* *) :
    outResult = "<internal error enum, formatterStringForFormatPrinting' >"
  case entityType (*) :
    outResult = "<internal error entity, formatterStringForFormatPrinting' >"
  end
}

#......................................................................................................................*

private filewrapper collectionControllerGenerationTemplate in "../generation-templates/collection-controller-templates" {
  "txt"
}{
}{
  template arrayControllerImplementationInSwift "array-controller.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string ARRAY_CONTROLLER_NAME
    ?@arrayControllerFilterListForGeneration FILTER_PROPERTIES
    ?@string MODEL_STRING
    ?@bool MODEL_IS_TRANSIENT
    ?@string MODEL_TYPE_NAME
    ?@string MODEL_TYPE_NAME_2
    ?@arrayControllerBoundColumnListForGeneration BOUND_COLUMNS
    ?@string ELEMENT_TYPE_NAME
    ?@filewrapper FILE_WRAPPER

  template filterFunction "array-controller-filter-function.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string ARRAY_CONTROLLER_NAME
    ?@arrayControllerFilterListForGeneration FILTER_PROPERTIES
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   GENERATION                                                                                                         *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

proc generateArrayControllers
  ?let @arrayControllerForGeneration inArrayControllerListForGeneration
  ?let @string inOutputDirectory {
  for () in inArrayControllerListForGeneration do
    let s = [filewrapper collectionControllerGenerationTemplate.arrayControllerImplementationInSwift
      !mOwnerName
      !mControllerName
      !mArrayControllerFilterListForGeneration
      !mModelString
      !mModelIsTransient
      !mModelTypeName
      !mModelTypeName2
      !mArrayControllerBoundColumnListForGeneration
      !mElementTypeName
      ![filewrapper collectionControllerGenerationTemplate]
    ]
    [@string generateFile
      !inOutputDirectory
      !"arrayController-" + mOwnerName + "-" +  mControllerName + ".swift"
      !s
    ]
    if [mArrayControllerFilterListForGeneration length] > 0 then
    let s = [filewrapper collectionControllerGenerationTemplate.filterFunction
      !mOwnerName
      !mControllerName
      !mArrayControllerFilterListForGeneration
    ]
    let fileName = "arrayControllerFilter-" + mOwnerName + "-" +  mControllerName + ".swift"
    [@string generateFileWithPattern
      !inOutputDirectory
      !fileName
      !"//"
      !"\n\n" # Defaut user zone1
      !s
      !"  return WHAT ?\n" # Defaut user zone2
      !"}\n\n//" + ["" stringByRightPadding !116 !'—'] + "*\n"
    ]
    end
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
