#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC TYPES                                                                                                     *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

abstract method @astDeclaration buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@semanticContext ioSemanticContext

#......................................................................................................................*

abstract method @astDeclaration semanticAnalysis
  ?let @semanticContext inSemanticContext
  ?!@structForGeneration ioGeneration

#......................................................................................................................*

list @secondaryDeclarationListWorkingList {
  @astDeclaration mDeclaration
  @secondaryPropertyList mSecondaryPropertyList
}

#......................................................................................................................*

abstract method @astDeclaration buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList ioSecondaryDeclarationListWorkingList
  ?!@uint ioSecondaryDeclarationCount

#......................................................................................................................*

abstract method @astDeclaration solveSecondaryProperty
  ?!@semanticContext ioSemanticContext
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @secondaryPropertyList inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties

#......................................................................................................................*

abstract method @abstractSecondaryProperty tryToSolveSecondaryProperty
  ?!@semanticContext ioSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?!@observablePropertyMap ioObservableProperties
  ?!@secondaryPropertyList ioUnsolvedProperties

#......................................................................................................................*

struct @semanticContext {
  @unifiedTypeMap mUnifiedTypeMap
  @outletClassMap mOutletClassMap
  @bindingSpecificationMap mBindingSpecificationMap
  @prefsObservablePropertyMap mPrefsObservablePropertyMap
  @documentObservablePropertyMap mDocumentObservablePropertyMap
  @entityObservablePropertyMap mEntityObservablePropertyMap
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

proc semanticAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @string unused inSourceFile
  ?let @astDeclarationStruct inAstDeclarationStruct
  !@structForGeneration outGeneration
{
#--- Build outlet class map
  [inAstDeclarationStruct.mOutletClassDeclarationList buildOutletClassMap ?let @outletClassMap outletClassMap]
#--- Build binding specification map
  buildBindingSpecificationMap (
    !inUnifiedTypeMap
    !inAstDeclarationStruct.mBindingSpecificationListMap
    ?let @bindingSpecificationMap bindingSpecificationMap
  )
#--- Semantic context
  @semanticContext semanticContext = .new {
    !inUnifiedTypeMap
    !outletClassMap
    !bindingSpecificationMap
    !{}
    !{}
    !{}
  }
#--- Build observable property maps from stored properties
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration buildObservablePropertyMapsFromStoredProperties
      !inUnifiedTypeMap
      !?semanticContext
    ]  
  end
#--- Building initial secondary property maps
  @secondaryDeclarationListWorkingList secondaryDeclarationListWorkingList = {}
  @uint secondaryDeclarationCount = 1 ;
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration buildInitialSecondaryPropertyListMap !?secondaryDeclarationListWorkingList !?secondaryDeclarationCount]
  end
#--- Iterate for building observable property maps
  @bool continue = true
  loop (secondaryDeclarationCount) while continue do
    @secondaryDeclarationListWorkingList newSecondaryDeclarationListWorkingList = {}
    for (declaration aList) in secondaryDeclarationListWorkingList do
      [declaration solveSecondaryProperty
        !?semanticContext
        !inUnifiedTypeMap
        !aList
        ?@secondaryPropertyList unsolvedProperties
      ]
      newSecondaryDeclarationListWorkingList += !declaration !unsolvedProperties
    end
    continue = newSecondaryDeclarationListWorkingList != secondaryDeclarationListWorkingList
    secondaryDeclarationListWorkingList = newSecondaryDeclarationListWorkingList
  end
#--- Semantic analysis of declarations
  outGeneration = .default
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration semanticAnalysis
      !semanticContext
      !?outGeneration
    ]  
  end
#--- Build controller template map
#  buildControllerTemplateMap (
#    !inUnifiedTypeMap
#    !inAstDeclarationStruct.mControllerTemplateList
#    ?let @bindingSpecificationMap templateControllerMap
#  )
##--- Type analysis
#  if @uint. errorCount == 0 then
#    typeAnalysis (
#      !inUnifiedTypeMap
#      !outletClassMap
#      !templateControllerMap
#      ?outGeneration
#    )
#  else
#    outGeneration = @structForGeneration.default
#  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
