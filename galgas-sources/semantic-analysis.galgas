#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC TYPES                                                                                                     *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

abstract method @astDeclaration buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@semanticContext ioSemanticContext

#......................................................................................................................*

abstract method @astDeclaration semanticAnalysis
  ?let @semanticContext inSemanticContext
  ?!@structForGeneration ioGeneration

#......................................................................................................................*

list @secondaryDeclarationListWorkingList {
  @astDeclaration mDeclaration
  @secondaryPropertyList mSecondaryPropertyList
}

#......................................................................................................................*

abstract method @astDeclaration buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList ioSecondaryDeclarationListWorkingList
  ?!@uint ioSecondaryDeclarationCount

#......................................................................................................................*

abstract method @astDeclaration solveSecondaryProperty
  ?!@semanticContext ioSemanticContext
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @secondaryPropertyList inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties

#......................................................................................................................*

abstract method @abstractSecondaryProperty tryToSolveSecondaryProperty
  ?!@semanticContext ioSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?!@observablePropertyMap ioObservableProperties
  ?!@secondaryPropertyList ioUnsolvedProperties

#......................................................................................................................*

struct @semanticContext {
  @unifiedTypeMap mUnifiedTypeMap
  @outletClassMap mOutletClassMap
  @bindingSpecificationMap mBindingSpecificationMap
  @observablePropertyMap mPreferencesObservablePropertyMap
  @documentObservablePropertyMap mDocumentObservablePropertyMap
  @entityObservablePropertyMap mEntityObservablePropertyMap
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

proc semanticAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @string inSourceFile
  ?let @astDeclarationStruct inAstDeclarationStruct
  !@structForGeneration outGeneration
{
#--- Build outlet class map
  [inAstDeclarationStruct.mOutletClassDeclarationList buildOutletClassMap ?let @outletClassMap outletClassMap]
#--- Build binding specification map
  buildBindingSpecificationMap (
    !inUnifiedTypeMap
    !inAstDeclarationStruct.mBindingSpecificationListMap
    ?let @bindingSpecificationMap bindingSpecificationMap
  )
#--- Semantic context
  @semanticContext semanticContext = .new {
    !inUnifiedTypeMap
    !outletClassMap
    !bindingSpecificationMap
    !{}
    !{}
    !{}
  }
#--- Build observable property maps from stored properties
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration buildObservablePropertyMapsFromStoredProperties
      !inUnifiedTypeMap
      !?semanticContext
    ]  
  end
  [inAstDeclarationStruct.mPreferences buildObservablePropertyMapsFromStoredProperties
    !inUnifiedTypeMap
    !?semanticContext
  ]
#--- Building initial secondary property maps
  @secondaryPropertyList preferencesSecondaryPropertyList = inAstDeclarationStruct.mPreferences.mSecondaryPropertyList
  @secondaryDeclarationListWorkingList secondaryDeclarationListWorkingList = {}
  @uint secondaryDeclarationCount = [preferencesSecondaryPropertyList length] + 1 ;
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration buildInitialSecondaryPropertyListMap !?secondaryDeclarationListWorkingList !?secondaryDeclarationCount]
  end
#--- Iterate for building observable property maps
  @bool continue = true
  loop (secondaryDeclarationCount) while continue do
    [inAstDeclarationStruct.mPreferences solveSecondaryProperty
      !?semanticContext
      !inUnifiedTypeMap
      !preferencesSecondaryPropertyList
      ?let @secondaryPropertyList newPreferencesSecondaryPropertyList
    ]
    @secondaryDeclarationListWorkingList newSecondaryDeclarationListWorkingList = {}
    for (declaration aList) in secondaryDeclarationListWorkingList do
      [declaration solveSecondaryProperty
        !?semanticContext
        !inUnifiedTypeMap
        !aList
        ?@secondaryPropertyList unsolvedProperties
      ]
      newSecondaryDeclarationListWorkingList += !declaration !unsolvedProperties
    end
    continue = 
      (newSecondaryDeclarationListWorkingList != secondaryDeclarationListWorkingList)
    ||
      (preferencesSecondaryPropertyList != newPreferencesSecondaryPropertyList)
    secondaryDeclarationListWorkingList = newSecondaryDeclarationListWorkingList
    preferencesSecondaryPropertyList = newPreferencesSecondaryPropertyList
  end
#--- Semantic analysis of declarations
  outGeneration = .default
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration semanticAnalysis
      !semanticContext
      !?outGeneration
    ]  
  end
  [inAstDeclarationStruct.mPreferences semanticAnalysis
    !inAstDeclarationStruct.mPreferences.mExternSwiftFunctionList
    !semanticContext
    !?outGeneration
  ]
#----------------------------------------- Output a binding description in latex
  if [option easyBindings_options.latexBindingDescription value] then
    var s = ""
    for () class_ in semanticContext.mBindingSpecificationMap do
      s += "\\section{Classe \\texttt{" + class_lkey + "}}\\index{" + class_lkey + "}\n\n"
      for () binding_ in class_mBindingMap do
        s += "\\subsection{Binding \\texttt{\\$" + binding_lkey + "}}\\index{\\$" + binding_lkey + "}\n\n"
        s += "{\\bf Type du modèle}\n\n"
        s += "\\begin{tabular}{ll}\n"
        s += "\\textbf{Type du modèle} & \\textbf{Modèle modifiable via le binding}\\\\\n"
        for () in binding_mOutletBindingSpecificationModelList do
          s += [mModelType swiftTypeName] + "& " + if mModelShouldBeWritableProperty then "Oui" else "Non" end + "\\\\\n"
        end
        s += "\\end{tabular}\n"
        if [binding_mControllerBindingOptionList length] == 0 then
          s += "{\\bf Type du modèle}\n\n"
        else
        
        end
#  @outletBindingSpecificationModelList mOutletBindingSpecificationModelList
#  @controllerBindingOptionDecoratedList mControllerBindingOptionList
      end
      s += "\n\n\n\n\n\n\n"
    end
    let latextFilePath = inSourceFile + ".bindings.tex"
    [s writeToFileWhenDifferentContents !latextFilePath ?*]
  end
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
