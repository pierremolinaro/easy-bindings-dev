#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC TYPES                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @classKind {
  case prefs
  case simpleClass
  case atomic (@typeKind kind)
  case document (@lstring rootEntityName)
  case entity (@bool isGraphic)
}

#·······················································································································

abstract class @propertyGeneration {
  @string mPropertyName
}

#·······················································································································

getter @propertyGeneration prefKeyDefinitionCode -> @string { result = "" }

#·······················································································································

abstract getter @propertyGeneration declarationCode -> @string

#·······················································································································

abstract getter @propertyGeneration configurationCode -> @string

#·······················································································································

getter @propertyGeneration terminationCode -> @string { result = "" }

#·······················································································································

getter @propertyGeneration setupFromDictionaryCode -> @string { result = "" }

#·······················································································································

getter @propertyGeneration saveIntoDictionaryCode -> @string { result = "" }

#·······················································································································

getter @propertyGeneration objectAccessibilityCode -> @string { result = "" }

#·······················································································································

getter @propertyGeneration populateExplorerWindowCode -> @string { result = "" }

#·······················································································································

getter @propertyGeneration clearObjectExplorerCode -> @string { result = "" }

#·······················································································································

list @propertyGenerationList {
  @propertyGeneration mProperty
}

#·······················································································································

map @classMap {
  @classKind mClassKind
  @propertyMap mPropertyMap
  @actionMap mActionMap
  @propertyGenerationList mPropertyGenerationList
  insert insertKey error message "the '%K' class is already declared in %L"
  search searchKey error message "there is no '%K' class"
}

#·······················································································································

enum @propertyAccessibility {
  case stored
  case proxy
  case transient
}

#·······················································································································

enum @typeKind {
  case boolType 
  case integerType 
  case doubleType
  case stringType 
  case dateType
  case fontType
  case colorType
  case enumType (@string enumTypeName @enumConstantMap constantMap)
  case entityType (@string entityName @bool graphic)
  case classType (@string className)
  case transientPropertyExternType (@string externTypeName)
}

#·······················································································································

enum @propertyKind {
  case property (@typeKind type @propertyAccessibility accessibility)
  case toMany (@lstring typeName @propertyAccessibility accessibility @bool graphic @bool isEntity)
  case toOne (@lstring typeName @propertyAccessibility accessibility @bool graphic)
  case arrayController (@lstring typeName @bool graphic @bool isEntity)
  case selectionController (@string typeName)
}

#·······················································································································

map @propertyMap {
  @propertyKind mKind
  @actionMap mActionMap
  insert insertKey error message "the '%K' property is already declared in %L"
  search searchKey error message "there is no '%K' property"
}

#·······················································································································

method @astDeclaration buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@semanticContextEX unused ioSemanticContext
{
}

#·······················································································································

method @astDeclaration semanticAnalysisEX
  ?let @semanticContextEX unused inSemanticContext
  ?!@generationStruct unused ioGeneration
{
}

#·······················································································································

list @secondaryDeclarationListWorkingList {
  @astDeclaration mDeclaration
  @secondaryPropertyList mSecondaryPropertyList
}

#·······················································································································

method @astDeclaration buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList unused ioSecondaryDeclarationListWorkingList
  ?!@uint unused ioSecondaryDeclarationCount
{
}

#·······················································································································

abstract method @astDeclaration solveSecondaryProperty
  ?!@semanticContextEX ioSemanticContext
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @secondaryPropertyList inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties
  ?!@simpleStoredPropertyListForGenerationEX ioSimpleStoredPropertyListForGeneration

#·······················································································································

abstract method @abstractSecondaryProperty tryToDefineSecondaryProperty
  ?!@semanticContextEX ioSemanticContext
  ?let @observablePropertyMap inRootObservableProperties
  ?!@observablePropertyMap ioObservableProperties
  ?!@secondaryPropertyList ioUnsolvedProperties
  ?!@simpleStoredPropertyListForGenerationEX ioSimpleStoredPropertyListForGeneration

#·······················································································································

struct @semanticContextEX {
  @classMap mClassMap
  @unifiedTypeMap mUnifiedTypeMap
  @outletClassMap mOutletClassMap
  @bindingSpecificationMap mBindingSpecificationMap
  @observablePropertyMap mPreferencesObservablePropertyMap
  @documentObservablePropertyMap mDocumentObservablePropertyMap
  @entityObservablePropertyMap mEntityObservablePropertyMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc semanticAnalysisEX
  ?let @classMap inClassMap
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @string inSourceFile
  ?let @astDeclarationStruct inAstDeclarationStruct
  ?!@generationStruct ioGeneration
{
#--- Build outlet class map
  @outletClassMap outletClassMap = {}
  [inAstDeclarationStruct.mOutletClassDeclarationList buildOutletClassMap !?outletClassMap]
#--- Build binding specification map
  @bindingSpecificationMap bindingSpecificationMap = {}
  buildBindingSpecificationMapEX (
    !inUnifiedTypeMap
    !outletClassMap
    !inAstDeclarationStruct.mBindingSpecificationListMap
    !?bindingSpecificationMap
  )
#--- Semantic context
  @semanticContextEX semanticContext = .new {
    !inClassMap
    !inUnifiedTypeMap
    !outletClassMap
    !bindingSpecificationMap
    !{}
    !{}
    !{}
  }
#--- Build observable property maps from stored properties
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration buildObservablePropertyMapsFromStoredProperties
      !inUnifiedTypeMap
      !?semanticContext
    ]  
  end
  [inAstDeclarationStruct.mPreferences buildObservablePropertyMapsFromStoredProperties
    !inUnifiedTypeMap
    !?semanticContext
  ]
#--- Building initial secondary property maps
  @secondaryPropertyList preferencesSecondaryPropertyList = inAstDeclarationStruct.mPreferences.mSecondaryPropertyList
  @secondaryDeclarationListWorkingList secondaryDeclarationListWorkingList = {}
  @uint secondaryDeclarationCount = [preferencesSecondaryPropertyList length] + 1 ;
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration buildInitialSecondaryPropertyListMap !?secondaryDeclarationListWorkingList !?secondaryDeclarationCount]
  end
#--- Iterate for building observable property maps
  @simpleStoredPropertyListForGenerationEX simpleStoredPropertyListForGeneration = {}
  @bool continue = true
  loop (secondaryDeclarationCount) while continue do
    @secondaryDeclarationListWorkingList newSecondaryDeclarationListWorkingList = {}
    for (declaration aList) in secondaryDeclarationListWorkingList do
      [declaration solveSecondaryProperty
        !?semanticContext
        !inUnifiedTypeMap
        !aList
        ?@secondaryPropertyList unsolvedProperties
        !?simpleStoredPropertyListForGeneration
      ]
      newSecondaryDeclarationListWorkingList += !declaration !unsolvedProperties
    end
    continue = 
      (newSecondaryDeclarationListWorkingList != secondaryDeclarationListWorkingList)
    secondaryDeclarationListWorkingList = newSecondaryDeclarationListWorkingList
  end
#--- Semantic analysis of declarations
  for () in inAstDeclarationStruct.mDeclarationList do
    [mDeclaration semanticAnalysisEX
      !semanticContext
      !?ioGeneration
    ]  
  end
#----------------------------------------- Output a binding description in latex
  if [option easyBindings_options.latexBindingDescription value] then
    var s = ""
    for () class_ in semanticContext.mOutletClassMap do
      s += "\\sectionLabel{Classe \\texttt{" + class_lkey + "}}{outletClass" +class_lkey + "}\\index{" + class_lkey + "}\n\n"
      if class_mHandleEnabledBinding || class_mHandlesRunAction || class_mHandlesTableValueBinding then
        s += "\\subsection{Bindings spéciaux}\n\n"
        if class_mHandleEnabledBinding then
          s += "Cette classe définit le binding \\$enabled.\\index{\\$enabled!" + class_lkey + "}\n\n"    
        end
        if class_mHandlesRunAction then
          s += "Cette classe définit le binding \\$run.\\index{\\$run!" + class_lkey + "}\n\n"    
        end
        if class_mHandlesTableValueBinding then
          s += "Cette classe définit le binding \\$tableValue.\\index{\\$tableValue!" + class_lkey + "}\n\n"    
        end
      end
      if [semanticContext.mBindingSpecificationMap hasKey !class_lkey.string] then
        for () binding_ in [semanticContext.mBindingSpecificationMap mBindingMapForKey !class_lkey.string] do
          s += "\\subsection{Binding \\texttt{\\$" + binding_lkey + "}}\\index{\\$" + binding_lkey + "!" + class_lkey + "}\n\n"
          s += "\\subsubsection{Type du modèle}\n\n"
          s += "\\begin{tabular}{|l|l|}\n"
          s += "\\hline\n"
          s += "\\textbf{Type du modèle} & \\textbf{Modèle modifiable via le binding}\\\\\n"
          s += "\\hline\n"
          for () in binding_mOutletBindingSpecificationModelList do
            s += [mModelType swiftTypeName] + " & " + if mModelShouldBeWritableProperty then "Oui" else "Non" end + "\\\\\n"
            s += "\\hline\n"
          end
          s += "\\end{tabular}\n"
          s += "\\subsubsection{Options}\n\n"
          if [binding_mControllerBindingOptionList length] == 0 then
            s += "Ce binding n'a pas d'option.\n\n"
          else
            s += "\\begin{tabular}{|l|l|}\n"
            s += "\\hline\n"
            s += "\\textbf{Nom de l'option} & \\textbf{Type de l'option}\\\\\n"
            s += "\\hline\n"
            for () in binding_mControllerBindingOptionList do
              s += mOptionName.string + " & " + [mOptionType swiftTypeName] + "\\\\\n"
              s += "\\hline\n"
            end
            s += "\\end{tabular}\n"
          end
        end
      end
      s += "\n\n\n\n\n\n\n"
    end
    let latextFilePath = inSourceFile + ".bindings.tex"
    [s writeToFileWhenDifferentContents !latextFilePath ?*]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
