#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @enumDeclarationEX : @astDeclaration {
  @lstring mEnumTypeName
  @lstringlist mEnumConstantNameList
}

#·······················································································································

class @enumerationDeclarationAST : @abstractDeclarationAST {
  @lstringlist mEnumConstantNameList
}

#·······················································································································

override method @enumerationDeclarationAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  [!?ioGraph addNode !mClassName !self]
}

#·······················································································································

override getter @enumerationDeclarationAST lkey -> @lstring {
  result = mClassName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <enum_declaration>
    ?let @bool inIsUserDefined
    ?!@astDeclarationStruct ioDeclarationAST {
    $enum$
    $Identifier$ ?let @lstring enumName
    ${$
    var enumConstants =@lstringlist.emptyList{}
    repeat
      $identifier$ ?let @lstring constantName
      enumConstants += !constantName
    while
      $,$
    end
    $}$
    ioDeclarationAST.mDeclarationList += !@enumDeclarationEX. new { !inIsUserDefined !enumName !enumConstants}
    ioDeclarationAST.mUnifiedDeclarationList += !@enumerationDeclarationAST.new {!enumName !enumConstants}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @enumConstantMap {
  insert insertKey error message "there is already a '%K' constant"
  search searchKey error message "the '%K' constant is not defined"
}

#·······················································································································

override method @enumerationDeclarationAST classAndPropertySemanticAnalysis
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  @enumConstantMap enumConstantMap = {}
  for (s) in mEnumConstantNameList do
    [!?enumConstantMap insertKey !s]
  end
  [!?ioSemanticContext.mClassMap insertKey
    !mClassName
    !.atomic {!kind: .enumType {!enumTypeName:mClassName !constantMap: enumConstantMap}}
    !{}
    !{}
    !{}
  ]
}










#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                             
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TYPE INVENTORY                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationEX typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  @enumConstantMap enumConstantMap = {}
  for (s) in mEnumConstantNameList do
    [!?enumConstantMap insertKey !s]
  end
  [!?ioUnifiedTypeMap insertKey
    !mEnumTypeName
    !@typeKind.enumType {!enumTypeName:mEnumTypeName.string !constantMap:enumConstantMap}
    !{}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationEX buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@semanticContextEX unused ioSemanticContext
{
}

#·······················································································································

override method @enumDeclarationEX buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList unused ioSecondaryDeclarationListWorkingList
  ?!@uint unused ioSecondaryDeclarationCount 
{
}

#·······················································································································

override method @enumDeclarationEX solveSecondaryProperty
  ?!@semanticContextEX unused ioSemanticContext
  ?let @unifiedTypeMap unused mUnifiedTypeMap
  ?let @secondaryPropertyList unused inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties
  ?!@simpleStoredPropertyListForGenerationEX unused ioSimpleStoredPropertyListForGeneration
{
  outUnsolvedProperties = {}
}

#·······················································································································

override method @enumDeclarationEX semanticAnalysis
  ?let @semanticContextEX unused inSemanticContext
  ?!@generationStruct ioGeneration
{
  ioGeneration.mEnumListForGeneration +=
    !mEnumTypeName.string
    !mEnumConstantNameList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION TYPE                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @enumListForGeneration {
  @string mEnumName
  @lstringlist mEnumConstantList
}

#·······················································································································

private filewrapper enumGenerationTemplate in "../generation-templates" {
}{
}{
  template enumGenerationInSwift "enum.swift.galgasTemplate"
    ?@string ENUM_TYPE_NAME
    ?@lstringlist CONSTANT_ORDERED_LIST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION CODE                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateEnums
  ?let @enumListForGeneration inEnumListForGeneration
  ?let @string inOutputDirectory
  ?!@stringset ioGeneratedFileSet
{
  for () in inEnumListForGeneration do
    if [mEnumConstantList length] > 0 then # Empty list is the generic type "Enum"
      let s = [filewrapper enumGenerationTemplate.enumGenerationInSwift
        !mEnumName
        !mEnumConstantList
      ]
      let fileName = "entity-" + mEnumName + ".swift"
      ioGeneratedFileSet += !fileName
      [@string generateFile
        !inOutputDirectory
        !fileName
        !s
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
