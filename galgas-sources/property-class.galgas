#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   AST                                                                                                                *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

enum @propertyClassDefaultValues {
  case string (@stringset values)
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

class @propertyClassDeclaration : @astDeclaration {
  @lstring mClassPropertyName
  @propertyClassDefaultValues mDefaultValues
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SYNTAX                                                                                                             *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  #....................................................................................................................*
  
  rule <class_declaration>
    ?let @bool inIsUserDefined
    ?!@astDeclarationStruct ioDeclarationAST
  {
    $property$
    $class$
    $Identifier$ ?let @lstring classPropertyName
    @stringset stringDefaultValues = {}
    $($
    repeat
      $identifier$ ?let @lstring defaultValue
      if [stringDefaultValues hasKey !defaultValue.string] then
        error defaultValue : "value already defined"
      end
      stringDefaultValues += !defaultValue.string
    while
      $,$
    end
    $)$
    $;$
    ioDeclarationAST.mDeclarationList += !@propertyClassDeclaration.new {
      !inIsUserDefined
      !classPropertyName
      !.string {!values:stringDefaultValues}
    }
  }

  #....................................................................................................................*

}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   TYPE INVENTORY                                                                                                     *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

override method @propertyClassDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  [!?ioUnifiedTypeMap insertKey
    !mClassPropertyName
    !.propertyClassType {!classPropertyName:mClassPropertyName.string !defaultValues:mDefaultValues}
    !{}
  ]
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#   SEMANTIC ANALYSIS                                                                                                  *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

# Only get current entity observable properties, do not collect in super entities
override method @propertyClassDeclaration buildObservablePropertyMapsFromStoredProperties
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?!@semanticContext unused ioSemanticContext
{
}

#......................................................................................................................*

override method @propertyClassDeclaration buildInitialSecondaryPropertyListMap
  ?!@secondaryDeclarationListWorkingList unused ioSecondaryDeclarationListWorkingList
  ?!@uint unused ioSecondaryDeclarationCount
{
}

#......................................................................................................................*

override method @propertyClassDeclaration solveSecondaryProperty
  ?!@semanticContext unused ioSemanticContext
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @secondaryPropertyList unused inPropertiesToSolve
  !@secondaryPropertyList outUnsolvedProperties
{
  outUnsolvedProperties = {}
}

#......................................................................................................................*

override method @propertyClassDeclaration semanticAnalysis
  ?let @semanticContext unused inSemanticContext
  ?!@structForGeneration ioGeneration
{
  ioGeneration.mPropertyClassList += !mClassPropertyName.string
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
