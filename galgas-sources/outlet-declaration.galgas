#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  AST                                                                                                                 *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @bindingOptionList {
  @lstring mOptionName
  @abstractDefaultValue mOptionValue
}

#......................................................................................................................*

enum @tableValueBinding {
  case noTableValueBinding
  case tableValueBinding (@lstring controllerName)
}

#......................................................................................................................*

list @outletDeclarationList {
  @lstring mOutletTypeName
  @lstring mOutletName
  @tableValueBinding mTableValueBindingDescriptor
  @runActionDescriptor mRunDescriptor
  @multipleBindingDescriptor mEnabledBindingDescriptor
  @multipleBindingDescriptor mHiddenBindingDescriptor
  @regularBindingList mRegularBindingList
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  SYNTAX                                                                                                              *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

#......................................................................................................................*

  rule <outlet_declaration> ?!@outletDeclarationList ioOutletDeclarationList {
    $outlet$
    $Identifier$ ?let outletTypeName
    $identifier$ ?let outletName
    var tableValueBinding = @tableValueBinding.noTableValueBinding 
    var runActionDescriptor = @runActionDescriptor.noAction 
    var enabledBindingDescriptor = @multipleBindingDescriptor.noBinding
    var hiddenBindingDescriptor = @multipleBindingDescriptor.noBinding
    @regularBindingList regularBindingList = {}
    repeat
    while
      $tableValue$
      if tableValueBinding != .noTableValueBinding then
        error .here : "duplicated $tableValue binding"
      end
      $identifier$ ?let @lstring controllerName
      tableValueBinding = .tableValueBinding {!controllerName:controllerName}
    while
      $run$
      if runActionDescriptor != .noAction then
        error .here : "duplicated $run binding"
      end
      @lstring runTargetName
      select
        $self$
        runTargetName = @lstring.new {!"self" !.here}
      or
        $identifier$ ?runTargetName
      end
      $.$
      $identifier$ ?let @lstring runActionName
      runActionDescriptor = .action {!target:runTargetName !action:runActionName}
  #--- Enabled
    while
      $enabled$
      if enabledBindingDescriptor != .noBinding then
        error .here : "duplicated $enabled binding"
      end
      <booleanMultipleBindingExpression> ?let @abstractBooleanMultipleBindingExpressionAST bindingExpression
      enabledBindingDescriptor = .binding {!expression:bindingExpression}
  #--- Hidden
    while
      $hidden$
      if hiddenBindingDescriptor != .noBinding then
        error .here : "duplicated $hidden binding"
      end
      <booleanMultipleBindingExpression> ?let @abstractBooleanMultipleBindingExpressionAST bindingExpression
      hiddenBindingDescriptor = .binding {!expression:bindingExpression}
  #--- Regular binding
    while
      $bindingName$ ?let @lstring bindingName
      @observablePropertyList observablePropertyList = {}
      repeat
        <observable_property> ?let @observablePropertyAST observableProperty
        observablePropertyList += !observableProperty
      while
        $,$
      end
      <binding_option_list> ?let bindingOptions
      regularBindingList +=
        !bindingName
        !observablePropertyList
        !bindingOptions
    end
  #---
    $;$
    ioOutletDeclarationList +=
      !outletTypeName
      !outletName
      !tableValueBinding
      !runActionDescriptor
      !enabledBindingDescriptor
      !hiddenBindingDescriptor
      !regularBindingList
  }
  
  #......................................................................................................................*

}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  SEMANTICS                                                                                                           *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @outletBindingModelList {
  @typeKind mModelType
  @propertyKind mKind
  @location mErrorLocation
}

#......................................................................................................................*

list @tableViewBindingGenerationList {
  @string mTableValueBindingOutletName
  @string mTableValueBindingControllerName
}

#......................................................................................................................*

getter @tableViewBindingGenerationList outletNameListForController ?let @string inControllerName -> @string outResult {
  outResult = ""
  @bool first = true
  for (outlet controller) in self do
    if controller == inControllerName then
      if first then
        first = false
      else
        outResult += ", "
      end
      outResult += outlet + "!"
    end
  end
}

#......................................................................................................................*

proc analyzeOutlets
  ?let @observablePropertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @outletDeclarationList inOutletDeclarationList
  ?let @observablePropertyMap inObservablePropertyMap
  ?let @actionMap inActionMap
  ?let @string inReceiverSwiftTypeName
  ?!@structForGeneration ioGeneration
  !@regularBindingsGenerationList outRegularBindingsGenerationList
  !@multipleBindingGenerationList outMultipleBindingGenerationList
  !@actionBindingListForGeneration outTargetActionList
  !@decoratedOutletMap outletMap
  !@tableViewBindingGenerationList outTableViewBindingGenerationList
{
  outRegularBindingsGenerationList = {}
  outTargetActionList = {}
  outMultipleBindingGenerationList = {}
  outletMap = {}
  outTableViewBindingGenerationList = {}
  for () outlet_ in inOutletDeclarationList do
    [!?outletMap insertKey !outlet_mOutletName !outlet_mOutletTypeName.string]
    [inSemanticContext.mOutletClassMap searchKey
      !outlet_mOutletTypeName
      ?let @bool handlesRunAction
      ?let @bool handlesTableViewBinding
      ?let @bool handlesEnabledBinding
      ?let @bool outletClassIsUserDefined
    ]
    if not outletClassIsUserDefined then
      ioGeneration.mNeededOutletClasses += !outlet_mOutletTypeName.string
    end
  #--- $tableView
    switch outlet_mTableValueBindingDescriptor
    case noTableValueBinding :
    case tableValueBinding (@lstring controllerName) :
      if not handlesTableViewBinding then
        error outlet_mOutletTypeName : "the '" + outlet_mOutletTypeName + "' type does not handle the $tableView binding"
      else
        [inObservablePropertyMap searchKey
          !controllerName
          ?let unused type
          ?let @propertyKind kind
          ?let multiplicity
          ?2*
        ]
        if kind != .arrayController then
          error controllerName : "the bound model should be an array controller"
        end
        if multiplicity != .collection then
          error controllerName : "the controller is not bound to a collection"
        end
        outTableViewBindingGenerationList += !outlet_mOutletName.string !controllerName.string
      end
    end
  #--- $run
    switch outlet_mRunDescriptor
    case noAction :
    case action (@lstring target @lstring action) :
      if not handlesRunAction then
        error outlet_mOutletTypeName : "the '" + outlet_mOutletTypeName + "' type does not handle run action"
      elsif target.string == "self" then
        [inActionMap searchKey !action]
        outTargetActionList +=
          !outlet_mOutletName.string
          !"self"
          !action.string
          !inReceiverSwiftTypeName
      else # It is a controller
        [inObservablePropertyMap searchKey
          !target
          ?4*
          ?let @actionMap controllerActionMap
        ]
        [controllerActionMap searchKey !action]
        outTargetActionList +=
          !outlet_mOutletName.string
          !target.string
          !action.string
          !"ArrayController_" + inReceiverSwiftTypeName + "_" + target
      end
    end
  #--- Enabled
    switch outlet_mEnabledBindingDescriptor
    case noBinding :
    case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
      [expression analyzeExpressionForMultipleBinding
        !inRootObservablePropertyMap
        !inSemanticContext
        !inObservablePropertyMap
        ?let @abstractBooleanMultipleBindingExpressionForGeneration enableExpression
        ?let @typeKind type
        ?let @location errorLocation
      ]
      if not handlesEnabledBinding then
        error errorLocation : "cet outlet n'accepte pas le binding $enabled"
      end
      if not [type isBoolType] then
        error errorLocation : "expression is not boolean"
      end
      outMultipleBindingGenerationList +=
        !outlet_mOutletName.string
        !"enabled"
        !enableExpression
    end
  #--- Hidden
    switch outlet_mHiddenBindingDescriptor
    case noBinding :
    case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
      [expression analyzeExpressionForMultipleBinding
        !inRootObservablePropertyMap
        !inSemanticContext
        !inObservablePropertyMap
        ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression
        ?let @typeKind type
        ?let @location errorLocation
      ]
      if not [type isBoolType] then
        error errorLocation : "expression is not boolean"
      end
      outMultipleBindingGenerationList +=
        !outlet_mOutletName.string
        !"hidden"
        !hiddenExpression
    end
  #---------------------------------- Regular bindings
    analyzeRegularBinding (
      !inRootObservablePropertyMap
      !inSemanticContext
      !inObservablePropertyMap
      !outlet_mOutletTypeName
      !outlet_mOutletName.string
      !outlet_mRegularBindingList
      !"self"
      !?outRegularBindingsGenerationList
    )
  end
}

#......................................................................................................................*

proc analyzeRegularBinding
  ?let @observablePropertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @observablePropertyMap inObservablePropertyMap
  ?let @lstring inOutletTypeName
  ?let @string inOutletName
  ?let @regularBindingList inRegularBindingList
  ?let @string inSelfSwiftName
  ?!@regularBindingsGenerationList ioRegularBindingsGenerationList
{
  for () in inRegularBindingList do
  #--- Analyze model
    var @outletBindingModelList boundModelTypeList = {}
    var @stringlist boundModelStringListForGeneration = {}
    for () in mObservablePropertyList do
      boundModelStringListForGeneration += ![mObservableProperty modelString !inSelfSwiftName]
      [mObservableProperty analyzeObservableProperty
        !inRootObservablePropertyMap
        !inSemanticContext
        !inObservablePropertyMap
        ?@typeKind type
        ?@propertyKind kind
        ?@propertyMultiplicity multiplicity
        ?let @string unused swiftTypeStringForTransientFunctionArgument
      ]
      if multiplicity != .single then
        error [mObservableProperty location]:"a collection cannot be bound"
      end
      boundModelTypeList += !type !kind ![mObservableProperty location]
    end
  #--- Analyze outlet binding
    [inSemanticContext.mBindingSpecificationMap searchKey
      !inOutletTypeName # outlet_mOutletTypeName
      ?let @outletBindingSpecificationMap bindingMap
    ]
    [bindingMap searchKey
      !mBindingName
      ?let @outletBindingSpecificationModelList outletBindingSpecificationModelList
      ?let @controllerBindingOptionDecoratedList controllerBindingOptionDecoratedList
    ]
    if [boundModelTypeList length] != [outletBindingSpecificationModelList length] then
      error mBindingName : [[outletBindingSpecificationModelList length] string] + " model(s) required for this binding"
    else
      for () required_ in outletBindingSpecificationModelList, () found_ in boundModelTypeList do
        if required_mModelShouldBeWritableProperty && (found_mKind == .transient) then
          error found_mErrorLocation : "the model is transient and the binding requires an writable model"
        end
        if [required_mModelType isEnumType] && [found_mModelType isEnumType] then # Ok
        elsif [required_mModelType swiftTypeName] != [found_mModelType swiftTypeName] then
          error found_mErrorLocation : "the model type should be " + [required_mModelType swiftTypeName]
        end
      end
    end
  #--- Check options
    var bindingOptionString = ""
    if [controllerBindingOptionDecoratedList length] != [mBindingOptionList length] then
      @string s
      if [controllerBindingOptionDecoratedList length] == 0 then
        s = "this binding has no option"
      else 
        s = "this binding requires the following options:"
        for () in controllerBindingOptionDecoratedList do
          s += "\n  - " + mOptionName + " : " + [mOptionType swiftTypeName]
        end
      end
      error mBindingName : s
    else
      for () controller_ in controllerBindingOptionDecoratedList, () binding_ in mBindingOptionList do
        if controller_mOptionName.string != binding_mOptionName.string then
          error binding_mOptionName : "the option name should be '" + controller_mOptionName + "'"
        end
        [binding_mOptionValue analyzeDefaultValueType 
          !{!controller_mOptionType}
          ?let @string optionValueAsString
        ]
        bindingOptionString += ", " + controller_mOptionName.string + ":" + optionValueAsString
      end
    end
  #--- Generate binding
    ioRegularBindingsGenerationList +=
      !inOutletName
      !mBindingName.string
      !boundModelStringListForGeneration
      !bindingOptionString
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#   GENERATION TYPES                                                                                                   *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @regularBindingsGenerationList {
  @string mOutletName
  @string mBindingName
  @stringlist mBoundObjectStringList
  @string mBindingOptionsString
}

#......................................................................................................................*

list @actionBindingListForGeneration {
  @string mOutletName
  @string mTargetName
  @string mActionName
  @string mTargetTypeName
}

#......................................................................................................................*

map @decoratedOutletMap {
  @string mOutletTypeName
  insert insertKey error message "the '%K' outlet is already declared"
  search searchKey error message "the '%K' outlet is not declared"
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
