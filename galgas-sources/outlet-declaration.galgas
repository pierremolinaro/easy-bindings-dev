#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  AST                                                                                                                 *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @bindingOptionList {
  @lstring mOptionName
  @abstractDefaultValue mOptionValue
}

#......................................................................................................................*

enum @tableValueBinding {
  case noTableValueBinding
  case tableValueBinding (@lstring controllerName)
}

#......................................................................................................................*

list @outletDeclarationList {
  @lstring mOutletTypeName
  @lstring mOutletName
  @tableValueBinding mTableValueBindingDescriptor
  @runActionDescriptor mRunDescriptor
  @multipleBindingDescriptor mEnabledBindingDescriptor
  @regularBindingList mRegularBindingList
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  SYNTAX                                                                                                              *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  rule <outlet_declaration>
    ?!@outletDeclarationList ioOutletDeclarationList
  {
    $outlet$
    $Identifier$ ?let outletTypeName
    $identifier$ ?let outletName
    var tableValueBinding = @tableValueBinding.noTableValueBinding 
    var runActionDescriptor = @runActionDescriptor.noAction 
    var enabledBindingDescriptor = @multipleBindingDescriptor.noEnabledBinding
    @regularBindingList regularBindingList = {}
    repeat
    while
      $tableValue$
      if tableValueBinding != .noTableValueBinding then
        error @location.here : "duplicated $tableValue binding"
      end
      $identifier$ ?let @lstring controllerName
      tableValueBinding = .tableValueBinding {!controllerName:controllerName}
    while
      $run$
      if runActionDescriptor != .noAction then
        error @location.here : "duplicated $run binding"
      end
      @lstring runTargetName
      select
        $self$
        runTargetName = @lstring.new {!"self" !.here}
      or
        $identifier$ ?runTargetName
      end
      $.$
      $identifier$ ?let @lstring runActionName
      runActionDescriptor = .action {!target:runTargetName !action:runActionName}
  #--- Enabled
    while
      $enabled$
      if enabledBindingDescriptor != @multipleBindingDescriptor. noEnabledBinding then
        error @location.here : "duplicated $enabled binding"
      end
      <booleanMultipleBindingExpression> ?let @abstractBooleanMultipleBindingExpressionAST bindingExpression
      enabledBindingDescriptor = @multipleBindingDescriptor.enabledBinding {!expression:bindingExpression}
  #--- Regular binding
    while
      $bindingName$ ?let @lstring bindingName
      @observablePropertyList observablePropertyList = {}
      repeat
        <observable_property> ?let @observablePropertyAST observableProperty
        observablePropertyList += !observableProperty
      while
        $,$
      end
      <binding_option_list> ?let bindingOptions
      regularBindingList +=
        !bindingName
        !observablePropertyList
        !bindingOptions
    end
  #---
    $;$
    ioOutletDeclarationList +=
      !outletTypeName
      !outletName
      !tableValueBinding
      !runActionDescriptor
      !enabledBindingDescriptor
      !regularBindingList
  }
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  SEMANTICS                                                                                                           *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @outletBindingModelList {
  @typeKind mModelType
  @propertyKind mKind
  @location mErrorLocation
}

#......................................................................................................................*

list @tableViewBindingGenerationList {
  @string mTableValueBindingOutletName
  @string mTableValueBindingControllerName
}

#......................................................................................................................*

getter @tableViewBindingGenerationList outletNameListForController ?let @string inControllerName -> @string outResult {
  outResult = ""
  @bool first = true
  for (outlet controller) in self do
    if controller == inControllerName then
      if first then
        first = false
      else
        outResult += ", "
      end
      outResult += outlet + "!"
    end
  end
}

#......................................................................................................................*

proc analyzeOutlets
  ?let @observablePropertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @outletDeclarationList inOutletDeclarationList
  ?let @observablePropertyMap inObservablePropertyMap
  ?let @actionMap inActionMap
  ?!@structForGeneration ioGeneration
  !@regularBindingsGenerationList outRegularBindingsGenerationList
  !@multipleBindingGenerationList outMultipleBindingGenerationList
  !@actionBindingListForGeneration outTargetActionList
  !@decoratedOutletMap outletMap
  !@tableViewBindingGenerationList outTableViewBindingGenerationList
{
  outRegularBindingsGenerationList = {}
  outTargetActionList = {}
  outMultipleBindingGenerationList = {}
  outletMap = {}
  outTableViewBindingGenerationList = {}
  for () outlet_ in inOutletDeclarationList do
    [!?outletMap insertKey !outlet_mOutletName !outlet_mOutletTypeName.string]
    [inSemanticContext.mOutletClassMap searchKey
      !outlet_mOutletTypeName
      ?let @bool handlesRunAction
      ?let @bool handlesTableViewBinding
    ]
    ioGeneration.mNeededOutletClasses += !outlet_mOutletTypeName.string
  #--- $tableView
    switch outlet_mTableValueBindingDescriptor
    case noTableValueBinding :
    case tableValueBinding (@lstring controllerName) :
      if not handlesTableViewBinding then
        error outlet_mOutletTypeName : "the '" + outlet_mOutletTypeName + "' type does not handle the $tableView binding"
      else
        [inObservablePropertyMap searchKey
          !controllerName
          ?let unused type
          ?let @propertyKind kind
          ?let multiplicity
          ?2*
        ]
        if kind != .arrayController then
          error controllerName : "the bound model should be an array controller"
        end
        if multiplicity != .collection then
          error controllerName : "the controller is not bound to a collection"
        end
        outTableViewBindingGenerationList += !outlet_mOutletName.string !controllerName.string
      end
    end
  #--- $run
    switch outlet_mRunDescriptor
    case noAction :
    case action (@lstring target @lstring action) :
      if not handlesRunAction then
        error outlet_mOutletTypeName : "the '" + outlet_mOutletTypeName + "' type does not handle run action"
      elsif target.string == "self" then
        [inActionMap searchKey !action]
        outTargetActionList +=
          !outlet_mOutletName.string
          !"self"
          !action.string
      else # It is a controller
        [inObservablePropertyMap searchKey !target ?4* ?let @actionMap controllerActionMap]
        [controllerActionMap searchKey !action]
        outTargetActionList += !outlet_mOutletName.string !target.string !action.string
      end
    end
  #--- Enabled
    switch outlet_mEnabledBindingDescriptor
    case noEnabledBinding :
    case enabledBinding (@abstractBooleanMultipleBindingExpressionAST expression) :
      [expression analyzeExpressionForMultipleBinding
        !inRootObservablePropertyMap
        !inSemanticContext
        !inObservablePropertyMap
        ?let @abstractBooleanMultipleBindingExpressionForGeneration enableExpression
        ?let @typeKind type
        ?let @location errorLocation
      ]
      if not [type isBoolType] then
        error errorLocation : "expression is not boolean"
      end
      outMultipleBindingGenerationList +=
        !outlet_mOutletName.string
        !"enabled"
        !enableExpression
    end
  #--- Regular bindings
    for () in outlet_mRegularBindingList do
    #--- Analyse model
      var @outletBindingModelList boundModelTypeList = {}
      var @stringlist boundModelStringListForGeneration = {}
      for () in mObservablePropertyList do
        boundModelStringListForGeneration += ![mObservableProperty modelString !"self"]
        [mObservableProperty analyzeObservableProperty
          !inRootObservablePropertyMap
          !inSemanticContext
          !inObservablePropertyMap
          ?@typeKind type
          ?@propertyKind kind
          ?@propertyMultiplicity multiplicity
          ?let @string unused swiftTypeStringForTransientFunctionArgument
        ]
        if multiplicity != .single then
          error [mObservableProperty location]:"a collection cannot be bound"
        end
        boundModelTypeList += !type !kind ![mObservableProperty location]
      end
    #--- Analyze outlet binding
      [inSemanticContext.mBindingSpecificationMap searchKey
        !outlet_mOutletTypeName
        ?let @outletBindingSpecificationMap bindingMap
      ]
      [bindingMap searchKey
        !mBindingName
        ?let @outletBindingSpecificationModelList outletBindingSpecificationModelList
        ?let @controllerBindingOptionDecoratedList controllerBindingOptionDecoratedList
      ]
      if [boundModelTypeList length] != [outletBindingSpecificationModelList length] then
        error mBindingName : [[outletBindingSpecificationModelList length] string] + " model(s) required for this binding"
      else
        for () required_ in outletBindingSpecificationModelList, () found_ in boundModelTypeList do
          if required_mModelShouldBeWritableProperty && (found_mKind == .transient) then
            error found_mErrorLocation : "the model is transient and the binding requires an writable model"
          end
          if [required_mModelType isEnumType] && [found_mModelType isEnumType] then # Ok
          elsif [required_mModelType swiftTypeName] != [found_mModelType swiftTypeName] then
            error found_mErrorLocation : "the model type should be " + [required_mModelType swiftTypeName]
          end
        end
      end
    #--- Check options
      var bindingOptionString = ""
      if [controllerBindingOptionDecoratedList length] != [mBindingOptionList length] then
        @string s
        if [controllerBindingOptionDecoratedList length] == 0 then
          s = "this binding has no option"
        else 
          s = "this binding requires the following options:"
          for () in controllerBindingOptionDecoratedList do
            s += "\n  - " + mOptionName + " : " + [mOptionType swiftTypeName]
          end
        end
        error mBindingName : s
      else
        for () controller_ in controllerBindingOptionDecoratedList, () binding_ in mBindingOptionList do
          if controller_mOptionName.string != binding_mOptionName.string then
            error binding_mOptionName : "the option name should be '" + controller_mOptionName + "'"
          end
          [binding_mOptionValue analyzeDefaultValueType 
            !{!controller_mOptionType}
            ?let @string optionValueAsString
          ]
          bindingOptionString += ", " + controller_mOptionName.string + ":" + optionValueAsString
        end
      end
    #--- Generate binding
      outRegularBindingsGenerationList +=
        !outlet_mOutletName.string
        !mBindingName.string
        !boundModelStringListForGeneration
        !bindingOptionString
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#   GENERATION TYPES                                                                                                   *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @regularBindingsGenerationList {
  @string mOutletName
  @string mBindingName
  @stringlist mBoundObjectStringList
  @string mBindingOptionsString
}

#......................................................................................................................*

list @actionBindingListForGeneration {
  @string mOutletName
  @string mTargetName
  @string mActionName
}

#......................................................................................................................*

map @decoratedOutletMap {
  @string mOutletTypeName
  insert insertKey error message "the '%K' outlet is already declared"
  search searchKey error message "the '%K' outlet is not declared"
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
