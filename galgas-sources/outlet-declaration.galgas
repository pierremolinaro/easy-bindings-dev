#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  AST                                                                                                                 *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @bindingOptionList {
  @lstring mOptionName
  @abstractDefaultValue mOptionValue
}

#......................................................................................................................*

list @outletDeclarationList {
  @lstring mOutletTypeName
  @lstring mOutletName
  @runActionDescriptor mRunDescriptor
  @multipleBindingDescriptor mEnabledBindingDescriptor
  @regularBindingList mRegularBindingList
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  SYNTAX                                                                                                              *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

syntax extension easyBindings_syntax {

  rule <outlet_declaration>
    ?!@outletDeclarationList ioOutletDeclarationList
  {
    $outlet$
    $Identifier$ ?let outletTypeName
    $identifier$ ?let outletName
  #--- Run
    var runActionDescriptor = @runActionDescriptor.noAction 
    var enabledBindingDescriptor = @multipleBindingDescriptor.noEnabledBinding
    @regularBindingList regularBindingList = {}
    repeat
    while
      $run$
      if runActionDescriptor != @runActionDescriptor.noAction then
        error @location.here : "duplicated $run binding"
      end
      @lstring runTargetName
      select
        $self$
        runTargetName = @lstring.new {!"self" !.here}
      or
        $identifier$ ?runTargetName
      end
      $.$
      $identifier$ ?let @lstring runActionName
      runActionDescriptor = @runActionDescriptor.action { !target:runTargetName !action:runActionName}
  #--- Enabled
    while
      $enabled$
      if enabledBindingDescriptor != @multipleBindingDescriptor. noEnabledBinding then
        error @location.here : "duplicated $enabled binding"
      end
      <booleanMultipleBindingExpression> ?let @abstractBooleanMultipleBindingExpressionAST bindingExpression
      enabledBindingDescriptor = @multipleBindingDescriptor.enabledBinding {!expression:bindingExpression}
  #--- Regular binding
    while
      $bindingName$ ?let @lstring bindingName
      @observablePropertyList observablePropertyList = {}
      repeat
        <observable_property> ?let @observablePropertyAST observableProperty
        observablePropertyList += !observableProperty
      while
        $,$
      end
      <binding_option_list> ?let bindingOptions
      regularBindingList +=
        !bindingName
        !observablePropertyList
        !bindingOptions
    end
  #---
    $;$
    ioOutletDeclarationList +=
      !outletTypeName
      !outletName
      !runActionDescriptor
      !enabledBindingDescriptor
      !regularBindingList
  }
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
#  SEMANTICS                                                                                                           *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @outletBindingModelList {
  @typeKind mModelType
  @propertyKind mKind
  @location mErrorLocation
}

#......................................................................................................................*

proc analyzeOutlets
  ?let @observablePropertyMap inRootObservablePropertyMap
  ?let @semanticContext inSemanticContext
  ?let @outletDeclarationList inOutletDeclarationList
  ?let @observablePropertyMap inObservablePropertyMap
  ?let @actionMap inActionMap
  ?let @arrayControllerMap inArrayControllerMap
  ?!@structForGeneration ioGeneration
  !@regularBindingsGenerationList outRegularBindingsGenerationList
  !@multipleBindingGenerationList outMultipleBindingGenerationList
  !@actionBindingListForGeneration outTargetActionList
  !@decoratedOutletMap outletMap
{
  outRegularBindingsGenerationList = {}
  outTargetActionList = {}
  outMultipleBindingGenerationList = {}
  outletMap = {}
  for () outlet_ in inOutletDeclarationList do
    [!?outletMap insertKey !outlet_mOutletName !outlet_mOutletTypeName.string]
    [inSemanticContext.mOutletClassMap searchKey !outlet_mOutletTypeName ?let @bool handlesRunAction]
    ioGeneration.mNeededOutletClasses += !outlet_mOutletTypeName.string
  #--- run
    switch outlet_mRunDescriptor
    case noAction :
    case action (@lstring target @lstring action) :
      if not handlesRunAction then
        error outlet_mOutletTypeName : "the '" + outlet_mOutletTypeName + "' type does not handle run action"
      elsif target.string == "self" then
        [inActionMap searchKey !action]
        outTargetActionList +=
          !outlet_mOutletName.string
          !"self"
          !action.string
      else # It is a controller
        [inArrayControllerMap searchKey !target ?2*]
        outTargetActionList += !outlet_mOutletName.string !target.string !action.string
      end
    end
  #--- Enabled
    switch outlet_mEnabledBindingDescriptor
    case noEnabledBinding :
    case enabledBinding (@abstractBooleanMultipleBindingExpressionAST expression) :
      [expression analyzeExpressionForMultipleBinding
        !inRootObservablePropertyMap
        !inSemanticContext
        !inObservablePropertyMap
        !inArrayControllerMap
        ?let @abstractBooleanMultipleBindingExpressionForGeneration enableExpression
        ?let @typeKind type
        ?let @location errorLocation
      ]
      if not [type isBoolType] then
        error errorLocation : "expression is not boolean"
      end
      outMultipleBindingGenerationList +=
        !outlet_mOutletName.string
        !"enabled"
        !enableExpression
    end
  #--- Regular bindings
    for () in outlet_mRegularBindingList do
    #--- Analyse model
      var @outletBindingModelList boundModelTypeList = {}
      var @stringlist boundModelStringListForGeneration = {}
      for () in mObservablePropertyList do
        boundModelStringListForGeneration += ![mObservableProperty modelString]
        [mObservableProperty analyzeObservableProperty
          !inRootObservablePropertyMap
          !inSemanticContext
          !inObservablePropertyMap
          !inArrayControllerMap
          ?@typeKind type
          ?@propertyKind kind
          ?@propertyMultiplicity multiplicity
          ?let @string unused swiftTypeStringForTransientFunctionArgument
        ]
        if multiplicity != .single then
          error [mObservableProperty location]:"a collection cannot be bound"
        end
        boundModelTypeList += !type !kind ![mObservableProperty location]
      end
    #--- Analyze outlet binding
      [inSemanticContext.mBindingSpecificationMap searchKey
        !outlet_mOutletTypeName
        ?let @outletBindingSpecificationMap bindingMap
      ]
      [bindingMap searchKey
        !mBindingName
        ?let @outletBindingSpecificationModelList outletBindingSpecificationModelList
        ?let @controllerBindingOptionDecoratedList controllerBindingOptionDecoratedList
      ]
      if [boundModelTypeList length] != [outletBindingSpecificationModelList length] then
        error mBindingName : [[outletBindingSpecificationModelList length] string] + " model(s) required for this binding"
      else
        for () required_ in outletBindingSpecificationModelList, () found_ in boundModelTypeList do
          if required_mModelShouldBeWritableProperty && (found_mKind == .transient) then
            error found_mErrorLocation : "the model is transient and the binding requires an writable model"
          end
          if [required_mModelType isEnumType] && [found_mModelType isEnumType] then # Ok
          elsif [required_mModelType swiftTypeName] != [found_mModelType swiftTypeName] then
            error found_mErrorLocation : "the model type should be " + [required_mModelType swiftTypeName]
          end
        end
      end
    #--- Check options
      var bindingOptionString = ""
      if [controllerBindingOptionDecoratedList length] != [mBindingOptionList length] then
        @string s
        if [controllerBindingOptionDecoratedList length] == 0 then
          s = "this binding has no option"
        else 
          s = "this binding requires the following options:"
          for () in controllerBindingOptionDecoratedList do
            s += "\n  - " + mOptionName + " : " + [mOptionType swiftTypeName]
          end
        end
        error mBindingName : s
      else
        for () controller_ in controllerBindingOptionDecoratedList, () binding_ in mBindingOptionList do
          if controller_mOptionName.string != binding_mOptionName.string then
            error binding_mOptionName : "the option name should be '" + controller_mOptionName + "'"
          end
          [binding_mOptionValue analyzeDefaultValueType 
            !{!controller_mOptionType}
            ?let @string optionValueAsString
          ]
          bindingOptionString += ", " + controller_mOptionName.string + ":" + optionValueAsString
        end
      end
    #--- Generate binding
      outRegularBindingsGenerationList +=
        !outlet_mOutletName.string
        !mBindingName.string
        !boundModelStringListForGeneration
        !bindingOptionString
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#   GENERATION TYPES                                                                                                   *
#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*

list @regularBindingsGenerationList {
  @string mOutletName
  @string mBindingName
  @stringlist mBoundObjectStringList
  @string mBindingOptionsString
}

#......................................................................................................................*

list @actionBindingListForGeneration {
  @string mOutletName
  @string mTargetName
  @string mActionName
}

#......................................................................................................................*

map @decoratedOutletMap {
  @string mOutletTypeName
  insert insertKey error message "the '%K' outlet is already declared"
  search searchKey error message "the '%K' outlet is not declared"
}

#——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*
