

#----------------------------------------------------------------------------*

list @validationStubRoutineListForGeneration {
  @string mObjectTypeName
  @string mModelName
  @string mModelTypeName
}

#----------------------------------------------------------------------------*

struct @structForGeneration {
  @transientListForGeneration mTransientListForGeneration
  @actionListForGeneration mActionListForGeneration
  @preferenceListForGeneration mPreferenceListForGeneration
  @documentListForGeneration mDocumentListForGeneration
  @entityListForGeneration mEntityListForGeneration
  @enumListForGeneration mEnumListForGeneration
  @stringset mNeededOutletClasses
  @arrayControllerForGeneration mAllArrayControllerForGeneration
  @validationStubRoutineListForGeneration mValidationStubRoutineListForGeneration
}

#----------------------------------------------------------------------------*

proc typeAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @outletClassMap inOutletClassMap
  ?let @bindingSpecificationMap inTemplateControllerMap
  !@structForGeneration outGeneration
{
  outGeneration = @structForGeneration.default
  for (@lstring lkey
       @typeKind typeKind
       @unifiedTypeMap-proxy superType
       @unifiedTypeMap-proxy rootEntityType
       @decoratedAttributeMap decoratedAttributeMap
       @decoratedTransientMap decoratedTransientMap
       @decoratedOutletMap decoratedOutletMap
       @decoratedObservablePropertyMap observablePropertyMap
       @decoratedEntityRelationshipMap currentRelationshipMap
       @actionMap actionMap
       @lstringlist enumConstantList
       @enumConstantMap enumConstantMap
       @arrayControllerMap arrayControllerMap) in inUnifiedTypeMap do
   #--- Build all observable property map
      @decoratedObservablePropertyMap allObservableProperties = observablePropertyMap
      var t = superType
      loop( [inUnifiedTypeMap count]) while not [t isNull] do
        for () super_ in [t mObservablePropertyMap] do
          [!?allObservableProperties insertKey
            !super_lkey
            !super_mPropertyType
            !super_mIsTransient
            !super_mPropertySignature
            !super_mIsCollection
         ]
        end
        t = [t mSuperType]
      end 
    unifiedTypeAnalysis (
      !inUnifiedTypeMap
      !inOutletClassMap
      !inTemplateControllerMap
      !lkey
      !typeKind
      !superType
      !rootEntityType
      !decoratedAttributeMap
      !decoratedTransientMap
      !decoratedOutletMap
      !observablePropertyMap
      !currentRelationshipMap
      !allObservableProperties
      !actionMap
      !enumConstantList
      !enumConstantMap
      !arrayControllerMap
      !?outGeneration
    )  
  end
}

#----------------------------------------------------------------------------*

private proc unifiedTypeAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @outletClassMap inOutletClassMap
  ?let @bindingSpecificationMap inBindingSpecificationMap
  ?let @lstring inTypeName
  ?let @typeKind inTypeKind
  ?let @unifiedTypeMap-proxy inSuperType
  ?let @unifiedTypeMap-proxy inRootEntityType
  ?let @decoratedAttributeMap decoratedAttributeMap
  ?let @decoratedTransientMap decoratedTransientMap
  ?let @decoratedOutletMap decoratedOutletMap
  ?let @decoratedObservablePropertyMap inCurrentObservablePropertyMap
  ?let @decoratedEntityRelationshipMap inCurrentRelationshipMap
  ?let @decoratedObservablePropertyMap inAllObservablePropertyMap
  ?let @actionMap inActionMap
  ?let @lstringlist inEnumConstantList
  ?let @enumConstantMap inEnumConstantMap
  ?let @arrayControllerMap inArrayControllerMap
  ?!@structForGeneration ioGeneration
{
#-------------------------------------------- Outlets
  analyzeOutlets (
    !inUnifiedTypeMap
    !inOutletClassMap
    !inBindingSpecificationMap
    !inTypeName
    !inTypeKind
    !inSuperType
    !inRootEntityType
    !decoratedAttributeMap
    !decoratedTransientMap
    !decoratedOutletMap
    !inCurrentObservablePropertyMap
    !inCurrentRelationshipMap
    !inAllObservablePropertyMap
    !inActionMap
    !inEnumConstantList
    !inEnumConstantMap
    !inArrayControllerMap
    !?ioGeneration
    ?let @regularBindingsGenerationList regularBindingsGenerationList
    ?let @multipleBindingGenerationList multipleBindingGenerationList
    ?let @targetActionList targetActionList
  )
#--- Analyze relationships
  @entityRelationshipListForGeneration entityRelationshipListForGeneration = {}
  for () in inCurrentRelationshipMap do
    [[mRelationshipType mCurrentRelationshipMap] searchKey
      !mOppositeRelationshipName
      ?let @bool oppositeRelationIsToMany
      ?let @unifiedTypeMap-proxy oppositeRelationshipType
      ?let @lstring oppositeOfOppositeRelationshipName
    ]
    if oppositeOfOppositeRelationshipName.string != lkey.string then
      error lkey : "the opposite relationship is '" + mOppositeRelationshipName
         + "' and names '" + oppositeOfOppositeRelationshipName + "' as opposite, instead of '" + lkey + "'"
    end
    if [oppositeRelationshipType key] != inTypeName.string then
      error lkey : "the opposite relationship type is '" + [oppositeRelationshipType key] + "', instead of '" + lkey + "'"
    end
    entityRelationshipListForGeneration +=
      !lkey.string
      !mIsToMany
      !mRelationshipType
      !mOppositeRelationshipName.string
      !oppositeRelationIsToMany
  end
#--------------------------------------------- Analyze array controllers
  @arrayControllerForGeneration documentArrayControllerForGeneration = {}
  for () in inArrayControllerMap do
  #--- Check model is a tomany relationship
    [mBoundModel analyzeBoundObservablePropertyForArrayControllerBinding
      ![inRootEntityType mCurrentRelationshipMap]
      ?let @unifiedTypeMap-proxy outElementTypeProxy
      ?let @lstring outBoundRootTomanyRelationshipName
    ]
  #--- Check outlet is a PMTableView
    [decoratedOutletMap searchKey !mTableViewOutletName ?let outletTypeName ?3*]
    if outletTypeName.string != "PMTableView" then
      error mTableViewOutletName : "this outlet is not an instance of PMTableView"
    end
  #--- Check colum bound models
    @arrayControllerBoundColumnListForGeneration arrayControllerBoundColumnListForGeneration = {}
    for () in mArrayControllerBoundColumnListAST do
      [[outElementTypeProxy mObservablePropertyMap] searchKey
        !mObservablePropertyName
        ?let @unifiedTypeMap-proxy propertyType
        ?* #?@bool boundModelIsTransient
        ?* #?@lstring mPropertySignature
        ?let @bool mIsCollection
      ]
      if mIsCollection then
        error mObservablePropertyName : "the bound property should not be a collection"
      end
      arrayControllerBoundColumnListForGeneration +=
        !mColumnName.string
        !mColumnOutletTypeName.string
        !mObservablePropertyName.string
        !propertyType
        !mBindingOptionList
    end
    documentArrayControllerForGeneration +=
      !lkey.string
      ![inRootEntityType key]
      !outBoundRootTomanyRelationshipName.string
      ![outElementTypeProxy key]
      !mTableViewOutletName.string
      !arrayControllerBoundColumnListForGeneration
  end
  ioGeneration.mAllArrayControllerForGeneration += documentArrayControllerForGeneration
#------------------------------------------------- Analyze transient dependancies
  @transientDefinitionListForGeneration transientDefinitionListForGeneration = {}
  for () in decoratedTransientMap do
    @transientDependencyListForGeneration transientDependencyListForGeneration = {}
    for () in mDependencyList do
      if not [[mTransientType mTypeKind] suitableForObservableProperty] then
        error lkey : "the '" + [mTransientType key] + "' type is not acceptable for transient"
      end
      [mDependency transientDependencySemanticAnalysis
        !inUnifiedTypeMap
        !lkey
        !inAllObservablePropertyMap
        !inArrayControllerMap
        !inRootEntityType
        !mTransientSignature
        !?transientDependencyListForGeneration
      ]
    end
    @dependanceListForGeneration dependencyListForGeneration = {}
    for () in mDependencyList do
      dependencyListForGeneration += ![mDependency buildDecoratedRepresentation !inRootEntityType]
    end
    transientDefinitionListForGeneration +=
      !lkey.string
      !mTransientType
      !mTransientSignature
      !dependencyListForGeneration
    ioGeneration.mTransientListForGeneration += !mTransientSignature.string !mTransientType !transientDependencyListForGeneration  
  end
#--- Analyze attributes default value
  @attributeListForGeneration attributeListForGeneration = {}
  for () in decoratedAttributeMap do
    [mDefaultValue analyzeDefaultValueType 
      !{!mAttributeType}
      ?let @string swiftDefaultValueAsString
    ]
    attributeListForGeneration += !mAttributeType !lkey.string !swiftDefaultValueAsString !mNeedsValidation
    if mNeedsValidation then
      ioGeneration.mValidationStubRoutineListForGeneration +=
        !inTypeName.string
        !lkey.string
        ![mAttributeType swiftTypeName]
    end
  end
#--- Build action list
  for () action_ in inActionMap do
    ioGeneration.mActionListForGeneration += !inTypeName.string !action_lkey.string
  end
#--- Build generation lists
  switch inTypeKind
  case enumType :
    ioGeneration.mEnumListForGeneration +=
      !inTypeName.string
      !inEnumConstantList
  case entityType :
    ioGeneration.mEntityListForGeneration +=
      !inTypeName.string
      !if [inSuperType isNull] then "" else [inSuperType key] end
      !attributeListForGeneration
      !transientDefinitionListForGeneration
      !entityRelationshipListForGeneration
  case documentType :
    ioGeneration.mDocumentListForGeneration +=
      !inTypeName.string
      ![inRootEntityType key]
      !attributeListForGeneration
      !transientDefinitionListForGeneration
      !decoratedOutletMap
      !documentArrayControllerForGeneration
      !targetActionList
      !regularBindingsGenerationList
      !multipleBindingGenerationList
  case preferencesType :
    ioGeneration.mPreferenceListForGeneration +=
      !inTypeName.string
      !attributeListForGeneration
      !transientDefinitionListForGeneration
      !decoratedOutletMap
      !regularBindingsGenerationList
      !multipleBindingGenerationList
  case bezierPathType, boolType, colorType, classType, controllerClassType, dataType, dateType,
       doubleType, fontType, imageType, integerType, menuType, nibClassType, outletClassType,
       protocolType, stringType, structType, uintegerType:
  end
}

#----------------------------------------------------------------------------*

abstract method @abstractTransientDependencyAST transientDependencySemanticAnalysis
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @lstring inTransientName
  ?let @decoratedObservablePropertyMap inAllObservablePropertyMap
  ?let @arrayControllerMap inArrayControllerMap
  ?let @unifiedTypeMap-proxy inRootEntityType
  ?let @lstring inTransientPropertySignature
  ?!@transientDependencyListForGeneration ioTransientDependencyListForGeneration

#----------------------------------------------------------------------------*
# analyzeBoundObservablePropertyForEnabledBinding                            *
#----------------------------------------------------------------------------*

#! analyzeBoundObservablePropertyForEnabledBinding

#----------------------------------------------------------------------------*

abstract method @abstractObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ?let @string inSelfTypeName
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @arrayControllerMap inArrayControllerMap
  ?let @decoratedObservablePropertyMap inObservablePropertyMap
  ?let @unifiedTypeMap-proxy inRootEntityType
  !@abstractBooleanMultipleBindingExpressionForGeneration outExpression

#----------------------------------------------------------------------------*

override method @selfObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ?let @string unused inSelfTypeName
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @decoratedObservablePropertyMap inObservablePropertyMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  !@abstractBooleanMultipleBindingExpressionForGeneration outExpression
{
  [inObservablePropertyMap searchKey
    !mSelfObservablePropertyName
    ?let @unifiedTypeMap-proxy propertyType
    ?* #outModelIsTransient
    ?* #?@lstring propertySignature
    ?let @bool isCollection
  ]
  if not [[propertyType mTypeKind] isBoolType] then
    error mSelfObservablePropertyName: "this property should be boolean"
  elsif isCollection then
    error mSelfObservablePropertyName : "the observable property should not be a collection"
  end
  outExpression = @observablePropertyAsBooleanMultipleBindingExpressionForGeneration.new {
    !"self." + mSelfObservablePropertyName
  }
}

#----------------------------------------------------------------------------*

override method @rootObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ?let @string unused inSelfTypeName
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @decoratedObservablePropertyMap unused inObservablePropertyMap
  ?let @unifiedTypeMap-proxy inRootEntityType
  !@abstractBooleanMultipleBindingExpressionForGeneration outExpression
{
#  outObservedTypeName := [inRootEntityType key] ;
  [[inRootEntityType mObservablePropertyMap] searchKey
    !mRootObservablePropertyName
    ?let @unifiedTypeMap-proxy propertyType
    ?* #outModelIsTransient
    ?* #?@lstring propertySignature
    ?* #?@bool isCollection
  ]
  if not [[propertyType mTypeKind] isBoolType] then
    error mRootObservablePropertyName: "this property should be boolean"
  end
#  if isCollection & not mNamesCountOption then
#    error mRootObservablePropertyName : "the observable property should not be a collection" ;
#  elsif mNamesCountOption & not isCollection then
#    error mRootObservablePropertyName : "the observable property should be a collection" ;
#  end if ;
  outExpression = @observablePropertyAsBooleanMultipleBindingExpressionForGeneration.new {
    !"self.rootObject." + mRootObservablePropertyName
  }
}

#----------------------------------------------------------------------------*

override method @preferenceObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ?let @string unused inSelfTypeName
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?let @arrayControllerMap unused inArrayControllerMap
  ?let @decoratedObservablePropertyMap unused inObservablePropertyMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  !@abstractBooleanMultipleBindingExpressionForGeneration outExpression
{
#--- Get preference type
  [inUnifiedTypeMap searchKey
    !mPreferenceName
    ?let @typeKind typeKind
    ?5*
    ?let @decoratedObservablePropertyMap observablePropertyMap
    ?5*
  ]
  if typeKind != @typeKind. preferencesType then
    error mPreferenceName : "there is no '" + mPreferenceName + "' preferences"
  end
#---    
  [observablePropertyMap searchKey
    !mPreferenceObservablePropertyName
    ?let @unifiedTypeMap-proxy propertyType
    ?* #outModelIsTransient
    ?* #?@lstring propertySignature
    ?let @bool isCollection
  ]
  if not [[propertyType mTypeKind] isBoolType] then
    error mPreferenceObservablePropertyName: "this property should be boolean"
  end
  if isCollection then
    error mPreferenceObservablePropertyName : "the observable property should not be a collection"
  end
  outExpression = @observablePropertyAsBooleanMultipleBindingExpressionForGeneration. new {
    !"g_" + mPreferenceName + "!." + mPreferenceObservablePropertyName
  }
}

#----------------------------------------------------------------------------*

override method @arrayControllerObservablePropertyAST analyzeBoundObservablePropertyForEnabledBinding
  ?let @string unused inSelfTypeName
  ?let @unifiedTypeMap unused inUnifiedTypeMap
  ?let @arrayControllerMap inArrayControllerMap
  ?let @decoratedObservablePropertyMap unused inObservablePropertyMap
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  !@abstractBooleanMultipleBindingExpressionForGeneration outExpression
{
#--- Get preference type
  [inArrayControllerMap searchKey
    !mArrayControllerName
    ?* # ?@abstractObservablePropertyAST boundModel
    ?3*
    ?let @decoratedObservablePropertyMap arrayControllerObservablePropertyMap
    ?*
    ?* # let @string observedTypeName
  ]
#---    
  [arrayControllerObservablePropertyMap searchKey
    !mArrayControllerObservablePropertyName
    ?let @unifiedTypeMap-proxy propertyType
    ?* # outModelIsTransient
    ?* #?@lstring propertySignature
    ?let @bool isCollection
  ]
  if not [[propertyType mTypeKind] isBoolType] then
    error mArrayControllerObservablePropertyName: "this property should be boolean"
  end
  if isCollection then
    error mArrayControllerObservablePropertyName : "the observable property should not be a collection"
  end
  outExpression = @observablePropertyAsBooleanMultipleBindingExpressionForGeneration.new {
    !"self." + mArrayControllerName + "." + mArrayControllerObservablePropertyName
  }
}

#----------------------------------------------------------------------------*
# analyzeBoundObservablePropertyForArrayControllerBinding                    *
#----------------------------------------------------------------------------*

#! analyzeBoundObservablePropertyForArrayControllerBinding

#----------------------------------------------------------------------------*

abstract method @abstractObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ?let @decoratedEntityRelationshipMap inCurrentRelationshipMap
  !@unifiedTypeMap-proxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName

#----------------------------------------------------------------------------*

override method @selfObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ?let @decoratedEntityRelationshipMap unused inCurrentRelationshipMap
  !@unifiedTypeMap-proxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName {
  error mSelfObservablePropertyName
    : "the bound array should be a root object model"
    : outBoundRootTomanyRelationshipName, outRelationshipTypeProxy
}

#----------------------------------------------------------------------------*

override method @rootObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ?let @decoratedEntityRelationshipMap inCurrentRelationshipMap
  !@unifiedTypeMap-proxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName {
  [inCurrentRelationshipMap searchKey
    !mRootObservablePropertyName
    ?let @bool mIsToMany
    ?outRelationshipTypeProxy
    ?*
  ]
  if not mIsToMany then
    error mRootObservablePropertyName : "the observable property should be a tomany relationship"
  end
  outBoundRootTomanyRelationshipName = mRootObservablePropertyName
}

#----------------------------------------------------------------------------*

override method @preferenceObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ?let @decoratedEntityRelationshipMap unused inCurrentRelationshipMap
  !@unifiedTypeMap-proxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName {
  error mPreferenceObservablePropertyName
    : "the bound array should be a root object model"
    : outBoundRootTomanyRelationshipName, outRelationshipTypeProxy
}

#----------------------------------------------------------------------------*

override method @arrayControllerObservablePropertyAST analyzeBoundObservablePropertyForArrayControllerBinding
  ?let @decoratedEntityRelationshipMap unused inCurrentRelationshipMap
  !@unifiedTypeMap-proxy outRelationshipTypeProxy
  !@lstring outBoundRootTomanyRelationshipName {
  error mArrayControllerObservablePropertyName
    : "the bound array should be a root object model"
    : outBoundRootTomanyRelationshipName, outRelationshipTypeProxy
}

#----------------------------------------------------------------------------*
# propertySignature                                                          *
#----------------------------------------------------------------------------*

#! propertySignature

#----------------------------------------------------------------------------*

abstract getter @abstractObservablePropertyAST propertySignature
  ?let @string inKind
  ?let @string inSelfTypeName
  ?let @unifiedTypeMap-proxy inRootypeProxy
  -> @lstring outSignature

#----------------------------------------------------------------------------*

override getter @selfObservablePropertyAST propertySignature
  ?let @string inKind
  ?let @string inSelfTypeName
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  -> @lstring outSignature {
  outSignature = @lstring. new {
    !inKind + "." + inSelfTypeName + "." + mSelfObservablePropertyName
    !mSelfObservablePropertyName.location}
}

#----------------------------------------------------------------------------*

override getter @rootObservablePropertyAST propertySignature
  ?let @string unused inKind
  ?let @string unused inSelfTypeName
  ?let @unifiedTypeMap-proxy inRootypeProxy
  -> @lstring outSignature {
  outSignature = @lstring. new {
    !"entity." + [inRootypeProxy key] + "." + mRootObservablePropertyName
    !mRootObservablePropertyName.location}
}

#----------------------------------------------------------------------------*

override getter @preferenceObservablePropertyAST propertySignature
  ?let @string unused inKind
  ?let @string unused inSelfTypeName
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  -> @lstring outSignature {
  outSignature = @lstring. new {
    !"preferences." + mPreferenceName + "." + mPreferenceObservablePropertyName
    !mPreferenceObservablePropertyName.location}
}

#----------------------------------------------------------------------------*

override getter @arrayControllerObservablePropertyAST propertySignature
  ?let @string inKind
  ?let @string inSelfTypeName
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  -> @lstring outSignature {
  outSignature = @lstring. new {
    !inKind + "." + inSelfTypeName + "." + mArrayControllerObservablePropertyName
    !mArrayControllerObservablePropertyName.location}
}

#----------------------------------------------------------------------------*
# arrayControllerTypeName                                                    *
#----------------------------------------------------------------------------*

#! arrayControllerTypeName

#----------------------------------------------------------------------------*

abstract getter @abstractObservablePropertyAST arrayControllerTypeName
  ?let @string inSelfTypeName
  ?let @unifiedTypeMap-proxy inRootypeProxy
  -> @string outTypeName

#----------------------------------------------------------------------------*

override getter @selfObservablePropertyAST arrayControllerTypeName
  ?let @string inSelfTypeName
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  -> @string outTypeName {
  outTypeName = "ArrayController_" + inSelfTypeName + "_" + mSelfObservablePropertyName
}

#----------------------------------------------------------------------------*

override getter @rootObservablePropertyAST arrayControllerTypeName
  ?let @string unused inSelfTypeName
  ?let @unifiedTypeMap-proxy inRootypeProxy
  -> @string outTypeName {
  outTypeName = "ArrayController_" + [inRootypeProxy key] + "_" + mRootObservablePropertyName
}

#----------------------------------------------------------------------------*

override getter @preferenceObservablePropertyAST arrayControllerTypeName
  ?let @string unused inSelfTypeName
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  -> @string outTypeName {
  outTypeName = "ArrayController_" + mPreferenceName + "_" + mPreferenceObservablePropertyName
}

#----------------------------------------------------------------------------*

override getter @arrayControllerObservablePropertyAST arrayControllerTypeName
  ?let @string inSelfTypeName
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  -> @string outTypeName {
  outTypeName = "ArrayController_" + inSelfTypeName + "_" + mArrayControllerObservablePropertyName
}

#----------------------------------------------------------------------------*
# modelSignatureForArrayController                                           *
#----------------------------------------------------------------------------*

#! modelSignatureForArrayController

#----------------------------------------------------------------------------*

abstract getter @abstractObservablePropertyAST modelSignatureForArrayController
  ?let @unifiedTypeMap-proxy inRootypeProxy
  ?let @string inSelfTypeName
  -> @string outSignature

#----------------------------------------------------------------------------*

override getter @selfObservablePropertyAST modelSignatureForArrayController
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  ?let @string inSelfTypeName
  -> @string outSignature {
  outSignature = inSelfTypeName + "_" + mSelfObservablePropertyName
}

#----------------------------------------------------------------------------*

override getter @rootObservablePropertyAST modelSignatureForArrayController
  ?let @unifiedTypeMap-proxy inRootypeProxy
  ?let @string unused inSelfTypeName
  -> @string outSignature {
  outSignature = [inRootypeProxy key] + "_" + mRootObservablePropertyName
}

#----------------------------------------------------------------------------*

override getter @preferenceObservablePropertyAST modelSignatureForArrayController
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  ?let @string unused inSelfTypeName
  -> @string outSignature {
  outSignature = mPreferenceName.string + "_" + mPreferenceObservablePropertyName
}

#----------------------------------------------------------------------------*

override getter @arrayControllerObservablePropertyAST modelSignatureForArrayController
  ?let @unifiedTypeMap-proxy unused inRootypeProxy
  ?let @string inSelfTypeName
  -> @string outSignature {
  outSignature = inSelfTypeName + "_" + mArrayControllerObservablePropertyName
}

#----------------------------------------------------------------------------*
#! buildDecoratedRepresentation
#----------------------------------------------------------------------------*

abstract getter @abstractTransientDependencyAST buildDecoratedRepresentation
  ?let @unifiedTypeMap-proxy inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult

#----------------------------------------------------------------------------*

override getter @transientRootSignDependencyAST buildDecoratedRepresentation
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult {
  outResult = @transientRootSignDependencyForGeneration. new { !mDeclarationLocation}
}

#----------------------------------------------------------------------------*

override getter @transientLocalDependencyAST buildDecoratedRepresentation
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult {
  outResult = @transientLocalDependencyForGeneration. new { !mMasterName !mNamesCountOption}
}

#----------------------------------------------------------------------------*

override getter @transientRootDependencyAST buildDecoratedRepresentation
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult {
  outResult = @transientRootDependencyForGeneration. new { !mMasterName !mNamesCountOption}
}

#----------------------------------------------------------------------------*

override getter @transientRootRelationshipDependencyAST buildDecoratedRepresentation
  ?let @unifiedTypeMap-proxy inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult {
  [[inRootEntityType mCurrentRelationshipMap] searchKey
    !mRelationshipName
    ?*
    ?let @unifiedTypeMap-proxy elementType
    ?*
  ]
  outResult = @transientRootRelationshipDependencyForGeneration. new { !elementType !mRelationshipName !mMasterName}
}

#----------------------------------------------------------------------------*

override getter @transientControllerDependencyAST buildDecoratedRepresentation
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult {
  outResult = @transientControllerDependencyForGeneration. new { !mControllerName !mMasterName}
}

#----------------------------------------------------------------------------*

override getter @transientPreferenceDependencyAST buildDecoratedRepresentation
  ?let @unifiedTypeMap-proxy unused inRootEntityType
  -> @abstractTransientDependencyForGeneration outResult {
  outResult = @transientPreferenceDependencyForGeneration. new { !mPreferencesName !mMasterName}
}

#----------------------------------------------------------------------------*

