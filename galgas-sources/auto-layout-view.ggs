//----------------------------------------------------------------------------------------------------------------------
#   AST
//----------------------------------------------------------------------------------------------------------------------

abstract class @astAbstractViewDeclaration {
}

//----------------------------------------------------------------------------------------------------------------------

class @astComputedHorizontalViewDeclaration : @astAbstractViewDeclaration {
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @astViewInstructionList mInstructionList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//----------------------------------------------------------------------------------------------------------------------

class @astComputedVerticalViewDeclaration : @astAbstractViewDeclaration {
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @astViewInstructionList mInstructionList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//----------------------------------------------------------------------------------------------------------------------

list @astViewDeclarationList {
  public let @lstring mViewName
  public let @astAbstractViewDeclaration mView
}

//----------------------------------------------------------------------------------------------------------------------

abstract class @astAbstractViewInstructionDeclaration {
}

//----------------------------------------------------------------------------------------------------------------------

class @astSeparatorInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @bool horizontal %selector
}

//----------------------------------------------------------------------------------------------------------------------

class @astDividerInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @bool horizontal %selector
}

//----------------------------------------------------------------------------------------------------------------------

enum @optionalHiddenBinding {
  case noBinding
  case binding (@abstractBooleanMultipleBindingExpressionAST hidden)
}

//----------------------------------------------------------------------------------------------------------------------

class @astHStackViewInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @astViewInstructionList mInstructionList
  public let @optionalHiddenBinding mOptionalHiddenBinding
  public let @astNewStackViewDeclarationList mAstNewStackViewDeclarationList
}

//----------------------------------------------------------------------------------------------------------------------

class @astVStackViewInstructionDeclaration : @astAbstractViewInstructionDeclaration {
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @astViewInstructionList mInstructionList
  public let @optionalHiddenBinding mOptionalHiddenBinding
  public let @astNewStackViewDeclarationList mAstNewStackViewDeclarationList
}

//----------------------------------------------------------------------------------------------------------------------

list @astNewStackViewDeclarationList {
  public let @lstring mInstanciedStackViewName
  public let @lstring mTypeStackViewName
}

//----------------------------------------------------------------------------------------------------------------------

class @astSpaceViewInstruction : @astAbstractViewInstructionDeclaration {
}

//----------------------------------------------------------------------------------------------------------------------

class @astLocalViewInstruction : @astAbstractViewInstructionDeclaration {
  public let @lstring mLocalView
}

//----------------------------------------------------------------------------------------------------------------------

class @astComputedViewInstruction : @astAbstractViewInstructionDeclaration {
  public let @lstring mAutoLayoutViewClassName
  public let @astAutoLayoutViewInstructionParameterList mParameterList
  public let @astAutoLayoutViewFunctionCallList mFunctionCallList
  public let @tableValueBinding mTableValueBinding
  public let @runActionDescriptor mRunActionDescriptor
  public let @multipleBindingDescriptor mEnabledBindingDescriptor
  public let @multipleBindingDescriptor mHiddenBindingDescriptor
  public let @graphicController mGraphicController
  public let @regularBindingList mRegularBindingList
  public let @lstring mConfiguratorName # Empty string if no configurator
  public let @lstring mOutletName # Empty string if no configurator
  public let @bool mOutletIsArray
}

//----------------------------------------------------------------------------------------------------------------------

list @astAutoLayoutViewFunctionCallList {
  public let @lstring mFunctionName
  public let @astAutoLayoutViewInstructionParameterList mParameterList
}

//----------------------------------------------------------------------------------------------------------------------

enum @astAutoLayoutViewInstructionParameterValue {
  case string (@string value)
  case menuItem (@string title @runActionDescriptor run @multipleBindingDescriptor enabled)
  case enumFunc (@lstring enumTypeName @lstring enumFuncName)
  case viewFunc (@astAbstractViewInstructionDeclaration instruction)
  case entity (@lstring entityName)
}

//----------------------------------------------------------------------------------------------------------------------

list @astAutoLayoutViewInstructionParameterList {
  public let @lstring mParameterName
  public let @autoLayoutClassParameterType mParameterType
  public let @astAutoLayoutViewInstructionParameterValue mParameter
}

//----------------------------------------------------------------------------------------------------------------------

list @astViewInstructionList {
  public let @astAbstractViewInstructionDeclaration mInstruction
}

//----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
//----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <stack_view_declaration> (?!@astViewDeclarationList ioViewDeclarationList) {
    $stackView$
    $viewName$ (?let viewName)
    $vStack$
    <auto_layout_func_call_list> (!?*, ?let functionCallList)
    ${$
    var @astNewStackViewDeclarationList astNewStackViewDeclarationList = []
    var @stringset stackViewInstances = []
    var instructionList = @astViewInstructionList []
    <view_instruction_list> (!horizontal: false, !?stackViewInstances, !?astNewStackViewDeclarationList, !?instructionList)
    $}$
    ioViewDeclarationList +=
      !viewName
      !@astComputedVerticalViewDeclaration (functionCallList, instructionList, astNewStackViewDeclarationList)
  }
 
  #·····················································································································
  
  rule <stack_view_declaration> (?!@astViewDeclarationList ioViewDeclarationList) {
    $stackView$
    $viewName$ (?let viewName)
    $hStack$
    <auto_layout_func_call_list> (!?*, ?let functionCallList)
    ${$
    var @astNewStackViewDeclarationList astNewStackViewDeclarationList = []
    var @stringset stackViewInstances = []
    var instructionList = @astViewInstructionList []
    <view_instruction_list> (!horizontal: true, !?stackViewInstances, !?astNewStackViewDeclarationList, !?instructionList)
    $}$
    ioViewDeclarationList +=
      !viewName
      !@astComputedHorizontalViewDeclaration (functionCallList, instructionList, astNewStackViewDeclarationList)
  }
 
  #·····················································································································
  
  rule <auto_layout_func_call_list> (?!@stringset ioStackViewInstances,
                                     !@astAutoLayoutViewFunctionCallList outFunctionCallList) {
   outFunctionCallList = []
   repeat
    while
       $identifier$ (?let functionName)
       <view_actual_parameter_list> (!?ioStackViewInstances, ?let actualParameterList)
       outFunctionCallList += !functionName !actualParameterList
    end
  }
   
  #·····················································································································
 
  rule <view_instruction_list> (?horizontal: @bool inHorizontal,
                                ?!@stringset ioStackViewInstances,
                                ?!@astNewStackViewDeclarationList ioNewStackViewDeclarationList,
                                ?!@astViewInstructionList ioInstructionList) {
    repeat
    while
      $newView$
      $identifier$ (?let instancedStackViewName)
      ioStackViewInstances += !instancedStackViewName
      $=$
      $viewName$ (?let typeStackViewName)
      $($
      $)$
      ioNewStackViewDeclarationList += !instancedStackViewName !typeStackViewName
    while
      $separator$
      ioInstructionList += !@astSeparatorInstructionDeclaration (!horizontal: inHorizontal)
    while
      $divider$
      ioInstructionList += !@astDividerInstructionDeclaration (!horizontal: inHorizontal)
    while
      $view$
      $identifier$ (?let localViewName)
      if not ioStackViewInstances.hasKey (localViewName.string) then
        error localViewName : "the view is not instancied"
      end
      ioInstructionList += !@astLocalViewInstruction (localViewName)
    while
      <view_instruction> (!?ioStackViewInstances, ?let instruction)
      ioInstructionList += !instruction
    end
  }
  
  #·····················································································································
 
  rule <view_instruction> (?!@stringset unused ioStackViewInstances,
                           !@astAbstractViewInstructionDeclaration outInstruction) {
    $space$
    outInstruction = @astSpaceViewInstruction ()
  }
  
 #·····················································································································
 
  rule <view_instruction> (?!@stringset ioStackViewInstances,
                           !@astAbstractViewInstructionDeclaration outInstruction) {
    <computed_view_instruction> (!?ioStackViewInstances, ?let instruction)
    outInstruction = instruction
  }
  
  #·····················································································································
 
  rule <computed_view_instruction> (?!@stringset ioStackViewInstances,
                                    !@astComputedViewInstruction outInstruction) {
    $Identifier$ (? let viewClassName)
    let @astAutoLayoutViewInstructionParameterList instanciationParameterList
    select
      instanciationParameterList = []
    or
      <view_actual_parameter_list> (!?ioStackViewInstances, ?instanciationParameterList)
    end
    let @lstring configuratorName
    let @lstring outletName
    let @bool outletIsArray
    select
      outletName = "".nowhere ()
      configuratorName = "".nowhere ()
      outletIsArray = false
    or
      $[$
      select
        outletName = "".nowhere ()
        outletIsArray = false
      or
        $outlet$
        $identifier$ (?outletName)
        outletIsArray = false
      or
        $outletArray$
        $identifier$ (?outletName)
        outletIsArray = true
      end
      select
        configuratorName = "".nowhere ()
      or
        $configurator$
        $identifier$ (?configuratorName)
      end
      $]$
    end
    let @tableValueBinding tableValueBinding
    let @runActionDescriptor runActionDescriptor
    let @multipleBindingDescriptor enabledBindingDescriptor
    let @multipleBindingDescriptor hiddenBindingDescriptor
    let @graphicController graphicController
    let @regularBindingList regularBindingList
    let @astAutoLayoutViewFunctionCallList autoLayoutViewFunctionCallList
    select
      tableValueBinding = .noTableValueBinding
      runActionDescriptor = .noAction
      enabledBindingDescriptor = .noBinding
      hiddenBindingDescriptor = .noBinding
      graphicController = .none
      regularBindingList = []
      autoLayoutViewFunctionCallList = []
    or
      ${$
      <auto_layout_func_call_list> (!?ioStackViewInstances, ?autoLayoutViewFunctionCallList)
      <outlet_binding> (?tableValueBinding,
                        ?runActionDescriptor,
                        ?enabledBindingDescriptor,
                        ?hiddenBindingDescriptor,
                        ?graphicController,
                        ?regularBindingList)
      $}$
    end
    outInstruction = @astComputedViewInstruction (
      viewClassName,
      instanciationParameterList,
      autoLayoutViewFunctionCallList,
      tableValueBinding,
      runActionDescriptor,
      enabledBindingDescriptor,
      hiddenBindingDescriptor,
      graphicController,
      regularBindingList,
      configuratorName,
      outletName,
      outletIsArray
    )
  }
  
 #·····················································································································
 
  rule <view_actual_parameter_list> (?!@stringset ioStackViewInstances,
                                     !@astAutoLayoutViewInstructionParameterList outParameterList) {
    outParameterList = []
    $($
    select
    or
      repeat
        $identifier$ (?let parameterName)
        $:$
        select
          <view_instruction> (!?ioStackViewInstances, ?let @astAbstractViewInstructionDeclaration instruction)
          outParameterList += !parameterName !.typeView !.viewFunc (!instruction: instruction)
        or
          $entity$
          $Identifier$ (?let entityName)
          outParameterList += !parameterName !.entity !.entity(!entityName: entityName)
        or
          $menuItem$
          $literal_string$ (?let menuItemTitle)
          let @runActionDescriptor runActionDescriptor
          select
            runActionDescriptor = .noAction
          or
            $run$
            let @lstring runTargetName
            select
              runTargetName = @lstring ("self", .here)
            or
              $controllerName$ (?runTargetName)
              $.$
            end
            $identifier$ (?let @lstring runActionName)
            runActionDescriptor = .action (!target:runTargetName, !action:runActionName)
          end
          var @multipleBindingDescriptor enabledBindingDescriptor = .noBinding
          select
            enabledBindingDescriptor = .noBinding
          or
            $enabled$
            <booleanMultipleBindingExpression> (?let @abstractBooleanMultipleBindingExpressionAST bindingExpression)
            enabledBindingDescriptor = .binding (!expression:bindingExpression)
          end
          outParameterList +=
           !parameterName
           !.menuItem
           !.menuItem (!title: menuItemTitle, !run: runActionDescriptor, !enabled: enabledBindingDescriptor)
        or
          $view$
          $identifier$ (?let viewName)
          if not ioStackViewInstances.hasKey (viewName.string) then
            error viewName : "view is not instancied"
          end
          outParameterList += !parameterName !.typeView !.string (!value: viewName.string)
        or
          $yes$
          outParameterList += !parameterName !.typeBool !.string (!value: "true")
        or
          $no$
          outParameterList += !parameterName !.typeBool !.string (!value: "false")
        or
          $literal_integer$ (?let uint32)
          outParameterList += !parameterName !.typeInt !.string (!value: uint32.uint.string ())
        or
          $-$
          $literal_integer$ (?let uint32)
          outParameterList += !parameterName !.typeInt !.string (!value: "-" + uint32.uint.string ())
        or
          $literal_string$ (?let literalString)
          outParameterList += !parameterName !.typeString !.string (!value: literalString.string.utf8Representation ())
        or
          $.$
          $identifier$ (?let enumConstantName)
          outParameterList += !parameterName !.typeEnum (!name: enumConstantName) !.string (!value: "." + enumConstantName)
        or
          $enum$
          $Identifier$ (?let enumTypeName)
          $.$
          $identifier$ (?let enumFuncName)
          outParameterList +=
            !parameterName 
            !.typeStringArray !.enumFunc (!enumTypeName: enumTypeName, !enumFuncName: enumFuncName)
        end
      while
        $,$
      end
    end
    $)$
  }
  
  #·····················································································································
 
  rule <view_instruction> (?!@stringset ioStackViewInstances,
                           !@astAbstractViewInstructionDeclaration outInstruction) {
    $vStack$
    <auto_layout_func_call_list> (!?ioStackViewInstances, ?let functionCallList)
    let @optionalHiddenBinding optionalHiddenBinding
    select
      optionalHiddenBinding = .noBinding
    or
      $hidden$
      <booleanMultipleBindingExpression> (?let @abstractBooleanMultipleBindingExpressionAST bindingExpression)
      optionalHiddenBinding = .binding (!hidden: bindingExpression)
    end
    ${$
    var @astNewStackViewDeclarationList astNewStackViewDeclarationList = []
    var instructionList = @astViewInstructionList []
    <view_instruction_list> (!horizontal: false, !?ioStackViewInstances, !?astNewStackViewDeclarationList, !?instructionList)
    outInstruction = @astVStackViewInstructionDeclaration (functionCallList, instructionList, optionalHiddenBinding, astNewStackViewDeclarationList)
    $}$
  }
  
  #·····················································································································
 
  rule <view_instruction> (?!@stringset ioStackViewInstances,
                           !@astAbstractViewInstructionDeclaration outInstruction) {
    $hStack$
    <auto_layout_func_call_list> (!?ioStackViewInstances, ?let functionCallList)
    let @optionalHiddenBinding optionalHiddenBinding
    select
      optionalHiddenBinding = .noBinding
    or
      $hidden$
      <booleanMultipleBindingExpression> (?let @abstractBooleanMultipleBindingExpressionAST bindingExpression)
      optionalHiddenBinding = .binding (!hidden: bindingExpression)
    end
    ${$
    var @astNewStackViewDeclarationList astNewStackViewDeclarationList = []
    var instructionList = @astViewInstructionList []
    <view_instruction_list> (!horizontal: true, !?ioStackViewInstances, !?astNewStackViewDeclarationList, !?instructionList)
    outInstruction = @astHStackViewInstructionDeclaration (functionCallList, instructionList, optionalHiddenBinding, astNewStackViewDeclarationList)
    $}$
  }
  
   #·····················································································································

}

//----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC ANALYSIS                            
//----------------------------------------------------------------------------------------------------------------------

map @autoLayoutViewDeclarationMap {
  insert insertKey error message "the '%K' view is already declared in %L"
  search searchKey error message "there is no '%K' view"
}

//----------------------------------------------------------------------------------------------------------------------

map @autoLayoutConfiguratorMap {
  public let @string mAutoLayoutOutletTypeName
  insert insertKey error message "the '%K' configurator is already declared in %L"
  search searchKey error message "there is no '%K' configurator"
}

//----------------------------------------------------------------------------------------------------------------------

map @autoLayoutOutletMap {
  public let @string mAutoLayoutOutletTypeName
  public let @bool mOutletIsArray
  insert insertKey error message "the '%K' outlet is already declared in %L"
  search searchKey error message "there is no '%K' outlet"
}

#·······················································································································

list @implicitViewFunctionGenerationList {
  public let @abstractViewInstructionGeneration mInstruction
}

#·······················································································································

abstract proc @astAbstractViewDeclaration.checkView(
  let @string inViewName,
  let @autoLayoutViewDeclarationMap inViewDeclarationMap,
  ?prefs: let @bool inPreferences,
  let @propertyMap inRootObservablePropertyMap,
  let @propertyMap inPreferencesPropertyMap,
  let @semanticContext inSemanticContext,
  let @propertyMap inObservablePropertyMap,
  let @actionMap inActionMap,
  let @string inReceiverSwiftTypeName,
  let @classMap inClassMap,
  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
  ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
  ?!@autoLayoutOutletMap ioOutletMap,
  !@abstractViewGeneration outGeneration)

#·······················································································································

proc @astAutoLayoutViewFunctionCallList.checkViewFunctionCallList(
                                let @astAutoLayoutViewFunctionMap inFunctionMap,
                                let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                let @bool inPreferences,
                                let @propertyMap inRootObservablePropertyMap,
                                let @propertyMap inPreferencesPropertyMap,
                                let @semanticContext inSemanticContext,
                                let @propertyMap inObservablePropertyMap,
                                let @actionMap inActionMap,
                                let @string inReceiverSwiftTypeName,
                                let @classMap inClassMap,
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                ?!@autoLayoutOutletMap ioOutletMap,
                                !@autoLayoutViewInstructionGenerationFuncCallList outFuncCallList) {
  outFuncCallList = []
  for (functionName actualParameterList) in self do
    var mangleName = functionName.string + "("
    for (parameterName 2*) in actualParameterList do
      mangleName += parameterName.string + ":"
    end
    mangleName += ")"
    inFunctionMap.searchKey (.new (mangleName, functionName.location), ?let formalParameterList)
    var @autoLayoutViewInstructionGenerationParameterList parameterList = []
    if formalParameterList.count () != actualParameterList.count () then
      error functionName 
      : formalParameterList.count ().string () + " parameter(s) required, " + actualParameterList.count () + " provided"
    else
      for (name type value) in actualParameterList, (formalName formalType) in formalParameterList do
        if let [formalType typeEnum ?name: let enumTypeName], let [type typeEnum ?name: let constantName] then
          inClassMap.searchKey (enumTypeName, ?let typeKind, ?3*)
          if let [typeKind atomic ?kind: let classKind], let [classKind enumType ?1* ?constantMap: let constantMap ?1*] then
            constantMap.searchKey (constantName, ?*)
          else
            error enumTypeName : "this type name is not an enum"
          end
        elsif type != formalType then
          error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
        end
        if name.string != formalName.string then
          error name : "the parameter name should be '" + formalName + "'"
        end
        switch value
        case viewFunc (instruction) :
          instruction.generateViewCode 
            (inViewDeclarationMap,
            !prefs: inPreferences,
            inRootObservablePropertyMap,
            inPreferencesPropertyMap,
            inSemanticContext,
            inObservablePropertyMap,
            inActionMap,
            inReceiverSwiftTypeName,
            inClassMap,
            !?ioImplicitViewFunctionGenerationList,
            !?ioConfiguratorMap,
            !?ioOutletMap,
            ?let @abstractViewInstructionGeneration viewInstruction
          )
          parameterList += !name !"self.computeImplicitView_" + ioImplicitViewFunctionGenerationList.count () + " ()"
          ioImplicitViewFunctionGenerationList += !viewInstruction
        case string (stringValue) :
          parameterList += !name !stringValue
        case entity (entityName) :
          inClassMap.searchKey (entityName, ?let classKind, ?3*)
          if not classKind.isEntity () then
            error entityName: "an entity is required here"
          end
          parameterList += !name !entityName.string + ".self"
        case menuItem (title run enabledBinding) :
          analyzeAutoLayoutRunBinding (
            run,
            !handlesRunAction: true,
            inPreferences,
            "".nowhere (), # mAutoLayoutViewClassName # inTypeName
            inActionMap,
            inObservablePropertyMap,
            inReceiverSwiftTypeName,
            ?let runBindingGeneration
          )
          analyzeAutoLayoutEnableBinding (
            enabledBinding,
            !handlesEnabledBinding: true,
            !prefs: inPreferences,
            inRootObservablePropertyMap,
            inSemanticContext,
            inObservablePropertyMap,
            !prefsMap: inPreferencesPropertyMap,
            ?let enabledBindingGeneration
          )
          var s = "AutoLayoutMenuItemDescriptor (title: " + title.utf8Representation ()
          switch runBindingGeneration 
          case none :
            s += ", target: nil, selector: nil"
          case run (targetName actionName runTargetName) :
            s += ", target: " + targetName + ", selector: #selector (" + runTargetName + "." + actionName + " (_:))"
          end
          switch enabledBindingGeneration 
          case none :
            s += ", enableBinding: .alwaysTrue"
          case enabled (binding) :
            s += ", enableBinding: " + binding.expressionString ()
          end
          s += ")"
          parameterList += !name !s
        case enumFunc (enumTypeName funcName) :
          inSemanticContext.mClassMap.searchKey (enumTypeName, ?let type, ?3*)
          if not type.isAtomic () then
            error enumTypeName : "this type should be an enum type"
          else
            type.atomic (?kind:let typeKind)
            if typeKind.isEnumType () then
              typeKind.enumType (?2*, ?funcMap:let funcMap)
              funcMap.searchKey (funcName, ?*)
            else
              error enumTypeName : "this type should be an enum type"
            end
          end
          parameterList += !name !enumTypeName.string + "." + funcName + " ()"
        end
      end
    end
    outFuncCallList += !functionName.string !parameterList
  end
}

#·······················································································································

override proc @astComputedHorizontalViewDeclaration.checkView(
                                  let @string unused inViewName,
                                  let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                  ?prefs: let @bool inPreferences,
                                  let @propertyMap inRootObservablePropertyMap,
                                  let @propertyMap inPreferencesPropertyMap,
                                  let @semanticContext inSemanticContext,
                                  let @propertyMap inObservablePropertyMap,
                                  let @actionMap inActionMap,
                                  let @string inReceiverSwiftTypeName,
                                  let @classMap inClassMap,
                                  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                  ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                  ?!@autoLayoutOutletMap ioOutletMap,
                                  !@abstractViewGeneration outGeneration) {
  self.mFunctionCallList.checkViewFunctionCallList
     (inSemanticContext.mAutoLayoutHStackFunctionMap,
     inViewDeclarationMap,
     inPreferences,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
  var @autoLayoutViewInstructionGenerationList instructionList = []
  for (instruction) in self.mInstructionList do
    instruction.generateViewCode
      (inViewDeclarationMap,
      !prefs: inPreferences,
      inRootObservablePropertyMap,
      inPreferencesPropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inActionMap,
      inReceiverSwiftTypeName,
      inClassMap,
      !?ioImplicitViewFunctionGenerationList,
      !?ioConfiguratorMap,
      !?ioOutletMap,
      ?let generatedInstruction
    )
    instructionList += !generatedInstruction
  end
  outGeneration = @computedHorizontalViewGeneration (funcCallList, instructionList, self.mNewStackViewDeclarationList)
}

#·······················································································································

override proc @astComputedVerticalViewDeclaration.checkView(
                                  let @string unused inViewName,
                                  let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                  ?prefs: let @bool inPreferences,
                                  let @propertyMap inRootObservablePropertyMap,
                                  let @propertyMap inPreferencesPropertyMap,
                                  let @semanticContext inSemanticContext,
                                  let @propertyMap inObservablePropertyMap,
                                  let @actionMap inActionMap,
                                  let @string inReceiverSwiftTypeName,
                                  let @classMap inClassMap,
                                  ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                  ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                  ?!@autoLayoutOutletMap ioOutletMap,
                                  !@abstractViewGeneration outGeneration) {
  var @autoLayoutViewInstructionGenerationList instructionList = []
  self.mFunctionCallList.checkViewFunctionCallList
     (inSemanticContext.mAutoLayoutVStackFunctionMap,
     inViewDeclarationMap,
     inPreferences,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
  for (instruction) in self.mInstructionList do
   instruction.generateViewCode
      (inViewDeclarationMap,
      !prefs: inPreferences,
      inRootObservablePropertyMap,
      inPreferencesPropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inActionMap,
      inReceiverSwiftTypeName,
      inClassMap,
      !?ioImplicitViewFunctionGenerationList,
      !?ioConfiguratorMap,
      !?ioOutletMap,
      ?let generatedInstruction
    )
    instructionList += !generatedInstruction
  end
  outGeneration = @computedVerticalViewGeneration (funcCallList, instructionList, self.mNewStackViewDeclarationList)
}

#·······················································································································

abstract proc @astAbstractViewInstructionDeclaration.generateViewCode(
                                let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                ?prefs:let @bool inPreferences,
                                let @propertyMap inRootObservablePropertyMap,
                                let @propertyMap inPreferencesPropertyMap,
                                let @semanticContext inSemanticContext,
                                let @propertyMap inObservablePropertyMap,
                                let @actionMap inActionMap,
                                let @string inReceiverSwiftTypeName,
                                let @classMap inClassMap,
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                ?!@autoLayoutOutletMap ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction)

#·······················································································································

override proc @astSpaceViewInstruction.generateViewCode(
                                let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                ?prefs: let @bool unused inPreferences,
                                let @propertyMap unused inRootObservablePropertyMap,
                                let @propertyMap unused inPreferencesPropertyMap,
                                let @semanticContext unused inSemanticContext,
                                let @propertyMap unused inObservablePropertyMap,
                                let @actionMap unused inActionMap,
                                let @string unused inReceiverSwiftTypeName,
                                let @classMap unused inClassMap,
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                ?!@autoLayoutOutletMap unused ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  outInstruction = @autoLayoutSpaceViewInstructionGeneration.new
}

#·······················································································································

override proc @astSeparatorInstructionDeclaration.generateViewCode(
                                let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                ?prefs: let @bool unused inPreferences,
                                let @propertyMap unused inRootObservablePropertyMap,
                                let @propertyMap unused inPreferencesPropertyMap,
                                let @semanticContext unused inSemanticContext,
                                let @propertyMap unused inObservablePropertyMap,
                                let @actionMap unused inActionMap,
                                let @string unused inReceiverSwiftTypeName,
                                let @classMap unused inClassMap,
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                ?!@autoLayoutOutletMap unused ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  outInstruction = @autoLayoutSeparatorInstructionGeneration (!horizontal: self.horizontal)
}

#·······················································································································

override proc @astDividerInstructionDeclaration.generateViewCode(
                                let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                ?prefs: let @bool unused inPreferences,
                                let @propertyMap unused inRootObservablePropertyMap,
                                let @propertyMap unused inPreferencesPropertyMap,
                                let @semanticContext unused inSemanticContext,
                                let @propertyMap unused inObservablePropertyMap,
                                let @actionMap unused inActionMap,
                                let @string unused inReceiverSwiftTypeName,
                                let @classMap unused inClassMap,
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                ?!@autoLayoutOutletMap unused ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  outInstruction = @autoLayoutDividerInstructionGeneration (!horizontal: self.horizontal)
}

#·······················································································································

override proc @astLocalViewInstruction.generateViewCode(
                                let @autoLayoutViewDeclarationMap unused inViewDeclarationMap,
                                ?prefs: let @bool unused inPreferences,
                                let @propertyMap unused inRootObservablePropertyMap,
                                let @propertyMap unused inPreferencesPropertyMap,
                                let @semanticContext unused inSemanticContext,
                                let @propertyMap unused inObservablePropertyMap,
                                let @actionMap unused inActionMap,
                                let @string unused inReceiverSwiftTypeName,
                                let @classMap unused inClassMap,
                                ?!@implicitViewFunctionGenerationList unused ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap unused ioConfiguratorMap,
                                ?!@autoLayoutOutletMap unused ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  outInstruction = @autoLayoutLocalViewInstructionGeneration (self.mLocalView.string)
}

#·······················································································································

override proc @astComputedViewInstruction.generateViewCode(
                                let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                                ?prefs: let @bool inPreferences,
                                let @propertyMap inRootObservablePropertyMap,
                                let @propertyMap inPreferencesPropertyMap,
                                let @semanticContext inSemanticContext,
                                let @propertyMap inObservablePropertyMap,
                                let @actionMap inActionMap,
                                let @string inReceiverSwiftTypeName,
                                let @classMap inClassMap,
                                ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                                ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                                ?!@autoLayoutOutletMap ioOutletMap,
                                !@abstractViewInstructionGeneration outInstruction) {
  inSemanticContext.mAutolayoutViewClassMap.searchKey
     (self.mAutoLayoutViewClassName,
     ?7*,
     ?let formalParameterList,
     ?let functionMap
  )
  var @autoLayoutViewInstructionGenerationParameterList parameterList = []
  if formalParameterList.count () != self.mParameterList.count () then
    error self.mAutoLayoutViewClassName 
    : formalParameterList.count ().string () + " parameter(s) required, " + self.mParameterList.count () + " provided"
  else
    for (name type value) in self.mParameterList, (formalName formalType) in formalParameterList do
      if let [formalType typeEnum ?name: let enumTypeName], let [type typeEnum ?name: let constantName] then
        inClassMap.searchKey (enumTypeName, ?let typeKind, ?3*)
        if let [typeKind atomic ?kind: let classKind], let [classKind enumType ?1* ?constantMap: let constantMap ?1*] then
          constantMap.searchKey (constantName, ?*)
        else
          error enumTypeName : "this type name is not an enum"
        end
      elsif type != formalType then
        error name : "the formal parameter requires " + formalType + ", actual parameter is " + type
      end
      if name.string != formalName.string then
        error name : "the parameter name should be '" + formalName + "'"
      end
      switch value
        case viewFunc (instruction) :
          instruction.generateViewCode 
            (inViewDeclarationMap,
            !prefs: inPreferences,
            inRootObservablePropertyMap,
            inPreferencesPropertyMap,
            inSemanticContext,
            inObservablePropertyMap,
            inActionMap,
            inReceiverSwiftTypeName,
            inClassMap,
            !?ioImplicitViewFunctionGenerationList,
            !?ioConfiguratorMap,
            !?ioOutletMap,
            ?let @abstractViewInstructionGeneration viewInstruction
          )
          parameterList += !name !"self.computeImplicitView_" + ioImplicitViewFunctionGenerationList.count () + " ()"
          ioImplicitViewFunctionGenerationList += !viewInstruction
      case entity (entityName) :
        inClassMap.searchKey (entityName, ?let classKind, ?3*)
        if not classKind.isEntity () then
          error entityName: "an entity is required here"
        end
        parameterList += !name !entityName.string + ".self"
      case string (stringValue) :
        parameterList += !name !stringValue
      case menuItem (title run enabledBinding) :
        analyzeAutoLayoutRunBinding (
          run,
          !handlesRunAction: true,
          inPreferences,
          "".nowhere (), # mAutoLayoutViewClassName # inTypeName
          inActionMap,
          inObservablePropertyMap,
          inReceiverSwiftTypeName,
          ?let runBindingGeneration
        )
        analyzeAutoLayoutEnableBinding (
          enabledBinding,
          !handlesEnabledBinding: true,
          !prefs: inPreferences,
          inRootObservablePropertyMap,
          inSemanticContext,
          inObservablePropertyMap,
          !prefsMap: inPreferencesPropertyMap,
          ?let enabledBindingGeneration
        )
        var s = "AutoLayoutMenuItemDescriptor (title: " + title.utf8Representation ()
        switch runBindingGeneration 
        case none :
          s += ", target: nil, selector: nil"
        case run (targetName actionName runTargetName) :
          s += ", target: " + targetName + ", selector: #selector (" + runTargetName + "." + actionName + " (_:))"
        end
        switch enabledBindingGeneration 
        case none :
          s += ", enableBinding: .alwaysTrue"
        case enabled (binding) :
          s += ", enableBinding: " + binding.expressionString ()
        end
        s += ")"
        parameterList += !name !s
      case enumFunc (enumTypeName funcName) :
        inSemanticContext.mClassMap.searchKey (enumTypeName, ?let type, ?3*)
        if not type.isAtomic () then
          error enumTypeName : "this type should be an enum type"
        else
          type.atomic (?kind:let typeKind)
          if typeKind.isEnumType () then
            typeKind.enumType (?2*, ?funcMap:let funcMap)
            funcMap.searchKey (funcName, ?*)
          else
            error enumTypeName : "this type should be an enum type"
          end
        end
        parameterList += !name !enumTypeName.string + "." + funcName + " ()"
      end
    end
  end
//-- Bindings
  analyzeAutoLayoutBinding (
    inPreferences,
    inRootObservablePropertyMap,
    inPreferencesPropertyMap,
    inSemanticContext,
    inObservablePropertyMap,
    inActionMap,
    inReceiverSwiftTypeName,

    self.mAutoLayoutViewClassName,

     self.mTableValueBinding,
     self.mRunActionDescriptor,
     self.mEnabledBindingDescriptor,
     self.mHiddenBindingDescriptor,
     self.mGraphicController,
     self.mRegularBindingList,

    ?let @autoLayoutRegularBindingsGenerationList regularBindingsGenerationList,
    ?let @autoLayoutMultipleBindingGenerationList multipleBindingGenerationList,
    ?let @autolayoutRunBindingForGeneration runBindingGeneration,
    ?let @string inTableViewBindingGeneration,
    ?let @autoLayoutViewGraphicControllerBindingGeneration ebViewGraphicControllerBindingGeneration
  )
  self.mFunctionCallList.checkViewFunctionCallList
     (functionMap,
     inViewDeclarationMap,
     inPreferences,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
//-- Check outlet
  if self.mOutletName.string != "" then
    !?ioOutletMap.insertKey (self.mOutletName, self.mAutoLayoutViewClassName, self.mOutletIsArray)
  end
//-- Check configurator
  if self.mConfiguratorName.string != "" then
    !?ioConfiguratorMap.insertKey (self.mConfiguratorName, self.mAutoLayoutViewClassName)
  end
//--  
  outInstruction = @autoLayoutComputedViewInstructionGeneration (
    self.mAutoLayoutViewClassName,
    parameterList,
    funcCallList,
    regularBindingsGenerationList,
    multipleBindingGenerationList,
    runBindingGeneration,
    inTableViewBindingGeneration,
    ebViewGraphicControllerBindingGeneration,
    self.mConfiguratorName.string,
    self.mOutletName.string,
    self.mOutletIsArray
  )
}

#·······················································································································

proc analyzeAutoLayoutBinding(
  let @bool inPreferences,
  let @propertyMap inRootObservablePropertyMap,
  let @propertyMap inPreferencesPropertyMap,
  let @semanticContext inSemanticContext,
  let @propertyMap inObservablePropertyMap,
  let @actionMap inActionMap,
  let @string inReceiverSwiftTypeName,

  let @lstring inTypeName,

  let @tableValueBinding inTableValueBinding,
  let @runActionDescriptor inRunActionDescriptor,
  let @multipleBindingDescriptor inEnabledBindingDescriptor,
  let @multipleBindingDescriptor inHiddenBindingDescriptor,
  let @graphicController inGraphicController,
  let @regularBindingList inRegularBindingList,

  !@autoLayoutRegularBindingsGenerationList outRegularBindingsGenerationList,
  !@autoLayoutMultipleBindingGenerationList outMultipleBindingGenerationList,
  !@autolayoutRunBindingForGeneration outRunBindingGeneration,
  !@string outTableViewBindingGeneration,
  !@autoLayoutViewGraphicControllerBindingGeneration outEBViewGraphicControllerBindingGeneration) {
  outRegularBindingsGenerationList = []
  outMultipleBindingGenerationList = []
  outTableViewBindingGeneration = "" # Empty String means no binding
  inSemanticContext.mAutolayoutViewClassMap.searchKey
    (inTypeName,
    ?*,
    ?let @bool handlesRunAction,
    ?let @bool handlesTableViewBinding,
    ?let @bool handlesEnabledBinding,
    ?let @bool handlesHiddenBinding,
    ?let @bool handleGraphicControllerBinding,
    ?3*
  )
//-- $graphicController
  outEBViewGraphicControllerBindingGeneration = .none
  switch inGraphicController
  case none :
  case defined (@lstring controllerName @lstring propertyName) :
    if not handleGraphicControllerBinding then
      error inTypeName : "the '" + inTypeName + "' type does not handle the $graphicController binding"
    else
      inObservablePropertyMap.searchKey
        (controllerName,
        ?let @propertyKind kind,
        ?2*
      )
      switch kind 
      case property (2*) :
        error controllerName : "the bound model should be an array controller"
      case toMany (4*) :
        error controllerName : "the bound model should be an array controller"
      case toOne (5*) :
        error controllerName : "the bound model should be an array controller"
      case arrayController (entityName graphic) :
        if propertyName.string == "" then
          if not graphic then
            error controllerName : "the controlled entity (" + entityName + ") should be a graphic entity"
          end
        else
          inSemanticContext.mClassMap.searchKey
            (entityName,
            ?*,
            ?let observablePropertyMap,
            ?2*
          )
          observablePropertyMap.searchKey (propertyName, ?let propertyKind, ?2*)
          switch propertyKind 
          case property (2*) :
            error controllerName : "the bound model should be a toMany property"
          case toMany (kEntityName * isGraphic *) :
            if not isGraphic then
              error controllerName : "the controlled entity (" + kEntityName + ") should be a graphic entity"
            end
          case toOne (5*) :
            error controllerName : "the bound model should be a toMany property"
          case arrayController (2*) :
            error controllerName : "the bound model should be a toMany property"
          case selectionController (*) :
            error controllerName : "the bound model should be a toMany property"
          end
       end
      case selectionController (*) :
        error controllerName : "the bound model should be an array controller"
      end
      outEBViewGraphicControllerBindingGeneration = .binding (!arrayControllerControllerName: controllerName.string)
    end
  end
//-- $tableView
  switch inTableValueBinding
  case noTableValueBinding :
  case tableValueBinding (@lstring controllerName) :
    if not handlesTableViewBinding then
      error inTypeName : "the '" + inTypeName + "' type does not handle the $tableView binding"
    elsif inPreferences then
      inPreferencesPropertyMap.searchKey
        (controllerName,
        ?let @propertyKind kind,
        ?2*
      )
      if not kind.isArrayController () then
        error controllerName : "the bound model should be an array controller"
      end
      outTableViewBindingGeneration = controllerName.string
    else
      inObservablePropertyMap.searchKey
        (controllerName,
        ?let @propertyKind kind,
        ?2*
      )
      if not kind.isArrayController () then
        error controllerName : "the bound model should be an array controller"
      end
      outTableViewBindingGeneration = controllerName.string
    end
  end
//-- $run
  analyzeAutoLayoutRunBinding (
    inRunActionDescriptor,
    !handlesRunAction: handlesRunAction,
    inPreferences,
    inTypeName,
    inActionMap,
    inObservablePropertyMap,
    inReceiverSwiftTypeName,
    ?outRunBindingGeneration
  )
//-- Enabled
  analyzeAutoLayoutEnableBinding (
    inEnabledBindingDescriptor,
    !handlesEnabledBinding: handlesEnabledBinding,
    !prefs: inPreferences,
    inRootObservablePropertyMap,
    inSemanticContext,
    inObservablePropertyMap,
    !prefsMap: inPreferencesPropertyMap,
    ?let enabledBindingGeneration
  )
  switch enabledBindingGeneration
  case none :
  case enabled (binding) :
    outMultipleBindingGenerationList += !"enabled" !binding
  end
//-- Hidden
  switch inHiddenBindingDescriptor
  case noBinding :
  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
    expression.analyzeExpressionForMultipleBinding
      (!prefs: inPreferences,
      inRootObservablePropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inPreferencesPropertyMap,
      ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression,
      ?let @typeKind type,
      ?let @location errorLocation
    )
    if not type.isBoolType () then
      error errorLocation : "expression is not boolean"
    end
    if not handlesHiddenBinding then
      error errorLocation : "cet outlet n'accepte pas le binding $hidden"
    end
    outMultipleBindingGenerationList +=
      !"hidden"
      !hiddenExpression
  end
//--------------------------------- Regular bindings
  analyzeAutoLayoutRegularBinding (
    !prefs: inPreferences,
    inRootObservablePropertyMap,
    inPreferencesPropertyMap,
    inSemanticContext,
    inObservablePropertyMap,
    inTypeName,
    inRegularBindingList,
    if inPreferences then "preferences_" else "self." end,
    !?outRegularBindingsGenerationList
  )
}

#·······················································································································

proc analyzeAutoLayoutEnableBinding(
  let @multipleBindingDescriptor inEnabledBindingDescriptor,
  ?handlesEnabledBinding: let @bool inHandlesEnabledBinding,
  ?prefs: let @bool inPreferences,
  let @propertyMap inRootObservablePropertyMap,
  let @semanticContext inSemanticContext,
  let @propertyMap inObservablePropertyMap,
  ?prefsMap: let @propertyMap inPreferencesPropertyMap,
  !@autolayoutEnabledBindingForGeneration outEnabledBindingGeneration)
{
  switch inEnabledBindingDescriptor
  case noBinding :
    outEnabledBindingGeneration = .none
  case binding (@abstractBooleanMultipleBindingExpressionAST expression) :
    expression.analyzeExpressionForMultipleBinding
      (!prefs: inPreferences,
      inRootObservablePropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inPreferencesPropertyMap,
      ?let @abstractBooleanMultipleBindingExpressionForGeneration enableExpression,
      ?let @typeKind type,
      ?let @location errorLocation
    )
    if not inHandlesEnabledBinding then
      error errorLocation : "cet outlet n'accepte pas le binding $enabled"
    end
    if not type.isBoolType () then
      error errorLocation : "expression is not boolean"
    end
    outEnabledBindingGeneration = .enabled (!binding: enableExpression)
  end
}

#·······················································································································

proc analyzeAutoLayoutRunBinding(
  let @runActionDescriptor inRunActionDescriptor,
  ?handlesRunAction: let @bool inHandlesRunAction,
  let @bool inPreferences,
  let @lstring inTypeName,
  let @actionMap inActionMap,
  let @propertyMap inObservablePropertyMap,
  let @string inReceiverSwiftTypeName,
  !@autolayoutRunBindingForGeneration outRunBindingGeneration)
{
  switch inRunActionDescriptor
  case noAction :
    outRunBindingGeneration = .none
  case action (@lstring target @lstring action) :
    if not inHandlesRunAction then
      error inTypeName : "the '" + inTypeName + "' type does not handle run action"
      spoil (outRunBindingGeneration)
    elsif target.string == "self" then
      inActionMap.searchKey (action)
      outRunBindingGeneration = .run (
        !targetName: "self",
        !actionName: action.string,
        !targetTypeName: inReceiverSwiftTypeName
      )
    else # It is a controller
      inObservablePropertyMap.searchKey
        (target,
        ?*,
        ?let @actionMap controllerActionMap,
        ?*
      )
      controllerActionMap.searchKey (action)
      outRunBindingGeneration = .run (
        !targetName: if inPreferences then "preferences_" else "" end + target.string,
        !actionName: action.string,
        !targetTypeName: "Controller_" + inReceiverSwiftTypeName + "_" + target
      )
    end
  end
}

#·······················································································································

proc analyzeAutoLayoutRegularBinding(
  ?prefs: let @bool inPreferences,
  let @propertyMap inRootPropertyMap,
  let @propertyMap inPreferencesPropertyMap,
  let @semanticContext inSemanticContext,
  let @propertyMap inBoundModelPropertyMap,
  let @lstring inOutletTypeName,
  let @regularBindingList inRegularBindingList,
  let @string inSelfSwiftName,
  ?!@autoLayoutRegularBindingsGenerationList ioRegularBindingsGenerationList)
{
  for (mBindingName mObservablePropertyList mBindingOptionList) in inRegularBindingList do
  //-- Analyze model
    var @outletBindingModelList boundModelTypeList = []
    var @boundObjectList boundModelListForGeneration = []
    for (mObservableProperty) in mObservablePropertyList do
      mObservableProperty.analyzeObservableProperty
        (inRootPropertyMap,
        inSemanticContext,
        if inPreferences then inPreferencesPropertyMap else inBoundModelPropertyMap end,
        ?let @propertyKind kind,
        ?let @string unused swiftTypeStringForTransientFunctionArgument,
        ?let @string unused defaultValueAsString
      )
      switch kind
      case property (2*) : # Ok
      case toMany (4*) :
        error mObservableProperty.location () :"a toMany property cannot be bound"
      case toOne (5*) :
        error mObservableProperty.location () :"a toOne property cannot be bound"
      case arrayController (2*) :
        error mObservableProperty.location () :"an array controller cannot be bound"
      case selectionController (*) :
        error mObservableProperty.location () :"a selection controller cannot be bound"
      end
      boundModelListForGeneration += !mObservableProperty.modelStringForSelf (inSelfSwiftName) !kind
      boundModelTypeList += !kind !mObservableProperty.location () 
    end
  //-- Analyze outlet binding
    var @outletBindingSpecificationModelList outletBindingSpecificationModelList = []
    var @controllerBindingOptionDecoratedList controllerBindingOptionDecoratedList = []
    var outletTypeName = inOutletTypeName
    var continues = true
    loop (inSemanticContext.mBindingSpecificationMap.count () + 1) while (outletTypeName.string != "") & continues do
      continues = false
      inSemanticContext.mAutoLayoutBindingSpecificationMap.searchKey
        (outletTypeName,
        ?let superOutletClassName,
        ?let bindingMap
      )
      if bindingMap.hasKey (mBindingName.string) then
        bindingMap.searchKey
          (mBindingName,
          ?outletBindingSpecificationModelList,
          ?controllerBindingOptionDecoratedList
        )
      else
        continues = true
        outletTypeName = superOutletClassName
      end
    end
    if continues then
      error mBindingName : "this binding is not defined"
    elsif boundModelTypeList.count () != outletBindingSpecificationModelList.count () then
      error mBindingName
      : outletBindingSpecificationModelList.count ().string ()
        + " model(s) required for this binding (found: "
        + boundModelTypeList.count () + ")"
    else
      for (required_mModelType required_mModelShouldBeWritableProperty) in outletBindingSpecificationModelList, (found_mKind found_mErrorLocation) in boundModelTypeList do
        if required_mModelShouldBeWritableProperty && found_mKind.isTransient () then
          error found_mErrorLocation : "the model is transient and the binding requires an writable model"
        end
        if required_mModelType.isEnumType () && found_mKind.isEnumType () then # Ok
        elsif required_mModelType.swiftTypeName () != found_mKind.swiftTypeName () then
          error found_mErrorLocation : "the model type should be " + required_mModelType.swiftTypeName ()
        end
      end
    end
  //-- Check options
    var bindingOptionString = ""
    if controllerBindingOptionDecoratedList.count () != mBindingOptionList.count () then
      var @string s
      if controllerBindingOptionDecoratedList.count () == 0 then
        s = "this binding has no option"
      else 
        s = "this binding requires the following options:"
        for (mOptionType mOptionName) in controllerBindingOptionDecoratedList do
          s += "\n  - " + mOptionName + " : " + mOptionType.swiftTypeName ()
        end
      end
      error mBindingName : s
    else
      for (controller_mOptionType controller_mOptionName) in controllerBindingOptionDecoratedList, (binding_mOptionName binding_mOptionValue) in mBindingOptionList do
        if controller_mOptionName.string != binding_mOptionName.string then
          error binding_mOptionName : "the option name should be '" + controller_mOptionName + "'"
        end
        binding_mOptionValue.analyzeDefaultValueType (
          [controller_mOptionType],
          inPreferencesPropertyMap,
          ?let @string optionValueAsString
        )
        bindingOptionString += ", " + controller_mOptionName.string + ":" + optionValueAsString
      end
    end
  //-- Generate binding
    ioRegularBindingsGenerationList +=
      !mBindingName.string
      !boundModelListForGeneration
      !bindingOptionString
  end
}

#·······················································································································

override proc @astHStackViewInstructionDeclaration.generateViewCode(
                        let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                        ?prefs: let @bool inPreferences,
                        let @propertyMap inRootObservablePropertyMap,
                        let @propertyMap inPreferencesPropertyMap,
                        let @semanticContext inSemanticContext,
                        let @propertyMap inObservablePropertyMap,
                        let @actionMap inActionMap,
                        let @string inReceiverSwiftTypeName,
                        let @classMap inClassMap,
                        ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                        ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                        ?!@autoLayoutOutletMap ioOutletMap,
                        !@abstractViewInstructionGeneration outInstruction) {
  var @autoLayoutViewInstructionGenerationList instructionList = []
  self.mFunctionCallList.checkViewFunctionCallList
     (inSemanticContext.mAutoLayoutHStackFunctionMap,
     inViewDeclarationMap,
     inPreferences,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
  var @autoLayoutMultipleBindingGenerationList multipleBindingGenerationList = []
  switch self.mOptionalHiddenBinding 
  case noBinding :
  case binding (hiddenBindingExpression) :
    hiddenBindingExpression.analyzeExpressionForMultipleBinding
      (!prefs: inPreferences,
      inRootObservablePropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inPreferencesPropertyMap,
      ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression,
      ?let @typeKind type,
      ?let @location errorLocation
    )
    if not type.isBoolType () then
      error errorLocation : "expression is not boolean"
    end
    multipleBindingGenerationList +=
      !"hidden"
      !hiddenExpression
  end
  for (instruction) in self.mInstructionList do
   instruction.generateViewCode
      (inViewDeclarationMap,
      !prefs: inPreferences,
      inRootObservablePropertyMap,
      inPreferencesPropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inActionMap,
      inReceiverSwiftTypeName,
      inClassMap,
      !?ioImplicitViewFunctionGenerationList,
      !?ioConfiguratorMap,
      !?ioOutletMap,
      ?let generatedInstruction
    )
    instructionList += !generatedInstruction
  end
  outInstruction = @hStackViewInstructionGeneration (
    funcCallList,
    instructionList,
    multipleBindingGenerationList,
    self.mAstNewStackViewDeclarationList
  )
}

#·······················································································································

override proc @astVStackViewInstructionDeclaration.generateViewCode(
                        let @autoLayoutViewDeclarationMap inViewDeclarationMap,
                        ?prefs: let @bool inPreferences,
                        let @propertyMap inRootObservablePropertyMap,
                        let @propertyMap inPreferencesPropertyMap,
                        let @semanticContext inSemanticContext,
                        let @propertyMap inObservablePropertyMap,
                        let @actionMap inActionMap,
                        let @string inReceiverSwiftTypeName,
                        let @classMap inClassMap,
                        ?!@implicitViewFunctionGenerationList ioImplicitViewFunctionGenerationList,
                        ?!@autoLayoutConfiguratorMap ioConfiguratorMap,
                        ?!@autoLayoutOutletMap ioOutletMap,
                        !@abstractViewInstructionGeneration outInstruction) {
  var @autoLayoutViewInstructionGenerationList instructionList = []
  self.mFunctionCallList.checkViewFunctionCallList
     (inSemanticContext.mAutoLayoutVStackFunctionMap,
     inViewDeclarationMap,
     inPreferences,
     inRootObservablePropertyMap,
     inPreferencesPropertyMap,
     inSemanticContext,
     inObservablePropertyMap,
     inActionMap,
     inReceiverSwiftTypeName,
     inClassMap,
     !?ioImplicitViewFunctionGenerationList,
     !?ioConfiguratorMap,
     !?ioOutletMap,
     ?let @autoLayoutViewInstructionGenerationFuncCallList funcCallList
  )
  var @autoLayoutMultipleBindingGenerationList multipleBindingGenerationList = []
  switch self.mOptionalHiddenBinding 
  case noBinding :
  case binding (hiddenBindingExpression) :
    hiddenBindingExpression.analyzeExpressionForMultipleBinding
      (!prefs: inPreferences,
      inRootObservablePropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inPreferencesPropertyMap,
      ?let @abstractBooleanMultipleBindingExpressionForGeneration hiddenExpression,
      ?let @typeKind type,
      ?let @location errorLocation
    )
    if not type.isBoolType () then
      error errorLocation : "expression is not boolean"
    end
    multipleBindingGenerationList +=
      !"hidden"
      !hiddenExpression
  end
  for (instruction) in self.mInstructionList do
   instruction.generateViewCode
      (inViewDeclarationMap,
      !prefs: inPreferences,
      inRootObservablePropertyMap,
      inPreferencesPropertyMap,
      inSemanticContext,
      inObservablePropertyMap,
      inActionMap,
      inReceiverSwiftTypeName,
      inClassMap,
      !?ioImplicitViewFunctionGenerationList,
      !?ioConfiguratorMap,
      !?ioOutletMap,
      ?let generatedInstruction
    )
    instructionList += !generatedInstruction
  end
  outInstruction = @vStackViewInstructionGeneration (
    funcCallList,
    instructionList,
    multipleBindingGenerationList,
    self.mAstNewStackViewDeclarationList
  )
}

//----------------------------------------------------------------------------------------------------------------------
#   GENERATION                            
//----------------------------------------------------------------------------------------------------------------------

abstract class @abstractViewGeneration {
}

//----------------------------------------------------------------------------------------------------------------------

class @computedHorizontalViewGeneration : @abstractViewGeneration {
  public let @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  public let @autoLayoutViewInstructionGenerationList mInstructionList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//----------------------------------------------------------------------------------------------------------------------

class @computedVerticalViewGeneration : @abstractViewGeneration {
  public let @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  public let @autoLayoutViewInstructionGenerationList mInstructionList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//----------------------------------------------------------------------------------------------------------------------

list @viewGenerationList {
  public let @string mViewName
  public let @abstractViewGeneration mView
}

//----------------------------------------------------------------------------------------------------------------------

abstract class @abstractViewInstructionGeneration {
}

//----------------------------------------------------------------------------------------------------------------------

class @hStackViewInstructionGeneration : @abstractViewInstructionGeneration {
  public let @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  public let @autoLayoutViewInstructionGenerationList mInstructionList
  public let @autoLayoutMultipleBindingGenerationList mMultipleBindingGenerationList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//----------------------------------------------------------------------------------------------------------------------

class @vStackViewInstructionGeneration : @abstractViewInstructionGeneration {
  public let @autoLayoutViewInstructionGenerationFuncCallList mFuncCallList
  public let @autoLayoutViewInstructionGenerationList mInstructionList
  public let @autoLayoutMultipleBindingGenerationList mMultipleBindingGenerationList
  public let @astNewStackViewDeclarationList mNewStackViewDeclarationList
}

//----------------------------------------------------------------------------------------------------------------------

class @autoLayoutSpaceViewInstructionGeneration : @abstractViewInstructionGeneration {
}

//----------------------------------------------------------------------------------------------------------------------

class @autoLayoutSeparatorInstructionGeneration : @abstractViewInstructionGeneration {
  public let @bool horizontal %selector
}

//----------------------------------------------------------------------------------------------------------------------

class @autoLayoutDividerInstructionGeneration : @abstractViewInstructionGeneration {
  public let @bool horizontal %selector
}

//----------------------------------------------------------------------------------------------------------------------

class @autoLayoutLocalViewInstructionGeneration : @abstractViewInstructionGeneration {
  public let @string mLocalView
}

#·······················································································································

list @autoLayoutRegularBindingsGenerationList {
  public let @string mBindingName
  public let @boundObjectList mBoundObjectList
  public let @string mBindingOptionsString
}

//----------------------------------------------------------------------------------------------------------------------

list @autoLayoutMultipleBindingGenerationList {
  public let @string mBindingName
  public let @abstractBooleanMultipleBindingExpressionForGeneration mBoundObjectExpression
}

#·······················································································································

enum @autolayoutRunBindingForGeneration {
  case none
  case run (@string targetName @string actionName @string targetTypeName)
}

#·······················································································································

enum @autoLayoutViewGraphicControllerBindingGeneration {
  case none
  case binding (@string arrayControllerControllerName)
}

#·······················································································································

enum @autolayoutEnabledBindingForGeneration {
  case none
  case enabled (@abstractBooleanMultipleBindingExpressionForGeneration binding)
}

//----------------------------------------------------------------------------------------------------------------------

class @autoLayoutComputedViewInstructionGeneration : @abstractViewInstructionGeneration {
  public let @lstring mAutoLayoutViewClassName
  public let @autoLayoutViewInstructionGenerationParameterList mParameterList
  public let @autoLayoutViewInstructionGenerationFuncCallList mFunctionCallList
  public let @autoLayoutRegularBindingsGenerationList mRegularBindingsGenerationList
  public let @autoLayoutMultipleBindingGenerationList mMultipleBindingGenerationList
  public let @autolayoutRunBindingForGeneration mRunBindingGeneration
  public let @string mTableViewBindingGeneration # Bound controller name; empty string means no binding
  public let @autoLayoutViewGraphicControllerBindingGeneration mEBViewGraphicControllerBindingGeneration
  public let @string mConfiguratorName # Empty string if no configurator
  public let @string mOutletName # Empty string if no configurator
  public let @bool mOutletIsArray
}

//----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationParameterList {
  public let @string mParameterName
  public let @string mParameterValue
}

//----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationFuncCallList {
  public let @string mFunctionName
  public let @autoLayoutViewInstructionGenerationParameterList mParameters
}

//----------------------------------------------------------------------------------------------------------------------

proc @autoLayoutViewInstructionGenerationFuncCallList.generate (let @string inIndentation, ?!@string ioStr) {
  for (funcName parameterList) in self do
    ioStr += inIndentation + "  ." + funcName + " ("
    for (parameterName parameterStringValue) in parameterList
      do ioStr += parameterName + ": " + parameterStringValue
      between ioStr += ", "
    end
    ioStr += ")\n"
  end
}

//----------------------------------------------------------------------------------------------------------------------

list @autoLayoutViewInstructionGenerationList {
  public let @abstractViewInstructionGeneration mInstruction
}

#·······················································································································

abstract func @abstractViewGeneration.generateViewBuilder (?prefs: let @bool inPreferences,
                                                           let @string inViewName) -> @string

#·······················································································································

override func @computedHorizontalViewGeneration.generateViewBuilder (?prefs: let @bool inPreferences,
                                                                     let @string inViewName) -> @string {
  result = "  final func " + inViewName + " () -> AutoLayoutHorizontalStackView {\n"
  result += "    let hStackView = AutoLayoutHorizontalStackView ()\n"
  self.mFuncCallList.generate ("    ", !?result)
  for (instance type) in self.mNewStackViewDeclarationList do
    result += "    let " + instance + " = self." + type + " ()\n"
  end
  for (instruction) in self.mInstructionList do (index)
    let name = "view_" + index
    result += instruction.generateViewInstruction (!prefs: inPreferences, name, "    ")
    result += "    _ = hStackView.appendView (" + name + ")\n"
  end
  result += "    return hStackView\n"
  result += "  }\n\n"
}

#·······················································································································

override func @computedVerticalViewGeneration.generateViewBuilder (?prefs: let @bool inPreferences,
                                                                   let @string inViewName) -> @string {
  result = "  final func " + inViewName + " () -> AutoLayoutVerticalStackView {\n"
  result += "    let vStackView = AutoLayoutVerticalStackView ()\n"
  self.mFuncCallList.generate ("    ", !?result)
  for (instance type) in self.mNewStackViewDeclarationList do
    result += "    let " + instance + " = self." + type + " ()\n"
  end
  for (instruction) in self.mInstructionList do (index)
    let name = "view_" + index
    result += instruction.generateViewInstruction (!prefs: inPreferences, name, "    ")
    result += "    _ = vStackView.appendView (" + name + ")\n"
  end
  result += "    return vStackView\n"
  result += "  }\n\n"
}

#·······················································································································

abstract func @abstractViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string

#·······················································································································

override func @autoLayoutSpaceViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool unused inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutFlexibleSpace ()\n"
}

#·······················································································································

override func @autoLayoutSeparatorInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool unused inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  if self.horizontal then
    result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView.VerticalSeparator ()\n"
  else
    result = inIndentation + "let " + inName + " = AutoLayoutVerticalStackView.HorizontalSeparator ()\n"
  end
}

#·······················································································································

override func @autoLayoutDividerInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool unused inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  if self.horizontal then
    result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView.VerticalDivider ()\n"
  else
    result = inIndentation + "let " + inName + " = AutoLayoutVerticalStackView.HorizontalDivider ()\n"
  end
}

#·······················································································································

override func @autoLayoutLocalViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool unused inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = " + self.mLocalView + "\n"
}

#·······················································································································

override func @autoLayoutComputedViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = AutoLayout" + self.mAutoLayoutViewClassName.string + " ("
  for parameter in self.mParameterList
  do
    result += parameter.mParameterName + ": " + parameter.mParameterValue
  between
    result += ", "
  end
  result += ")\n"
  self.mFunctionCallList.generate (inIndentation, !?result)
  for (bindingName boundObjectList optionListString) in self.mRegularBindingsGenerationList do
    result += inIndentation + "  .bind_" + bindingName + " ("
    for (boundObjectString *) in boundObjectList
      do result += boundObjectString
      between result += ", "
    end
    result += optionListString + ")\n"
  end
  for (bindingName binding) in self.mMultipleBindingGenerationList do 
    result += inIndentation + "  .bind_" + bindingName + " (" + binding.expressionString () + ")\n"
  end
  switch self.mRunBindingGeneration
  case none :
  case run (targetName actionName targetTypeName) :
    result += inIndentation + "  .bind_run (\n"
    result += inIndentation + "    target: " + targetName + ",\n"
    result += inIndentation + "    selector: #selector (" + targetTypeName + "." + actionName + " (_:))\n"
    result += inIndentation + "  )\n"
  end
  switch self.mEBViewGraphicControllerBindingGeneration
  case none :
  case binding (controllerName) :
    result += inIndentation + "  .bind_graphic_controller (self." + controllerName + ")\n"
  end
  if self.mTableViewBindingGeneration != "" then
    let prefix = if inPreferences then "preferences_" else "self." end
    result += inIndentation + prefix + self.mTableViewBindingGeneration + ".bind_tableView (" + inName + ")\n"
  end
  if self.mOutletName != "" then
    if self.mOutletIsArray then
       result += inIndentation + "self." + self.mOutletName + ".append (" + inName + ") // Outlet Array\n"
   else
      result += inIndentation + "self." + self.mOutletName + " = " + inName + " // Outlet\n"
    end
  end
  if self.mConfiguratorName != "" then
    result += inIndentation + "self.configure_" + self.mConfiguratorName + " (" + inName + ") // Configurator\n"
  end
}

#·······················································································································

override func @hStackViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutHorizontalStackView ()\n"
  self.mFuncCallList.generate (inIndentation, !?result)
  for (bindingName binding) in self.mMultipleBindingGenerationList do 
    result += inIndentation + "  .bind_" + bindingName + " (" + binding.expressionString () + ")\n"
  end
  for (instance type) in self.mNewStackViewDeclarationList do
    result += inIndentation + "let " + instance + " = self." + type + " ()\n"
  end
  result += inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  for (instruction) in self.mInstructionList do (index)
     let name = inName + "_" + index
     result += instruction.generateViewInstruction (!prefs: inPreferences, name, indentation)
     result += indentation + "_ = " + inName + ".appendView (" + name + ")\n"
  end
  result += inIndentation + "}\n"
}

#·······················································································································

override func @vStackViewInstructionGeneration.generateViewInstruction (
                         ?prefs: let @bool inPreferences,
                         let @string inName,
                         let @string inIndentation) -> @string {
  result = inIndentation + "let " + inName + " = AutoLayoutVerticalStackView ()\n"
  self.mFuncCallList.generate (inIndentation, !?result)
  for (bindingName binding) in self.mMultipleBindingGenerationList do 
    result += inIndentation + "  .bind_" + bindingName + " (" + binding.expressionString () + ")\n"
  end
  for (instance type) in self.mNewStackViewDeclarationList do
    result += inIndentation + "let " + instance + " = self." + type + " ()\n"
  end
  result += inIndentation + "do{\n"
  let indentation = inIndentation + "  "
  for (instruction) in self.mInstructionList do (index)
     let name = inName + "_" + index
     result += instruction.generateViewInstruction (!prefs: inPreferences, name, indentation)
     result += indentation + "_ = " + inName + ".appendView (" + name + ")\n"
  end
  result += inIndentation + "}\n"
}

//----------------------------------------------------------------------------------------------------------------------
