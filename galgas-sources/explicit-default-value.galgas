#-----------------------------------------------------------------------------------------------------------------------
#   AST   
#-----------------------------------------------------------------------------------------------------------------------

abstract class @abstractDefaultValue {
}

#·······················································································································

class @boolAsDefaultValue : @abstractDefaultValue {
  @lbool mValue
}

#·······················································································································

class @doubleAsDefaultValue : @abstractDefaultValue {
  @ldouble mValue
}

#·······················································································································

class @integerAsDefaultValue : @abstractDefaultValue {
  @luint mValue
  @bool mNegative
}

#·······················································································································

class @stringAsDefaultValue : @abstractDefaultValue {
  @lstring mValue
}

#·······················································································································

class @identifierAsDefaultValue : @abstractDefaultValue {
  @lstring mValue
}

#·······················································································································

class @prefsAsDefaultValue : @abstractDefaultValue {
  @lstring mPrefPropertyName
}

#-----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
#-----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

  #·····················································································································
  
   rule <explicit_value> !@abstractDefaultValue outDefaultValue {
    select
      $yes$
      outDefaultValue = @boolAsDefaultValue.new {!.new {!true !.here}}
    or
      $no$
      outDefaultValue = @boolAsDefaultValue.new {!.new {!false !.here}}
    or
      $literal_integer$ ?let @luint integerValue
      outDefaultValue = @integerAsDefaultValue.new {!integerValue !false}
    or
      $-$
      $literal_integer$ ?let @luint integerValue
      outDefaultValue = @integerAsDefaultValue.new {!integerValue !true}
    or
      $literal_double$ ?let @ldouble doubleValue ?*
      outDefaultValue = @doubleAsDefaultValue.new {!doubleValue}
    or
      $literal_string$ ?let @lstring stringValue
      outDefaultValue = @stringAsDefaultValue.new {!stringValue}
    or
      $identifier$ ?let @lstring stringValue
      outDefaultValue = @identifierAsDefaultValue.new {!stringValue}
    or
      $prefs$
      $.$
      $identifier$ ?let name
      outDefaultValue = @prefsAsDefaultValue.new {!name}
    end
  }

  #·····················································································································

}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTICS                             
#-----------------------------------------------------------------------------------------------------------------------

abstract method @abstractDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  ?let @propertyMap inPreferencesPropertyMap
  !@string outSwiftDefaultValueAsString

#·······················································································································

method @abstractDefaultValue enterDefaultValuePrecedence
   ?let @lstring unused inNode
   ?!@declarationPrecedenceGraph unused ioGraph {
}

#·······················································································································
  
override method @boolAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  ?let @propertyMap unused inPreferencesPropertyMap
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in  inAttributeActualTypeList while not found do
    switch mType
    case boolType :
      outSwiftDefaultValueAsString = if mValue.bool then "true" else "false" end
      found = true
    case integerType, uint32Type, dataType, dateType, doubleType,
         stringType, fontType, colorType, bezierPathType, bezierPathArrayType :
    case entityType (2*) :
    case classType (*) :
    case enumType (3*) :
    case transientPropertyExternType (*) :
    end
  end
  if not found then
    error mValue
    : "only a boolean attribute can be initialized by YES or NO"  
  end
}

#·······················································································································
  
override method @integerAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  ?let @propertyMap unused inPreferencesPropertyMap
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in  inAttributeActualTypeList while not found do
    switch mType
    case integerType :
      outSwiftDefaultValueAsString = if mNegative then "-" else "" end + [mValue.uint string]
      found = true
    case uint32Type :
      if mNegative then
        error mValue : "Uint32 value should be ≥ 0"
      end
      outSwiftDefaultValueAsString = [mValue.uint string]
      found = true
    case fontType :
      outSwiftDefaultValueAsString = "NSFont.systemFont (ofSize: " + mValue.uint + ".0)"
      found = true
    case boolType, dateType, dataType, doubleType, stringType, colorType, bezierPathType, bezierPathArrayType :
    case entityType (2*) :
    case enumType (3*) :
    case classType (*) :
    case transientPropertyExternType (*) :
    end
  end
  if not found then
    error mValue
    : "only an integer attribute can be initialized by an integer constant"  
  end
}

#·······················································································································
  
override method @doubleAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  ?let @propertyMap unused inPreferencesPropertyMap
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in  inAttributeActualTypeList while not found do
    switch mType
    case doubleType :
      outSwiftDefaultValueAsString = [mValue.double string]
      found = true
    case boolType, dateType, dataType, integerType, uint32Type,
         stringType, fontType, colorType, bezierPathType, bezierPathArrayType :
    case entityType (2*) :
    case enumType (3*) :
    case classType (*) :
    case transientPropertyExternType (*) :
    end
  end
  if not found then
    error mValue
    : "only a double attribute can be initialized by a floating point constant"  
  end
}

#·······················································································································
  
override method @stringAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  ?let @propertyMap unused inPreferencesPropertyMap
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in  inAttributeActualTypeList while not found do
    switch mType
    case stringType :
      outSwiftDefaultValueAsString = "\""+ mValue.string + "\""
      found = true
    case boolType, dateType, dataType, integerType, uint32Type, doubleType,
         fontType, colorType, bezierPathType, bezierPathArrayType :
    case entityType (2*) :
    case enumType (3*) :
    case classType (*) :
    case transientPropertyExternType (*) :
    end
  end
  if not found then
    error mValue
    : "only a string attribute can be initialized by a string constant"  
  end
}

#·······················································································································

func %once predefinedDates -> @stringset {
  result = {}
  result += !"now"
  result += !"distantPast"
}

#·······················································································································

func %once predefinedColors -> @stringset {
  result = {}
  result += !"black"
  result += !"blue"
  result += !"brown"
  result += !"clear"
  result += !"control"
  result += !"controlDarkShadow"
  result += !"controlHighlight"
  result += !"controlLightHighlight"
  result += !"controlShadow"
  result += !"controlText"
  result += !"cyan"
  result += !"darkGray"
  result += !"disabledControlText"
  result += !"gray"
  result += !"green"
  result += !"grid"
  result += !"header"
  result += !"headerText"
  result += !"highlight"
  result += !"keyboardFocusIndicator"
  result += !"knob"
  result += !"lightGray"
  result += !"magenta"
  result += !"orange"
  result += !"purple"
  result += !"red"
  result += !"scrollBar"
  result += !"selectedControl"
  result += !"selectedControlText"
  result += !"selectedKnob"
  result += !"selectedMenuItem"
  result += !"selectedMenuItemText"
  result += !"selectedTextBackground"
  result += !"selectedText"
  result += !"shadow"
  result += !"textBackground"
  result += !"white"
  result += !"windowBackground"
  result += !"windowFrame"
  result += !"windowFrameText"
  result += !"yellow"
}
#·······················································································································
  
override method @identifierAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  ?let @propertyMap unused inPreferencesPropertyMap
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in inAttributeActualTypeList while not found do
    switch mType 
    case dateType :
      found = true
      if [predefinedDates () hasKey !mValue.string] then
        if mValue.string == "now" then
          outSwiftDefaultValueAsString = "Date ()"
        elsif mValue.string == "distantPast" then
          outSwiftDefaultValueAsString = "Date.distantPast"
        else
          error mValue : "unknown predefined date" 
        end 
      else
        error mValue : "unknown predefined date"  
      end
    case bezierPathType :
      found = true
      if mValue.string == "empty" then
        outSwiftDefaultValueAsString = "NSBezierPath ()"
      else
        error mValue : "only 'empty' is accepted as default NSBezierPath"  
      end
    case bezierPathArrayType :
      found = true
      if mValue.string == "empty" then
        outSwiftDefaultValueAsString = "BezierPathArray ()"
      else
        error mValue : "only 'empty' is accepted as default BezierPathArray"  
      end
    case enumType (@string enumTypeName @enumConstantMap constantMap *
    ) :
      found = true
      if [constantMap hasKey !mValue.string] then
        outSwiftDefaultValueAsString = enumTypeName + "." + mValue.string
      else
        error mValue
        : "the '" + enumTypeName + "' enumeration does not define '" + mValue + "' constant"
        : outSwiftDefaultValueAsString  
      end
    case entityType (2*) :
      error mValue : "invalid entity type"  
    case classType (*) :
      error mValue : "invalid class type"  
    case boolType :
      error mValue : "invalid bool type"  
    case dataType :
      found = true
      if mValue.string == "empty" then
        outSwiftDefaultValueAsString = "Data ()"
      else
        error mValue : "only 'empty' is accepted as default Data"  
      end
    case doubleType :
      error mValue : "invalid double type"  
    case integerType :
      error mValue : "invalid integer type"  
    case uint32Type :
      error mValue : "invalid UInt32 type"  
    case stringType :
      error mValue : "invalid string type"  
    case fontType :
      error mValue : "invalid font type"
    case colorType :
      if [predefinedColors () hasKey !mValue.string] then
        outSwiftDefaultValueAsString = "NSColor." + mValue.string
        found = true
      else
        error mValue : "unknown predefined color"  
      end
    case transientPropertyExternType (*) :
      error mValue : "invalid image type"  
    end
  end
  if not found then
    error mValue
    : "unknow type for this identifier"  
  end
}

#·······················································································································
 
override method @prefsAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  ?let @propertyMap inPreferencesPropertyMap
  !@string outSwiftDefaultValueAsString
{
  [inPreferencesPropertyMap searchKey !mPrefPropertyName ?let @propertyKind kind ?2*]
  switch kind
  case property (@typeKind type *) :
    var found = false
    for (t) in inAttributeActualTypeList while not found do
      found = type == t
    end
    if not found then
      error mPrefPropertyName : "the atomic property type is not compatible"
    end
  case toMany (4*) :
    error mPrefPropertyName : "an atomic property is required here"
  case toOne (4*) :
    error mPrefPropertyName : "an atomic property is required here"
  case arrayController (2*) :
    error mPrefPropertyName : "an atomic property is required here"
  case selectionController (*) :
    error mPrefPropertyName : "an atomic property is required here"
  end
  outSwiftDefaultValueAsString = "preferences_" + mPrefPropertyName
}

#·······················································································································

override method @prefsAsDefaultValue enterDefaultValuePrecedence
   ?let @lstring inNode
   ?!@declarationPrecedenceGraph ioGraph
{
  let p = @lstring.new {!preferencesName () + " " + mPrefPropertyName.string !mPrefPropertyName.location}
  [!?ioGraph addEdge !inNode !p]
}

#-----------------------------------------------------------------------------------------------------------------------
