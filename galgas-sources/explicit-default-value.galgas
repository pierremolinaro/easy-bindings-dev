#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractDefaultValue {
}

#·······················································································································

class @boolAsDefaultValue : @abstractDefaultValue {
  @lbool mValue
}

#·······················································································································

class @doubleAsDefaultValue : @abstractDefaultValue {
  @ldouble mValue
}

#·······················································································································

class @integerAsDefaultValue : @abstractDefaultValue {
  @luint mValue
  @bool mNegative
}

#·······················································································································

class @stringAsDefaultValue : @abstractDefaultValue {
  @lstring mValue
}

#·······················································································································

class @identifierAsDefaultValue : @abstractDefaultValue {
  @lstring mValue
}

#·······················································································································

list @defaultValueList {
  @abstractDefaultValue mDefaultValue
}

#·······················································································································

class @listAsDefaultValue : @abstractDefaultValue {
  @location mStartLocation
  @defaultValueList mDefaultValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
   rule <explicit_value> !@abstractDefaultValue outDefaultValue {
    select
      $yes$
      outDefaultValue = @boolAsDefaultValue.new {!.new {!true !.here}}
    or
      $no$
      outDefaultValue = @boolAsDefaultValue.new {!.new {!false !.here}}
    or
      $literal_integer$ ?var  @luint integerValue
      outDefaultValue = @integerAsDefaultValue.new {!integerValue !false}
    or
      $-$
      $literal_integer$ ?var  @luint integerValue
      outDefaultValue = @integerAsDefaultValue.new {!integerValue !true}
    or
      $literal_double$ ?var  @ldouble doubleValue ?*
      outDefaultValue = @doubleAsDefaultValue.new {!doubleValue}
    or
      $literal_string$ ?var @lstring stringValue
      outDefaultValue = @stringAsDefaultValue.new {!stringValue}
    or
      $identifier$ ?let @lstring stringValue
      outDefaultValue = @identifierAsDefaultValue.new {!stringValue}
    or
      $($
      let startLocation = @location.here
      @defaultValueList defaultValueList = {}
      repeat
        <explicit_value> ?var @abstractDefaultValue defaultValue
        defaultValueList += !defaultValue
      while
        $,$
      end
      $)$
      outDefaultValue = @listAsDefaultValue.new {!startLocation !defaultValueList}
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                             
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString

#·······················································································································
  
override method @boolAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in  inAttributeActualTypeList while not found do
    switch mType
    case boolType :
      outSwiftDefaultValueAsString = if mValue.bool then "true" else "false" end
      found = true
    case integerType, dataType, dateType, doubleType, stringType, fontType, colorType :
    case entityType (2*) :
    case classType (*) :
    case enumType (* *) :
    case transientPropertyExternType (*) :
    end
  end
  if not found then
    error mValue
    : "only a boolean attribute can be initialized by YES or NO"  
  end
}

#·······················································································································
  
override method @integerAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in  inAttributeActualTypeList while not found do
    switch mType
    case integerType :
      outSwiftDefaultValueAsString = if mNegative then "-" else "" end + [mValue.uint string]
      found = true
    case fontType :
      outSwiftDefaultValueAsString = "NSFont.systemFont (ofSize: " + mValue.uint + ".0)"
      found = true
    case boolType, dateType, dataType, doubleType, stringType, colorType :
    case entityType (2*) :
    case enumType (* *) :
    case classType (*) :
    case transientPropertyExternType (*) :
    end
  end
  if not found then
    error mValue
    : "only an integer attribute can be initialized by an integer constant"  
  end
}

#·······················································································································
  
override method @doubleAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in  inAttributeActualTypeList while not found do
    switch mType
    case doubleType :
      outSwiftDefaultValueAsString = [mValue.double string]
      found = true
    case boolType, dateType, dataType, integerType, stringType, fontType, colorType :
    case entityType (2*) :
    case enumType (* *) :
    case classType (*) :
    case transientPropertyExternType (*) :
    end
  end
  if not found then
    error mValue
    : "only a double attribute can be initialized by a floating point constant"  
  end
}

#·······················································································································
  
override method @stringAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in  inAttributeActualTypeList while not found do
    switch mType
    case stringType :
      outSwiftDefaultValueAsString = "\""+ mValue.string + "\""
      found = true
    case boolType, dateType, dataType, integerType, doubleType, fontType, colorType :
    case entityType (2*) :
    case enumType (* *) :
    case classType (*) :
    case transientPropertyExternType (*) :
    end
  end
  if not found then
    error mValue
    : "only a string attribute can be initialized by a string constant"  
  end
}

#·······················································································································

func %once predefinedDates -> @stringset {
  result = {}
  result += !"date"
}

#·······················································································································

func %once predefinedColors -> @stringset {
  result = {}
  result += !"black"
  result += !"blue"
  result += !"brown"
  result += !"clear"
  result += !"control"
  result += !"controlDarkShadow"
  result += !"controlHighlight"
  result += !"controlLightHighlight"
  result += !"controlShadow"
  result += !"controlText"
  result += !"cyan"
  result += !"darkGray"
  result += !"disabledControlText"
  result += !"gray"
  result += !"green"
  result += !"grid"
  result += !"header"
  result += !"headerText"
  result += !"highlight"
  result += !"keyboardFocusIndicator"
  result += !"knob"
  result += !"lightGray"
  result += !"magenta"
  result += !"orange"
  result += !"purple"
  result += !"red"
  result += !"scrollBar"
  result += !"selectedControl"
  result += !"selectedControlText"
  result += !"selectedKnob"
  result += !"selectedMenuItem"
  result += !"selectedMenuItemText"
  result += !"selectedTextBackground"
  result += !"selectedText"
  result += !"shadow"
  result += !"textBackground"
  result += !"white"
  result += !"windowBackground"
  result += !"windowFrame"
  result += !"windowFrameText"
  result += !"yellow"
}
#·······················································································································
  
override method @identifierAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
  for () in inAttributeActualTypeList while not found do
    switch mType 
    case dateType :
      found = true
      if [predefinedDates () hasKey !mValue.string] then
        outSwiftDefaultValueAsString = "Date ()"
      else
        error mValue : "unknown predefined date"  
      end
    case enumType (@string enumTypeName @enumConstantMap constantMap) :
      found = true
      if [constantMap hasKey !mValue.string] then
        outSwiftDefaultValueAsString = enumTypeName + "." + mValue.string
      else
        error mValue
        : "the '" + enumTypeName + "' enumeration does not define '" + mValue + "' constant"
        : outSwiftDefaultValueAsString  
      end
    case entityType (2*) :
      error mValue : "invalid entity type"  
    case classType (*) :
      error mValue : "invalid class type"  
    case boolType :
      error mValue : "invalid bool type"  
    case dataType :
      found = true
      if mValue.string == "empty" then
        outSwiftDefaultValueAsString = "Data ()"
      else
        error mValue : "only 'empty' is accepted as default Data"  
      end
    case doubleType :
      error mValue : "invalid double type"  
    case integerType :
      error mValue : "invalid integer type"  
    case stringType :
      error mValue : "invalid string type"  
    case fontType :
      error mValue : "invalid font type"
    case colorType :
      if [predefinedColors () hasKey !mValue.string] then
        outSwiftDefaultValueAsString = "NSColor." + mValue.string
        found = true
      else
        error mValue : "unknown predefined color"  
      end
    case transientPropertyExternType (*) :
      error mValue : "invalid image type"  
    end
  end
  if not found then
    error mValue
    : "unknow type for this identifier"  
  end
}

#·······················································································································
 
override method @listAsDefaultValue analyzeDefaultValueType 
  ?let @typeKindList unused inAttributeActualTypeList
  !@string outSwiftDefaultValueAsString
{
  outSwiftDefaultValueAsString = ""
  @bool found = false
#  foreach inAttributeActualTypeList while not found do
#    if [mType mTypeKind] == [@typeKind structType] then
#      found := true ;
#      ioFileInclusionSet->mHeaderFileInclusionSet += ![mType ebTypeName] ;
#      [inContextAnalysisStruct->mStructTypeMap searchKey
#        !mType->mTypeName
#        ?@structFieldList fieldList
#      ] ;
#      if [mDefaultValueList length] != [fieldList length] then
#        error mStartLocation : "the '" . [mType ebTypeName] . "' struct needs " . [fieldList length] . " values for initialization" ;
#      else
#        outDirectDefaultValueAsString := "make" . [mType ebTypeName] . " (" ;
#        foreach mDefaultValueList, fieldList
#        do
#          [mDefaultValue analyzeDefaultValueType
#            ![@EXebTypeList listWithValue !mFieldType]
#            !inContextAnalysisStruct
#            ?@string directDefaultValueAsString
#            ?2*
#            !?ioFileInclusionSet
#          ] ;
#          outDirectDefaultValueAsString .= directDefaultValueAsString ;
#        between
#          outDirectDefaultValueAsString .= ", " ;
#        end foreach ; 
#        outDirectDefaultValueAsString .= ")" ;     
#      end if ;
#    elsif mType->mKind == [@EXTypeKind fontType] then
#      found := true ;
#      const @string errorMessage := "an NSFont should be initialized by a (fontName, fontSize) value" ;
#      if [mDefaultValueList length] != 2 then
#        error mStartLocation : errorMessage ; 
#      else
#        const @abstractDefaultValue v0 := [mDefaultValueList mDefaultValueAtIndex !0] ; 
#        const @abstractDefaultValue v1 := [mDefaultValueList mDefaultValueAtIndex !1] ;
#        @identifierAsDefaultValue fontName ;
#        if (v0 is == @identifierAsDefaultValue) then 
#          fontName := (cast v0 : @identifierAsDefaultValue) ;
#        else
#          error mStartLocation : errorMessage : fontName ;
#        end if ;
#        @integerAsDefaultValue fontSize ;
#        if (v1 is == @integerAsDefaultValue) then 
#          fontSize := (cast v1 : @integerAsDefaultValue) ;
#        else
#          error mStartLocation : errorMessage : fontSize ;
#        end if ;
#        if [predefinedFonts [] hasKey ![fontName mValue]->string] then
#          outDirectDefaultValueAsString := "[NSFont " . [fontName mValue]->string . ":" . [[fontSize mValue]->uint string] . "]" ;
#          outObjectiveCDefaultValueAsString := outDirectDefaultValueAsString ;
#          outSwiftDefaultValueAsString := "NSFont (" . [fontName mValue]->string . ", " . [[fontSize mValue]->uint string] . ")" ;
#        else
#          error [fontName mValue]
#          : "unknown predefined font name"
#          : outDirectDefaultValueAsString, outObjectiveCDefaultValueAsString
#          ;  
#        end if ;
#      end if ;
#    end if ;
#  end foreach ;
  if not found then
    error mStartLocation
    : "invalid initialization value"  
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
