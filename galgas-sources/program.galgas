#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   PROGRAM                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @semanticContext {
  @classMap mClassMap
  @outletClassMap mOutletClassMap
  @bindingSpecificationMap mBindingSpecificationMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

case . "eb"
  message "a source text file with the .easyBindings extension"
  grammar easyBindings_grammar
  ?sourceFilePath:@lstring inSourceFile
{
  @astDeclarationStruct declarationStruct = .default
#----------------------------------------- Parse predefined outlets files
  grammar easyBindings_grammar on ([filewrapper predefinedOutletClasses.sourceFile], "")
    !userDefined:false
    !?declarationStruct
    ?*
#----------------------------------------- Parse source file
  grammar easyBindings_grammar in inSourceFile
    !userDefined:true
    !?declarationStruct
    ?var @location endOfSourceFile
#------------------------ Add prefs declaration
  declarationStruct.mUnifiedDeclarationList += !@prefsDeclarationAST.new {
    !.new{!preferencesName () !.nowhere}
    !declarationStruct.mPreferences
  }
#----------------------------------------- Add Atomic type declarations
  enterAtomicClassesIn (!?declarationList: declarationStruct.mUnifiedDeclarationList)
#----------------------------------------- Sort properties
  sortProperties (!inSourceFile.string !declarationStruct.mUnifiedDeclarationList ?let sortedDeclarationListAST)
#----------------------------------------- Build outlet class map
  @semanticContext semanticContext = .default
  [declarationStruct.mOutletClassDeclarationList buildOutletClassMap !?semanticContext.mOutletClassMap]
#----------------------------------------- Semantic Analysis, first phase
  @generationStruct generation = .default
  for (declaration) in sortedDeclarationListAST do
    [declaration firstAnalysisPhase !?semanticContext !?generation]
  end
#----------------------------------------- Build binding specification map
  buildBindingSpecificationMap (
    !?semanticContext
    !declarationStruct.mBindingSpecificationListMap
  )
#----------------------------------------- Semantic Analysis, second phase
  for (declaration) in sortedDeclarationListAST do
    [declaration secondAnalysisPhase !?semanticContext !?generation]
  end
#----------------------------------------- Semantic Analysis, third phase
  for (declaration) in sortedDeclarationListAST do
    [declaration thirdAnalysisPhase !?semanticContext !?generation]
  end




#----------------------------------------- Type inventory
  typeInventory (!declarationStruct.mDeclarationList ?@unifiedTypeMap unifiedTypeMap)
#----------------------------------------- Check all types are defined
  let unsolvedProxyList = [unifiedTypeMap unsolvedProxyList]
  for () in  unsolvedProxyList do
    error mValue :"type " + mValue + " is undefined"
  end
#----------------------------------------- Topological sort types and continue
  if [unsolvedProxyList length] == 0 then
    [unifiedTypeMap topologicalSort
      ?var @lstringlist sortedTypeNames
      ?var @lstringlist unsortedTypeNames
    ]
    if [unsortedTypeNames length] > 0 then
      var s = "cannot sort types ; the following types are involved in circular dependence:"
      for () in  unsortedTypeNames do
        s += "\n-- " + mValue
      end
      error @location.here : s
    else
     semanticAnalysisEX (
        !semanticContext.mClassMap
        !unifiedTypeMap
        !inSourceFile.string
        !declarationStruct
        !?generation
      )
      if @uint.errorCount == 0 then
        generateCode (
          !declarationStruct.mXcodeProject.string
          !generation
          !inSourceFile.string
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   FILEWRAPPER: predefined outlet classes
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper predefinedOutletClasses in "../generation-templates" {
}{
}{
  template sourceFile "predefinedOutletClasses.eb"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
