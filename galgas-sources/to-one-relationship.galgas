#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @toOneRelationshipListEX {
  @lstring mCurrentEntityName
  @lstring mDestinationEntityName
  @lstring mToOneRelationshipName
  @lstring mOppositeRelationshipName # Empty string if not inverse relation ship
  @propertyMultiplicity mInverseRelationMultiplicity
  @bool mCascading
}

#·······················································································································

class @toOneRelationshipAST : @abstractDeclarationAST {
  @lstring mDestinationEntityName
  @lstring mToOneRelationshipName
  @lstring mOppositeRelationshipName # Empty string if not inverse relation ship
  @propertyMultiplicity mInverseRelationMultiplicity
  @bool mCascading
}

#·······················································································································

override method @toOneRelationshipAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  let node = @lstring.new {!mClassName.string + " " + mToOneRelationshipName !mToOneRelationshipName.location}
  [!?ioGraph addNode !node !self]
  [!?ioGraph addEdge !node !mClassName]
  [!?ioGraph addEdge !node !mDestinationEntityName]
}

#·······················································································································

override getter @toOneRelationshipAST lkey -> @lstring {
  result = @lstring.new {!mClassName.string + " " + mToOneRelationshipName !mToOneRelationshipName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································

  rule <toOne_relationship>
            ?let @lstring inCurrentEntity
            ?!@toOneRelationshipListEX ioToOneRelationshipList
            ?!@astDeclarationStruct ioDeclarationAST
  {
    $toOne$
    @bool cascading = false
    repeat
    while
      $@attribute$ ?let attributeName
      if attributeName.string == "cascading" then
        if cascading then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        cascading = true
      else
        error attributeName : "unknow attribute" fixit { replace "@cascading" }
      end
    end
    $Identifier$ ?let @lstring destinationEntityName
    $identifier$ ?let @lstring relationshipName
    @propertyMultiplicity inverseRelationMultiplicity
    @lstring inverseRelationshipName
    select
      inverseRelationMultiplicity = .single
      inverseRelationshipName = ["" here]
    or
      $inverse$
      select
        $toOne$
        inverseRelationMultiplicity = .single
      or
        $toMany$
        inverseRelationMultiplicity = .collection
      end
      $identifier$ ?inverseRelationshipName
      end
    $;$
    ioToOneRelationshipList +=
      !inCurrentEntity
      !destinationEntityName
      !relationshipName
      !inverseRelationshipName
      !inverseRelationMultiplicity
      !cascading
    ioDeclarationAST.mUnifiedDeclarationList += !@toOneRelationshipAST.new {
      !inCurrentEntity
      !destinationEntityName
      !relationshipName
      !inverseRelationshipName
      !inverseRelationMultiplicity
      !cascading
    }
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @toOneRelationshipAST firstAnalysisPhase 
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  with mClassName in !?ioSemanticContext.mClassMap 
    error message searchKey
  do
    [ioSemanticContext.mClassMap searchKey !mDestinationEntityName ?let classKind ?let destinationEntityPropertyMap ?2*]
    switch classKind
    case prefs :
      error mDestinationEntityName : "an entity is required here"
    case simpleClass :
      error mDestinationEntityName : "an entity is required here"
    case atomic (*) :
      error mDestinationEntityName : "an entity is required here"
    case document (*) :
      error mDestinationEntityName : "an entity is required here"
    case entity (graphic) :
      let kind = @propertyKind.toOne {
        !typeName: mDestinationEntityName
        !accessibility: .stored
        !graphic: graphic
      }
      [!?mPropertyMap insertKey !mToOneRelationshipName !kind !{}]
    #--- Code Generation
      mPropertyGenerationList += !@toOnePropertyGeneration.new {
        !mToOneRelationshipName.string
        !mClassName
        !kind
        !mOppositeRelationshipName
        !mInverseRelationMultiplicity
        !destinationEntityPropertyMap
        !mCascading
      }
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @toOnePropertyGeneration : @propertyGeneration {
  @string mClassName
  @propertyKind mRelationshipType
  @string mOppositeRelationshipName
  @propertyMultiplicity mInverseRelationMultiplicity
  @propertyMap mDestinationEntityObservablePropertyMap
  @bool mCascading
}

#·······················································································································

list @toOnePropertyGenerationList {
  @toOnePropertyGeneration mProperty
}

#·······················································································································

override getter @toOnePropertyGeneration declarationCode -> @string {
  result  = "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n"
  result += "  //   To one property: " + mPropertyName + "\n"
  result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
  result += "  var " + mPropertyName + "_property = ToOneRelationship_" + mClassName
          + "_" + mPropertyName + " ()\n\n"
  result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
  result += "  var " + mPropertyName + "_property_selection : EBSelection <Bool> {\n"
  result += "    return .single (self." + mPropertyName + "_property.propval == nil)\n"
  result += "  }\n\n"
}

#·······················································································································

override getter @toOnePropertyGeneration configurationCode -> @string {
  result  = "  //--- To one property: " + mPropertyName + "\n"
  result += "    self." + mPropertyName + "_property.owner = self\n"
}

#·······················································································································

override getter @toOnePropertyGeneration setupFromDictionaryCode -> @string {
  result  = ""
  if [mInverseRelationMultiplicity isSingle] then
    result += "  //--- To one property: " + mPropertyName + "\n"
    result += "    self." + mPropertyName + "_property.setProp (readEntityFromDictionary (\n"
    result += "      inRelationshipName: \"" + mPropertyName + "\",\n"
    result += "      inDictionary: inDictionary,\n"
    result += "      managedObjectArray: &managedObjectArray\n"
    result += "    ) as? " + [mRelationshipType swiftTypeName] + ")\n"
  end
}

#·······················································································································

override getter @toOnePropertyGeneration saveIntoDictionaryCode -> @string {
  result  = ""
  if [mInverseRelationMultiplicity isSingle] then
    result +="  //--- To one property: " + mPropertyName + "\n"
    result += "    self.store (managedObject:self." + mPropertyName + "_property.propval,\n"
    result += "      relationshipName: \"" + mPropertyName + "\",\n"
    result += "      intoDictionary: ioDictionary)\n"
  end
}

#·······················································································································

override getter @toOnePropertyGeneration objectAccessibilityCode -> @string {
  result  = "  //--- To one property: " + mPropertyName + "\n"
  result += "    if let managedObject = self." + mPropertyName + "_property.propval {\n"
  result += "      objects.append (managedObject)\n"
  result += "    }\n"
}

#·······················································································································

override getter @toOnePropertyGeneration clearObjectExplorerCode -> @string {
  result  = "  //--- To one property: " + mPropertyName + "\n"
  result += "    self." + mPropertyName + "_property.mObserverExplorer = nil\n"
  result += "    self." + mPropertyName + "_property.mValueExplorer = nil\n"
}










#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TYPE INVENTORY                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @toOneRelationshipListEX typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap
{
  for () in self do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mDestinationEntityName
      ?*
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   OBSERVABLE PROPERTY MAP               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @toOneRelationshipListEX buildObservablePropertyMap
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@observablePropertyMap ioObservableProperties
{
  for () in self do
  #--- Property type
    [inUnifiedTypeMap searchKey !mDestinationEntityName ?let type ?let actionMap]
  #--- Check type
    @bool graphic
    switch type
    case boolType, integerType, stringType, dateType, doubleType, fontType, colorType :
      error mDestinationEntityName: "a simple type cannot be used as entitytype" : graphic
    case enumType (* *) :
      error mDestinationEntityName: "an enumeration type cannot be used as entitytype" : graphic
    case classType (*) :
      error mDestinationEntityName: "a class type cannot be used as entitytype" : graphic
    case transientPropertyExternType (*) :
      error mOppositeRelationshipName: "the opposite type cannot be used as entity type" : graphic
    case entityType (* isGraphic) : # Ok
      graphic = isGraphic
    end
  #--- Enter in property map
    [!?ioObservableProperties insertKey
      !mToOneRelationshipName
      !.toOne {!typeName: mDestinationEntityName !accessibility: .stored !graphic: graphic}
      !mOppositeRelationshipName.string
      !actionMap
      !mCascading
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @toOneRelationshipListEX semanticAnalysis
  ?let @semanticContextEX inSemanticContext
  !@toOneEntityRelationshipListForGeneration outToOneEntityRelationshipListForGeneration
{
  outToOneEntityRelationshipListForGeneration = {}
  for () in self do
    [inSemanticContext.mUnifiedTypeMap searchKey !mDestinationEntityName ?let type ?*]
    [inSemanticContext.mEntityObservablePropertyMap searchKey
      !mDestinationEntityName
      ?@observablePropertyMap destinationEntityObservablePropertyMap
      ?*
    ]
    outToOneEntityRelationshipListForGeneration +=
      !mToOneRelationshipName.string
      !type
      !mOppositeRelationshipName.string
      !mInverseRelationMultiplicity
      !destinationEntityObservablePropertyMap
      !mCascading
  #--- Check inverse relationship
    if mOppositeRelationshipName.string != "" then
      [destinationEntityObservablePropertyMap searchForInverseRelationship
         !mOppositeRelationshipName
         ?let @propertyKind oppositeKind
         ?let @string oppositeOfOpposite
         ?2*
       ]
     #--- Check opposite type
      if [oppositeKind swiftTypeName] != mCurrentEntityName.string then
        error mOppositeRelationshipName
        : "the type of the opposite property '" + mOppositeRelationshipName
          + "' should be '" + mCurrentEntityName + "' (found '" + [oppositeKind swiftTypeName] + "')"
      end
      switch oppositeKind 
      case property (2*) :
        error mOppositeRelationshipName : "a property cannot be an opposite of a relationship"
      case toMany (* accessibility 2*) :
        if [accessibility isTransient] then
          error mOppositeRelationshipName : "this relationship is transient, should be stored"
        end
        if mInverseRelationMultiplicity != .collection then
          error mOppositeRelationshipName : "inverse relationship multiplicity error (toMany <-> toOne)"
        end
      case toOne (* accessibility *) :
        if [accessibility isTransient] then
          error mOppositeRelationshipName : "this relationship is transient, should be stored"
        end
        if mInverseRelationMultiplicity != .single then
          error mOppositeRelationshipName : "inverse relationship multiplicity error (toMany <-> toOne)"
        end
      case arrayController (3*) :
         error mOppositeRelationshipName : "an array controller cannot be an opposite of a relationship"
      case selectionController (*) :
         error mOppositeRelationshipName : "a selection controller cannot be an opposite of a relationship"
      end
      if oppositeOfOpposite != mToOneRelationshipName.string then
        error mOppositeRelationshipName : "inverse relationship does not name '"
           + mToOneRelationshipName + "' as opposite"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION TYPES                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @toOneEntityRelationshipListForGeneration {
  @string mToOneRelationshipName
  @typeKind mRelationshipType
  @string mOppositeRelationshipName
  @propertyMultiplicity mInverseRelationMultiplicity
  @observablePropertyMap mDestinationEntityObservablePropertyMap
  @bool mCascading
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
