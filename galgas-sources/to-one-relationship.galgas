#-----------------------------------------------------------------------------------------------------------------------
#   AST   
#-----------------------------------------------------------------------------------------------------------------------

enum @toOneOppositeRelationship {
  case none
  case oppositeIsToOne (@lstring oppositeRelationshipName)
  case oppositeIsToMany (@lstring oppositeRelationshipName)
}

#·······················································································································

shared class @toOneRelationshipAST : @abstractDeclarationAST {
  @lstring mDestinationEntityName
  @lstring mToOneRelationshipName
  @toOneOppositeRelationship mOpposite
  @bool mUsedForSignature
}

#·······················································································································

override method @toOneRelationshipAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  let node = @lstring.new {!self.mClassName.string + " " + self.mToOneRelationshipName !self.mToOneRelationshipName.location}
  [!?ioGraph addNode !node !self]
  [!?ioGraph addEdge !node !self.mClassName]
  [!?ioGraph addEdge !node !self.mDestinationEntityName]
}

#·······················································································································

override getter @toOneRelationshipAST nodeKey -> @lstring {
  result = @lstring.new {!self.mClassName.string + " " + self.mToOneRelationshipName !self.mToOneRelationshipName.location}
}

#-----------------------------------------------------------------------------------------------------------------------
#   SYNTAX
#-----------------------------------------------------------------------------------------------------------------------

syntax extension easyBindings_syntax {

  #·····················································································································

  rule <toOne_relationship> ?let @lstring inCurrentEntity ?!@astDeclarationStruct ioDeclarationAST {
    $toOne$
    @bool usedForSignature = false
    repeat
    while
      $@attribute$ ?let attributeName
      if attributeName.string == "signature" then
        if usedForSignature then
          error attributeName : "duplicated attribute" fixit { remove }
        end
        usedForSignature = true
      else
        error attributeName : "unknow attribute" fixit { replace "@signature" }
      end
    end
    $Identifier$ ?let @lstring destinationEntityName
    $identifier$ ?let @lstring relationshipName
    @toOneOppositeRelationship opposite
    select
      opposite = .none
    or
      $inverse$
      select
        $toOne$
        $identifier$ ?let inverseRelationshipName
        opposite = .oppositeIsToOne {!oppositeRelationshipName: inverseRelationshipName}
      or
        $toMany$
        $identifier$ ?let inverseRelationshipName
        opposite = .oppositeIsToMany {!oppositeRelationshipName: inverseRelationshipName}
      end
    end
    $;$
    ioDeclarationAST.mUnifiedDeclarationList += !@toOneRelationshipAST.new {
      !inCurrentEntity
      !destinationEntityName
      !relationshipName
      !opposite
      !usedForSignature
    }
  }
  
  #·····················································································································

}

#-----------------------------------------------------------------------------------------------------------------------
#   SEMANTIC ANALYSIS                       
#-----------------------------------------------------------------------------------------------------------------------

override method @toOneRelationshipAST firstAnalysisPhase 
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  with self.mClassName in !?ioSemanticContext.mClassMap 
    error message searchKey
  do
    [ioSemanticContext.mClassMap searchKey !self.mDestinationEntityName ?let classKind ?3*]
    switch classKind
    case prefs :
      error self.mDestinationEntityName : "an entity is required here"
    case atomic (*) :
      error self.mDestinationEntityName : "an entity is required here"
    case document (*) :
      error self.mDestinationEntityName : "an entity is required here"
    case entity (* graphic *) :
      let kind = @propertyKind.toOne {
        !typeName: self.mDestinationEntityName
        !accessibility: .stored
        !graphic: graphic
        !opposite: self.mOpposite
      }
      [!?mPropertyMap insertKey !self.mToOneRelationshipName !kind !{} !false]
    end
  end
}

#-----------------------------------------------------------------------------------------------------------------------

override method @toOneRelationshipAST thirdAnalysisPhase 
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  with self.mClassName in !?ioSemanticContext.mClassMap 
    error message searchKey
  do
    [ioSemanticContext.mClassMap searchKey !self.mDestinationEntityName ?let classKind ?let destinationEntityPropertyMap ?2*]
    switch classKind
    case prefs :
    case atomic (*) :
    case document (*) :
    case entity (* graphic *) :
      let kind = @propertyKind.toOne {
        !typeName: self.mDestinationEntityName
        !accessibility: .stored
        !graphic: graphic
        !opposite: self.mOpposite
      }
    #--- Code Generation
      mPropertyGenerationList += !@toOnePropertyGeneration.new {
        !self.mToOneRelationshipName.string
        !self.mClassName
        !kind
        !self.mOpposite
        !destinationEntityPropertyMap
        !self.mUsedForSignature
      }
    end
  end
}

#-----------------------------------------------------------------------------------------------------------------------
#   GENERATION                       
#-----------------------------------------------------------------------------------------------------------------------

shared class @toOnePropertyGeneration : @propertyGeneration {
  @string mClassName
  @propertyKind mRelationshipType
  @toOneOppositeRelationship mOpposite
  @propertyMap mDestinationEntityObservablePropertyMap
  @bool mUsedForSignature
}

#·······················································································································

list @toOnePropertyGenerationList {
  @toOnePropertyGeneration mProperty
}

#·······················································································································

override getter @toOnePropertyGeneration propertyDeclarationCode
   ?let @bool unused inPreferences
   ?let @stringset unused inOverriddenTransients -> @string
{
  result  = "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n"
  result += "  //   To one property: " + self.mPropertyName + "\n"
  result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
  result += "  final let " + self.mPropertyName + "_property = StoredObject_" + [self.mRelationshipType swiftTypeName]
  result +=            " (usedForSignature: " + [self.mUsedForSignature cString] + ")\n\n"
  result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
  result += "  final var " + self.mPropertyName + " : " + [self.mRelationshipType swiftTypeName] + "? {\n"
  result += "    get {\n"
  result += "      return self." + self.mPropertyName + "_property.propval\n"
  result += "    }\n"
  result += "    set {\n"
  result += "      if self." + self.mPropertyName + "_property.propval != nil {\n"
  result += "        self." + self.mPropertyName + "_property.setProp (nil)\n"
  result += "      }\n"
  result += "      if newValue != nil {\n"
  result += "        self." + self.mPropertyName + "_property.setProp (newValue)\n"
  result += "      }\n"
  result += "    }\n"
  result += "  }\n\n"
  result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
  result += "  final let " + self.mPropertyName + "_none = EBGenericTransientProperty <Bool> ()\n\n"
}

#·······················································································································

override getter @toOnePropertyGeneration initCode -> @string {
  result = ""
}

#·······················································································································

override getter @toOnePropertyGeneration configurationCode ?let @bool unused inPreferences -> @string {
  switch self.mOpposite
  case oppositeIsToMany (oppositeName) :
    result  = "  //--- To one property: " + self.mPropertyName + " (has opposite to many relationship: " + oppositeName + ")\n"
    result += "    self." + self.mPropertyName + "_property.ebUndoManager = self.ebUndoManager\n"
    result += "    self." + self.mPropertyName + "_property.setOppositeRelationShipFunctions (\n"
    result += "      setter: { [weak self] inObject in if let me = self { inObject." + oppositeName + "_property.add (me) } },\n"
    result += "      resetter: { [weak self] inObject in if let me = self { inObject." + oppositeName + "_property.remove (me) } }\n"
    result += "    )\n"
  case none :
    result  = "  //--- To one property: " + self.mPropertyName + "\n"
    result += "    self." + self.mPropertyName + "_property.ebUndoManager = self.ebUndoManager\n"
  case oppositeIsToOne (oppositeName) :
    result  = "  //--- To one property: " + self.mPropertyName + " (has opposite to one relationship: " + oppositeName + ")\n"
    result += "    self." + self.mPropertyName + "_property.ebUndoManager = self.ebUndoManager\n"
    result += "    self." + self.mPropertyName + "_property.setOppositeRelationShipFunctions (\n"
    result += "      setter: { [weak self] inObject in if let me = self { inObject." + oppositeName + "_property.setProp (me) } },\n"
    result += "      resetter: { inObject in inObject." + oppositeName + "_property.setProp (nil) }\n"
    result += "    )\n"
  end
}

#·······················································································································

override getter @toOnePropertyGeneration setupRelationshipFromDictionaryCode -> @string {
  result  = ""
#  if [mInverseRelationMultiplicity isSingle] then
    result += "  //--- To one property: " + self.mPropertyName + "\n"
    result += "    do{\n"
    result += "      let possibleEntity = readEntityFromDictionary (\n"
    result += "        inRelationshipName: \"" + self.mPropertyName + "\",\n"
    result += "        inDictionary: inDictionary,\n"
    result += "        managedObjectArray: &managedObjectArray\n"
    result += "      )\n"
    result += "      if let entity = possibleEntity as? " + [self.mRelationshipType swiftTypeName] + " {\n"
    result += "        self." + self.mPropertyName + "_property.setProp (entity)\n"
    result += "      }\n"
    result += "    }\n"
#  end
}

#·······················································································································

override getter @toOnePropertyGeneration saveIntoDictionaryCode -> @string {
  result  = ""
  switch self.mOpposite
  case oppositeIsToMany (*) :
  case none :
    result +="  //--- To one property: " + self.mPropertyName + "\n"
    result += "    self.store (managedObject:self." + self.mPropertyName + "_property.propval,\n"
    result += "      relationshipName: \"" + self.mPropertyName + "\",\n"
    result += "      intoDictionary: ioDictionary)\n"
  case oppositeIsToOne (oppositeName) :
    result +="  //--- To one property: " + self.mPropertyName + " // Opposite is toOne " + oppositeName + "\n"
    result += "    self.store (managedObject:self." + self.mPropertyName + "_property.propval,\n"
    result += "      relationshipName: \"" + self.mPropertyName + "\",\n"
    result += "      intoDictionary: ioDictionary)\n"
  end
}

#·······················································································································

override getter @toOnePropertyGeneration objectAccessibilityCode -> @string {
  result  = "  //--- To one property: " + self.mPropertyName + "\n"
  result += "    if let object = self." + self.mPropertyName + " {\n"
  result += "      objects.append (object)\n"
  result += "    }\n"
}

#·······················································································································

override getter @toOnePropertyGeneration objectAccessibilityCodeForSaveOperation -> @string {
  result  = "  //--- To one property: " + self.mPropertyName + "\n"
  result += "    if let object = self." + self.mPropertyName + " {\n"
  result += "      objects.append (object)\n"
  result += "    }\n"
}

#·······················································································································

override getter @toOnePropertyGeneration clearObjectExplorerCode -> @string {
  result  = "    //--- To one property: " + self.mPropertyName + "\n"
  result += "      self." + self.mPropertyName + "_property.mObserverExplorer = nil\n"
  result += "      self." + self.mPropertyName + "_property.mValueExplorer = nil\n"
}

#-----------------------------------------------------------------------------------------------------------------------
