

#----------------------------------------------------------------------------*

override method @predefinedTypeDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap {
  [!?ioUnifiedTypeMap insertKey
    ![mTypeName nowhere]
    !mKind
    !@unifiedTypeMap-proxy. null # Super type
    !@unifiedTypeMap-proxy. null # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
    !@lstringlist {} # mEnumConstantList
    !@enumConstantMap {} # mEnumConstantMap
    !{} # No array controller
  ]
}

#----------------------------------------------------------------------------*

override method @enumDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap {
  @enumConstantMap enumConstantMap = {}
  for (s) in mEnumConstantNameList do
    [!?enumConstantMap insertKey !s]
  end
  [!?ioUnifiedTypeMap insertKey
    !mEnumTypeName
    !@typeKind. enumType
    !@unifiedTypeMap-proxy. null # Super type
    !@unifiedTypeMap-proxy. null # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
    !mEnumConstantNameList
    !enumConstantMap
    !{} # No array controller
  ]
}

#----------------------------------------------------------------------------*

override method @structDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap {
  for () in  mFieldList do
    [!?ioUnifiedTypeMap enterEdge
      !mStructTypeName
      !mFieldTypeName
    ]
  end
  log mStructTypeName
  [!?ioUnifiedTypeMap insertKey
    !mStructTypeName
    !@typeKind. structType
    !@unifiedTypeMap-proxy. null # Super type
    !@unifiedTypeMap-proxy. null # Root entity
    !@decoratedAttributeMap {}
    !@decoratedTransientMap {}
    !@decoratedOutletMap {}
    !@decoratedObservablePropertyMap {}
    !@decoratedEntityRelationshipMap {}
    !@actionMap {}
    !@lstringlist {} # mEnumConstantList
    !@enumConstantMap {} # mEnumConstantMap
    !{} # No array controller
  ]
}

#----------------------------------------------------------------------------*

override method @unifiedTypeDeclaration typeInventory
  ?!@unifiedTypeMap ioUnifiedTypeMap {
  let kindName = [mTypeKind kindName]
#------------------------------- Super type ?
  @unifiedTypeMap-proxy superTypeProxy
  if mSuperTypeName.string == "" then
    superTypeProxy = @unifiedTypeMap-proxy. null
  else
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mSuperTypeName
      ?superTypeProxy
    ]
    [!?ioUnifiedTypeMap enterEdge
      !mTypeName
      !mSuperTypeName
    ]
  end
#------------------------------------------------ Root Entity ?
  @unifiedTypeMap-proxy rootEntityType
  if mRootEntityName.string == "" then
    rootEntityType = @unifiedTypeMap-proxy. null
  else
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mRootEntityName
      ?rootEntityType
    ]
  [!?ioUnifiedTypeMap enterEdge !mTypeName !mRootEntityName]
  end
#---------------------------------- Analyze attributes
  @decoratedObservablePropertyMap observablePropertyMap = {}
  @decoratedAttributeMap decoratedAttributeMap = {}
  for () in  mAttributeList do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mAttributeTypeName
      ?let @unifiedTypeMap-proxy attributeType
    ]
    [!?ioUnifiedTypeMap enterEdge !mTypeName !mAttributeTypeName]
    [!?decoratedAttributeMap insertKey
      !mAttributeName
      !attributeType
      !mDefaultValue
      !mNeedsValidation
     ]
    [!?observablePropertyMap insertKey
      !mAttributeName
      !attributeType
      !false # Is not transient
      !@lstring. new { !kindName + "." + mTypeName + "." + mAttributeName !mAttributeName.location}
      !false # is not a collection
     ]
  end
#---------------------------------------- Analyze relationship (only check name is unique)
  @decoratedEntityRelationshipMap currentRelationshipMap = {}
  for () in  mRelationshipList do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mDestinationEntityName
      ?let @unifiedTypeMap-proxy destinationTypeProxy
    ]
    [!?currentRelationshipMap insertKey
      !mRelationshipName
      !mIsToMany
      !destinationTypeProxy
      !mInverseRelationshipName
    ]
    [!?observablePropertyMap insertKey
      !mRelationshipName
      !destinationTypeProxy
      !false # Is not transient
      !@lstring. new { !kindName + "." + mTypeName + "." + mRelationshipName !mRelationshipName.location}
      !true # is a collection
     ]
  end
#------------------------------------- Analyze transient properties
  @decoratedTransientMap decoratedTransientMap = {}
  for () in  mTransientList do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mTransientTypeName
      ?let @unifiedTypeMap-proxy transientType
    ]
    let signature = @lstring. new { !kindName + "." + mTypeName + "." + mTransientName !mTransientName.location}
    [!?decoratedTransientMap insertKey
      !mTransientName
      !transientType
      !signature
      !mDependencyList
    ]
    [!?observablePropertyMap insertKey
      !mTransientName
      !transientType
      !true # Is transient
      !signature
      !false # is not a collection
     ]
  end
#---------------------------------- Analyze arraies
  for () in  mArrayList do
    [@unifiedTypeMap-proxy makeProxy
      !?ioUnifiedTypeMap
      !mElementClassName
      ?*
    ]
    [!?ioUnifiedTypeMap enterEdge !mTypeName !mElementClassName]
  end
#------------------------------------- Analyze outlets
  @decoratedOutletMap decoratedOutletMap = {}
  for () in  mOutletDeclarationList do
    [!?decoratedOutletMap insertKey
      !mOutletName
      !mOutletType
      !mRunDescriptor
      !mEnabledBindingDescriptor
      !mRegularBindingList
    ]
  end
#--------------------------------------------------- Analyze actions
  @actionMap documentActionMap = {}
  for actionName in mActionDeclarationList do
    [!?documentActionMap insertKey !actionName.mValue]
  end
#--------------------------------------------------- Analyze array controllers
  @arrayControllerMap arrayControllerMap = {}
  for () in mArrayControllerDeclarationListAST do
    let arrayController_propertySignature = @lstring. new {
      !kindName + "." + mTypeName + "." + mControllerName
      !mControllerName.location}
    [@unifiedTypeMap-proxy makeProxy !?ioUnifiedTypeMap !["Bool" nowhere] ?let @unifiedTypeMap-proxy boolTypeProxy]
    let @decoratedObservablePropertyMap arrayControllerObservablePropertyMap = {
      !["canRemove" nowhere]
      !boolTypeProxy
      !false # mIsTransient ;
      !arrayController_propertySignature
      !false # mIsCollection ;
    }
    [!?arrayControllerMap insertKey
      !mControllerName
      !mBoundModel
      !mTableViewOutletName
      !mArrayControllerBoundColumnListAST
      !{!["add" nowhere], !["remove" nowhere]}
      !arrayControllerObservablePropertyMap
      !arrayController_propertySignature
      ![mBoundModel arrayControllerTypeName !mTypeName.string !rootEntityType]
    ]
  end
#------------------------------------- Enter in type map
  [!?ioUnifiedTypeMap insertKey
    !mTypeName
    !mTypeKind
    !superTypeProxy
    !rootEntityType
    !decoratedAttributeMap
    !decoratedTransientMap
    !decoratedOutletMap
    !observablePropertyMap
    !currentRelationshipMap
    !documentActionMap
    !@lstringlist {} # mEnumConstantList
    !@enumConstantMap {} # mEnumConstantMap
    !arrayControllerMap
  ]
}

#----------------------------------------------------------------------------*

