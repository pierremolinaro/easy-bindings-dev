#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @objectControllerDeclarationAST : @abstractDeclarationAST {
  @lstring mControllerName
  @bool mIsRoot
  @lstring mRootEntityName
  @lstring mToOneRelationshipName
}

#·······················································································································

override method @objectControllerDeclarationAST enterInPrecedenceGraph ?!@declarationPrecedenceGraph ioGraph {
  let node = @lstring.new {!mClassName.string + " " + mControllerName !mControllerName.location}
  [!?ioGraph addNode !node !self]
  [!?ioGraph addEdge !node !mClassName]
  if not mIsRoot then
    [!?ioGraph addEdge !node !.new {!mClassName.string + " " + mToOneRelationshipName !mToOneRelationshipName.location}]
  elsif mRootEntityName.string != "" then
    [!?ioGraph addEdge !node !.new {!mRootEntityName.string + " " + mToOneRelationshipName !mToOneRelationshipName.location}]
  end
}

#·······················································································································

override getter @objectControllerDeclarationAST nodeKey -> @lstring {
  result = @lstring.new {!mClassName.string + " " + mControllerName !mControllerName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension easyBindings_syntax {

  #·····················································································································
  
  rule <controller_declaration>
            ?let @lstring inCurrentEntity
            ?let @lstring inRootEntity
            ?!@astDeclarationStruct ioDeclarationAST
  {
    $objectController$
    $controllerName$ ?let @lstring controllerName
    warning controllerName : "OBJECT CONTROLLER"
  #--- Model
    $:$
    @bool isRoot
    select
      $root$
      isRoot = true
    or
      $self$
      isRoot = false
    end
    $.$
    $identifier$ ?let @lstring relationshipName
    $;$
    ioDeclarationAST.mUnifiedDeclarationList += !@objectControllerDeclarationAST.new {
      !inCurrentEntity
      !controllerName
      !isRoot
      !inRootEntity
      !relationshipName
    }
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CLASS AND PROPERTY SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @objectControllerDeclarationAST firstAnalysisPhase 
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct unused ioGeneration
{
  with mClassName in !?ioSemanticContext.mClassMap 
    error message searchKey
  do
    if mIsRoot then
      [ioSemanticContext.mClassMap searchKey !mRootEntityName ?* ?let rootProperties ?2*]
      [rootProperties searchKey !mToOneRelationshipName ?let classKind ?2*]
      switch classKind
      case property (2*) :
        error mRootEntityName : "a toOne relationship is required here"
      case toOne (typeName * graphic *) :
        let kind = @propertyKind.objectController {
          !typeName: typeName
          !graphic: graphic
        }
        [!?mPropertyMap insertKey !mControllerName !kind !{} !false]
    #--- Code Generation
      mPropertyGenerationList += !@objectControllerPropertyGeneration.new {
        !mControllerName.string
        !"rootObject." + mToOneRelationshipName
        !mClassName
      }
      case toMany (4*) :
        error mRootEntityName : "a toOne relationship is required here"
      case arrayController (2*) :
        error mRootEntityName : "a toOne relationship is required here"
      case objectController (2*) :
        error mRootEntityName : "a toOne relationship is required here"
      case selectionController (*) :
        error mRootEntityName : "a toOne relationship is required here"
      end
    else
      [mPropertyMap searchKey !mToOneRelationshipName ?let classKind ?2*]
      switch classKind
      case property (2*) :
        error mRootEntityName : "a toOne relationship is required here"
      case toOne (typeName * graphic *) :
        let kind = @propertyKind.arrayController {
          !typeName: typeName
          !graphic: graphic
        }
        [!?mPropertyMap insertKey !mControllerName !kind !{} !false]
    #--- Code Generation
      mPropertyGenerationList += !@objectControllerPropertyGeneration.new {
        !mControllerName.string
        !mToOneRelationshipName
        !mClassName
      }
      case toMany (4*) :
        error mRootEntityName : "a toOne relationship is required here"
      case arrayController (2*) :
        error mRootEntityName : "a toOne relationship is required here"
      case objectController (2*) :
        error mRootEntityName : "a toOne relationship is required here"
      case selectionController (*) :
        error mRootEntityName : "a toOne relationship is required here"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SECOND ANALYSIS PHASE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @objectControllerDeclarationAST thirdAnalysisPhase
       ?!@semanticContext ioSemanticContext
       ?!@generationStruct ioGeneration
{
  @propertyMap boundModelPropertyMap
  if mIsRoot then
    [ioSemanticContext.mClassMap searchKey
       !mRootEntityName
       ?*
       ?boundModelPropertyMap 
       ?2*
     ]
  else
    [ioSemanticContext.mClassMap searchKey
       !mClassName
       ?*
       ?boundModelPropertyMap 
       ?2*
     ]  
  end
  [boundModelPropertyMap searchKey
     !mToOneRelationshipName
     ?let @propertyKind boundModelClassKind
     ?2*
  ]
#------------------------------------------------------------ Check colum bound models
  @actionMap actionMap
  @propertyMap propertyMap
  @bool graphic
  @string elementTypeName
  switch boundModelClassKind
  case property (2*) :
    error mToOneRelationshipName
      : "a toOne property is required here"
      : graphic, propertyMap, actionMap, elementTypeName
  case toOne (typeName * isGraphic *) :
    elementTypeName = typeName
    graphic = isGraphic
    [ioSemanticContext.mClassMap searchKey !typeName ?* ?propertyMap ?actionMap ?*]
  case toMany (4*) :
    error mToOneRelationshipName
      : "a toOne property is required here"
      : graphic, propertyMap, actionMap, elementTypeName
  case arrayController (2*) :
    error mToOneRelationshipName
      : "a toOne property is required here"
      : graphic, propertyMap, actionMap, elementTypeName
  case objectController (2*) :
    error mToOneRelationshipName
      : "a toOne property is required here"
      : graphic, propertyMap, actionMap, elementTypeName
  case selectionController (*) :
    error mToOneRelationshipName
      : "a toOne property is required here"
      : graphic, propertyMap, actionMap, elementTypeName
  end
  let modelString = if mIsRoot
    then "self.rootObject." + mToOneRelationshipName + "_property"
    else "self." + mToOneRelationshipName + "_property"
  end
  let modelTypeString = if mIsRoot
    then "ToOneRelationship_" + mRootEntityName + "_" + mToOneRelationshipName
    else "ToOneRelationship_" + mClassName + "_" + mToOneRelationshipName
  end
#---
  ioGeneration.mFileGenerationList += !@objectControllerGeneration.new {
    !mClassName
    !mControllerName
    !modelString
    !modelTypeString
    !elementTypeName
    !graphic
    !propertyMap
  }
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @objectControllerPropertyGeneration : @propertyGeneration {
  @string mModelString
  @string mOwnerName
}

#·······················································································································

override getter @objectControllerPropertyGeneration propertyDeclarationCode ?let @stringset unused inOverriddenTransients -> @string {
  result  = "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n"
  result += "  //   Object controller: " + mPropertyName + "\n"
  result += "  //" + @string.stringWithSequenceOfCharacters  {!'·' !116} + "\n\n"
  result += "  var " + mPropertyName + " = Controller_" + mOwnerName + "_" + mPropertyName + " ()\n\n"
}

#·······················································································································

override getter @objectControllerPropertyGeneration configurationCode -> @string {
  result  = "  //--- Object controller property: " + mPropertyName + "\n"
  result += "    self." + mPropertyName + ".bind_model (self." + mModelString + "_property)\n"
}

#·······················································································································

override getter @objectControllerPropertyGeneration populateExplorerWindowCode -> @string {
  result  = "  //--- Object controller property: " + mPropertyName + "\n"
  result += "    self." + mPropertyName + ".addExplorer (name: \"" + mPropertyName + "\", y:&y, view:view)\n"
}

#·······················································································································

override getter @objectControllerPropertyGeneration terminationCode -> @string {
  result  = "  //--- Object controller property: " + mPropertyName + "\n"
  result += "    self." + mPropertyName + ".unbind_model ()\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @objectControllerGeneration : @abstractFileGeneration {
  @string mOwnerName # document name, prefs name, ...
  @lstring mControllerName
  @string mModelString
  @string mModelTypeName
  @string mElementTypeName
  @bool mElementTypeIsGraphic
  @propertyMap mPropertyMap
}

#·······················································································································

private filewrapper objectControllerGenerationTemplate in "../generation-templates/controllers" {
}{
}{
  template objectControllerImplementationInSwift "object-controller.swift.galgasTemplate"
    ?@string OWNER_NAME
    ?@string ARRAY_CONTROLLER_NAME
    ?@string MODEL_STRING
    ?@string MODEL_TYPE_NAME
    ?@string ELEMENT_TYPE_NAME
    ?@bool ELEMENT_TYPE_IS_GRAPHIC
    ?@propertyMap SELECTION_OBSERVABLE_PROPERTY_MAP
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @objectControllerGeneration generateCode
    ?let @string inOutputDirectory
    ?!@stringset unused ioGeneratedFileSet
{
#--- Build observed property set (for sorting and filtering)
  let s = [filewrapper objectControllerGenerationTemplate.objectControllerImplementationInSwift
    !mOwnerName
    !mControllerName
    !mModelString
    !mModelTypeName
    !mElementTypeName
    !mElementTypeIsGraphic
    !mPropertyMap
  ]
  [@string generateFile
    !inOutputDirectory
    !"controller-object-" + mOwnerName + "-" +  mControllerName + ".swift"
    !s
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
